{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/landscape/.gitignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1550135292198},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1550135292199},{"_id":"themes/landscape/README.md","hash":"c7e83cfe8f2c724fc9cac32bd71bb5faf9ceeddb","modified":1550135292199},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1550135292198},{"_id":"themes/landscape/_config.yml","hash":"fb8c98a0f6ff9f962637f329c22699721854cd73","modified":1550135292199},{"_id":"themes/landscape/package.json","hash":"85358dc34311c6662e841584e206a4679183943f","modified":1550135292207},{"_id":"source/_posts/cookies.md","hash":"9472f2741fd458d532872c0be1f3f2a0b40d0851","modified":1572594495222},{"_id":"source/_posts/Let's Encrypt SSL.md","hash":"5e638f906e622817ab93fe64d640477c06213e6d","modified":1564130117299},{"_id":"source/_posts/css.md","hash":"9590d3fdce6d3f296d0e1e1aa7bf73fe53c1e41d","modified":1564558383647},{"_id":"source/_posts/docker.md","hash":"b073b3d18f350b12fafb88c094aa65f13d05d40e","modified":1564130117301},{"_id":"source/_posts/es6.md","hash":"cce27d006226882310d98842d33e30d604a7eabf","modified":1564130117301},{"_id":"source/_posts/es8.md","hash":"3bf925cc89354e04c865a4568ec27fa40c46b9ef","modified":1564130117301},{"_id":"source/_posts/eslint.md","hash":"f63c0eef0f9062e5850f00bc3435aa02f0261bb8","modified":1564130117302},{"_id":"source/_posts/graphql.md","hash":"89cf554cba1910b0bf8ff13d3bd63816904409b8","modified":1566548722505},{"_id":"source/_posts/gitInfo.md","hash":"f3e8f5bbeeed906957941ec45e8300f19c74066a","modified":1564130117303},{"_id":"source/_posts/hexo.md","hash":"1010707ca170d6de3a91c19aed39e79558a0bc9a","modified":1564130117303},{"_id":"source/_posts/http.md","hash":"d590199258741bdbbec52d2fcda94f4435580de0","modified":1564130117303},{"_id":"source/_posts/interview.md","hash":"118d62cafc4b9450991b606da96b77e6c34eb8bc","modified":1564130117305},{"_id":"source/_posts/loadtest.md","hash":"430b59a7b6776d600d67a6f6a0051bb0b758338f","modified":1564130117306},{"_id":"source/_posts/linux.md","hash":"60d30ab858b207b512fc5e873e41d1bc650edd9f","modified":1564130117305},{"_id":"source/_posts/pattern.md","hash":"85ff08997e08d562362138ed63a097f5b4cf3de6","modified":1564130117308},{"_id":"source/_posts/pm2.md","hash":"c8fc02c5bff7e9dc766e78c52456ccb4f62b7426","modified":1564130117309},{"_id":"source/_posts/postgre.md","hash":"58288a0cd5d4992365d259d095a3b2a469667ff5","modified":1564130117310},{"_id":"source/_posts/package.md","hash":"f646274eae13168f9d9d81a1e6523b196c036c8b","modified":1571711315947},{"_id":"source/_posts/security.md","hash":"c9ed6d135e5dbe5d523a994f1facfba49fff9887","modified":1564130117312},{"_id":"source/_posts/typescript.md","hash":"7de3284a07085eb11fd734aaca0b65780f8f566f","modified":1564130117313},{"_id":"source/_posts/vue.md","hash":"14632a435c4efa19499cbf3edcf607b466a1e21a","modified":1564564929869},{"_id":"source/_posts/webpack.md","hash":"d0e18538557cadfceeee6ea05ffa6c1597aeb6d7","modified":1571711824406},{"_id":"source/categories/index.md","hash":"d51db580efc1edca02813a5939b51abb9333c3c2","modified":1550135292197},{"_id":"source/about/index.md","hash":"0330b10bfb69136ccca8e2b04cf01353c89d26cb","modified":1550135292197},{"_id":"source/_posts/regex.md","hash":"64363c742732a41966dd2cfd19c0bc4472abef99","modified":1565775130590},{"_id":"source/tags/index.md","hash":"ba27695f1572dff9ace58e82b5a66c43840fe56c","modified":1550135292198},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1550135292200},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1550135292200},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1550135292201},{"_id":"themes/landscape/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1550135292200},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1550135292201},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1550135292201},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1550135292200},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1550135292206},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1550135292206},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1550135292206},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1550135292206},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1550135292207},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1550135292207},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1550135292206},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1550135292207},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"dc5d69f1bef3499d7d56c03727e178f3d56b40f7","modified":1564130117316},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1550135292202},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"931aaaffa0910a48199388ede576184ff15793ee","modified":1550135292202},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1550135292202},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1550135292202},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1550135292203},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"83a1ab12eb2a871bddf0620f611a97f13ebd731d","modified":1564130117317},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"c21ca56f419d01a9f49c27b6be9f4a98402b2aa3","modified":1550135292203},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1550135292203},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1550135292205},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1550135292205},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1550135292206},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1550135292205},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1550135292205},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1550135292206},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1550135292208},{"_id":"themes/landscape/source/css/_variables.styl","hash":"5e37a6571caf87149af83ac1cc0cdef99f117350","modified":1550135292210},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1550135292215},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1550135292216},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1550135292216},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1550135292216},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1550135292217},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1550135292217},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1550135292217},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1550135292219},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1550135292220},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1550135292219},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1550135292219},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1550135292204},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1550135292204},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1550135292204},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1550135292204},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1550135292204},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1550135292205},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1550135292208},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1550135292208},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1550135292208},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1550135292208},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1550135292208},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1550135292209},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1550135292209},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1550135292209},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1550135292209},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1550135292210},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1550135292209},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1550135292210},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1550135292211},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1550135292211},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1550135292213},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1550135292217},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1550135292218},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1550135292218},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1550135292218},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1550135292218},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1550135292219},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1550135292213},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1550135292215},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1550135292212},{"_id":"public/about/index.html","hash":"07483050af9ad08506aca605d25936243b79bf2d","modified":1572594418009},{"_id":"public/categories/index.html","hash":"43019d161238a5896097d88e7c8e5da73a4c423f","modified":1572594418009},{"_id":"public/tags/index.html","hash":"2ac59a3aa9a5aad916488625d315a0992b0217d7","modified":1572594418009},{"_id":"public/2019/08/23/graphql/index.html","hash":"a841b31ecd6a033ff24d39b6735f03a0562a64c3","modified":1572594418009},{"_id":"public/2019/07/02/linux/index.html","hash":"bc4493e001f55186ac80aaa3b7de3bf9c6a35182","modified":1572594418009},{"_id":"public/2019/07/02/es8/index.html","hash":"143a45d674686ca25f3bd34cf68e69b90fccfaec","modified":1572594418009},{"_id":"public/2019/05/14/http/index.html","hash":"0b576f48336d904e2cbad2da423b1120ab21f246","modified":1572594418009},{"_id":"public/2019/05/07/css/index.html","hash":"c241ecde97d8e4a2d7df993fe44e6637063a7de8","modified":1572594418009},{"_id":"public/2019/04/25/security/index.html","hash":"d61595b6a4cd5c10e0c7786a0ab9b9291b3ca055","modified":1572594418009},{"_id":"public/2019/02/20/gitInfo/index.html","hash":"dd68a3e6d07c399670784c2732ce8ae2b6e3418a","modified":1572594418009},{"_id":"public/2017/01/17/loadtest/index.html","hash":"eccadd2e9bf92f7e7f5bffc9935bbd5b396124ed","modified":1572594418009},{"_id":"public/2016/12/29/pm2/index.html","hash":"880e1097f3576706e56b36654582ded2b1dc0cdd","modified":1572594418009},{"_id":"public/2016/12/21/hexo/index.html","hash":"e6427e42415dc87addb68bce71110f26980b2674","modified":1572594418010},{"_id":"public/archives/index.html","hash":"6b79740580ee0659d3299da8cece803b39daf1aa","modified":1572594418010},{"_id":"public/archives/page/2/index.html","hash":"8c79f71b37a8e7121738df690017e558496bd35f","modified":1572594418010},{"_id":"public/archives/page/3/index.html","hash":"4b781e6ed84f59f5cf881715fe9084f795e4d561","modified":1572594418010},{"_id":"public/archives/2016/index.html","hash":"5394970495fa01680ec1d95bb5a5b5921ed52edf","modified":1572594418010},{"_id":"public/archives/2016/12/index.html","hash":"0878ad2aa4d1602667dfaad3beb6544996224ee2","modified":1572594418010},{"_id":"public/archives/2017/index.html","hash":"9c81c6e64faf879311c707f0d4a48cc2fe52b3b2","modified":1572594418010},{"_id":"public/archives/2017/01/index.html","hash":"cac651910deeea946164840f918fcd311044db64","modified":1572594418010},{"_id":"public/archives/2017/02/index.html","hash":"dc8b45877846e352d75c1da81deb266ddae4f513","modified":1572594418010},{"_id":"public/archives/2019/index.html","hash":"ea5ae21817570bdb0a268bb8d400f3318155eb3d","modified":1572594418010},{"_id":"public/archives/2019/page/2/index.html","hash":"ec396a7f65cc401c05ae2193f728d193e5d483a7","modified":1572594418010},{"_id":"public/archives/2019/02/index.html","hash":"a06290b53deee361270e2f7b1e0e6d8edf09e18b","modified":1572594418010},{"_id":"public/archives/2019/04/index.html","hash":"3e930d4252018e529057a2cafff6604eddea721d","modified":1572594418010},{"_id":"public/archives/2019/05/index.html","hash":"a5809fa3ab3da46ce2c46f46046c72d5673cb2a5","modified":1572594418010},{"_id":"public/archives/2019/06/index.html","hash":"abf7c85c41e66da80b1428446ea66d799072d60e","modified":1572594418010},{"_id":"public/archives/2019/07/index.html","hash":"b61930a562a7f9d1ce9b0304ba153c6e47c2dfc8","modified":1572594418010},{"_id":"public/archives/2019/08/index.html","hash":"37f866dbf250eb7f7a5c1cbdae2a56204b6288f8","modified":1572594418010},{"_id":"public/tags/零碎/index.html","hash":"adac94498f87c999c638bb1cf7a16b50dc78e990","modified":1572594418010},{"_id":"public/tags/https/index.html","hash":"2f6ec8432fb49d9692a49893a7f291bb8576470b","modified":1572594418010},{"_id":"public/tags/css/index.html","hash":"4f7d838665425f9ee48f2b4d4f98b75ac235da6d","modified":1572594418010},{"_id":"public/tags/docker/index.html","hash":"51c5cda122f330975fbf62c586ed5665521e62ce","modified":1572594418011},{"_id":"public/tags/es/index.html","hash":"5224dff5d83b989bc13a26aa99b7a3d76b9d3b71","modified":1572594418011},{"_id":"public/tags/eslint/index.html","hash":"b0dde53afcd2267153a6a982a507669b59804294","modified":1572594418011},{"_id":"public/tags/git/index.html","hash":"0abae46a50853af740250105d45e138aa12a2f04","modified":1572594418011},{"_id":"public/tags/hexo/index.html","hash":"00cefd410af518672f58aa0e99f066b42c11936b","modified":1572594418011},{"_id":"public/tags/http/index.html","hash":"4c75f4c32af610130a9bba9571a7e7fd5d4e6acc","modified":1572594418011},{"_id":"public/tags/interview/index.html","hash":"cde45e96f89fc9547fb0038455d4117af5eb2774","modified":1572594418011},{"_id":"public/tags/loadtest/index.html","hash":"24d78b5543146ca503323f040530c76cbd26a413","modified":1572594418011},{"_id":"public/tags/ops/index.html","hash":"e71f8bfad19f5504c1418a50ffb51069a7af9d2b","modified":1572594418011},{"_id":"public/tags/pattern/index.html","hash":"03860a9a2043e7026604ccd8e9bf85dd9c99606a","modified":1572594418011},{"_id":"public/tags/pm2/index.html","hash":"2670c63dacfc9fa8a198fa1fc8f057e47c5ee89e","modified":1572594418011},{"_id":"public/tags/postgre/index.html","hash":"dec46daee85e7f30883247c1378374a32b65156d","modified":1572594418011},{"_id":"public/tags/useful-package/index.html","hash":"d8a3c054db3ac4f4359cb4491b1e6c7410b1d60c","modified":1572594418011},{"_id":"public/tags/安全/index.html","hash":"aec088529fcd717d4d052fd4f1119e7903564316","modified":1572594418011},{"_id":"public/tags/ts/index.html","hash":"1f9b0524d3c1840643d9efa63d0a43ccbef31145","modified":1572594418011},{"_id":"public/tags/vue-eventloop-js/index.html","hash":"c9c2004f43e2dab3285e21889e0d07e961eb4366","modified":1572594418011},{"_id":"public/tags/webpack/index.html","hash":"a399dbd2c9f95837fe3ce94890337c7549e0a53a","modified":1572594418011},{"_id":"public/tags/regex/index.html","hash":"9fb918448e478e72fa64befbff00ea6e4afa72e2","modified":1572594418012},{"_id":"public/2019/06/28/es6/index.html","hash":"d5a40a953e4607837fb59add2139fa2410906515","modified":1572594418012},{"_id":"public/2019/06/24/cookies/index.html","hash":"2ccadc335975014c1c48dac7bf6a53fc328fc7ce","modified":1572594503079},{"_id":"public/2019/06/24/regex/index.html","hash":"e192c2bf1638e78d394380acb9523137c22dee31","modified":1572594418012},{"_id":"public/2019/02/25/typescript/index.html","hash":"5c91e6ce671f0656d1c3d9919203dd57d45c2c09","modified":1572594418012},{"_id":"public/2019/02/14/package/index.html","hash":"38d7df893790bdea7aa51572d917b0edee0edf4e","modified":1572594418012},{"_id":"public/2017/02/21/postgre/index.html","hash":"15db102ccc520d5d5b984abe49ad93afd8e3f5ae","modified":1572594418012},{"_id":"public/2017/01/23/interview/index.html","hash":"1c059ae735ac4b6e58a72dd7d86623f59fb14994","modified":1572594418012},{"_id":"public/2017/01/19/vue/index.html","hash":"84bb9e2e154fcf4dc96e78c2ffa6169238b58c65","modified":1572594418012},{"_id":"public/2017/01/17/webpack/index.html","hash":"de23119cc6e7c89021b3193364b76249fcbd4ccd","modified":1572594418012},{"_id":"public/2016/12/26/pattern/index.html","hash":"7c1e71bb26f4600af0d12328f41144368f8be163","modified":1572594418012},{"_id":"public/2016/12/25/eslint/index.html","hash":"afd58d38ac02239088f992e108597676e229d273","modified":1572594418012},{"_id":"public/2016/12/21/Let's Encrypt SSL/index.html","hash":"c35dbed5a4d1a9f375d8d4a4edefae2a4f2fc099","modified":1572594418012},{"_id":"public/2016/12/14/docker/index.html","hash":"2e9fc3311902512100722d3ff9fa0ea245d7907a","modified":1572594418012},{"_id":"public/index.html","hash":"60b83b11c7d8f5fc713873e03870f4c13fb621c1","modified":1572594503079},{"_id":"public/page/2/index.html","hash":"d5cf9c7a69dd299837baed547b18e5a1aef5a942","modified":1572594418012},{"_id":"public/page/3/index.html","hash":"695775210f512bfbb9fad4e7ae62a1d6acc16955","modified":1572594418013},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1572594418017},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1572594418017},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1572594418017},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1572594418017},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1572594418017},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1572594418018},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1572594418018},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1572594418018},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1572594418018},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1572594418452},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1572594418453},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1572594418457},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1572594418457},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1572594418458},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1572594418458},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1572594418458},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1572594418458},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1572594418458},{"_id":"public/css/style.css","hash":"fffb3966bf36057a325498aba9ce3a2ea7bd79e1","modified":1572594418458},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1572594418458},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1572594418458},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1572594418462},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1572594418463}],"Category":[],"Data":[],"Page":[{"title":"categories","date":"2017-01-19T08:52:48.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2017-01-19 16:52:48\ntype: \"categories\"\n---\n","updated":"2019-02-14T09:08:12.197Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ck2fu41z90001f18suqf0b531","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"about","date":"2017-01-19T08:44:34.000Z","_content":"adfsdfffffffff","source":"about/index.md","raw":"---\ntitle: about\ndate: 2017-01-19 16:44:34\n---\nadfsdfffffffff","updated":"2019-02-14T09:08:12.197Z","path":"about/index.html","comments":1,"layout":"page","_id":"ck2fu41zb0003f18shjh2kxjk","content":"<p>adfsdfffffffff</p>\n","site":{"data":{}},"excerpt":"","more":"<p>adfsdfffffffff</p>\n"},{"title":"tags","date":"2017-01-19T08:53:34.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2017-01-19 16:53:34\ntype: \"tags\"\n---\n","updated":"2019-02-14T09:08:12.198Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ck2fu41ze0006f18s9ewgswq3","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"cookies","date":"2019-06-24T06:40:18.000Z","_content":"\n:smile:\n### 发版\n1. 发布阶段：更新chagelog ,打 git tag 。\n\n### word\n1. deflate 放气，紧缩\n1. Sanitize 消毒，净化\n1. \n### js\n\n1. 随机字符串 Math.random().toString(36).substr(2));\n\n2. Babel pollyfy 的作用 ：https://zhuanlan.zhihu.com/p/29058936\n\n3. Babel stag2 的功能  https://github.com/babel/babel/tree/master/packages/babel-preset-stage-2\n1. 所有的babel 包  https://github.com/babel/babel/tree/master/packages\n1.  npx babel-upgrade\n1. ES2019 中为Symbol对象添加了只读属性 description ，该对象返回包含Symbol描述的字符串。\n1. 变量的临时死区  \n1. SET 操作的时间复杂度\n1. 如果你传的 context 就 null 或者 undefined，那么 window 对象就是默认的 context（严格模式下默认 context 是 undefined）\n1. 高阶函数的定义\n1. 作用域以及作用域链  函数作用域 —闭包\n1. ES6 模块功能是它的导入模块是导出时模块的实时只读视图。（相比起 CommonJS，导入的是导出模块的拷贝副本，因此也不是实时的）。只读视图和内存拷贝的区别。\n1. atob() 对经过 base-64 编码的字符串进行解码,btoa() base64加吗\n1. Console.dir  显示对象所有的属性和方法\n1. Broadcast Channel API 允许同一原始域和用户代理下的所有窗口,iFrames 等进行交互。也就是说，如果用户打开了同一个网站的的两个标签窗口，如果网站内容发生了变化，那么两个窗口会同时得到更新通知。\n1. escape 在处理 0xff 之外字符的时候，是直接使用字符的 unicode 在前面加上一个 「%u」，而encodeURI则是先进行 UTF-8，再在 UTF-8 的每个字节码前加上一个 「%」； 所以通过encodeUrI 可以获取utf-8 字节长度\n1. \n\n#### 编译\n1. 无论你使用的是解释型语言(JavaScript、Python、Ruby)还是编译型语言(c#、Java、Rust)，都有一个共同的部分:将源代码作为纯文本解析为 抽象语法树(abstract syntax tree, AST) 的数据结构。\n1. AST 不仅以结构化的方式显示源代码，而且在语义分析中扮演着重要角色。在语义分析中，编译器验证程序和语言元素的语法使用是否正确。之后，使用 AST 来生成实际的字节码或者机器码。\n1. 转义的过程：\n   ```text\n   编写ES6代码\n   babylon 进行解析\n   解析得到 AST\n   plugin 用 babel-traverse 对 AST 树进行遍历转译\n   得到新的 AST树\n   用 babel-generator 通过 AST 树生成 ES5 代码\n   ```\n1. 要应用更新，Virtual DOM核心功能将发挥作用，即 协调算法，它的工作是提供最优的解决方案来解决以前和当前虚拟DOM 状态之间的差异。\n\n## opentracing\n1. Opentracing 的carrier 有多种实现，tracer 的inject（客户端进程） 和 extract（服务端进程），这样 客户端和服务端 就可以拥有相同的trace context。\n1. Server 首先extract check 有没有注入的span，没有的话启动一个新的span\n\n## mac\n1. Mac 设置path  export PATH=$PATH:\n1.  查看端口占用：lsof -i:3001\n1. export http_proxy=\"http://localhost:8899\"\n1. Grep -A 5 显示后面5行信息\n\n## npm\n1. npm config edit\n1. npm config set init.author.name \"ryansecreat\"\n1. npm config set init.email='chenjingnan@jd.com’\n1. npm config set init.license \"MIT\"\n1. npm start --prefix path/to/your/folder   //指定目录下运行\n1. npm repo   浏览器中打开repo\n1. npm publish --registry=http://registry.npmjs.org  --registry=https://registry.npm.taobao.org\n1. npm outdated  查看过时package\n1. npm publish --tag=beta.\n1. npm version patch -m \"Upgrade to %s for reasons”\n1. npm dist-tag add n-n-n-n@1.0.2-1 latest  将某个预发版本更新为最新   \n1. npm ping [--registry <registry>]\n\n### node\n1. Stream cork uncork\n1. escape-html  This function will escape the following characters: \", ', &, <, and >.\n1. domain模块，把处理多个不同的IO的操作作为一个组。注册事件和回调到domain，当发生一个错误事件或抛出一个错误时，domain对象会被通知，不会丢失上下文环境，也不导致程序错误立即退出，与process.on('uncaughtException')不同。\n1. stream tranform\n```text\nconst { Transform } = require('stream');\n\nconst myTransform = new Transform({\n  transform(chunk, encoding, callback) {\n    // ...\n  }\n});\n```\n1. 可以引入corejs实现feature\n1. 性能分析\nNode 性能分析，抓取火焰图 node --inspect app.js\nNode  --prof-process  https://github.com/nswbmw/node-in-debugging/blob/master/1.3%20Tick%20Processor.md\n \n1. 一个promise类 \n```javascript\nclass Sleep {\nthen(resolve, reject){\n\n}\n}\n```\n1. Node 内置了pipeline  const { pipeline } = require('stream');\n1. Elastic APM 是 Elastic 公司开源的一款 APM 工具\n1. Error.prepareStackTrace:定制化堆栈信息    Error.captureStackTrace:隐藏内部的实现细节，优化错误栈。\n1.http2\n```text\nhttp2基础理论\n\nHTTP2是二进制协议\n这是一个复用协议。并行的请求能在同一个链接中处理，移除了HTTP/1.x中顺序和阻塞的约束。\n压缩了headers。因为headers在一系列请求中常常是相似的，其移除了重复和传输重复数据的成本。\n其允许服务器在客户端缓存中填充数据，通过一个叫服务器推送的机制来提前请求。\n对Alt-Svc的支持允许了给定资源的位置和资源鉴定，允许了更智能的CDN缓冲机制。\nClient-Hints 的引入允许浏览器或者客户端来主动交流它的需求，或者是硬件约束的信息给服务端。\n在Cookie头中引入安全相关的的前缀，现在帮助保证一个安全的cookie没被更改过。\n\n```\n1. Https https://zhuanlan.zhihu.com/p/27395037    https://blog.51cto.com/11883699/2160032\n1. Ca 使用证书颁发机构的证书中的公钥去解密被颁发者的指纹算法和指纹，并计算比对指纹，正确才能验证身份\n1. const { EventEmitter } = require('events’);  EventEmitter 的继承\n1. Require.resovle() 获取模块的绝对路径  \n1. peerDependencies 相关模块安装\n1. websocket \n```text\nWebSocket 使用了自定义的二进制分帧格式，把每个应用消息切分成一或多个帧，发送到目的地之后再组装起来，等到接收到完整的消息后再通知接收端。基本的成帧协议定义了帧类型有操作码、有效载荷的长度，指定位置的Extension data和Application data，统称为Payload data，保留了一些特殊位和操作码供后期扩展。在打开握手完成后，终端发送一个关闭帧之前的任何时间里，数据帧可能由客户端或服务器的任何一方发送。\n\n• 帧：最小的通信单位，包含可变长度的帧首部和净荷部分，净荷可能包含完整或部分应用消息。\n• 消息：一系列帧，与应用消息对等。\n```\n1. jwt 签名算法\n```text\nHS256 使用密钥生成固定的签名，RS256 使用成非对称进行签名。简单地说，HS256 必须与任何想要验证 JWT的 客户端或 API 共享秘密。\nRS256 生成非对称签名，这意味着必须使用私钥来签签名 JWT，并且必须使用对应的公钥来验证签名。与对称算法不同，使用 RS256 可以保证服务端是 JWT 的签名者，因为服务端是唯一拥有私钥的一方。这样做将不再需要在许多应用程序之间共享私钥\n\n这种方法可以让我们分离开签发与验证，签发时需要用一个密钥，验证时使用公钥，也就是有公钥的地方只能做验证，但不能签发 JWT。\n```\n### egg\n1. 启动顺序\n```text\nMaster 启动后先 fork Agent 进程\nAgent 初始化成功后，通过 IPC 通道通知 Master\nMaster 再 fork 多个 App Worker\nApp Worker 初始化成功，通知 Master\n所有的进程初始化成功后，Master 通知 Agent 和 Worker 应用启动成功\n```\n### 网络\n1. 子网是所属VPC IP地址范围内的 IP 地址块。目前私有网络中的云资源部署在子网内，如云主机、容器、负载均衡等。\n\n1. 可用区（Availability Zone）是电力及网络之间互相独立的物理区域，相同可用区内的实例之间较之同地域不同可用区内实例之间的网络延时更小。同地域内不同可用区之间提供内网互通环境，可用区之间可做到故障隔离。\n  若您的业务要求有较低网络时延，建议将实例或者Pod部署在同一可用区内。\n  \n### vim \nj: 下移一行；\n\nk: 上移一行；\n\nw: 前移一个单词，光标停在下一个单词开头；\n\ne: 前移一个单词，光标停在下一个单词末尾；\n\n0: 移动到行首。\n\n$: 移动到行尾。\n\nn|: 把光标移到递n列上\n\nzz: 将当前行移动到屏幕中央。\n\no: 在下面新建一行插入；\n\nO: 在上面新建一行插入；\n\na: 在光标后插入；\n\nA: 在当前行最后插入；\n\nu: 取消一(n)个改动。\n\nctrl + r: 重做最后的改动。","source":"_posts/cookies.md","raw":"---\ntitle: cookies\ndate: 2019-06-24 14:40:18\ntags: 零碎\n---\n\n:smile:\n### 发版\n1. 发布阶段：更新chagelog ,打 git tag 。\n\n### word\n1. deflate 放气，紧缩\n1. Sanitize 消毒，净化\n1. \n### js\n\n1. 随机字符串 Math.random().toString(36).substr(2));\n\n2. Babel pollyfy 的作用 ：https://zhuanlan.zhihu.com/p/29058936\n\n3. Babel stag2 的功能  https://github.com/babel/babel/tree/master/packages/babel-preset-stage-2\n1. 所有的babel 包  https://github.com/babel/babel/tree/master/packages\n1.  npx babel-upgrade\n1. ES2019 中为Symbol对象添加了只读属性 description ，该对象返回包含Symbol描述的字符串。\n1. 变量的临时死区  \n1. SET 操作的时间复杂度\n1. 如果你传的 context 就 null 或者 undefined，那么 window 对象就是默认的 context（严格模式下默认 context 是 undefined）\n1. 高阶函数的定义\n1. 作用域以及作用域链  函数作用域 —闭包\n1. ES6 模块功能是它的导入模块是导出时模块的实时只读视图。（相比起 CommonJS，导入的是导出模块的拷贝副本，因此也不是实时的）。只读视图和内存拷贝的区别。\n1. atob() 对经过 base-64 编码的字符串进行解码,btoa() base64加吗\n1. Console.dir  显示对象所有的属性和方法\n1. Broadcast Channel API 允许同一原始域和用户代理下的所有窗口,iFrames 等进行交互。也就是说，如果用户打开了同一个网站的的两个标签窗口，如果网站内容发生了变化，那么两个窗口会同时得到更新通知。\n1. escape 在处理 0xff 之外字符的时候，是直接使用字符的 unicode 在前面加上一个 「%u」，而encodeURI则是先进行 UTF-8，再在 UTF-8 的每个字节码前加上一个 「%」； 所以通过encodeUrI 可以获取utf-8 字节长度\n1. \n\n#### 编译\n1. 无论你使用的是解释型语言(JavaScript、Python、Ruby)还是编译型语言(c#、Java、Rust)，都有一个共同的部分:将源代码作为纯文本解析为 抽象语法树(abstract syntax tree, AST) 的数据结构。\n1. AST 不仅以结构化的方式显示源代码，而且在语义分析中扮演着重要角色。在语义分析中，编译器验证程序和语言元素的语法使用是否正确。之后，使用 AST 来生成实际的字节码或者机器码。\n1. 转义的过程：\n   ```text\n   编写ES6代码\n   babylon 进行解析\n   解析得到 AST\n   plugin 用 babel-traverse 对 AST 树进行遍历转译\n   得到新的 AST树\n   用 babel-generator 通过 AST 树生成 ES5 代码\n   ```\n1. 要应用更新，Virtual DOM核心功能将发挥作用，即 协调算法，它的工作是提供最优的解决方案来解决以前和当前虚拟DOM 状态之间的差异。\n\n## opentracing\n1. Opentracing 的carrier 有多种实现，tracer 的inject（客户端进程） 和 extract（服务端进程），这样 客户端和服务端 就可以拥有相同的trace context。\n1. Server 首先extract check 有没有注入的span，没有的话启动一个新的span\n\n## mac\n1. Mac 设置path  export PATH=$PATH:\n1.  查看端口占用：lsof -i:3001\n1. export http_proxy=\"http://localhost:8899\"\n1. Grep -A 5 显示后面5行信息\n\n## npm\n1. npm config edit\n1. npm config set init.author.name \"ryansecreat\"\n1. npm config set init.email='chenjingnan@jd.com’\n1. npm config set init.license \"MIT\"\n1. npm start --prefix path/to/your/folder   //指定目录下运行\n1. npm repo   浏览器中打开repo\n1. npm publish --registry=http://registry.npmjs.org  --registry=https://registry.npm.taobao.org\n1. npm outdated  查看过时package\n1. npm publish --tag=beta.\n1. npm version patch -m \"Upgrade to %s for reasons”\n1. npm dist-tag add n-n-n-n@1.0.2-1 latest  将某个预发版本更新为最新   \n1. npm ping [--registry <registry>]\n\n### node\n1. Stream cork uncork\n1. escape-html  This function will escape the following characters: \", ', &, <, and >.\n1. domain模块，把处理多个不同的IO的操作作为一个组。注册事件和回调到domain，当发生一个错误事件或抛出一个错误时，domain对象会被通知，不会丢失上下文环境，也不导致程序错误立即退出，与process.on('uncaughtException')不同。\n1. stream tranform\n```text\nconst { Transform } = require('stream');\n\nconst myTransform = new Transform({\n  transform(chunk, encoding, callback) {\n    // ...\n  }\n});\n```\n1. 可以引入corejs实现feature\n1. 性能分析\nNode 性能分析，抓取火焰图 node --inspect app.js\nNode  --prof-process  https://github.com/nswbmw/node-in-debugging/blob/master/1.3%20Tick%20Processor.md\n \n1. 一个promise类 \n```javascript\nclass Sleep {\nthen(resolve, reject){\n\n}\n}\n```\n1. Node 内置了pipeline  const { pipeline } = require('stream');\n1. Elastic APM 是 Elastic 公司开源的一款 APM 工具\n1. Error.prepareStackTrace:定制化堆栈信息    Error.captureStackTrace:隐藏内部的实现细节，优化错误栈。\n1.http2\n```text\nhttp2基础理论\n\nHTTP2是二进制协议\n这是一个复用协议。并行的请求能在同一个链接中处理，移除了HTTP/1.x中顺序和阻塞的约束。\n压缩了headers。因为headers在一系列请求中常常是相似的，其移除了重复和传输重复数据的成本。\n其允许服务器在客户端缓存中填充数据，通过一个叫服务器推送的机制来提前请求。\n对Alt-Svc的支持允许了给定资源的位置和资源鉴定，允许了更智能的CDN缓冲机制。\nClient-Hints 的引入允许浏览器或者客户端来主动交流它的需求，或者是硬件约束的信息给服务端。\n在Cookie头中引入安全相关的的前缀，现在帮助保证一个安全的cookie没被更改过。\n\n```\n1. Https https://zhuanlan.zhihu.com/p/27395037    https://blog.51cto.com/11883699/2160032\n1. Ca 使用证书颁发机构的证书中的公钥去解密被颁发者的指纹算法和指纹，并计算比对指纹，正确才能验证身份\n1. const { EventEmitter } = require('events’);  EventEmitter 的继承\n1. Require.resovle() 获取模块的绝对路径  \n1. peerDependencies 相关模块安装\n1. websocket \n```text\nWebSocket 使用了自定义的二进制分帧格式，把每个应用消息切分成一或多个帧，发送到目的地之后再组装起来，等到接收到完整的消息后再通知接收端。基本的成帧协议定义了帧类型有操作码、有效载荷的长度，指定位置的Extension data和Application data，统称为Payload data，保留了一些特殊位和操作码供后期扩展。在打开握手完成后，终端发送一个关闭帧之前的任何时间里，数据帧可能由客户端或服务器的任何一方发送。\n\n• 帧：最小的通信单位，包含可变长度的帧首部和净荷部分，净荷可能包含完整或部分应用消息。\n• 消息：一系列帧，与应用消息对等。\n```\n1. jwt 签名算法\n```text\nHS256 使用密钥生成固定的签名，RS256 使用成非对称进行签名。简单地说，HS256 必须与任何想要验证 JWT的 客户端或 API 共享秘密。\nRS256 生成非对称签名，这意味着必须使用私钥来签签名 JWT，并且必须使用对应的公钥来验证签名。与对称算法不同，使用 RS256 可以保证服务端是 JWT 的签名者，因为服务端是唯一拥有私钥的一方。这样做将不再需要在许多应用程序之间共享私钥\n\n这种方法可以让我们分离开签发与验证，签发时需要用一个密钥，验证时使用公钥，也就是有公钥的地方只能做验证，但不能签发 JWT。\n```\n### egg\n1. 启动顺序\n```text\nMaster 启动后先 fork Agent 进程\nAgent 初始化成功后，通过 IPC 通道通知 Master\nMaster 再 fork 多个 App Worker\nApp Worker 初始化成功，通知 Master\n所有的进程初始化成功后，Master 通知 Agent 和 Worker 应用启动成功\n```\n### 网络\n1. 子网是所属VPC IP地址范围内的 IP 地址块。目前私有网络中的云资源部署在子网内，如云主机、容器、负载均衡等。\n\n1. 可用区（Availability Zone）是电力及网络之间互相独立的物理区域，相同可用区内的实例之间较之同地域不同可用区内实例之间的网络延时更小。同地域内不同可用区之间提供内网互通环境，可用区之间可做到故障隔离。\n  若您的业务要求有较低网络时延，建议将实例或者Pod部署在同一可用区内。\n  \n### vim \nj: 下移一行；\n\nk: 上移一行；\n\nw: 前移一个单词，光标停在下一个单词开头；\n\ne: 前移一个单词，光标停在下一个单词末尾；\n\n0: 移动到行首。\n\n$: 移动到行尾。\n\nn|: 把光标移到递n列上\n\nzz: 将当前行移动到屏幕中央。\n\no: 在下面新建一行插入；\n\nO: 在上面新建一行插入；\n\na: 在光标后插入；\n\nA: 在当前行最后插入；\n\nu: 取消一(n)个改动。\n\nctrl + r: 重做最后的改动。","slug":"cookies","published":1,"updated":"2019-11-01T07:49:37.224Z","_id":"ck2fu41z60000f18sarcp7dnl","comments":1,"layout":"post","photos":[],"link":"","content":"<p>:smile:</p>\n<h3 id=\"发版\"><a href=\"#发版\" class=\"headerlink\" title=\"发版\"></a>发版</h3><ol>\n<li>发布阶段：更新chagelog ,打 git tag 。</li>\n</ol>\n<h3 id=\"word\"><a href=\"#word\" class=\"headerlink\" title=\"word\"></a>word</h3><ol>\n<li>deflate 放气，紧缩</li>\n<li>Sanitize 消毒，净化</li>\n<li><h3 id=\"js\"><a href=\"#js\" class=\"headerlink\" title=\"js\"></a>js</h3></li>\n<li><p>随机字符串 Math.random().toString(36).substr(2));</p>\n</li>\n<li><p>Babel pollyfy 的作用 ：<a href=\"https://zhuanlan.zhihu.com/p/29058936\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/29058936</a></p>\n</li>\n<li><p>Babel stag2 的功能  <a href=\"https://github.com/babel/babel/tree/master/packages/babel-preset-stage-2\" target=\"_blank\" rel=\"noopener\">https://github.com/babel/babel/tree/master/packages/babel-preset-stage-2</a></p>\n</li>\n<li>所有的babel 包  <a href=\"https://github.com/babel/babel/tree/master/packages\" target=\"_blank\" rel=\"noopener\">https://github.com/babel/babel/tree/master/packages</a></li>\n<li>npx babel-upgrade</li>\n<li>ES2019 中为Symbol对象添加了只读属性 description ，该对象返回包含Symbol描述的字符串。</li>\n<li>变量的临时死区  </li>\n<li>SET 操作的时间复杂度</li>\n<li>如果你传的 context 就 null 或者 undefined，那么 window 对象就是默认的 context（严格模式下默认 context 是 undefined）</li>\n<li>高阶函数的定义</li>\n<li>作用域以及作用域链  函数作用域 —闭包</li>\n<li>ES6 模块功能是它的导入模块是导出时模块的实时只读视图。（相比起 CommonJS，导入的是导出模块的拷贝副本，因此也不是实时的）。只读视图和内存拷贝的区别。</li>\n<li>atob() 对经过 base-64 编码的字符串进行解码,btoa() base64加吗</li>\n<li>Console.dir  显示对象所有的属性和方法</li>\n<li>Broadcast Channel API 允许同一原始域和用户代理下的所有窗口,iFrames 等进行交互。也就是说，如果用户打开了同一个网站的的两个标签窗口，如果网站内容发生了变化，那么两个窗口会同时得到更新通知。</li>\n<li>escape 在处理 0xff 之外字符的时候，是直接使用字符的 unicode 在前面加上一个 「%u」，而encodeURI则是先进行 UTF-8，再在 UTF-8 的每个字节码前加上一个 「%」； 所以通过encodeUrI 可以获取utf-8 字节长度</li>\n<li></li>\n</ol>\n<h4 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h4><ol>\n<li>无论你使用的是解释型语言(JavaScript、Python、Ruby)还是编译型语言(c#、Java、Rust)，都有一个共同的部分:将源代码作为纯文本解析为 抽象语法树(abstract syntax tree, AST) 的数据结构。</li>\n<li>AST 不仅以结构化的方式显示源代码，而且在语义分析中扮演着重要角色。在语义分析中，编译器验证程序和语言元素的语法使用是否正确。之后，使用 AST 来生成实际的字节码或者机器码。</li>\n<li><p>转义的过程：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">编写ES6代码</span><br><span class=\"line\">babylon 进行解析</span><br><span class=\"line\">解析得到 AST</span><br><span class=\"line\">plugin 用 babel-traverse 对 AST 树进行遍历转译</span><br><span class=\"line\">得到新的 AST树</span><br><span class=\"line\">用 babel-generator 通过 AST 树生成 ES5 代码</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>要应用更新，Virtual DOM核心功能将发挥作用，即 协调算法，它的工作是提供最优的解决方案来解决以前和当前虚拟DOM 状态之间的差异。</p>\n</li>\n</ol>\n<h2 id=\"opentracing\"><a href=\"#opentracing\" class=\"headerlink\" title=\"opentracing\"></a>opentracing</h2><ol>\n<li>Opentracing 的carrier 有多种实现，tracer 的inject（客户端进程） 和 extract（服务端进程），这样 客户端和服务端 就可以拥有相同的trace context。</li>\n<li>Server 首先extract check 有没有注入的span，没有的话启动一个新的span</li>\n</ol>\n<h2 id=\"mac\"><a href=\"#mac\" class=\"headerlink\" title=\"mac\"></a>mac</h2><ol>\n<li>Mac 设置path  export PATH=$PATH:</li>\n<li>查看端口占用：lsof -i:3001</li>\n<li>export http_proxy=”<a href=\"http://localhost:8899&quot;\" target=\"_blank\" rel=\"noopener\">http://localhost:8899&quot;</a></li>\n<li>Grep -A 5 显示后面5行信息</li>\n</ol>\n<h2 id=\"npm\"><a href=\"#npm\" class=\"headerlink\" title=\"npm\"></a>npm</h2><ol>\n<li>npm config edit</li>\n<li>npm config set init.author.name “ryansecreat”</li>\n<li>npm config set <a href=\"mailto:init.email=&#39;chenjingnan@jd.com\" target=\"_blank\" rel=\"noopener\">init.email=&#39;chenjingnan@jd.com</a>’</li>\n<li>npm config set init.license “MIT”</li>\n<li>npm start –prefix path/to/your/folder   //指定目录下运行</li>\n<li>npm repo   浏览器中打开repo</li>\n<li>npm publish –registry=<a href=\"http://registry.npmjs.org\" target=\"_blank\" rel=\"noopener\">http://registry.npmjs.org</a>  –registry=<a href=\"https://registry.npm.taobao.org\" target=\"_blank\" rel=\"noopener\">https://registry.npm.taobao.org</a></li>\n<li>npm outdated  查看过时package</li>\n<li>npm publish –tag=beta.</li>\n<li>npm version patch -m “Upgrade to %s for reasons”</li>\n<li>npm dist-tag add <a href=\"mailto:n-n-n-n@1.0.2-1\" target=\"_blank\" rel=\"noopener\">n-n-n-n@1.0.2-1</a> latest  将某个预发版本更新为最新   </li>\n<li>npm ping [–registry <registry>]</registry></li>\n</ol>\n<h3 id=\"node\"><a href=\"#node\" class=\"headerlink\" title=\"node\"></a>node</h3><ol>\n<li>Stream cork uncork</li>\n<li>escape-html  This function will escape the following characters: “, ‘, &amp;, &lt;, and &gt;.</li>\n<li>domain模块，把处理多个不同的IO的操作作为一个组。注册事件和回调到domain，当发生一个错误事件或抛出一个错误时，domain对象会被通知，不会丢失上下文环境，也不导致程序错误立即退出，与process.on(‘uncaughtException’)不同。</li>\n<li><p>stream tranform</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const &#123; Transform &#125; = require(&apos;stream&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">const myTransform = new Transform(&#123;</span><br><span class=\"line\">  transform(chunk, encoding, callback) &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>可以引入corejs实现feature</p>\n</li>\n<li><p>性能分析<br>Node 性能分析，抓取火焰图 node –inspect app.js<br>Node  –prof-process  <a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/1.3%20Tick%20Processor.md\" target=\"_blank\" rel=\"noopener\">https://github.com/nswbmw/node-in-debugging/blob/master/1.3%20Tick%20Processor.md</a></p>\n</li>\n<li><p>一个promise类 </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sleep</span> </span>&#123;</span><br><span class=\"line\">then(resolve, reject)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Node 内置了pipeline  const { pipeline } = require(‘stream’);</p>\n</li>\n<li>Elastic APM 是 Elastic 公司开源的一款 APM 工具</li>\n<li><p>Error.prepareStackTrace:定制化堆栈信息    Error.captureStackTrace:隐藏内部的实现细节，优化错误栈。<br>1.http2</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http2基础理论</span><br><span class=\"line\"></span><br><span class=\"line\">HTTP2是二进制协议</span><br><span class=\"line\">这是一个复用协议。并行的请求能在同一个链接中处理，移除了HTTP/1.x中顺序和阻塞的约束。</span><br><span class=\"line\">压缩了headers。因为headers在一系列请求中常常是相似的，其移除了重复和传输重复数据的成本。</span><br><span class=\"line\">其允许服务器在客户端缓存中填充数据，通过一个叫服务器推送的机制来提前请求。</span><br><span class=\"line\">对Alt-Svc的支持允许了给定资源的位置和资源鉴定，允许了更智能的CDN缓冲机制。</span><br><span class=\"line\">Client-Hints 的引入允许浏览器或者客户端来主动交流它的需求，或者是硬件约束的信息给服务端。</span><br><span class=\"line\">在Cookie头中引入安全相关的的前缀，现在帮助保证一个安全的cookie没被更改过。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Https <a href=\"https://zhuanlan.zhihu.com/p/27395037\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/27395037</a>    <a href=\"https://blog.51cto.com/11883699/2160032\" target=\"_blank\" rel=\"noopener\">https://blog.51cto.com/11883699/2160032</a></p>\n</li>\n<li>Ca 使用证书颁发机构的证书中的公钥去解密被颁发者的指纹算法和指纹，并计算比对指纹，正确才能验证身份</li>\n<li>const { EventEmitter } = require(‘events’);  EventEmitter 的继承</li>\n<li>Require.resovle() 获取模块的绝对路径  </li>\n<li>peerDependencies 相关模块安装</li>\n<li><p>websocket </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WebSocket 使用了自定义的二进制分帧格式，把每个应用消息切分成一或多个帧，发送到目的地之后再组装起来，等到接收到完整的消息后再通知接收端。基本的成帧协议定义了帧类型有操作码、有效载荷的长度，指定位置的Extension data和Application data，统称为Payload data，保留了一些特殊位和操作码供后期扩展。在打开握手完成后，终端发送一个关闭帧之前的任何时间里，数据帧可能由客户端或服务器的任何一方发送。</span><br><span class=\"line\"></span><br><span class=\"line\">• 帧：最小的通信单位，包含可变长度的帧首部和净荷部分，净荷可能包含完整或部分应用消息。</span><br><span class=\"line\">• 消息：一系列帧，与应用消息对等。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>jwt 签名算法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HS256 使用密钥生成固定的签名，RS256 使用成非对称进行签名。简单地说，HS256 必须与任何想要验证 JWT的 客户端或 API 共享秘密。</span><br><span class=\"line\">RS256 生成非对称签名，这意味着必须使用私钥来签签名 JWT，并且必须使用对应的公钥来验证签名。与对称算法不同，使用 RS256 可以保证服务端是 JWT 的签名者，因为服务端是唯一拥有私钥的一方。这样做将不再需要在许多应用程序之间共享私钥</span><br><span class=\"line\"></span><br><span class=\"line\">这种方法可以让我们分离开签发与验证，签发时需要用一个密钥，验证时使用公钥，也就是有公钥的地方只能做验证，但不能签发 JWT。</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"egg\"><a href=\"#egg\" class=\"headerlink\" title=\"egg\"></a>egg</h3><ol>\n<li>启动顺序<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Master 启动后先 fork Agent 进程</span><br><span class=\"line\">Agent 初始化成功后，通过 IPC 通道通知 Master</span><br><span class=\"line\">Master 再 fork 多个 App Worker</span><br><span class=\"line\">App Worker 初始化成功，通知 Master</span><br><span class=\"line\">所有的进程初始化成功后，Master 通知 Agent 和 Worker 应用启动成功</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h3><ol>\n<li><p>子网是所属VPC IP地址范围内的 IP 地址块。目前私有网络中的云资源部署在子网内，如云主机、容器、负载均衡等。</p>\n</li>\n<li><p>可用区（Availability Zone）是电力及网络之间互相独立的物理区域，相同可用区内的实例之间较之同地域不同可用区内实例之间的网络延时更小。同地域内不同可用区之间提供内网互通环境，可用区之间可做到故障隔离。<br>若您的业务要求有较低网络时延，建议将实例或者Pod部署在同一可用区内。</p>\n</li>\n</ol>\n<h3 id=\"vim\"><a href=\"#vim\" class=\"headerlink\" title=\"vim\"></a>vim</h3><p>j: 下移一行；</p>\n<p>k: 上移一行；</p>\n<p>w: 前移一个单词，光标停在下一个单词开头；</p>\n<p>e: 前移一个单词，光标停在下一个单词末尾；</p>\n<p>0: 移动到行首。</p>\n<p>$: 移动到行尾。</p>\n<p>n|: 把光标移到递n列上</p>\n<p>zz: 将当前行移动到屏幕中央。</p>\n<p>o: 在下面新建一行插入；</p>\n<p>O: 在上面新建一行插入；</p>\n<p>a: 在光标后插入；</p>\n<p>A: 在当前行最后插入；</p>\n<p>u: 取消一(n)个改动。</p>\n<p>ctrl + r: 重做最后的改动。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>:smile:</p>\n<h3 id=\"发版\"><a href=\"#发版\" class=\"headerlink\" title=\"发版\"></a>发版</h3><ol>\n<li>发布阶段：更新chagelog ,打 git tag 。</li>\n</ol>\n<h3 id=\"word\"><a href=\"#word\" class=\"headerlink\" title=\"word\"></a>word</h3><ol>\n<li>deflate 放气，紧缩</li>\n<li>Sanitize 消毒，净化</li>\n<li><h3 id=\"js\"><a href=\"#js\" class=\"headerlink\" title=\"js\"></a>js</h3></li>\n<li><p>随机字符串 Math.random().toString(36).substr(2));</p>\n</li>\n<li><p>Babel pollyfy 的作用 ：<a href=\"https://zhuanlan.zhihu.com/p/29058936\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/29058936</a></p>\n</li>\n<li><p>Babel stag2 的功能  <a href=\"https://github.com/babel/babel/tree/master/packages/babel-preset-stage-2\" target=\"_blank\" rel=\"noopener\">https://github.com/babel/babel/tree/master/packages/babel-preset-stage-2</a></p>\n</li>\n<li>所有的babel 包  <a href=\"https://github.com/babel/babel/tree/master/packages\" target=\"_blank\" rel=\"noopener\">https://github.com/babel/babel/tree/master/packages</a></li>\n<li>npx babel-upgrade</li>\n<li>ES2019 中为Symbol对象添加了只读属性 description ，该对象返回包含Symbol描述的字符串。</li>\n<li>变量的临时死区  </li>\n<li>SET 操作的时间复杂度</li>\n<li>如果你传的 context 就 null 或者 undefined，那么 window 对象就是默认的 context（严格模式下默认 context 是 undefined）</li>\n<li>高阶函数的定义</li>\n<li>作用域以及作用域链  函数作用域 —闭包</li>\n<li>ES6 模块功能是它的导入模块是导出时模块的实时只读视图。（相比起 CommonJS，导入的是导出模块的拷贝副本，因此也不是实时的）。只读视图和内存拷贝的区别。</li>\n<li>atob() 对经过 base-64 编码的字符串进行解码,btoa() base64加吗</li>\n<li>Console.dir  显示对象所有的属性和方法</li>\n<li>Broadcast Channel API 允许同一原始域和用户代理下的所有窗口,iFrames 等进行交互。也就是说，如果用户打开了同一个网站的的两个标签窗口，如果网站内容发生了变化，那么两个窗口会同时得到更新通知。</li>\n<li>escape 在处理 0xff 之外字符的时候，是直接使用字符的 unicode 在前面加上一个 「%u」，而encodeURI则是先进行 UTF-8，再在 UTF-8 的每个字节码前加上一个 「%」； 所以通过encodeUrI 可以获取utf-8 字节长度</li>\n<li></li>\n</ol>\n<h4 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h4><ol>\n<li>无论你使用的是解释型语言(JavaScript、Python、Ruby)还是编译型语言(c#、Java、Rust)，都有一个共同的部分:将源代码作为纯文本解析为 抽象语法树(abstract syntax tree, AST) 的数据结构。</li>\n<li>AST 不仅以结构化的方式显示源代码，而且在语义分析中扮演着重要角色。在语义分析中，编译器验证程序和语言元素的语法使用是否正确。之后，使用 AST 来生成实际的字节码或者机器码。</li>\n<li><p>转义的过程：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">编写ES6代码</span><br><span class=\"line\">babylon 进行解析</span><br><span class=\"line\">解析得到 AST</span><br><span class=\"line\">plugin 用 babel-traverse 对 AST 树进行遍历转译</span><br><span class=\"line\">得到新的 AST树</span><br><span class=\"line\">用 babel-generator 通过 AST 树生成 ES5 代码</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>要应用更新，Virtual DOM核心功能将发挥作用，即 协调算法，它的工作是提供最优的解决方案来解决以前和当前虚拟DOM 状态之间的差异。</p>\n</li>\n</ol>\n<h2 id=\"opentracing\"><a href=\"#opentracing\" class=\"headerlink\" title=\"opentracing\"></a>opentracing</h2><ol>\n<li>Opentracing 的carrier 有多种实现，tracer 的inject（客户端进程） 和 extract（服务端进程），这样 客户端和服务端 就可以拥有相同的trace context。</li>\n<li>Server 首先extract check 有没有注入的span，没有的话启动一个新的span</li>\n</ol>\n<h2 id=\"mac\"><a href=\"#mac\" class=\"headerlink\" title=\"mac\"></a>mac</h2><ol>\n<li>Mac 设置path  export PATH=$PATH:</li>\n<li>查看端口占用：lsof -i:3001</li>\n<li>export http_proxy=”<a href=\"http://localhost:8899&quot;\" target=\"_blank\" rel=\"noopener\">http://localhost:8899&quot;</a></li>\n<li>Grep -A 5 显示后面5行信息</li>\n</ol>\n<h2 id=\"npm\"><a href=\"#npm\" class=\"headerlink\" title=\"npm\"></a>npm</h2><ol>\n<li>npm config edit</li>\n<li>npm config set init.author.name “ryansecreat”</li>\n<li>npm config set <a href=\"mailto:init.email=&#39;chenjingnan@jd.com\" target=\"_blank\" rel=\"noopener\">init.email=&#39;chenjingnan@jd.com</a>’</li>\n<li>npm config set init.license “MIT”</li>\n<li>npm start –prefix path/to/your/folder   //指定目录下运行</li>\n<li>npm repo   浏览器中打开repo</li>\n<li>npm publish –registry=<a href=\"http://registry.npmjs.org\" target=\"_blank\" rel=\"noopener\">http://registry.npmjs.org</a>  –registry=<a href=\"https://registry.npm.taobao.org\" target=\"_blank\" rel=\"noopener\">https://registry.npm.taobao.org</a></li>\n<li>npm outdated  查看过时package</li>\n<li>npm publish –tag=beta.</li>\n<li>npm version patch -m “Upgrade to %s for reasons”</li>\n<li>npm dist-tag add <a href=\"mailto:n-n-n-n@1.0.2-1\" target=\"_blank\" rel=\"noopener\">n-n-n-n@1.0.2-1</a> latest  将某个预发版本更新为最新   </li>\n<li>npm ping [–registry <registry>]</registry></li>\n</ol>\n<h3 id=\"node\"><a href=\"#node\" class=\"headerlink\" title=\"node\"></a>node</h3><ol>\n<li>Stream cork uncork</li>\n<li>escape-html  This function will escape the following characters: “, ‘, &amp;, &lt;, and &gt;.</li>\n<li>domain模块，把处理多个不同的IO的操作作为一个组。注册事件和回调到domain，当发生一个错误事件或抛出一个错误时，domain对象会被通知，不会丢失上下文环境，也不导致程序错误立即退出，与process.on(‘uncaughtException’)不同。</li>\n<li><p>stream tranform</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const &#123; Transform &#125; = require(&apos;stream&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">const myTransform = new Transform(&#123;</span><br><span class=\"line\">  transform(chunk, encoding, callback) &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>可以引入corejs实现feature</p>\n</li>\n<li><p>性能分析<br>Node 性能分析，抓取火焰图 node –inspect app.js<br>Node  –prof-process  <a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/1.3%20Tick%20Processor.md\" target=\"_blank\" rel=\"noopener\">https://github.com/nswbmw/node-in-debugging/blob/master/1.3%20Tick%20Processor.md</a></p>\n</li>\n<li><p>一个promise类 </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sleep</span> </span>&#123;</span><br><span class=\"line\">then(resolve, reject)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Node 内置了pipeline  const { pipeline } = require(‘stream’);</p>\n</li>\n<li>Elastic APM 是 Elastic 公司开源的一款 APM 工具</li>\n<li><p>Error.prepareStackTrace:定制化堆栈信息    Error.captureStackTrace:隐藏内部的实现细节，优化错误栈。<br>1.http2</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http2基础理论</span><br><span class=\"line\"></span><br><span class=\"line\">HTTP2是二进制协议</span><br><span class=\"line\">这是一个复用协议。并行的请求能在同一个链接中处理，移除了HTTP/1.x中顺序和阻塞的约束。</span><br><span class=\"line\">压缩了headers。因为headers在一系列请求中常常是相似的，其移除了重复和传输重复数据的成本。</span><br><span class=\"line\">其允许服务器在客户端缓存中填充数据，通过一个叫服务器推送的机制来提前请求。</span><br><span class=\"line\">对Alt-Svc的支持允许了给定资源的位置和资源鉴定，允许了更智能的CDN缓冲机制。</span><br><span class=\"line\">Client-Hints 的引入允许浏览器或者客户端来主动交流它的需求，或者是硬件约束的信息给服务端。</span><br><span class=\"line\">在Cookie头中引入安全相关的的前缀，现在帮助保证一个安全的cookie没被更改过。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Https <a href=\"https://zhuanlan.zhihu.com/p/27395037\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/27395037</a>    <a href=\"https://blog.51cto.com/11883699/2160032\" target=\"_blank\" rel=\"noopener\">https://blog.51cto.com/11883699/2160032</a></p>\n</li>\n<li>Ca 使用证书颁发机构的证书中的公钥去解密被颁发者的指纹算法和指纹，并计算比对指纹，正确才能验证身份</li>\n<li>const { EventEmitter } = require(‘events’);  EventEmitter 的继承</li>\n<li>Require.resovle() 获取模块的绝对路径  </li>\n<li>peerDependencies 相关模块安装</li>\n<li><p>websocket </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WebSocket 使用了自定义的二进制分帧格式，把每个应用消息切分成一或多个帧，发送到目的地之后再组装起来，等到接收到完整的消息后再通知接收端。基本的成帧协议定义了帧类型有操作码、有效载荷的长度，指定位置的Extension data和Application data，统称为Payload data，保留了一些特殊位和操作码供后期扩展。在打开握手完成后，终端发送一个关闭帧之前的任何时间里，数据帧可能由客户端或服务器的任何一方发送。</span><br><span class=\"line\"></span><br><span class=\"line\">• 帧：最小的通信单位，包含可变长度的帧首部和净荷部分，净荷可能包含完整或部分应用消息。</span><br><span class=\"line\">• 消息：一系列帧，与应用消息对等。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>jwt 签名算法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HS256 使用密钥生成固定的签名，RS256 使用成非对称进行签名。简单地说，HS256 必须与任何想要验证 JWT的 客户端或 API 共享秘密。</span><br><span class=\"line\">RS256 生成非对称签名，这意味着必须使用私钥来签签名 JWT，并且必须使用对应的公钥来验证签名。与对称算法不同，使用 RS256 可以保证服务端是 JWT 的签名者，因为服务端是唯一拥有私钥的一方。这样做将不再需要在许多应用程序之间共享私钥</span><br><span class=\"line\"></span><br><span class=\"line\">这种方法可以让我们分离开签发与验证，签发时需要用一个密钥，验证时使用公钥，也就是有公钥的地方只能做验证，但不能签发 JWT。</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"egg\"><a href=\"#egg\" class=\"headerlink\" title=\"egg\"></a>egg</h3><ol>\n<li>启动顺序<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Master 启动后先 fork Agent 进程</span><br><span class=\"line\">Agent 初始化成功后，通过 IPC 通道通知 Master</span><br><span class=\"line\">Master 再 fork 多个 App Worker</span><br><span class=\"line\">App Worker 初始化成功，通知 Master</span><br><span class=\"line\">所有的进程初始化成功后，Master 通知 Agent 和 Worker 应用启动成功</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h3><ol>\n<li><p>子网是所属VPC IP地址范围内的 IP 地址块。目前私有网络中的云资源部署在子网内，如云主机、容器、负载均衡等。</p>\n</li>\n<li><p>可用区（Availability Zone）是电力及网络之间互相独立的物理区域，相同可用区内的实例之间较之同地域不同可用区内实例之间的网络延时更小。同地域内不同可用区之间提供内网互通环境，可用区之间可做到故障隔离。<br>若您的业务要求有较低网络时延，建议将实例或者Pod部署在同一可用区内。</p>\n</li>\n</ol>\n<h3 id=\"vim\"><a href=\"#vim\" class=\"headerlink\" title=\"vim\"></a>vim</h3><p>j: 下移一行；</p>\n<p>k: 上移一行；</p>\n<p>w: 前移一个单词，光标停在下一个单词开头；</p>\n<p>e: 前移一个单词，光标停在下一个单词末尾；</p>\n<p>0: 移动到行首。</p>\n<p>$: 移动到行尾。</p>\n<p>n|: 把光标移到递n列上</p>\n<p>zz: 将当前行移动到屏幕中央。</p>\n<p>o: 在下面新建一行插入；</p>\n<p>O: 在上面新建一行插入；</p>\n<p>a: 在光标后插入；</p>\n<p>A: 在当前行最后插入；</p>\n<p>u: 取消一(n)个改动。</p>\n<p>ctrl + r: 重做最后的改动。</p>\n"},{"title":"Let's Encrypt","date":"2016-12-21T03:47:39.000Z","_content":"\n### 使用Let's Encrypt生成免费SSL证书\n\n官网：[Let's Encrypt](https://letsencrypt.org/)\n\nLet's Encrypt是由互联网安全研究小组（ISRG，一个公益组织）提供的服务。提供免费、自动化、开放的证书签发服务。\n\nLet's Encrypt颁发的证书有期是90天，需要在过期前进行续期，好在Let's Encrypt已经提供了自动续期的脚本。\n\n官网推荐使用[Certbot](https://certbot.eff.org/)工具来部署Https证书。在Certbot首页上选择Web服务器及服务器OS类型，我们在这里以Nginx + CentOS 6为例来说明。\n\n原文链接：[https://certbot.eff.org/#centos6-nginx](https://certbot.eff.org/#centos6-nginx)\n\n0. #### 生成证书\n\n\t0. 安装证书生成工具certbot-auto：\n\n\t\t```\n\t\twget https://dl.eff.org/certbot-auto\n\t\tchmod a+x certbot-auto\n\t\t```\n\t0. 安装依赖\n\n\t\t运行```./certbot-auto```，安装所有依赖项。过程中可能会提示```Virtualenv Command Not Found```，需要[安装pip](https://pip.pypa.io/en/stable/installing/)、virtualenv包：```pip install virtualenv```。\n\n\t0. 配置Nginx\n\t\t\n\t\t为需要配置https的站点添加以下配置，将访问/.well-known的请求指向本地目录。Let's Encrypt在生成证书的过程中，会在/var/www/www.xxx.com/.well-known目录生成一个临时文件，并且会访问类似于http://www.xxx.com/.well-known/acme-challenge/HGr8U1IeTW4kY_Z6UIyaakzOkyQgPr_7ArlLgtZE8SX的url，来检查域名配置是否有效。\n\n\t\t添加以下配置，并重启Nginx：nginx -s reload，如果reload不生效，可以试试restart。\n\t\t\n\t\t```\n\t\tserver {\n\n\t\t\t...\t\t\t\n\n\t\t\tlocation /.well-known {\n\t        \talias /var/www/www.xxx.com/.well-known;\n\t    \t}\n\n\t\t\t...\n\n\t\t}\n\t\t```\n\n\t\t*即使证书生成之后，也需要保留Nginx的这一个配置，因为证书的续期还需要这一个配置。*\n\n\t0. 通过向导生成证书\n\n\t\t运行```./certbot-auto certonly```，会通过向导方式一步一步来生成证书。过程中间会用到上一步在Nginx中配置的本地目录。\n\n\t\t**对证书生成过程和原理比较熟悉的话，可以不使用向导方式，直接使用certbot-auto命令```./certbot-auto certonly --webroot -w /var/www/www.xxx.com -d xxx.com -d www.xxx.com -w /var/www/thing -d thing.is -d m.thing.is```可以快速高效地生成证书**\n\n\t\t生成的证书默认在/etc/letsencrypt/live/www.xxx.com/目录。\n\n0. #### 配置Nginx使用证书\n\n\t添加以下配置，并重启Nginx：```nginx -s reload```，如果reload不生效，可以试试restart。\n\n\t```\n\tserver {\n\n\t\t...\n\t\tlisten 443;\n\n\t    ssl on;\n        ssl_stapling_verify on;\n        ssl_certificate         /etc/letsencrypt/live/www.xxx.com/fullchain.pem;\n        ssl_certificate_key     /etc/letsencrypt/live/www.xxx.com/privkey.pem;\n\n\t\t...\n\n\t}\n\t```\n\n0. #### 检查证书的有效性\n\n\t打开浏览器，检查证书的有效性。\n\n0. #### 证书续期\n\n\tLet's Encrypt颁发的证书有期是90天，需要在过期前进行续期，好在Let's Encrypt已经提供了自动续期的脚本。\n\n\t官网说明，可以一天调用两次，如果检测到证书不需要更新，是什么都不做的，以减少意外造成的故障。\n\n\t先运行```certbot-auto renew --dry-run```命令检查证书自动续期是否正常，如果正常，将```certbot-auto renew --quiet```命令添加到系统的计划任务cron中，就可以实现证书自动续期了。\n\n\t```\n\t01 1 * * * ./path/to/certbot-auto renew --quiet\n\t```\n\t表示每天的1点1分自动执行续期脚本。\n\n\n\n\n\n","source":"_posts/Let's Encrypt SSL.md","raw":"---\ntitle: Let's Encrypt\ndate: 2016-12-21 11:47:39\ntags: https\n---\n\n### 使用Let's Encrypt生成免费SSL证书\n\n官网：[Let's Encrypt](https://letsencrypt.org/)\n\nLet's Encrypt是由互联网安全研究小组（ISRG，一个公益组织）提供的服务。提供免费、自动化、开放的证书签发服务。\n\nLet's Encrypt颁发的证书有期是90天，需要在过期前进行续期，好在Let's Encrypt已经提供了自动续期的脚本。\n\n官网推荐使用[Certbot](https://certbot.eff.org/)工具来部署Https证书。在Certbot首页上选择Web服务器及服务器OS类型，我们在这里以Nginx + CentOS 6为例来说明。\n\n原文链接：[https://certbot.eff.org/#centos6-nginx](https://certbot.eff.org/#centos6-nginx)\n\n0. #### 生成证书\n\n\t0. 安装证书生成工具certbot-auto：\n\n\t\t```\n\t\twget https://dl.eff.org/certbot-auto\n\t\tchmod a+x certbot-auto\n\t\t```\n\t0. 安装依赖\n\n\t\t运行```./certbot-auto```，安装所有依赖项。过程中可能会提示```Virtualenv Command Not Found```，需要[安装pip](https://pip.pypa.io/en/stable/installing/)、virtualenv包：```pip install virtualenv```。\n\n\t0. 配置Nginx\n\t\t\n\t\t为需要配置https的站点添加以下配置，将访问/.well-known的请求指向本地目录。Let's Encrypt在生成证书的过程中，会在/var/www/www.xxx.com/.well-known目录生成一个临时文件，并且会访问类似于http://www.xxx.com/.well-known/acme-challenge/HGr8U1IeTW4kY_Z6UIyaakzOkyQgPr_7ArlLgtZE8SX的url，来检查域名配置是否有效。\n\n\t\t添加以下配置，并重启Nginx：nginx -s reload，如果reload不生效，可以试试restart。\n\t\t\n\t\t```\n\t\tserver {\n\n\t\t\t...\t\t\t\n\n\t\t\tlocation /.well-known {\n\t        \talias /var/www/www.xxx.com/.well-known;\n\t    \t}\n\n\t\t\t...\n\n\t\t}\n\t\t```\n\n\t\t*即使证书生成之后，也需要保留Nginx的这一个配置，因为证书的续期还需要这一个配置。*\n\n\t0. 通过向导生成证书\n\n\t\t运行```./certbot-auto certonly```，会通过向导方式一步一步来生成证书。过程中间会用到上一步在Nginx中配置的本地目录。\n\n\t\t**对证书生成过程和原理比较熟悉的话，可以不使用向导方式，直接使用certbot-auto命令```./certbot-auto certonly --webroot -w /var/www/www.xxx.com -d xxx.com -d www.xxx.com -w /var/www/thing -d thing.is -d m.thing.is```可以快速高效地生成证书**\n\n\t\t生成的证书默认在/etc/letsencrypt/live/www.xxx.com/目录。\n\n0. #### 配置Nginx使用证书\n\n\t添加以下配置，并重启Nginx：```nginx -s reload```，如果reload不生效，可以试试restart。\n\n\t```\n\tserver {\n\n\t\t...\n\t\tlisten 443;\n\n\t    ssl on;\n        ssl_stapling_verify on;\n        ssl_certificate         /etc/letsencrypt/live/www.xxx.com/fullchain.pem;\n        ssl_certificate_key     /etc/letsencrypt/live/www.xxx.com/privkey.pem;\n\n\t\t...\n\n\t}\n\t```\n\n0. #### 检查证书的有效性\n\n\t打开浏览器，检查证书的有效性。\n\n0. #### 证书续期\n\n\tLet's Encrypt颁发的证书有期是90天，需要在过期前进行续期，好在Let's Encrypt已经提供了自动续期的脚本。\n\n\t官网说明，可以一天调用两次，如果检测到证书不需要更新，是什么都不做的，以减少意外造成的故障。\n\n\t先运行```certbot-auto renew --dry-run```命令检查证书自动续期是否正常，如果正常，将```certbot-auto renew --quiet```命令添加到系统的计划任务cron中，就可以实现证书自动续期了。\n\n\t```\n\t01 1 * * * ./path/to/certbot-auto renew --quiet\n\t```\n\t表示每天的1点1分自动执行续期脚本。\n\n\n\n\n\n","slug":"Let's Encrypt SSL","published":1,"updated":"2019-07-26T08:35:17.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2fu41za0002f18sfblm83je","content":"<h3 id=\"使用Let’s-Encrypt生成免费SSL证书\"><a href=\"#使用Let’s-Encrypt生成免费SSL证书\" class=\"headerlink\" title=\"使用Let’s Encrypt生成免费SSL证书\"></a>使用Let’s Encrypt生成免费SSL证书</h3><p>官网：<a href=\"https://letsencrypt.org/\" target=\"_blank\" rel=\"noopener\">Let’s Encrypt</a></p>\n<p>Let’s Encrypt是由互联网安全研究小组（ISRG，一个公益组织）提供的服务。提供免费、自动化、开放的证书签发服务。</p>\n<p>Let’s Encrypt颁发的证书有期是90天，需要在过期前进行续期，好在Let’s Encrypt已经提供了自动续期的脚本。</p>\n<p>官网推荐使用<a href=\"https://certbot.eff.org/\" target=\"_blank\" rel=\"noopener\">Certbot</a>工具来部署Https证书。在Certbot首页上选择Web服务器及服务器OS类型，我们在这里以Nginx + CentOS 6为例来说明。</p>\n<p>原文链接：<a href=\"https://certbot.eff.org/#centos6-nginx\" target=\"_blank\" rel=\"noopener\">https://certbot.eff.org/#centos6-nginx</a></p>\n<ol start=\"0\">\n<li><h4 id=\"生成证书\"><a href=\"#生成证书\" class=\"headerlink\" title=\"生成证书\"></a>生成证书</h4><ol start=\"0\">\n<li><p>安装证书生成工具certbot-auto：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://dl.eff.org/certbot-auto</span><br><span class=\"line\">chmod a+x certbot-auto</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>安装依赖</p>\n<p> 运行<figure class=\"highlight plain\"><figcaption><span>Command Not Found```，需要[安装pip](https://pip.pypa.io/en/stable/installing/)、virtualenv包：```pip install virtualenv```。</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">0. 配置Nginx</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t为需要配置https的站点添加以下配置，将访问/.well-known的请求指向本地目录。Let&apos;s Encrypt在生成证书的过程中，会在/var/www/www.xxx.com/.well-known目录生成一个临时文件，并且会访问类似于http://www.xxx.com/.well-known/acme-challenge/HGr8U1IeTW4kY_Z6UIyaakzOkyQgPr_7ArlLgtZE8SX的url，来检查域名配置是否有效。</span><br><span class=\"line\"></span><br><span class=\"line\">\t添加以下配置，并重启Nginx：nginx -s reload，如果reload不生效，可以试试restart。</span><br></pre></td></tr></table></figure></p>\n<p> server {</p>\n<pre><code>...            \n\nlocation /.well-known {\n    alias /var/www/www.xxx.com/.well-known;\n}\n\n...\n</code></pre><p> }</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">\t\t*即使证书生成之后，也需要保留Nginx的这一个配置，因为证书的续期还需要这一个配置。*</span><br><span class=\"line\"></span><br><span class=\"line\">\t0. 通过向导生成证书</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t运行```./certbot-auto certonly```，会通过向导方式一步一步来生成证书。过程中间会用到上一步在Nginx中配置的本地目录。</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t**对证书生成过程和原理比较熟悉的话，可以不使用向导方式，直接使用certbot-auto命令```./certbot-auto certonly --webroot -w /var/www/www.xxx.com -d xxx.com -d www.xxx.com -w /var/www/thing -d thing.is -d m.thing.is```可以快速高效地生成证书**</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t生成的证书默认在/etc/letsencrypt/live/www.xxx.com/目录。</span><br><span class=\"line\"></span><br><span class=\"line\">0. #### 配置Nginx使用证书</span><br><span class=\"line\"></span><br><span class=\"line\">\t添加以下配置，并重启Nginx：```nginx -s reload```，如果reload不生效，可以试试restart。</span><br></pre></td></tr></table></figure>\n<p>server {</p>\n<p> …<br> listen 443;</p>\n<p> ssl on;<br> ssl_stapling_verify on;<br> ssl_certificate         /etc/letsencrypt/live/<a href=\"http://www.xxx.com/fullchain.pem\" target=\"_blank\" rel=\"noopener\">www.xxx.com/fullchain.pem</a>;<br> ssl_certificate_key     /etc/letsencrypt/live/<a href=\"http://www.xxx.com/privkey.pem\" target=\"_blank\" rel=\"noopener\">www.xxx.com/privkey.pem</a>;</p>\n<p> …</p>\n<p>}</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">0. #### 检查证书的有效性</span><br><span class=\"line\"></span><br><span class=\"line\">\t打开浏览器，检查证书的有效性。</span><br><span class=\"line\"></span><br><span class=\"line\">0. #### 证书续期</span><br><span class=\"line\"></span><br><span class=\"line\">\tLet&apos;s Encrypt颁发的证书有期是90天，需要在过期前进行续期，好在Let&apos;s Encrypt已经提供了自动续期的脚本。</span><br><span class=\"line\"></span><br><span class=\"line\">\t官网说明，可以一天调用两次，如果检测到证书不需要更新，是什么都不做的，以减少意外造成的故障。</span><br><span class=\"line\"></span><br><span class=\"line\">\t先运行```certbot-auto renew --dry-run```命令检查证书自动续期是否正常，如果正常，将```certbot-auto renew --quiet```命令添加到系统的计划任务cron中，就可以实现证书自动续期了。</span><br></pre></td></tr></table></figure>\n<p>01 1 <em> </em> * ./path/to/certbot-auto renew –quiet<br><code>`</code><br>表示每天的1点1分自动执行续期脚本。</p>\n</li>\n</ol>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"使用Let’s-Encrypt生成免费SSL证书\"><a href=\"#使用Let’s-Encrypt生成免费SSL证书\" class=\"headerlink\" title=\"使用Let’s Encrypt生成免费SSL证书\"></a>使用Let’s Encrypt生成免费SSL证书</h3><p>官网：<a href=\"https://letsencrypt.org/\" target=\"_blank\" rel=\"noopener\">Let’s Encrypt</a></p>\n<p>Let’s Encrypt是由互联网安全研究小组（ISRG，一个公益组织）提供的服务。提供免费、自动化、开放的证书签发服务。</p>\n<p>Let’s Encrypt颁发的证书有期是90天，需要在过期前进行续期，好在Let’s Encrypt已经提供了自动续期的脚本。</p>\n<p>官网推荐使用<a href=\"https://certbot.eff.org/\" target=\"_blank\" rel=\"noopener\">Certbot</a>工具来部署Https证书。在Certbot首页上选择Web服务器及服务器OS类型，我们在这里以Nginx + CentOS 6为例来说明。</p>\n<p>原文链接：<a href=\"https://certbot.eff.org/#centos6-nginx\" target=\"_blank\" rel=\"noopener\">https://certbot.eff.org/#centos6-nginx</a></p>\n<ol start=\"0\">\n<li><h4 id=\"生成证书\"><a href=\"#生成证书\" class=\"headerlink\" title=\"生成证书\"></a>生成证书</h4><ol start=\"0\">\n<li><p>安装证书生成工具certbot-auto：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://dl.eff.org/certbot-auto</span><br><span class=\"line\">chmod a+x certbot-auto</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>安装依赖</p>\n<p> 运行<figure class=\"highlight plain\"><figcaption><span>Command Not Found```，需要[安装pip](https://pip.pypa.io/en/stable/installing/)、virtualenv包：```pip install virtualenv```。</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">0. 配置Nginx</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t为需要配置https的站点添加以下配置，将访问/.well-known的请求指向本地目录。Let&apos;s Encrypt在生成证书的过程中，会在/var/www/www.xxx.com/.well-known目录生成一个临时文件，并且会访问类似于http://www.xxx.com/.well-known/acme-challenge/HGr8U1IeTW4kY_Z6UIyaakzOkyQgPr_7ArlLgtZE8SX的url，来检查域名配置是否有效。</span><br><span class=\"line\"></span><br><span class=\"line\">\t添加以下配置，并重启Nginx：nginx -s reload，如果reload不生效，可以试试restart。</span><br></pre></td></tr></table></figure></p>\n<p> server {</p>\n<pre><code>...            \n\nlocation /.well-known {\n    alias /var/www/www.xxx.com/.well-known;\n}\n\n...\n</code></pre><p> }</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">\t\t*即使证书生成之后，也需要保留Nginx的这一个配置，因为证书的续期还需要这一个配置。*</span><br><span class=\"line\"></span><br><span class=\"line\">\t0. 通过向导生成证书</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t运行```./certbot-auto certonly```，会通过向导方式一步一步来生成证书。过程中间会用到上一步在Nginx中配置的本地目录。</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t**对证书生成过程和原理比较熟悉的话，可以不使用向导方式，直接使用certbot-auto命令```./certbot-auto certonly --webroot -w /var/www/www.xxx.com -d xxx.com -d www.xxx.com -w /var/www/thing -d thing.is -d m.thing.is```可以快速高效地生成证书**</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t生成的证书默认在/etc/letsencrypt/live/www.xxx.com/目录。</span><br><span class=\"line\"></span><br><span class=\"line\">0. #### 配置Nginx使用证书</span><br><span class=\"line\"></span><br><span class=\"line\">\t添加以下配置，并重启Nginx：```nginx -s reload```，如果reload不生效，可以试试restart。</span><br></pre></td></tr></table></figure>\n<p>server {</p>\n<p> …<br> listen 443;</p>\n<p> ssl on;<br> ssl_stapling_verify on;<br> ssl_certificate         /etc/letsencrypt/live/<a href=\"http://www.xxx.com/fullchain.pem\" target=\"_blank\" rel=\"noopener\">www.xxx.com/fullchain.pem</a>;<br> ssl_certificate_key     /etc/letsencrypt/live/<a href=\"http://www.xxx.com/privkey.pem\" target=\"_blank\" rel=\"noopener\">www.xxx.com/privkey.pem</a>;</p>\n<p> …</p>\n<p>}</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">0. #### 检查证书的有效性</span><br><span class=\"line\"></span><br><span class=\"line\">\t打开浏览器，检查证书的有效性。</span><br><span class=\"line\"></span><br><span class=\"line\">0. #### 证书续期</span><br><span class=\"line\"></span><br><span class=\"line\">\tLet&apos;s Encrypt颁发的证书有期是90天，需要在过期前进行续期，好在Let&apos;s Encrypt已经提供了自动续期的脚本。</span><br><span class=\"line\"></span><br><span class=\"line\">\t官网说明，可以一天调用两次，如果检测到证书不需要更新，是什么都不做的，以减少意外造成的故障。</span><br><span class=\"line\"></span><br><span class=\"line\">\t先运行```certbot-auto renew --dry-run```命令检查证书自动续期是否正常，如果正常，将```certbot-auto renew --quiet```命令添加到系统的计划任务cron中，就可以实现证书自动续期了。</span><br></pre></td></tr></table></figure>\n<p>01 1 <em> </em> * ./path/to/certbot-auto renew –quiet<br><code>`</code><br>表示每天的1点1分自动执行续期脚本。</p>\n</li>\n</ol>\n</li>\n</ol>\n"},{"title":"css","date":"2019-05-07T07:12:57.000Z","_content":"\n1. overflow:https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow\n\n1. Element.scrollTop 属性可以获取或设置一个元素的内容垂直滚动的像素数。\n\noffsetTop: 当前元素顶部距离最近父元素顶部的距离,和有没有滚动条没有关系。单位px，只读元素。\n\n  scrollHeight: 因为子元素比父元素高，父元素不想被子元素撑的一样高就显示出了滚动条，在滚动的过程中本元素有部分被隐藏了，scrollHeight代表包括当前不可见部分的元素的高度。而可见部分的高度其实就是clientHeight，也就是scrollHeight>=clientHeight恒成立。在有滚动条时讨论scrollHeight才有意义，在没有滚动条时scrollHeight==clientHeight恒成立。单位px，只读元素。\n\n   https://imweb.io/topic/57c5409e808fd2fb204eef52\n\n   clientheight offsetheight \n\n\n1. 相对位置：\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/position\n\n1. Image alt 属性是一个必需的属性，它规定在图像无法显示时的替代文本。\n\n\ntext-decoration 设置下划线等\nhttps://jsfiddle.net/ryansecreat/58um7k43/\n\ndocument​.active​Element\n\n 返回当前页面中获得焦点的元素,也就是说,如果此时用户按下了键盘上某个键,会在该元素上触发键盘事件.该属性是只读的.\n \n #### 性能  \n1. 尽量使用 flexbox 而不是老的布局模型。它运行速度更快，可为你的应用程序创造巨大的性能优势。\n1. 根据 Google Developer，渲染线程分为 主线程 (main thread) 和 合成线程 (compositor thread)。如果 CSS 动画只是改变 transforms 和 opacity，这时整个 CSS 动画得以在 合成线程完成（而JS动画则会在 主线程 执行，然后触发合成线程进行下一步操作），在 JS 执行一些昂贵的任务时，主线程繁忙，CSS 动画由于使用了合成线程可以保持流畅\n1. CSS动画有天然事件支持（TransitionEnd、AnimationEnd，但是它们都需要针对浏览器加前缀），JS则需要自己写事件。\n1. 在实现一些小的交互动效的时候，就多考虑考虑 CSS 动画。对于一些复杂控制的动画，使用 javascript 比较可靠。\n\n#### 块元素是一个元素，占用了全部宽度，在前后都是换行符。\n   ```text\n   块元素的例子：\n   \n   <h1>\n   <p>\n   <div>\n   内联元素只需要必要的宽度，不强制换行。\n   \n   内联元素的例子：\n   \n   <span>\n   <a>\n   \n```\n\n#### 内容对齐（justify-content）属性应用在弹性容器上，把弹性项沿着弹性容器的主轴线（main axis）对齐。\n       \n   align-items 设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式。\n   设置\"margin\"值为\"auto\"值，自动获取弹性容器中剩余的空间。所以设置垂直方向margin值为\"auto\"，可以使弹性子元素在弹性容器的两上轴方向都完全居中。 当容器为flex时会自动居中。\n   \n   如果在元素上设置了 box-sizing: border-box; 则 padding(内边距) 和 border(边框) 也包含在 width 和 height 中:\n   \n   transform: rotateX(120deg);  x轴旋转 \n   \n   \n   ","source":"_posts/css.md","raw":"---\ntitle: css\ndate: 2019-05-07 15:12:57\ntags: css\n---\n\n1. overflow:https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow\n\n1. Element.scrollTop 属性可以获取或设置一个元素的内容垂直滚动的像素数。\n\noffsetTop: 当前元素顶部距离最近父元素顶部的距离,和有没有滚动条没有关系。单位px，只读元素。\n\n  scrollHeight: 因为子元素比父元素高，父元素不想被子元素撑的一样高就显示出了滚动条，在滚动的过程中本元素有部分被隐藏了，scrollHeight代表包括当前不可见部分的元素的高度。而可见部分的高度其实就是clientHeight，也就是scrollHeight>=clientHeight恒成立。在有滚动条时讨论scrollHeight才有意义，在没有滚动条时scrollHeight==clientHeight恒成立。单位px，只读元素。\n\n   https://imweb.io/topic/57c5409e808fd2fb204eef52\n\n   clientheight offsetheight \n\n\n1. 相对位置：\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/position\n\n1. Image alt 属性是一个必需的属性，它规定在图像无法显示时的替代文本。\n\n\ntext-decoration 设置下划线等\nhttps://jsfiddle.net/ryansecreat/58um7k43/\n\ndocument​.active​Element\n\n 返回当前页面中获得焦点的元素,也就是说,如果此时用户按下了键盘上某个键,会在该元素上触发键盘事件.该属性是只读的.\n \n #### 性能  \n1. 尽量使用 flexbox 而不是老的布局模型。它运行速度更快，可为你的应用程序创造巨大的性能优势。\n1. 根据 Google Developer，渲染线程分为 主线程 (main thread) 和 合成线程 (compositor thread)。如果 CSS 动画只是改变 transforms 和 opacity，这时整个 CSS 动画得以在 合成线程完成（而JS动画则会在 主线程 执行，然后触发合成线程进行下一步操作），在 JS 执行一些昂贵的任务时，主线程繁忙，CSS 动画由于使用了合成线程可以保持流畅\n1. CSS动画有天然事件支持（TransitionEnd、AnimationEnd，但是它们都需要针对浏览器加前缀），JS则需要自己写事件。\n1. 在实现一些小的交互动效的时候，就多考虑考虑 CSS 动画。对于一些复杂控制的动画，使用 javascript 比较可靠。\n\n#### 块元素是一个元素，占用了全部宽度，在前后都是换行符。\n   ```text\n   块元素的例子：\n   \n   <h1>\n   <p>\n   <div>\n   内联元素只需要必要的宽度，不强制换行。\n   \n   内联元素的例子：\n   \n   <span>\n   <a>\n   \n```\n\n#### 内容对齐（justify-content）属性应用在弹性容器上，把弹性项沿着弹性容器的主轴线（main axis）对齐。\n       \n   align-items 设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式。\n   设置\"margin\"值为\"auto\"值，自动获取弹性容器中剩余的空间。所以设置垂直方向margin值为\"auto\"，可以使弹性子元素在弹性容器的两上轴方向都完全居中。 当容器为flex时会自动居中。\n   \n   如果在元素上设置了 box-sizing: border-box; 则 padding(内边距) 和 border(边框) 也包含在 width 和 height 中:\n   \n   transform: rotateX(120deg);  x轴旋转 \n   \n   \n   ","slug":"css","published":1,"updated":"2019-07-31T07:33:03.647Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2fu41zd0005f18s9y1sj839","content":"<ol>\n<li><p>overflow:<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow</a></p>\n</li>\n<li><p>Element.scrollTop 属性可以获取或设置一个元素的内容垂直滚动的像素数。</p>\n</li>\n</ol>\n<p>offsetTop: 当前元素顶部距离最近父元素顶部的距离,和有没有滚动条没有关系。单位px，只读元素。</p>\n<p>  scrollHeight: 因为子元素比父元素高，父元素不想被子元素撑的一样高就显示出了滚动条，在滚动的过程中本元素有部分被隐藏了，scrollHeight代表包括当前不可见部分的元素的高度。而可见部分的高度其实就是clientHeight，也就是scrollHeight&gt;=clientHeight恒成立。在有滚动条时讨论scrollHeight才有意义，在没有滚动条时scrollHeight==clientHeight恒成立。单位px，只读元素。</p>\n<p>   <a href=\"https://imweb.io/topic/57c5409e808fd2fb204eef52\" target=\"_blank\" rel=\"noopener\">https://imweb.io/topic/57c5409e808fd2fb204eef52</a></p>\n<p>   clientheight offsetheight </p>\n<ol>\n<li><p>相对位置：<br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/position\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/position</a></p>\n</li>\n<li><p>Image alt 属性是一个必需的属性，它规定在图像无法显示时的替代文本。</p>\n</li>\n</ol>\n<p>text-decoration 设置下划线等<br><a href=\"https://jsfiddle.net/ryansecreat/58um7k43/\" target=\"_blank\" rel=\"noopener\">https://jsfiddle.net/ryansecreat/58um7k43/</a></p>\n<p>document​.active​Element</p>\n<p> 返回当前页面中获得焦点的元素,也就是说,如果此时用户按下了键盘上某个键,会在该元素上触发键盘事件.该属性是只读的.</p>\n<h4 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h4><ol>\n<li>尽量使用 flexbox 而不是老的布局模型。它运行速度更快，可为你的应用程序创造巨大的性能优势。</li>\n<li>根据 Google Developer，渲染线程分为 主线程 (main thread) 和 合成线程 (compositor thread)。如果 CSS 动画只是改变 transforms 和 opacity，这时整个 CSS 动画得以在 合成线程完成（而JS动画则会在 主线程 执行，然后触发合成线程进行下一步操作），在 JS 执行一些昂贵的任务时，主线程繁忙，CSS 动画由于使用了合成线程可以保持流畅</li>\n<li>CSS动画有天然事件支持（TransitionEnd、AnimationEnd，但是它们都需要针对浏览器加前缀），JS则需要自己写事件。</li>\n<li>在实现一些小的交互动效的时候，就多考虑考虑 CSS 动画。对于一些复杂控制的动画，使用 javascript 比较可靠。</li>\n</ol>\n<h4 id=\"块元素是一个元素，占用了全部宽度，在前后都是换行符。\"><a href=\"#块元素是一个元素，占用了全部宽度，在前后都是换行符。\" class=\"headerlink\" title=\"块元素是一个元素，占用了全部宽度，在前后都是换行符。\"></a>块元素是一个元素，占用了全部宽度，在前后都是换行符。</h4>   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">块元素的例子：</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;h1&gt;</span><br><span class=\"line\">&lt;p&gt;</span><br><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">内联元素只需要必要的宽度，不强制换行。</span><br><span class=\"line\"></span><br><span class=\"line\">内联元素的例子：</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;span&gt;</span><br><span class=\"line\">&lt;a&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"内容对齐（justify-content）属性应用在弹性容器上，把弹性项沿着弹性容器的主轴线（main-axis）对齐。\"><a href=\"#内容对齐（justify-content）属性应用在弹性容器上，把弹性项沿着弹性容器的主轴线（main-axis）对齐。\" class=\"headerlink\" title=\"内容对齐（justify-content）属性应用在弹性容器上，把弹性项沿着弹性容器的主轴线（main axis）对齐。\"></a>内容对齐（justify-content）属性应用在弹性容器上，把弹性项沿着弹性容器的主轴线（main axis）对齐。</h4><p>   align-items 设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式。<br>   设置”margin”值为”auto”值，自动获取弹性容器中剩余的空间。所以设置垂直方向margin值为”auto”，可以使弹性子元素在弹性容器的两上轴方向都完全居中。 当容器为flex时会自动居中。</p>\n<p>   如果在元素上设置了 box-sizing: border-box; 则 padding(内边距) 和 border(边框) 也包含在 width 和 height 中:</p>\n<p>   transform: rotateX(120deg);  x轴旋转 </p>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><p>overflow:<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow</a></p>\n</li>\n<li><p>Element.scrollTop 属性可以获取或设置一个元素的内容垂直滚动的像素数。</p>\n</li>\n</ol>\n<p>offsetTop: 当前元素顶部距离最近父元素顶部的距离,和有没有滚动条没有关系。单位px，只读元素。</p>\n<p>  scrollHeight: 因为子元素比父元素高，父元素不想被子元素撑的一样高就显示出了滚动条，在滚动的过程中本元素有部分被隐藏了，scrollHeight代表包括当前不可见部分的元素的高度。而可见部分的高度其实就是clientHeight，也就是scrollHeight&gt;=clientHeight恒成立。在有滚动条时讨论scrollHeight才有意义，在没有滚动条时scrollHeight==clientHeight恒成立。单位px，只读元素。</p>\n<p>   <a href=\"https://imweb.io/topic/57c5409e808fd2fb204eef52\" target=\"_blank\" rel=\"noopener\">https://imweb.io/topic/57c5409e808fd2fb204eef52</a></p>\n<p>   clientheight offsetheight </p>\n<ol>\n<li><p>相对位置：<br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/position\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/position</a></p>\n</li>\n<li><p>Image alt 属性是一个必需的属性，它规定在图像无法显示时的替代文本。</p>\n</li>\n</ol>\n<p>text-decoration 设置下划线等<br><a href=\"https://jsfiddle.net/ryansecreat/58um7k43/\" target=\"_blank\" rel=\"noopener\">https://jsfiddle.net/ryansecreat/58um7k43/</a></p>\n<p>document​.active​Element</p>\n<p> 返回当前页面中获得焦点的元素,也就是说,如果此时用户按下了键盘上某个键,会在该元素上触发键盘事件.该属性是只读的.</p>\n<h4 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h4><ol>\n<li>尽量使用 flexbox 而不是老的布局模型。它运行速度更快，可为你的应用程序创造巨大的性能优势。</li>\n<li>根据 Google Developer，渲染线程分为 主线程 (main thread) 和 合成线程 (compositor thread)。如果 CSS 动画只是改变 transforms 和 opacity，这时整个 CSS 动画得以在 合成线程完成（而JS动画则会在 主线程 执行，然后触发合成线程进行下一步操作），在 JS 执行一些昂贵的任务时，主线程繁忙，CSS 动画由于使用了合成线程可以保持流畅</li>\n<li>CSS动画有天然事件支持（TransitionEnd、AnimationEnd，但是它们都需要针对浏览器加前缀），JS则需要自己写事件。</li>\n<li>在实现一些小的交互动效的时候，就多考虑考虑 CSS 动画。对于一些复杂控制的动画，使用 javascript 比较可靠。</li>\n</ol>\n<h4 id=\"块元素是一个元素，占用了全部宽度，在前后都是换行符。\"><a href=\"#块元素是一个元素，占用了全部宽度，在前后都是换行符。\" class=\"headerlink\" title=\"块元素是一个元素，占用了全部宽度，在前后都是换行符。\"></a>块元素是一个元素，占用了全部宽度，在前后都是换行符。</h4>   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">块元素的例子：</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;h1&gt;</span><br><span class=\"line\">&lt;p&gt;</span><br><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">内联元素只需要必要的宽度，不强制换行。</span><br><span class=\"line\"></span><br><span class=\"line\">内联元素的例子：</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;span&gt;</span><br><span class=\"line\">&lt;a&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"内容对齐（justify-content）属性应用在弹性容器上，把弹性项沿着弹性容器的主轴线（main-axis）对齐。\"><a href=\"#内容对齐（justify-content）属性应用在弹性容器上，把弹性项沿着弹性容器的主轴线（main-axis）对齐。\" class=\"headerlink\" title=\"内容对齐（justify-content）属性应用在弹性容器上，把弹性项沿着弹性容器的主轴线（main axis）对齐。\"></a>内容对齐（justify-content）属性应用在弹性容器上，把弹性项沿着弹性容器的主轴线（main axis）对齐。</h4><p>   align-items 设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式。<br>   设置”margin”值为”auto”值，自动获取弹性容器中剩余的空间。所以设置垂直方向margin值为”auto”，可以使弹性子元素在弹性容器的两上轴方向都完全居中。 当容器为flex时会自动居中。</p>\n<p>   如果在元素上设置了 box-sizing: border-box; 则 padding(内边距) 和 border(边框) 也包含在 width 和 height 中:</p>\n<p>   transform: rotateX(120deg);  x轴旋转 </p>\n"},{"title":"docker 常用命令","date":"2016-12-14T09:56:03.000Z","_content":"总结一下常用命令:\n\n其中<>阔起来的参数为必选，[]阔起来为可选\n\ndocker version 查看docker的版本号，包括客户端、服务端、依赖的Go等\ndocker info 查看系统(docker)层面信息，包括管理的images, containers数等\ndocker search <image> 在docker index中搜索image\ndocker pull <image> 从docker registry server 中下拉image\ndocker push <image|repository> 推送一个image或repository到registry\ndocker push <image|repository>:TAG 同上，指定tag\ndocker inspect <image|container> 查看image或container的底层信息\ndocker images TODO filter out the intermediate image layers (intermediate image layers 是什么)\ndocker images -a 列出所有的images\ndocker ps 默认显示正在运行中的container\ndocker ps -l 显示最后一次创建的container，包括未运行的\ndocker ps -a 显示所有的container，包括未运行的\ndocker logs <container> 查看container的日志，也就是执行命令的一些输出\ndocker rm <container...> 删除一个或多个container\ndocker rm `docker ps -a -q` 删除所有的container\ndocker ps -a -q | xargs docker rm 同上, 删除所有的container\ndocker rmi <image...> 删除一个或多个image\ndocker start/stop/restart <container> 开启/停止/重启container\ndocker start -i <container> 启动一个container并进入交互模式\ndocker attach <container> attach一个运行中的container\ndocker run <image> <command> 使用image创建container并执行相应命令，然后停止\ndocker run -i -t <image> /bin/bash 使用image创建container并进入交互模式, login shell是/bin/bash\ndocker run -i -t -p <host_port:contain_port> 将container的端口映射到宿主机的端口\ndocker commit <container> [repo:tag] 将一个container固化为一个新的image，后面的repo:tag可选\ndocker build <path> 寻找path路径下名为的Dockerfile的配置文件，使用此配置生成新的image\ndocker build -t repo[:tag] 同上，可以指定repo和可选的tag\ndocker build - < <dockerfile> 使用指定的dockerfile配置文件，docker以stdin方式获取内容，使用此配置生成新的image\ndocker port <container> <container port> 查看本地哪个端口映射到container的指定端口，其实用docker ps 也可以看到\n\n\n### 安装docker\n1. 利用官方脚本：\n\n```\n$ sudo yum update\n$ sudo curl -sSL https://get.docker.com/ | sh\n```\n2.  用黄狗安装：\n\n```\n$ sudo yum update\n$ sudo yum -y install docker\n$ sudo systemctl start docker\n```\n### 删除操作\n##### 删除所有已经停止的continer  -q 列出所有id\n\n```\ndocker rm $(docker ps -a -q)\n```\n##### 删除所有镜像\n\n```\ndocker rmi $(docker images | grep none | awk '{print $3}' | sort -r)\n```\n### 命令说明\n1. 其中go的语法模板\n \n```\ndocker images --format \"{{.ID}}: {{.Repository}}\"\ndocker images --format \"table {{.ID}}\\t{{.Repository}}\\t{{.Tag}}\"\n```\n2. filter 过滤参数\n \n```\ndocker images -f since=mongo:3.2\n```\n 表示自从3.2 版本以来所有的镜像。\n3. docker run -it --rm --name ryanserver ubuntu:14.04 bash \n   \n   it 表示交互终端 \n   rm 推出后删除\n   ubuntu  镜像名称\n   bash bash命令\n   naem 指定container名称\n```\ndocker run --name webserver -d -p 85:80 nginx\n```\n\n4. docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]\n- -a :提交的镜像作者；\n- -c :使用Dockerfile指令来创建镜像；\n- -m :提交时的说明文字；\n- -p :在commit时，将容器暂停。\n如：\n\n```\n$ docker commit \\\n    --author \"Tao Wang <twang2218@gmail.com>\" \\\n    --message \"修改了默认网页\" \\\n    webserver \\\n    nginx:v2\n```\n5.通过dockfile制作镜像\n\n```\nFROM nginx\nRUN echo '<h1>Hello, Docker!</h1>' > /usr/share/nginx/html/index.html\n```\nfrom 指定基础镜像 \n\nDockerfile中每次运行run 都执行了一层。&& 将各个所需命令串联起来\n\nDockerfile 支持 Shell 类的行尾添加 \\ 的命令换行方式，以及行首# 进行注释的格式\n一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。\n\ncopy 文件时可使用通配符，其通配符规则要满足 Go 的 filepath.Match 规则，如：\n\n```\nCOPY hom* /mydir/\nCOPY hom?.txt /mydir/\n```\nAdd 功能和copy 类似，不过自带解压功能：\n\n```\nFROM scratch\nADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /\n```\n###### 环境变量的配置\n格式有两种：\n  ● ENV <key> <value>\n  ● ENV <key1>=<value1> <key2>=<value2>...\n例如 ENV VERSION=1.0 DEBUG=on \\\n     NAME=\"Happy Feet\n######  匿名卷\n在 Dockerfile 中，我们可以事先指定某些目录挂载为匿名卷，\n任何向 /data 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如：\ndocker run -d -v mydata:/data xxxx\n###### 挂载host目录\n将host机中的文件挂载到container中：\ndocker可以支持把一个宿主机上的目录挂载到镜像里。\n\n```\ndocker run -it -v /home/dock/Downloads:/usr/Downloads ubuntu64 /bin/bash\n```\n\n通过-v参数，冒号前为宿主机目录，必须为绝对路径，冒号后为镜像内挂载的路径。\n\n一个dockfile:\n \n```\nMAINTAINER Anna Doe <anna@example.com>\nnodejs pm2:\nFROM node:0.11.13\n# or just node, without tag\n\nRUN npm install -g pm2\nRUN pm2 dump\n# dump will start pm2 daemon and create everything needed\n\nVOLUME [\"/srv/apps\", \"/srv/logs\", \"/srv/server.json\"]\n# don't put the files in docker container, user -v\n\nEXPOSE 3000\n\nCMD [\"pm2\", \"start\", \"/srv/server.json\", \"--no-daemon\"]\n# no daemon mode for docker\n```\n\n6. docker build -t repo[:tag] . \n   \n可以指定repo和可选的tag\n如果注意，会看到 docker build 命令最后有一个 .。. 表示当前目录\ncopy命令只有在当前上下文有有效\n\n7. 从container中导出\n导出(Export)\nExport命令用于持久化容器（不是镜像）\n接着执行导出：\nsudo docker export <CONTAINER ID> > /home/export.tar\n\n导出后，可以通过docker import   导入，如\n\n```\ncat busy.tar | sudo docker import - busy:v1.0\n\n```\n\n8. 保存镜像\n   sudo docker save busybox-1 > /home/save.tar\n\n\n```\n用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以使用 docker import 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。\n```\n\n9. docker 自启动配置\n\n自动启动container 如下：\n\n```\ndocker run -ti --restart=on-failure:3   \n失败后会启动三次\n```\n10. 用非root用户操作docker\n下面是使用非root用户操作的步骤\n\n```\n创建docker组\nsudo groupadd docker\n将当前用户加入docker组\nsudo gpasswd -a ${USER} docker\n重新启动docker服务（下面是CentOS7的命令）\nsudo systemctl restart docker\n当前用户退出系统重新登陆\n运行docker命令\ndocker ps\n```\n\n11.用docker 启动zookeeper \n\n```\nps -aux | grep docker\ndocker run  --name alizookeeper --restart always -d -P zookeeper\n```\n\n ","source":"_posts/docker.md","raw":"---\ntitle: docker 常用命令\ndate: 2016-12-14 17:56:03\ntags: docker\n---\n总结一下常用命令:\n\n其中<>阔起来的参数为必选，[]阔起来为可选\n\ndocker version 查看docker的版本号，包括客户端、服务端、依赖的Go等\ndocker info 查看系统(docker)层面信息，包括管理的images, containers数等\ndocker search <image> 在docker index中搜索image\ndocker pull <image> 从docker registry server 中下拉image\ndocker push <image|repository> 推送一个image或repository到registry\ndocker push <image|repository>:TAG 同上，指定tag\ndocker inspect <image|container> 查看image或container的底层信息\ndocker images TODO filter out the intermediate image layers (intermediate image layers 是什么)\ndocker images -a 列出所有的images\ndocker ps 默认显示正在运行中的container\ndocker ps -l 显示最后一次创建的container，包括未运行的\ndocker ps -a 显示所有的container，包括未运行的\ndocker logs <container> 查看container的日志，也就是执行命令的一些输出\ndocker rm <container...> 删除一个或多个container\ndocker rm `docker ps -a -q` 删除所有的container\ndocker ps -a -q | xargs docker rm 同上, 删除所有的container\ndocker rmi <image...> 删除一个或多个image\ndocker start/stop/restart <container> 开启/停止/重启container\ndocker start -i <container> 启动一个container并进入交互模式\ndocker attach <container> attach一个运行中的container\ndocker run <image> <command> 使用image创建container并执行相应命令，然后停止\ndocker run -i -t <image> /bin/bash 使用image创建container并进入交互模式, login shell是/bin/bash\ndocker run -i -t -p <host_port:contain_port> 将container的端口映射到宿主机的端口\ndocker commit <container> [repo:tag] 将一个container固化为一个新的image，后面的repo:tag可选\ndocker build <path> 寻找path路径下名为的Dockerfile的配置文件，使用此配置生成新的image\ndocker build -t repo[:tag] 同上，可以指定repo和可选的tag\ndocker build - < <dockerfile> 使用指定的dockerfile配置文件，docker以stdin方式获取内容，使用此配置生成新的image\ndocker port <container> <container port> 查看本地哪个端口映射到container的指定端口，其实用docker ps 也可以看到\n\n\n### 安装docker\n1. 利用官方脚本：\n\n```\n$ sudo yum update\n$ sudo curl -sSL https://get.docker.com/ | sh\n```\n2.  用黄狗安装：\n\n```\n$ sudo yum update\n$ sudo yum -y install docker\n$ sudo systemctl start docker\n```\n### 删除操作\n##### 删除所有已经停止的continer  -q 列出所有id\n\n```\ndocker rm $(docker ps -a -q)\n```\n##### 删除所有镜像\n\n```\ndocker rmi $(docker images | grep none | awk '{print $3}' | sort -r)\n```\n### 命令说明\n1. 其中go的语法模板\n \n```\ndocker images --format \"{{.ID}}: {{.Repository}}\"\ndocker images --format \"table {{.ID}}\\t{{.Repository}}\\t{{.Tag}}\"\n```\n2. filter 过滤参数\n \n```\ndocker images -f since=mongo:3.2\n```\n 表示自从3.2 版本以来所有的镜像。\n3. docker run -it --rm --name ryanserver ubuntu:14.04 bash \n   \n   it 表示交互终端 \n   rm 推出后删除\n   ubuntu  镜像名称\n   bash bash命令\n   naem 指定container名称\n```\ndocker run --name webserver -d -p 85:80 nginx\n```\n\n4. docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]\n- -a :提交的镜像作者；\n- -c :使用Dockerfile指令来创建镜像；\n- -m :提交时的说明文字；\n- -p :在commit时，将容器暂停。\n如：\n\n```\n$ docker commit \\\n    --author \"Tao Wang <twang2218@gmail.com>\" \\\n    --message \"修改了默认网页\" \\\n    webserver \\\n    nginx:v2\n```\n5.通过dockfile制作镜像\n\n```\nFROM nginx\nRUN echo '<h1>Hello, Docker!</h1>' > /usr/share/nginx/html/index.html\n```\nfrom 指定基础镜像 \n\nDockerfile中每次运行run 都执行了一层。&& 将各个所需命令串联起来\n\nDockerfile 支持 Shell 类的行尾添加 \\ 的命令换行方式，以及行首# 进行注释的格式\n一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。\n\ncopy 文件时可使用通配符，其通配符规则要满足 Go 的 filepath.Match 规则，如：\n\n```\nCOPY hom* /mydir/\nCOPY hom?.txt /mydir/\n```\nAdd 功能和copy 类似，不过自带解压功能：\n\n```\nFROM scratch\nADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /\n```\n###### 环境变量的配置\n格式有两种：\n  ● ENV <key> <value>\n  ● ENV <key1>=<value1> <key2>=<value2>...\n例如 ENV VERSION=1.0 DEBUG=on \\\n     NAME=\"Happy Feet\n######  匿名卷\n在 Dockerfile 中，我们可以事先指定某些目录挂载为匿名卷，\n任何向 /data 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如：\ndocker run -d -v mydata:/data xxxx\n###### 挂载host目录\n将host机中的文件挂载到container中：\ndocker可以支持把一个宿主机上的目录挂载到镜像里。\n\n```\ndocker run -it -v /home/dock/Downloads:/usr/Downloads ubuntu64 /bin/bash\n```\n\n通过-v参数，冒号前为宿主机目录，必须为绝对路径，冒号后为镜像内挂载的路径。\n\n一个dockfile:\n \n```\nMAINTAINER Anna Doe <anna@example.com>\nnodejs pm2:\nFROM node:0.11.13\n# or just node, without tag\n\nRUN npm install -g pm2\nRUN pm2 dump\n# dump will start pm2 daemon and create everything needed\n\nVOLUME [\"/srv/apps\", \"/srv/logs\", \"/srv/server.json\"]\n# don't put the files in docker container, user -v\n\nEXPOSE 3000\n\nCMD [\"pm2\", \"start\", \"/srv/server.json\", \"--no-daemon\"]\n# no daemon mode for docker\n```\n\n6. docker build -t repo[:tag] . \n   \n可以指定repo和可选的tag\n如果注意，会看到 docker build 命令最后有一个 .。. 表示当前目录\ncopy命令只有在当前上下文有有效\n\n7. 从container中导出\n导出(Export)\nExport命令用于持久化容器（不是镜像）\n接着执行导出：\nsudo docker export <CONTAINER ID> > /home/export.tar\n\n导出后，可以通过docker import   导入，如\n\n```\ncat busy.tar | sudo docker import - busy:v1.0\n\n```\n\n8. 保存镜像\n   sudo docker save busybox-1 > /home/save.tar\n\n\n```\n用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以使用 docker import 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。\n```\n\n9. docker 自启动配置\n\n自动启动container 如下：\n\n```\ndocker run -ti --restart=on-failure:3   \n失败后会启动三次\n```\n10. 用非root用户操作docker\n下面是使用非root用户操作的步骤\n\n```\n创建docker组\nsudo groupadd docker\n将当前用户加入docker组\nsudo gpasswd -a ${USER} docker\n重新启动docker服务（下面是CentOS7的命令）\nsudo systemctl restart docker\n当前用户退出系统重新登陆\n运行docker命令\ndocker ps\n```\n\n11.用docker 启动zookeeper \n\n```\nps -aux | grep docker\ndocker run  --name alizookeeper --restart always -d -P zookeeper\n```\n\n ","slug":"docker","published":1,"updated":"2019-07-26T08:35:17.301Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2fu41zf0007f18swoohlp3h","content":"<p>总结一下常用命令:</p>\n<p>其中&lt;&gt;阔起来的参数为必选，[]阔起来为可选</p>\n<p>docker version 查看docker的版本号，包括客户端、服务端、依赖的Go等<br>docker info 查看系统(docker)层面信息，包括管理的images, containers数等<br>docker search <image> 在docker index中搜索image<br>docker pull <image> 从docker registry server 中下拉image<br>docker push &lt;image|repository&gt; 推送一个image或repository到registry<br>docker push &lt;image|repository&gt;:TAG 同上，指定tag<br>docker inspect &lt;image|container&gt; 查看image或container的底层信息<br>docker images TODO filter out the intermediate image layers (intermediate image layers 是什么)<br>docker images -a 列出所有的images<br>docker ps 默认显示正在运行中的container<br>docker ps -l 显示最后一次创建的container，包括未运行的<br>docker ps -a 显示所有的container，包括未运行的<br>docker logs <container> 查看container的日志，也就是执行命令的一些输出<br>docker rm &lt;container…&gt; 删除一个或多个container<br>docker rm <code>docker ps -a -q</code> 删除所有的container<br>docker ps -a -q | xargs docker rm 同上, 删除所有的container<br>docker rmi &lt;image…&gt; 删除一个或多个image<br>docker start/stop/restart <container> 开启/停止/重启container<br>docker start -i <container> 启动一个container并进入交互模式<br>docker attach <container> attach一个运行中的container<br>docker run <image> <command> 使用image创建container并执行相应命令，然后停止<br>docker run -i -t <image> /bin/bash 使用image创建container并进入交互模式, login shell是/bin/bash<br>docker run -i -t -p &lt;host_port:contain_port&gt; 将container的端口映射到宿主机的端口<br>docker commit <container> [repo:tag] 将一个container固化为一个新的image，后面的repo:tag可选<br>docker build <path> 寻找path路径下名为的Dockerfile的配置文件，使用此配置生成新的image<br>docker build -t repo[:tag] 同上，可以指定repo和可选的tag<br>docker build - &lt; <dockerfile> 使用指定的dockerfile配置文件，docker以stdin方式获取内容，使用此配置生成新的image<br>docker port <container> <container port=\"\"> 查看本地哪个端口映射到container的指定端口，其实用docker ps 也可以看到</container></container></dockerfile></path></container></image></image></container></container></container></container></image></image></p>\n<h3 id=\"安装docker\"><a href=\"#安装docker\" class=\"headerlink\" title=\"安装docker\"></a>安装docker</h3><ol>\n<li>利用官方脚本：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo yum update</span><br><span class=\"line\">$ sudo curl -sSL https://get.docker.com/ | sh</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>用黄狗安装：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo yum update</span><br><span class=\"line\">$ sudo yum -y install docker</span><br><span class=\"line\">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除操作\"><a href=\"#删除操作\" class=\"headerlink\" title=\"删除操作\"></a>删除操作</h3><h5 id=\"删除所有已经停止的continer-q-列出所有id\"><a href=\"#删除所有已经停止的continer-q-列出所有id\" class=\"headerlink\" title=\"删除所有已经停止的continer  -q 列出所有id\"></a>删除所有已经停止的continer  -q 列出所有id</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker rm $(docker ps -a -q)</span><br></pre></td></tr></table></figure>\n<h5 id=\"删除所有镜像\"><a href=\"#删除所有镜像\" class=\"headerlink\" title=\"删除所有镜像\"></a>删除所有镜像</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker rmi $(docker images | grep none | awk &apos;&#123;print $3&#125;&apos; | sort -r)</span><br></pre></td></tr></table></figure>\n<h3 id=\"命令说明\"><a href=\"#命令说明\" class=\"headerlink\" title=\"命令说明\"></a>命令说明</h3><ol>\n<li>其中go的语法模板</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker images --format &quot;&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;&quot;</span><br><span class=\"line\">docker images --format &quot;table &#123;&#123;.ID&#125;&#125;\\t&#123;&#123;.Repository&#125;&#125;\\t&#123;&#123;.Tag&#125;&#125;&quot;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>filter 过滤参数</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker images -f since=mongo:3.2</span><br></pre></td></tr></table></figure>\n<p> 表示自从3.2 版本以来所有的镜像。</p>\n<ol start=\"3\">\n<li><p>docker run -it –rm –name ryanserver ubuntu:14.04 bash </p>\n<p>it 表示交互终端<br>rm 推出后删除<br>ubuntu  镜像名称<br>bash bash命令<br>naem 指定container名称</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run --name webserver -d -p 85:80 nginx</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</p>\n</li>\n</ol>\n<ul>\n<li>-a :提交的镜像作者；</li>\n<li>-c :使用Dockerfile指令来创建镜像；</li>\n<li>-m :提交时的说明文字；</li>\n<li>-p :在commit时，将容器暂停。<br>如：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker commit \\</span><br><span class=\"line\">    --author &quot;Tao Wang &lt;twang2218@gmail.com&gt;&quot; \\</span><br><span class=\"line\">    --message &quot;修改了默认网页&quot; \\</span><br><span class=\"line\">    webserver \\</span><br><span class=\"line\">    nginx:v2</span><br></pre></td></tr></table></figure>\n<p>5.通过dockfile制作镜像</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM nginx</span><br><span class=\"line\">RUN echo &apos;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure>\n<p>from 指定基础镜像 </p>\n<p>Dockerfile中每次运行run 都执行了一层。&amp;&amp; 将各个所需命令串联起来</p>\n<p>Dockerfile 支持 Shell 类的行尾添加 \\ 的命令换行方式，以及行首# 进行注释的格式<br>一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p>\n<p>copy 文件时可使用通配符，其通配符规则要满足 Go 的 filepath.Match 规则，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">COPY hom* /mydir/</span><br><span class=\"line\">COPY hom?.txt /mydir/</span><br></pre></td></tr></table></figure>\n<p>Add 功能和copy 类似，不过自带解压功能：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM scratch</span><br><span class=\"line\">ADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /</span><br></pre></td></tr></table></figure>\n<h6 id=\"环境变量的配置\"><a href=\"#环境变量的配置\" class=\"headerlink\" title=\"环境变量的配置\"></a>环境变量的配置</h6><p>格式有两种：<br>  ● ENV <key> <value><br>  ● ENV <key1>=<value1> <key2>=<value2>…<br>例如 ENV VERSION=1.0 DEBUG=on \\<br>     NAME=”Happy Feet</value2></key2></value1></key1></value></key></p>\n<h6 id=\"匿名卷\"><a href=\"#匿名卷\" class=\"headerlink\" title=\"匿名卷\"></a>匿名卷</h6><p>在 Dockerfile 中，我们可以事先指定某些目录挂载为匿名卷，<br>任何向 /data 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如：<br>docker run -d -v mydata:/data xxxx</p>\n<h6 id=\"挂载host目录\"><a href=\"#挂载host目录\" class=\"headerlink\" title=\"挂载host目录\"></a>挂载host目录</h6><p>将host机中的文件挂载到container中：<br>docker可以支持把一个宿主机上的目录挂载到镜像里。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -it -v /home/dock/Downloads:/usr/Downloads ubuntu64 /bin/bash</span><br></pre></td></tr></table></figure>\n<p>通过-v参数，冒号前为宿主机目录，必须为绝对路径，冒号后为镜像内挂载的路径。</p>\n<p>一个dockfile:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MAINTAINER Anna Doe &lt;anna@example.com&gt;</span><br><span class=\"line\">nodejs pm2:</span><br><span class=\"line\">FROM node:0.11.13</span><br><span class=\"line\"># or just node, without tag</span><br><span class=\"line\"></span><br><span class=\"line\">RUN npm install -g pm2</span><br><span class=\"line\">RUN pm2 dump</span><br><span class=\"line\"># dump will start pm2 daemon and create everything needed</span><br><span class=\"line\"></span><br><span class=\"line\">VOLUME [&quot;/srv/apps&quot;, &quot;/srv/logs&quot;, &quot;/srv/server.json&quot;]</span><br><span class=\"line\"># don&apos;t put the files in docker container, user -v</span><br><span class=\"line\"></span><br><span class=\"line\">EXPOSE 3000</span><br><span class=\"line\"></span><br><span class=\"line\">CMD [&quot;pm2&quot;, &quot;start&quot;, &quot;/srv/server.json&quot;, &quot;--no-daemon&quot;]</span><br><span class=\"line\"># no daemon mode for docker</span><br></pre></td></tr></table></figure>\n<ol start=\"6\">\n<li>docker build -t repo[:tag] . </li>\n</ol>\n<p>可以指定repo和可选的tag<br>如果注意，会看到 docker build 命令最后有一个 .。. 表示当前目录<br>copy命令只有在当前上下文有有效</p>\n<ol start=\"7\">\n<li>从container中导出<br>导出(Export)<br>Export命令用于持久化容器（不是镜像）<br>接着执行导出：<br>sudo docker export <container id=\"\"> &gt; /home/export.tar</container></li>\n</ol>\n<p>导出后，可以通过docker import   导入，如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat busy.tar | sudo docker import - busy:v1.0</span><br></pre></td></tr></table></figure>\n<ol start=\"8\">\n<li>保存镜像<br>sudo docker save busybox-1 &gt; /home/save.tar</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以使用 docker import 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</span><br></pre></td></tr></table></figure>\n<ol start=\"9\">\n<li>docker 自启动配置</li>\n</ol>\n<p>自动启动container 如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -ti --restart=on-failure:3   </span><br><span class=\"line\">失败后会启动三次</span><br></pre></td></tr></table></figure>\n<ol start=\"10\">\n<li>用非root用户操作docker<br>下面是使用非root用户操作的步骤</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">创建docker组</span><br><span class=\"line\">sudo groupadd docker</span><br><span class=\"line\">将当前用户加入docker组</span><br><span class=\"line\">sudo gpasswd -a $&#123;USER&#125; docker</span><br><span class=\"line\">重新启动docker服务（下面是CentOS7的命令）</span><br><span class=\"line\">sudo systemctl restart docker</span><br><span class=\"line\">当前用户退出系统重新登陆</span><br><span class=\"line\">运行docker命令</span><br><span class=\"line\">docker ps</span><br></pre></td></tr></table></figure>\n<p>11.用docker 启动zookeeper </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ps -aux | grep docker</span><br><span class=\"line\">docker run  --name alizookeeper --restart always -d -P zookeeper</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>总结一下常用命令:</p>\n<p>其中&lt;&gt;阔起来的参数为必选，[]阔起来为可选</p>\n<p>docker version 查看docker的版本号，包括客户端、服务端、依赖的Go等<br>docker info 查看系统(docker)层面信息，包括管理的images, containers数等<br>docker search <image> 在docker index中搜索image<br>docker pull <image> 从docker registry server 中下拉image<br>docker push &lt;image|repository&gt; 推送一个image或repository到registry<br>docker push &lt;image|repository&gt;:TAG 同上，指定tag<br>docker inspect &lt;image|container&gt; 查看image或container的底层信息<br>docker images TODO filter out the intermediate image layers (intermediate image layers 是什么)<br>docker images -a 列出所有的images<br>docker ps 默认显示正在运行中的container<br>docker ps -l 显示最后一次创建的container，包括未运行的<br>docker ps -a 显示所有的container，包括未运行的<br>docker logs <container> 查看container的日志，也就是执行命令的一些输出<br>docker rm &lt;container…&gt; 删除一个或多个container<br>docker rm <code>docker ps -a -q</code> 删除所有的container<br>docker ps -a -q | xargs docker rm 同上, 删除所有的container<br>docker rmi &lt;image…&gt; 删除一个或多个image<br>docker start/stop/restart <container> 开启/停止/重启container<br>docker start -i <container> 启动一个container并进入交互模式<br>docker attach <container> attach一个运行中的container<br>docker run <image> <command> 使用image创建container并执行相应命令，然后停止<br>docker run -i -t <image> /bin/bash 使用image创建container并进入交互模式, login shell是/bin/bash<br>docker run -i -t -p &lt;host_port:contain_port&gt; 将container的端口映射到宿主机的端口<br>docker commit <container> [repo:tag] 将一个container固化为一个新的image，后面的repo:tag可选<br>docker build <path> 寻找path路径下名为的Dockerfile的配置文件，使用此配置生成新的image<br>docker build -t repo[:tag] 同上，可以指定repo和可选的tag<br>docker build - &lt; <dockerfile> 使用指定的dockerfile配置文件，docker以stdin方式获取内容，使用此配置生成新的image<br>docker port <container> <container port=\"\"> 查看本地哪个端口映射到container的指定端口，其实用docker ps 也可以看到</container></container></dockerfile></path></container></image></image></container></container></container></container></image></image></p>\n<h3 id=\"安装docker\"><a href=\"#安装docker\" class=\"headerlink\" title=\"安装docker\"></a>安装docker</h3><ol>\n<li>利用官方脚本：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo yum update</span><br><span class=\"line\">$ sudo curl -sSL https://get.docker.com/ | sh</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>用黄狗安装：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo yum update</span><br><span class=\"line\">$ sudo yum -y install docker</span><br><span class=\"line\">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除操作\"><a href=\"#删除操作\" class=\"headerlink\" title=\"删除操作\"></a>删除操作</h3><h5 id=\"删除所有已经停止的continer-q-列出所有id\"><a href=\"#删除所有已经停止的continer-q-列出所有id\" class=\"headerlink\" title=\"删除所有已经停止的continer  -q 列出所有id\"></a>删除所有已经停止的continer  -q 列出所有id</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker rm $(docker ps -a -q)</span><br></pre></td></tr></table></figure>\n<h5 id=\"删除所有镜像\"><a href=\"#删除所有镜像\" class=\"headerlink\" title=\"删除所有镜像\"></a>删除所有镜像</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker rmi $(docker images | grep none | awk &apos;&#123;print $3&#125;&apos; | sort -r)</span><br></pre></td></tr></table></figure>\n<h3 id=\"命令说明\"><a href=\"#命令说明\" class=\"headerlink\" title=\"命令说明\"></a>命令说明</h3><ol>\n<li>其中go的语法模板</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker images --format &quot;&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;&quot;</span><br><span class=\"line\">docker images --format &quot;table &#123;&#123;.ID&#125;&#125;\\t&#123;&#123;.Repository&#125;&#125;\\t&#123;&#123;.Tag&#125;&#125;&quot;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>filter 过滤参数</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker images -f since=mongo:3.2</span><br></pre></td></tr></table></figure>\n<p> 表示自从3.2 版本以来所有的镜像。</p>\n<ol start=\"3\">\n<li><p>docker run -it –rm –name ryanserver ubuntu:14.04 bash </p>\n<p>it 表示交互终端<br>rm 推出后删除<br>ubuntu  镜像名称<br>bash bash命令<br>naem 指定container名称</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run --name webserver -d -p 85:80 nginx</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</p>\n</li>\n</ol>\n<ul>\n<li>-a :提交的镜像作者；</li>\n<li>-c :使用Dockerfile指令来创建镜像；</li>\n<li>-m :提交时的说明文字；</li>\n<li>-p :在commit时，将容器暂停。<br>如：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker commit \\</span><br><span class=\"line\">    --author &quot;Tao Wang &lt;twang2218@gmail.com&gt;&quot; \\</span><br><span class=\"line\">    --message &quot;修改了默认网页&quot; \\</span><br><span class=\"line\">    webserver \\</span><br><span class=\"line\">    nginx:v2</span><br></pre></td></tr></table></figure>\n<p>5.通过dockfile制作镜像</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM nginx</span><br><span class=\"line\">RUN echo &apos;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure>\n<p>from 指定基础镜像 </p>\n<p>Dockerfile中每次运行run 都执行了一层。&amp;&amp; 将各个所需命令串联起来</p>\n<p>Dockerfile 支持 Shell 类的行尾添加 \\ 的命令换行方式，以及行首# 进行注释的格式<br>一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p>\n<p>copy 文件时可使用通配符，其通配符规则要满足 Go 的 filepath.Match 规则，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">COPY hom* /mydir/</span><br><span class=\"line\">COPY hom?.txt /mydir/</span><br></pre></td></tr></table></figure>\n<p>Add 功能和copy 类似，不过自带解压功能：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM scratch</span><br><span class=\"line\">ADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /</span><br></pre></td></tr></table></figure>\n<h6 id=\"环境变量的配置\"><a href=\"#环境变量的配置\" class=\"headerlink\" title=\"环境变量的配置\"></a>环境变量的配置</h6><p>格式有两种：<br>  ● ENV <key> <value><br>  ● ENV <key1>=<value1> <key2>=<value2>…<br>例如 ENV VERSION=1.0 DEBUG=on \\<br>     NAME=”Happy Feet</value2></key2></value1></key1></value></key></p>\n<h6 id=\"匿名卷\"><a href=\"#匿名卷\" class=\"headerlink\" title=\"匿名卷\"></a>匿名卷</h6><p>在 Dockerfile 中，我们可以事先指定某些目录挂载为匿名卷，<br>任何向 /data 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如：<br>docker run -d -v mydata:/data xxxx</p>\n<h6 id=\"挂载host目录\"><a href=\"#挂载host目录\" class=\"headerlink\" title=\"挂载host目录\"></a>挂载host目录</h6><p>将host机中的文件挂载到container中：<br>docker可以支持把一个宿主机上的目录挂载到镜像里。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -it -v /home/dock/Downloads:/usr/Downloads ubuntu64 /bin/bash</span><br></pre></td></tr></table></figure>\n<p>通过-v参数，冒号前为宿主机目录，必须为绝对路径，冒号后为镜像内挂载的路径。</p>\n<p>一个dockfile:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MAINTAINER Anna Doe &lt;anna@example.com&gt;</span><br><span class=\"line\">nodejs pm2:</span><br><span class=\"line\">FROM node:0.11.13</span><br><span class=\"line\"># or just node, without tag</span><br><span class=\"line\"></span><br><span class=\"line\">RUN npm install -g pm2</span><br><span class=\"line\">RUN pm2 dump</span><br><span class=\"line\"># dump will start pm2 daemon and create everything needed</span><br><span class=\"line\"></span><br><span class=\"line\">VOLUME [&quot;/srv/apps&quot;, &quot;/srv/logs&quot;, &quot;/srv/server.json&quot;]</span><br><span class=\"line\"># don&apos;t put the files in docker container, user -v</span><br><span class=\"line\"></span><br><span class=\"line\">EXPOSE 3000</span><br><span class=\"line\"></span><br><span class=\"line\">CMD [&quot;pm2&quot;, &quot;start&quot;, &quot;/srv/server.json&quot;, &quot;--no-daemon&quot;]</span><br><span class=\"line\"># no daemon mode for docker</span><br></pre></td></tr></table></figure>\n<ol start=\"6\">\n<li>docker build -t repo[:tag] . </li>\n</ol>\n<p>可以指定repo和可选的tag<br>如果注意，会看到 docker build 命令最后有一个 .。. 表示当前目录<br>copy命令只有在当前上下文有有效</p>\n<ol start=\"7\">\n<li>从container中导出<br>导出(Export)<br>Export命令用于持久化容器（不是镜像）<br>接着执行导出：<br>sudo docker export <container id=\"\"> &gt; /home/export.tar</container></li>\n</ol>\n<p>导出后，可以通过docker import   导入，如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat busy.tar | sudo docker import - busy:v1.0</span><br></pre></td></tr></table></figure>\n<ol start=\"8\">\n<li>保存镜像<br>sudo docker save busybox-1 &gt; /home/save.tar</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以使用 docker import 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</span><br></pre></td></tr></table></figure>\n<ol start=\"9\">\n<li>docker 自启动配置</li>\n</ol>\n<p>自动启动container 如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -ti --restart=on-failure:3   </span><br><span class=\"line\">失败后会启动三次</span><br></pre></td></tr></table></figure>\n<ol start=\"10\">\n<li>用非root用户操作docker<br>下面是使用非root用户操作的步骤</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">创建docker组</span><br><span class=\"line\">sudo groupadd docker</span><br><span class=\"line\">将当前用户加入docker组</span><br><span class=\"line\">sudo gpasswd -a $&#123;USER&#125; docker</span><br><span class=\"line\">重新启动docker服务（下面是CentOS7的命令）</span><br><span class=\"line\">sudo systemctl restart docker</span><br><span class=\"line\">当前用户退出系统重新登陆</span><br><span class=\"line\">运行docker命令</span><br><span class=\"line\">docker ps</span><br></pre></td></tr></table></figure>\n<p>11.用docker 启动zookeeper </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ps -aux | grep docker</span><br><span class=\"line\">docker run  --name alizookeeper --restart always -d -P zookeeper</span><br></pre></td></tr></table></figure>\n"},{"title":"es6","date":"2019-06-28T03:58:20.000Z","_content":"### reflect \n1. 修改某些Object方法的返回结果，让其变得更合理\n```javascript\n// 老写法\ntry {\n  Object.defineProperty(target, property, attributes);\n  // success\n} catch (e) {\n  // failure\n}\n\n// 新写法\nif (Reflect.defineProperty(target, property, attributes)) {\n  // success\n} else {\n  // failure\n}\n```\n\n1. 命令式改为函数式\n```javascript\n// 老写法\n'assign' in Object // true\n\n// 新写法\nReflect.has(Object, 'assign') // true\n```\n\n1. Reflect对象的方法与Proxy对象的方法一一对应\n```javascript\nProxy(target, {\n  set: function(target, name, value, receiver) {\n    var success = Reflect.set(target, name, value, receiver);\n    if (success) {\n      console.log('property ' + name + ' on ' + target + ' set to ' + value);\n    }\n    return success;\n  }\n});\n```\n####async 函数是什么？一句话，它就是 Generator 函数的语法糖。\n```javascript\nconst fs = require('fs');\n\nconst readFile = function (fileName) {\n  return new Promise(function (resolve, reject) {\n    fs.readFile(fileName, function(error, data) {\n      if (error) return reject(error);\n      resolve(data);\n    });\n  });\n};\n\nconst gen = function* () {\n  const f1 = yield readFile('/etc/fstab');\n  const f2 = yield readFile('/etc/shells');\n  console.log(f1.toString());\n  console.log(f2.toString());\n};\n```\n### module \n1. CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。\n```javascript\n\nvar counter = 3;\nfunction incCounter() {\n  counter++;\n}\nmodule.exports = {\n  counter: counter,\n  incCounter: incCounter,\n};\n\n// main.js\nvar mod = require('./lib');\n\nconsole.log(mod.counter);  // 3\nmod.incCounter();\nconsole.log(mod.counter); // 3\n```\n可以使用Es6 加载commonjs 模块。 CommonJS 模块的输出缓存机制，在 ES6 加载方式下依然有效。\n\n\nCommonJS 模块加载 ES6 模块，不能使用require命令，而要使用import()函数。\n\n```javascript\n// es.mjs\nlet foo = { bar: 'my-default' };\nexport default foo;\n\n// cjs.js\nconst es_namespace = await import('./es.mjs');\n// es_namespace = {\n//   get default() {\n//     ...\n//   }\n// }\nconsole.log(es_namespace.default);\n// { bar:'my-default' }\n```\n\n### lit\n1. 数组的空位 [,,,]\n\n1. parentheses to be omitted, as in\n\ntry {\n  // ...\n} catch {\n  // ...\n}\n\n### generator\n1. Generator  yield表达式后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。\n  yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。\n\n1. Co 模块相关于一个generator 的执行器。co 模块其实就是将两种自动执行器（Thunk 函数和 Promise 对象），包装成一个模块。使用 co 的前提条件是，Generator 函数的yield命令后面，只能是 Thunk 函数或 Promise 对象。\n1. 代码中，虽然map方法的参数是async函数，但它是并发执行的，因为只有async函数内部是继发执行，外部不受影响。后面的for..of循环内部使用了await，因此实现了按顺序输出\n```javascript\nasync function logInOrder(urls) {\n  // 并发读取远程URL\n  const textPromises = urls.map(async url => {\n    const response = await fetch(url);\n    return response.text();\n  });\n\n  // 按次序输出\n  for (const textPromise of textPromises) {\n    console.log(await textPromise);\n  }\n}\n```\n1. 对象的Symbol.iterator\n  \n  由于 Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的Symbol.iterator属性，从而使得该对象具有 Iterator 接口。\n```javascript\nvar myIterable = {};\nmyIterable[Symbol.iterator] = function* () {\n  yield 1;\n  yield 2;\n  yield 3;\n};\n\n[...myIterable]\n\n```\n   Iterator 接口和generator 函数：\n   ```javascript\nlet obj = {\n  * [Symbol.iterator]() {\n    yield 'hello';\n    yield 'world';\n  }\n};\n```\n\n1. 只要 Generator 函数内部部署了try...catch代码块，那么遍历器的throw方法抛出的错误，不影响下一次遍历。\n   \n   Gnerator 嵌套：\n   \n```javascript\nfunction* inner() {\n       yield 'hello!';\n   }\n   \n   function* outer1() {\n       yield 'open';\n       yield *inner();\n       yield 'close';\n   }\n```\n1. 异步的同步表达：\n    \n```javascript\n   function* main() {\n     var result = yield request(\"http://some.url\");\n     var resp = JSON.parse(result);\n       console.log(resp.value);\n   }\n   \n   function request(url) {\n     makeAjaxCall(url, function(response){\n       it.next(response);\n     });\n   }\n   \n   var it = main();\n   it.next();\n   \n```\n\n### proxy\n\n1. Proxy 的 construct 用于拦截 new()\n   isExtensible方法拦截Object.isExtensible操作。\n   ownKeys方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作。\n   \n   Object.getOwnPropertyNames()\n   Object.getOwnPropertySymbols()\n   Object.keys()\n   for...in循环\n```javascript\nvar obj = new Proxy({}, {\n     get: function (target, key, receiver) {\n       console.log(`getting ${key}!`);\n       return Reflect.get(target, key, receiver);\n     },\n     set: function (target, key, value, receiver) {\n       console.log(`setting ${key}!`);\n       return Reflect.set(target, key, value, receiver);\n     }\n   });\n```\n\n1. Class 的generator :\n```javascript\nclass Foo {\n     constructor(...args) {\n       this.args = args;\n     }\n     * [Symbol.iterator]() {\n       for (let arg of this.args) {\n         yield arg;\n       }\n     }\n   }\n\n```\n1. 绑定上下文\n\n```javascript\nfunction selfish (target) {\n  const cache = new WeakMap();\n  const handler = {\n    get (target, key) {\n      const value = Reflect.get(target, key);\n      if (typeof value !== 'function') {\n        return value;\n      }\n      if (!cache.has(value)) {\n        cache.set(value, value.bind(target));\n      }\n      return cache.get(value);\n    }\n  };\n  const proxy = new Proxy(target, handler);\n  return proxy;\n}\n\nconst logger = selfish(new Logger());\n```   \n\n#### 类型转换 \n1. 转换为数字\n```javascript\nlet int = \"15\";\nint = +int;\nconsole.log(int); // Result: 15\nconsole.log(typeof int); Result: \"number\"\n\n//这也可以用于将布尔值转换为数字，如下所示\n console.log(+true);  // Return: 1\n console.log(+false); // Return: 0\n\n```\n#### console \n```javascript\n\nconsole.table()\nconsole.dir()\nconsole.count()\nConsole.time() \nconsoel.timeLog()\n console.time(\"answer time\");\nalert(\"Click to continue\");\nconsole.timeEnd(\"answer time”);\n\n```\n\n#### 对象的结构 \n1. 对象的解构：let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };\n```javascript\nlet obj = {   p: [     'Hello',     { y: 'World' }   ] }; \nlet { p: [x, { y }] } = obj; x // \"Hello\"\n```\n\n2. 展开运算符的妙用 \n```javascript\n\n//需要根据一个条件创建两个不同的对象，可以使用展开运算符号来处理。\n\nconst getUser = (emailIncluded) => {\n  return {\n    name: 'John',\n    surname: 'Doe',\n    ...emailIncluded && { email : 'john@doe.com' }\n  }\n}\n\n```\n####\n","source":"_posts/es6.md","raw":"---\ntitle: es6\ndate: 2019-06-28 11:58:20\ntags: es\n---\n### reflect \n1. 修改某些Object方法的返回结果，让其变得更合理\n```javascript\n// 老写法\ntry {\n  Object.defineProperty(target, property, attributes);\n  // success\n} catch (e) {\n  // failure\n}\n\n// 新写法\nif (Reflect.defineProperty(target, property, attributes)) {\n  // success\n} else {\n  // failure\n}\n```\n\n1. 命令式改为函数式\n```javascript\n// 老写法\n'assign' in Object // true\n\n// 新写法\nReflect.has(Object, 'assign') // true\n```\n\n1. Reflect对象的方法与Proxy对象的方法一一对应\n```javascript\nProxy(target, {\n  set: function(target, name, value, receiver) {\n    var success = Reflect.set(target, name, value, receiver);\n    if (success) {\n      console.log('property ' + name + ' on ' + target + ' set to ' + value);\n    }\n    return success;\n  }\n});\n```\n####async 函数是什么？一句话，它就是 Generator 函数的语法糖。\n```javascript\nconst fs = require('fs');\n\nconst readFile = function (fileName) {\n  return new Promise(function (resolve, reject) {\n    fs.readFile(fileName, function(error, data) {\n      if (error) return reject(error);\n      resolve(data);\n    });\n  });\n};\n\nconst gen = function* () {\n  const f1 = yield readFile('/etc/fstab');\n  const f2 = yield readFile('/etc/shells');\n  console.log(f1.toString());\n  console.log(f2.toString());\n};\n```\n### module \n1. CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。\n```javascript\n\nvar counter = 3;\nfunction incCounter() {\n  counter++;\n}\nmodule.exports = {\n  counter: counter,\n  incCounter: incCounter,\n};\n\n// main.js\nvar mod = require('./lib');\n\nconsole.log(mod.counter);  // 3\nmod.incCounter();\nconsole.log(mod.counter); // 3\n```\n可以使用Es6 加载commonjs 模块。 CommonJS 模块的输出缓存机制，在 ES6 加载方式下依然有效。\n\n\nCommonJS 模块加载 ES6 模块，不能使用require命令，而要使用import()函数。\n\n```javascript\n// es.mjs\nlet foo = { bar: 'my-default' };\nexport default foo;\n\n// cjs.js\nconst es_namespace = await import('./es.mjs');\n// es_namespace = {\n//   get default() {\n//     ...\n//   }\n// }\nconsole.log(es_namespace.default);\n// { bar:'my-default' }\n```\n\n### lit\n1. 数组的空位 [,,,]\n\n1. parentheses to be omitted, as in\n\ntry {\n  // ...\n} catch {\n  // ...\n}\n\n### generator\n1. Generator  yield表达式后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。\n  yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。\n\n1. Co 模块相关于一个generator 的执行器。co 模块其实就是将两种自动执行器（Thunk 函数和 Promise 对象），包装成一个模块。使用 co 的前提条件是，Generator 函数的yield命令后面，只能是 Thunk 函数或 Promise 对象。\n1. 代码中，虽然map方法的参数是async函数，但它是并发执行的，因为只有async函数内部是继发执行，外部不受影响。后面的for..of循环内部使用了await，因此实现了按顺序输出\n```javascript\nasync function logInOrder(urls) {\n  // 并发读取远程URL\n  const textPromises = urls.map(async url => {\n    const response = await fetch(url);\n    return response.text();\n  });\n\n  // 按次序输出\n  for (const textPromise of textPromises) {\n    console.log(await textPromise);\n  }\n}\n```\n1. 对象的Symbol.iterator\n  \n  由于 Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的Symbol.iterator属性，从而使得该对象具有 Iterator 接口。\n```javascript\nvar myIterable = {};\nmyIterable[Symbol.iterator] = function* () {\n  yield 1;\n  yield 2;\n  yield 3;\n};\n\n[...myIterable]\n\n```\n   Iterator 接口和generator 函数：\n   ```javascript\nlet obj = {\n  * [Symbol.iterator]() {\n    yield 'hello';\n    yield 'world';\n  }\n};\n```\n\n1. 只要 Generator 函数内部部署了try...catch代码块，那么遍历器的throw方法抛出的错误，不影响下一次遍历。\n   \n   Gnerator 嵌套：\n   \n```javascript\nfunction* inner() {\n       yield 'hello!';\n   }\n   \n   function* outer1() {\n       yield 'open';\n       yield *inner();\n       yield 'close';\n   }\n```\n1. 异步的同步表达：\n    \n```javascript\n   function* main() {\n     var result = yield request(\"http://some.url\");\n     var resp = JSON.parse(result);\n       console.log(resp.value);\n   }\n   \n   function request(url) {\n     makeAjaxCall(url, function(response){\n       it.next(response);\n     });\n   }\n   \n   var it = main();\n   it.next();\n   \n```\n\n### proxy\n\n1. Proxy 的 construct 用于拦截 new()\n   isExtensible方法拦截Object.isExtensible操作。\n   ownKeys方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作。\n   \n   Object.getOwnPropertyNames()\n   Object.getOwnPropertySymbols()\n   Object.keys()\n   for...in循环\n```javascript\nvar obj = new Proxy({}, {\n     get: function (target, key, receiver) {\n       console.log(`getting ${key}!`);\n       return Reflect.get(target, key, receiver);\n     },\n     set: function (target, key, value, receiver) {\n       console.log(`setting ${key}!`);\n       return Reflect.set(target, key, value, receiver);\n     }\n   });\n```\n\n1. Class 的generator :\n```javascript\nclass Foo {\n     constructor(...args) {\n       this.args = args;\n     }\n     * [Symbol.iterator]() {\n       for (let arg of this.args) {\n         yield arg;\n       }\n     }\n   }\n\n```\n1. 绑定上下文\n\n```javascript\nfunction selfish (target) {\n  const cache = new WeakMap();\n  const handler = {\n    get (target, key) {\n      const value = Reflect.get(target, key);\n      if (typeof value !== 'function') {\n        return value;\n      }\n      if (!cache.has(value)) {\n        cache.set(value, value.bind(target));\n      }\n      return cache.get(value);\n    }\n  };\n  const proxy = new Proxy(target, handler);\n  return proxy;\n}\n\nconst logger = selfish(new Logger());\n```   \n\n#### 类型转换 \n1. 转换为数字\n```javascript\nlet int = \"15\";\nint = +int;\nconsole.log(int); // Result: 15\nconsole.log(typeof int); Result: \"number\"\n\n//这也可以用于将布尔值转换为数字，如下所示\n console.log(+true);  // Return: 1\n console.log(+false); // Return: 0\n\n```\n#### console \n```javascript\n\nconsole.table()\nconsole.dir()\nconsole.count()\nConsole.time() \nconsoel.timeLog()\n console.time(\"answer time\");\nalert(\"Click to continue\");\nconsole.timeEnd(\"answer time”);\n\n```\n\n#### 对象的结构 \n1. 对象的解构：let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };\n```javascript\nlet obj = {   p: [     'Hello',     { y: 'World' }   ] }; \nlet { p: [x, { y }] } = obj; x // \"Hello\"\n```\n\n2. 展开运算符的妙用 \n```javascript\n\n//需要根据一个条件创建两个不同的对象，可以使用展开运算符号来处理。\n\nconst getUser = (emailIncluded) => {\n  return {\n    name: 'John',\n    surname: 'Doe',\n    ...emailIncluded && { email : 'john@doe.com' }\n  }\n}\n\n```\n####\n","slug":"es6","published":1,"updated":"2019-07-26T08:35:17.301Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2fu41zg0008f18snzsf3riw","content":"<h3 id=\"reflect\"><a href=\"#reflect\" class=\"headerlink\" title=\"reflect\"></a>reflect</h3><ol>\n<li><p>修改某些Object方法的返回结果，让其变得更合理</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 老写法</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.defineProperty(target, property, attributes);</span><br><span class=\"line\">  <span class=\"comment\">// success</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// failure</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 新写法</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">Reflect</span>.defineProperty(target, property, attributes)) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// success</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// failure</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>命令式改为函数式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 老写法</span></span><br><span class=\"line\"><span class=\"string\">'assign'</span> <span class=\"keyword\">in</span> <span class=\"built_in\">Object</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 新写法</span></span><br><span class=\"line\"><span class=\"built_in\">Reflect</span>.has(<span class=\"built_in\">Object</span>, <span class=\"string\">'assign'</span>) <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Reflect对象的方法与Proxy对象的方法一一对应</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Proxy</span>(target, &#123;</span><br><span class=\"line\">  <span class=\"keyword\">set</span>: function(target, name, value, receiver) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> success = <span class=\"built_in\">Reflect</span>.set(target, name, value, receiver);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (success) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'property '</span> + name + <span class=\"string\">' on '</span> + target + <span class=\"string\">' set to '</span> + value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> success;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>####async 函数是什么？一句话，它就是 Generator 函数的语法糖。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> readFile = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fileName</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    fs.readFile(fileName, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error, data</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (error) <span class=\"keyword\">return</span> reject(error);</span><br><span class=\"line\">      resolve(data);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> gen = <span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> f1 = <span class=\"keyword\">yield</span> readFile(<span class=\"string\">'/etc/fstab'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> f2 = <span class=\"keyword\">yield</span> readFile(<span class=\"string\">'/etc/shells'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(f1.toString());</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(f2.toString());</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"module\"><a href=\"#module\" class=\"headerlink\" title=\"module\"></a>module</h3><ol>\n<li>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> counter = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">incCounter</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  counter++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  counter: counter,</span><br><span class=\"line\">  incCounter: incCounter,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// main.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> mod = <span class=\"built_in\">require</span>(<span class=\"string\">'./lib'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(mod.counter);  <span class=\"comment\">// 3</span></span><br><span class=\"line\">mod.incCounter();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(mod.counter); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>可以使用Es6 加载commonjs 模块。 CommonJS 模块的输出缓存机制，在 ES6 加载方式下依然有效。</p>\n<p>CommonJS 模块加载 ES6 模块，不能使用require命令，而要使用import()函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// es.mjs</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> foo = &#123; <span class=\"attr\">bar</span>: <span class=\"string\">'my-default'</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> foo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// cjs.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> es_namespace = <span class=\"keyword\">await</span> <span class=\"keyword\">import</span>(<span class=\"string\">'./es.mjs'</span>);</span><br><span class=\"line\"><span class=\"comment\">// es_namespace = &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   get default() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     ...</span></span><br><span class=\"line\"><span class=\"comment\">//   &#125;</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(es_namespace.default);</span><br><span class=\"line\"><span class=\"comment\">// &#123; bar:'my-default' &#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"lit\"><a href=\"#lit\" class=\"headerlink\" title=\"lit\"></a>lit</h3><ol>\n<li><p>数组的空位 [,,,]</p>\n</li>\n<li><p>parentheses to be omitted, as in</p>\n</li>\n</ol>\n<p>try {<br>  // …<br>} catch {<br>  // …<br>}</p>\n<h3 id=\"generator\"><a href=\"#generator\" class=\"headerlink\" title=\"generator\"></a>generator</h3><ol>\n<li><p>Generator  yield表达式后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。<br>yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。</p>\n</li>\n<li><p>Co 模块相关于一个generator 的执行器。co 模块其实就是将两种自动执行器（Thunk 函数和 Promise 对象），包装成一个模块。使用 co 的前提条件是，Generator 函数的yield命令后面，只能是 Thunk 函数或 Promise 对象。</p>\n</li>\n<li><p>代码中，虽然map方法的参数是async函数，但它是并发执行的，因为只有async函数内部是继发执行，外部不受影响。后面的for..of循环内部使用了await，因此实现了按顺序输出</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">logInOrder</span>(<span class=\"params\">urls</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 并发读取远程URL</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> textPromises = urls.map(<span class=\"keyword\">async</span> url =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> response = <span class=\"keyword\">await</span> fetch(url);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> response.text();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 按次序输出</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> textPromise <span class=\"keyword\">of</span> textPromises) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">await</span> textPromise);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>对象的Symbol.iterator</p>\n<p>由于 Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的Symbol.iterator属性，从而使得该对象具有 Iterator 接口。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myIterable = &#123;&#125;;</span><br><span class=\"line\">myIterable[<span class=\"built_in\">Symbol</span>.iterator] = <span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">[...myIterable]</span><br></pre></td></tr></table></figure>\n<p>Iterator 接口和generator 函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">  * [<span class=\"built_in\">Symbol</span>.iterator]() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"string\">'hello'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"string\">'world'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>只要 Generator 函数内部部署了try…catch代码块，那么遍历器的throw方法抛出的错误，不影响下一次遍历。</p>\n<p>Gnerator 嵌套：</p>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">inner</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">yield</span> <span class=\"string\">'hello!'</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">outer1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">yield</span> <span class=\"string\">'open'</span>;</span><br><span class=\"line\">       <span class=\"keyword\">yield</span> *inner();</span><br><span class=\"line\">       <span class=\"keyword\">yield</span> <span class=\"string\">'close'</span>;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>异步的同步表达：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">main</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = <span class=\"keyword\">yield</span> request(<span class=\"string\">\"http://some.url\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> resp = <span class=\"built_in\">JSON</span>.parse(result);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(resp.value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">request</span>(<span class=\"params\">url</span>) </span>&#123;</span><br><span class=\"line\">  makeAjaxCall(url, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">response</span>)</span>&#123;</span><br><span class=\"line\">    it.next(response);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> it = main();</span><br><span class=\"line\">it.next();</span><br></pre></td></tr></table></figure>\n<h3 id=\"proxy\"><a href=\"#proxy\" class=\"headerlink\" title=\"proxy\"></a>proxy</h3><ol>\n<li><p>Proxy 的 construct 用于拦截 new()<br>isExtensible方法拦截Object.isExtensible操作。<br>ownKeys方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作。</p>\n<p>Object.getOwnPropertyNames()<br>Object.getOwnPropertySymbols()<br>Object.keys()<br>for…in循环</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(&#123;&#125;, &#123;</span><br><span class=\"line\">     <span class=\"keyword\">get</span>: function (target, key, receiver) &#123;</span><br><span class=\"line\">       <span class=\"built_in\">console</span>.log(<span class=\"string\">`getting <span class=\"subst\">$&#123;key&#125;</span>!`</span>);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.get(target, key, receiver);</span><br><span class=\"line\">     &#125;,</span><br><span class=\"line\">     <span class=\"keyword\">set</span>: function (target, key, value, receiver) &#123;</span><br><span class=\"line\">       <span class=\"built_in\">console</span>.log(<span class=\"string\">`setting <span class=\"subst\">$&#123;key&#125;</span>!`</span>);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.set(target, key, value, receiver);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Class 的generator :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">constructor</span>(...args) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">this</span>.args = args;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     * [<span class=\"built_in\">Symbol</span>.iterator]() &#123;</span><br><span class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> arg <span class=\"keyword\">of</span> <span class=\"keyword\">this</span>.args) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">yield</span> arg;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>绑定上下文</p>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">selfish</span> (<span class=\"params\">target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> cache = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> handler = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span> (target, key) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> value = <span class=\"built_in\">Reflect</span>.get(target, key);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> value !== <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!cache.has(value)) &#123;</span><br><span class=\"line\">        cache.set(value, value.bind(target));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> cache.get(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> proxy = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target, handler);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> proxy;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> logger = selfish(<span class=\"keyword\">new</span> Logger());</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`   </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">#### 类型转换 </span></span><br><span class=\"line\"><span class=\"string\">1. 转换为数字</span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>javascript</span><br><span class=\"line\"><span class=\"keyword\">let</span> int = <span class=\"string\">\"15\"</span>;</span><br><span class=\"line\">int = +int;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(int); <span class=\"comment\">// Result: 15</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> int); Result: <span class=\"string\">\"number\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这也可以用于将布尔值转换为数字，如下所示</span></span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(+<span class=\"literal\">true</span>);  <span class=\"comment\">// Return: 1</span></span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(+<span class=\"literal\">false</span>); <span class=\"comment\">// Return: 0</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"console\"><a href=\"#console\" class=\"headerlink\" title=\"console\"></a>console</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.table()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.dir()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.count()</span><br><span class=\"line\">Console.time() </span><br><span class=\"line\">consoel.timeLog()</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.time(<span class=\"string\">\"answer time\"</span>);</span><br><span class=\"line\">alert(<span class=\"string\">\"Click to continue\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">\"answer time”);</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"对象的结构\"><a href=\"#对象的结构\" class=\"headerlink\" title=\"对象的结构\"></a>对象的结构</h4><ol>\n<li><p>对象的解构：let { x, y, …z } = { x: 1, y: 2, a: 3, b: 4 };</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;   <span class=\"attr\">p</span>: [     <span class=\"string\">'Hello'</span>,     &#123; <span class=\"attr\">y</span>: <span class=\"string\">'World'</span> &#125;   ] &#125;; </span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; <span class=\"attr\">p</span>: [x, &#123; y &#125;] &#125; = obj; x <span class=\"comment\">// \"Hello\"</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>展开运算符的妙用 </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//需要根据一个条件创建两个不同的对象，可以使用展开运算符号来处理。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> getUser = <span class=\"function\">(<span class=\"params\">emailIncluded</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'John'</span>,</span><br><span class=\"line\">    surname: <span class=\"string\">'Doe'</span>,</span><br><span class=\"line\">    ...emailIncluded &amp;&amp; &#123; <span class=\"attr\">email</span> : <span class=\"string\">'john@doe.com'</span> &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>####</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"reflect\"><a href=\"#reflect\" class=\"headerlink\" title=\"reflect\"></a>reflect</h3><ol>\n<li><p>修改某些Object方法的返回结果，让其变得更合理</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 老写法</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.defineProperty(target, property, attributes);</span><br><span class=\"line\">  <span class=\"comment\">// success</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// failure</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 新写法</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">Reflect</span>.defineProperty(target, property, attributes)) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// success</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// failure</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>命令式改为函数式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 老写法</span></span><br><span class=\"line\"><span class=\"string\">'assign'</span> <span class=\"keyword\">in</span> <span class=\"built_in\">Object</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 新写法</span></span><br><span class=\"line\"><span class=\"built_in\">Reflect</span>.has(<span class=\"built_in\">Object</span>, <span class=\"string\">'assign'</span>) <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Reflect对象的方法与Proxy对象的方法一一对应</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Proxy</span>(target, &#123;</span><br><span class=\"line\">  <span class=\"keyword\">set</span>: function(target, name, value, receiver) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> success = <span class=\"built_in\">Reflect</span>.set(target, name, value, receiver);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (success) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'property '</span> + name + <span class=\"string\">' on '</span> + target + <span class=\"string\">' set to '</span> + value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> success;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>####async 函数是什么？一句话，它就是 Generator 函数的语法糖。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> readFile = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fileName</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    fs.readFile(fileName, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error, data</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (error) <span class=\"keyword\">return</span> reject(error);</span><br><span class=\"line\">      resolve(data);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> gen = <span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> f1 = <span class=\"keyword\">yield</span> readFile(<span class=\"string\">'/etc/fstab'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> f2 = <span class=\"keyword\">yield</span> readFile(<span class=\"string\">'/etc/shells'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(f1.toString());</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(f2.toString());</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"module\"><a href=\"#module\" class=\"headerlink\" title=\"module\"></a>module</h3><ol>\n<li>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> counter = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">incCounter</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  counter++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  counter: counter,</span><br><span class=\"line\">  incCounter: incCounter,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// main.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> mod = <span class=\"built_in\">require</span>(<span class=\"string\">'./lib'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(mod.counter);  <span class=\"comment\">// 3</span></span><br><span class=\"line\">mod.incCounter();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(mod.counter); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>可以使用Es6 加载commonjs 模块。 CommonJS 模块的输出缓存机制，在 ES6 加载方式下依然有效。</p>\n<p>CommonJS 模块加载 ES6 模块，不能使用require命令，而要使用import()函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// es.mjs</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> foo = &#123; <span class=\"attr\">bar</span>: <span class=\"string\">'my-default'</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> foo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// cjs.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> es_namespace = <span class=\"keyword\">await</span> <span class=\"keyword\">import</span>(<span class=\"string\">'./es.mjs'</span>);</span><br><span class=\"line\"><span class=\"comment\">// es_namespace = &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   get default() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     ...</span></span><br><span class=\"line\"><span class=\"comment\">//   &#125;</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(es_namespace.default);</span><br><span class=\"line\"><span class=\"comment\">// &#123; bar:'my-default' &#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"lit\"><a href=\"#lit\" class=\"headerlink\" title=\"lit\"></a>lit</h3><ol>\n<li><p>数组的空位 [,,,]</p>\n</li>\n<li><p>parentheses to be omitted, as in</p>\n</li>\n</ol>\n<p>try {<br>  // …<br>} catch {<br>  // …<br>}</p>\n<h3 id=\"generator\"><a href=\"#generator\" class=\"headerlink\" title=\"generator\"></a>generator</h3><ol>\n<li><p>Generator  yield表达式后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。<br>yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。</p>\n</li>\n<li><p>Co 模块相关于一个generator 的执行器。co 模块其实就是将两种自动执行器（Thunk 函数和 Promise 对象），包装成一个模块。使用 co 的前提条件是，Generator 函数的yield命令后面，只能是 Thunk 函数或 Promise 对象。</p>\n</li>\n<li><p>代码中，虽然map方法的参数是async函数，但它是并发执行的，因为只有async函数内部是继发执行，外部不受影响。后面的for..of循环内部使用了await，因此实现了按顺序输出</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">logInOrder</span>(<span class=\"params\">urls</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 并发读取远程URL</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> textPromises = urls.map(<span class=\"keyword\">async</span> url =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> response = <span class=\"keyword\">await</span> fetch(url);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> response.text();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 按次序输出</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> textPromise <span class=\"keyword\">of</span> textPromises) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">await</span> textPromise);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>对象的Symbol.iterator</p>\n<p>由于 Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的Symbol.iterator属性，从而使得该对象具有 Iterator 接口。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myIterable = &#123;&#125;;</span><br><span class=\"line\">myIterable[<span class=\"built_in\">Symbol</span>.iterator] = <span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">[...myIterable]</span><br></pre></td></tr></table></figure>\n<p>Iterator 接口和generator 函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">  * [<span class=\"built_in\">Symbol</span>.iterator]() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"string\">'hello'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"string\">'world'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>只要 Generator 函数内部部署了try…catch代码块，那么遍历器的throw方法抛出的错误，不影响下一次遍历。</p>\n<p>Gnerator 嵌套：</p>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">inner</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">yield</span> <span class=\"string\">'hello!'</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">outer1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">yield</span> <span class=\"string\">'open'</span>;</span><br><span class=\"line\">       <span class=\"keyword\">yield</span> *inner();</span><br><span class=\"line\">       <span class=\"keyword\">yield</span> <span class=\"string\">'close'</span>;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>异步的同步表达：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">main</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = <span class=\"keyword\">yield</span> request(<span class=\"string\">\"http://some.url\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> resp = <span class=\"built_in\">JSON</span>.parse(result);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(resp.value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">request</span>(<span class=\"params\">url</span>) </span>&#123;</span><br><span class=\"line\">  makeAjaxCall(url, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">response</span>)</span>&#123;</span><br><span class=\"line\">    it.next(response);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> it = main();</span><br><span class=\"line\">it.next();</span><br></pre></td></tr></table></figure>\n<h3 id=\"proxy\"><a href=\"#proxy\" class=\"headerlink\" title=\"proxy\"></a>proxy</h3><ol>\n<li><p>Proxy 的 construct 用于拦截 new()<br>isExtensible方法拦截Object.isExtensible操作。<br>ownKeys方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作。</p>\n<p>Object.getOwnPropertyNames()<br>Object.getOwnPropertySymbols()<br>Object.keys()<br>for…in循环</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(&#123;&#125;, &#123;</span><br><span class=\"line\">     <span class=\"keyword\">get</span>: function (target, key, receiver) &#123;</span><br><span class=\"line\">       <span class=\"built_in\">console</span>.log(<span class=\"string\">`getting <span class=\"subst\">$&#123;key&#125;</span>!`</span>);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.get(target, key, receiver);</span><br><span class=\"line\">     &#125;,</span><br><span class=\"line\">     <span class=\"keyword\">set</span>: function (target, key, value, receiver) &#123;</span><br><span class=\"line\">       <span class=\"built_in\">console</span>.log(<span class=\"string\">`setting <span class=\"subst\">$&#123;key&#125;</span>!`</span>);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.set(target, key, value, receiver);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Class 的generator :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">constructor</span>(...args) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">this</span>.args = args;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     * [<span class=\"built_in\">Symbol</span>.iterator]() &#123;</span><br><span class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> arg <span class=\"keyword\">of</span> <span class=\"keyword\">this</span>.args) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">yield</span> arg;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>绑定上下文</p>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">selfish</span> (<span class=\"params\">target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> cache = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> handler = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span> (target, key) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> value = <span class=\"built_in\">Reflect</span>.get(target, key);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> value !== <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!cache.has(value)) &#123;</span><br><span class=\"line\">        cache.set(value, value.bind(target));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> cache.get(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> proxy = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target, handler);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> proxy;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> logger = selfish(<span class=\"keyword\">new</span> Logger());</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`   </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">#### 类型转换 </span></span><br><span class=\"line\"><span class=\"string\">1. 转换为数字</span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>javascript</span><br><span class=\"line\"><span class=\"keyword\">let</span> int = <span class=\"string\">\"15\"</span>;</span><br><span class=\"line\">int = +int;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(int); <span class=\"comment\">// Result: 15</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> int); Result: <span class=\"string\">\"number\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这也可以用于将布尔值转换为数字，如下所示</span></span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(+<span class=\"literal\">true</span>);  <span class=\"comment\">// Return: 1</span></span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(+<span class=\"literal\">false</span>); <span class=\"comment\">// Return: 0</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"console\"><a href=\"#console\" class=\"headerlink\" title=\"console\"></a>console</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.table()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.dir()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.count()</span><br><span class=\"line\">Console.time() </span><br><span class=\"line\">consoel.timeLog()</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.time(<span class=\"string\">\"answer time\"</span>);</span><br><span class=\"line\">alert(<span class=\"string\">\"Click to continue\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">\"answer time”);</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"对象的结构\"><a href=\"#对象的结构\" class=\"headerlink\" title=\"对象的结构\"></a>对象的结构</h4><ol>\n<li><p>对象的解构：let { x, y, …z } = { x: 1, y: 2, a: 3, b: 4 };</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;   <span class=\"attr\">p</span>: [     <span class=\"string\">'Hello'</span>,     &#123; <span class=\"attr\">y</span>: <span class=\"string\">'World'</span> &#125;   ] &#125;; </span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; <span class=\"attr\">p</span>: [x, &#123; y &#125;] &#125; = obj; x <span class=\"comment\">// \"Hello\"</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>展开运算符的妙用 </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//需要根据一个条件创建两个不同的对象，可以使用展开运算符号来处理。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> getUser = <span class=\"function\">(<span class=\"params\">emailIncluded</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'John'</span>,</span><br><span class=\"line\">    surname: <span class=\"string\">'Doe'</span>,</span><br><span class=\"line\">    ...emailIncluded &amp;&amp; &#123; <span class=\"attr\">email</span> : <span class=\"string\">'john@doe.com'</span> &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>####</p>\n"},{"title":"es8","date":"2019-07-02T03:37:11.000Z","_content":"\n1. Stage 0: strawman——最初想法的提交。\n   Stage 1: proposal（提案）——由TC39至少一名成员倡导的正式提案文件，该文件包括API事例。\n   Stage 2: draft（草案）——功能规范的初始版本，该版本包含功能规范的两个实验实现。\n   Stage 3: candidate（候选）——提案规范通过审查并从厂商那里收集反馈\n   Stage 4: finished（完成）——提案准备加入ECMAScript，但是到浏览器或者Nodejs中可能需要更长的时间\n   \n2. es2018(es9) \n promise.finally  正则表达式匹配组 \n regex 先行断言和反向断言、dotall  \n \n1. Template Literals\n\n1. \n \n","source":"_posts/es8.md","raw":"---\ntitle: es8\ndate: 2019-07-02 11:37:11\ntags: es\n---\n\n1. Stage 0: strawman——最初想法的提交。\n   Stage 1: proposal（提案）——由TC39至少一名成员倡导的正式提案文件，该文件包括API事例。\n   Stage 2: draft（草案）——功能规范的初始版本，该版本包含功能规范的两个实验实现。\n   Stage 3: candidate（候选）——提案规范通过审查并从厂商那里收集反馈\n   Stage 4: finished（完成）——提案准备加入ECMAScript，但是到浏览器或者Nodejs中可能需要更长的时间\n   \n2. es2018(es9) \n promise.finally  正则表达式匹配组 \n regex 先行断言和反向断言、dotall  \n \n1. Template Literals\n\n1. \n \n","slug":"es8","published":1,"updated":"2019-07-26T08:35:17.301Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2fu41zh000bf18slzyn0feq","content":"<ol>\n<li><p>Stage 0: strawman——最初想法的提交。<br>Stage 1: proposal（提案）——由TC39至少一名成员倡导的正式提案文件，该文件包括API事例。<br>Stage 2: draft（草案）——功能规范的初始版本，该版本包含功能规范的两个实验实现。<br>Stage 3: candidate（候选）——提案规范通过审查并从厂商那里收集反馈<br>Stage 4: finished（完成）——提案准备加入ECMAScript，但是到浏览器或者Nodejs中可能需要更长的时间</p>\n</li>\n<li><p>es2018(es9)<br>promise.finally  正则表达式匹配组<br>regex 先行断言和反向断言、dotall  </p>\n</li>\n<li><p>Template Literals</p>\n</li>\n<li></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><p>Stage 0: strawman——最初想法的提交。<br>Stage 1: proposal（提案）——由TC39至少一名成员倡导的正式提案文件，该文件包括API事例。<br>Stage 2: draft（草案）——功能规范的初始版本，该版本包含功能规范的两个实验实现。<br>Stage 3: candidate（候选）——提案规范通过审查并从厂商那里收集反馈<br>Stage 4: finished（完成）——提案准备加入ECMAScript，但是到浏览器或者Nodejs中可能需要更长的时间</p>\n</li>\n<li><p>es2018(es9)<br>promise.finally  正则表达式匹配组<br>regex 先行断言和反向断言、dotall  </p>\n</li>\n<li><p>Template Literals</p>\n</li>\n<li></li>\n</ol>\n"},{"title":"eslint","date":"2016-12-25T05:31:39.000Z","_content":"\nESLint 一旦发现配置文件中有 \"root\": true，它就会停止在父级目录中寻找。\n\n```\n\n在整个文件中取消eslint检查：\n\n/* eslint-disable */\n\n// Disables all rules for the rest of the file \nalert(‘foo’);\n\n在整个文件中禁用某一项eslint规则的检查：\n\n/* eslint-disable no-alert */\n\n// Disables no-alert for the rest of the file \nalert(‘foo’);\n\n针对某一行禁用eslint检查：\n\nalert(‘foo’); // eslint-disable-line\n\n// eslint-disable-next-line \nalert(‘foo’);\n\n针对某一行的某一具体规则禁用eslint检查：\n\nalert(‘foo’); // eslint-disable-line no-alert\n\n// eslint-disable-next-line no-alert \nalert(‘foo’);\n\n针对某一行禁用多项具体规则的检查：\n\nalert(‘foo’); // eslint-disable-line no-alert, quotes, semi\n\n// eslint-disable-next-line no-alert, quotes, semi \nalert(‘foo’);\n```\n\n```\n行内配置\n\n\n/*eslint-disable*/ 和 /*eslint-enable*/\n\n/*global*/\n/*eslint*/\n/*eslint-env*/\n\n\n命令行选项：\n\n--global\n--rule\n--env\n\n-c、--config\n\n\n\n项目级配置：\n\n与要检测的文件在同一目录下的 .eslintrc.* 或 package.json 文件\n继续在父级目录寻找 .eslintrc 或 package.json文件，直到根目录（包括根目录）或直到发现一个有\"root\": true的配置。\n如果不是（1）到（3）中的任何一种情况，退回到 ~/.eslintrc 中自定义的默认配置。\n\n```\n\nglob 模式的配置\n```json  \n{\n  \"rules\": {\n    \"quotes\": [ 2, \"double\" ]\n  },\n\n  \"overrides\": [\n    {\n      \"files\": [ \"bin/*.js\", \"lib/*.js\" ],\n      \"excludedFiles\": \"*.test.js\",\n      \"rules\": {\n        \"quotes\": [ 2, \"single\" ]\n      }\n    }\n  ]\n}\n\n```\n\nignore 文件配置：\n\n# Ignore built files except build/index.js\nbuild/*\n!build/index.js\n\n全局变量\n```javascript\n  globals: {\n        MyGlobal: true\n    }\n```\n\n\n ","source":"_posts/eslint.md","raw":"---\ntitle: eslint\ndate: 2016-12-25 13:31:39\ntags: eslint\n---\n\nESLint 一旦发现配置文件中有 \"root\": true，它就会停止在父级目录中寻找。\n\n```\n\n在整个文件中取消eslint检查：\n\n/* eslint-disable */\n\n// Disables all rules for the rest of the file \nalert(‘foo’);\n\n在整个文件中禁用某一项eslint规则的检查：\n\n/* eslint-disable no-alert */\n\n// Disables no-alert for the rest of the file \nalert(‘foo’);\n\n针对某一行禁用eslint检查：\n\nalert(‘foo’); // eslint-disable-line\n\n// eslint-disable-next-line \nalert(‘foo’);\n\n针对某一行的某一具体规则禁用eslint检查：\n\nalert(‘foo’); // eslint-disable-line no-alert\n\n// eslint-disable-next-line no-alert \nalert(‘foo’);\n\n针对某一行禁用多项具体规则的检查：\n\nalert(‘foo’); // eslint-disable-line no-alert, quotes, semi\n\n// eslint-disable-next-line no-alert, quotes, semi \nalert(‘foo’);\n```\n\n```\n行内配置\n\n\n/*eslint-disable*/ 和 /*eslint-enable*/\n\n/*global*/\n/*eslint*/\n/*eslint-env*/\n\n\n命令行选项：\n\n--global\n--rule\n--env\n\n-c、--config\n\n\n\n项目级配置：\n\n与要检测的文件在同一目录下的 .eslintrc.* 或 package.json 文件\n继续在父级目录寻找 .eslintrc 或 package.json文件，直到根目录（包括根目录）或直到发现一个有\"root\": true的配置。\n如果不是（1）到（3）中的任何一种情况，退回到 ~/.eslintrc 中自定义的默认配置。\n\n```\n\nglob 模式的配置\n```json  \n{\n  \"rules\": {\n    \"quotes\": [ 2, \"double\" ]\n  },\n\n  \"overrides\": [\n    {\n      \"files\": [ \"bin/*.js\", \"lib/*.js\" ],\n      \"excludedFiles\": \"*.test.js\",\n      \"rules\": {\n        \"quotes\": [ 2, \"single\" ]\n      }\n    }\n  ]\n}\n\n```\n\nignore 文件配置：\n\n# Ignore built files except build/index.js\nbuild/*\n!build/index.js\n\n全局变量\n```javascript\n  globals: {\n        MyGlobal: true\n    }\n```\n\n\n ","slug":"eslint","published":1,"updated":"2019-07-26T08:35:17.302Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2fu41zi000cf18srz445k4b","content":"<p>ESLint 一旦发现配置文件中有 “root”: true，它就会停止在父级目录中寻找。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">在整个文件中取消eslint检查：</span><br><span class=\"line\"></span><br><span class=\"line\">/* eslint-disable */</span><br><span class=\"line\"></span><br><span class=\"line\">// Disables all rules for the rest of the file </span><br><span class=\"line\">alert(‘foo’);</span><br><span class=\"line\"></span><br><span class=\"line\">在整个文件中禁用某一项eslint规则的检查：</span><br><span class=\"line\"></span><br><span class=\"line\">/* eslint-disable no-alert */</span><br><span class=\"line\"></span><br><span class=\"line\">// Disables no-alert for the rest of the file </span><br><span class=\"line\">alert(‘foo’);</span><br><span class=\"line\"></span><br><span class=\"line\">针对某一行禁用eslint检查：</span><br><span class=\"line\"></span><br><span class=\"line\">alert(‘foo’); // eslint-disable-line</span><br><span class=\"line\"></span><br><span class=\"line\">// eslint-disable-next-line </span><br><span class=\"line\">alert(‘foo’);</span><br><span class=\"line\"></span><br><span class=\"line\">针对某一行的某一具体规则禁用eslint检查：</span><br><span class=\"line\"></span><br><span class=\"line\">alert(‘foo’); // eslint-disable-line no-alert</span><br><span class=\"line\"></span><br><span class=\"line\">// eslint-disable-next-line no-alert </span><br><span class=\"line\">alert(‘foo’);</span><br><span class=\"line\"></span><br><span class=\"line\">针对某一行禁用多项具体规则的检查：</span><br><span class=\"line\"></span><br><span class=\"line\">alert(‘foo’); // eslint-disable-line no-alert, quotes, semi</span><br><span class=\"line\"></span><br><span class=\"line\">// eslint-disable-next-line no-alert, quotes, semi </span><br><span class=\"line\">alert(‘foo’);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">行内配置</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">/*eslint-disable*/ 和 /*eslint-enable*/</span><br><span class=\"line\"></span><br><span class=\"line\">/*global*/</span><br><span class=\"line\">/*eslint*/</span><br><span class=\"line\">/*eslint-env*/</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">命令行选项：</span><br><span class=\"line\"></span><br><span class=\"line\">--global</span><br><span class=\"line\">--rule</span><br><span class=\"line\">--env</span><br><span class=\"line\"></span><br><span class=\"line\">-c、--config</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">项目级配置：</span><br><span class=\"line\"></span><br><span class=\"line\">与要检测的文件在同一目录下的 .eslintrc.* 或 package.json 文件</span><br><span class=\"line\">继续在父级目录寻找 .eslintrc 或 package.json文件，直到根目录（包括根目录）或直到发现一个有&quot;root&quot;: true的配置。</span><br><span class=\"line\">如果不是（1）到（3）中的任何一种情况，退回到 ~/.eslintrc 中自定义的默认配置。</span><br></pre></td></tr></table></figure>\n<p>glob 模式的配置<br><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"rules\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"quotes\"</span>: [ <span class=\"number\">2</span>, <span class=\"string\">\"double\"</span> ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">\"overrides\"</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"files\"</span>: [ <span class=\"string\">\"bin/*.js\"</span>, <span class=\"string\">\"lib/*.js\"</span> ],</span><br><span class=\"line\">      <span class=\"attr\">\"excludedFiles\"</span>: <span class=\"string\">\"*.test.js\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"rules\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"quotes\"</span>: [ <span class=\"number\">2</span>, <span class=\"string\">\"single\"</span> ]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>ignore 文件配置：</p>\n<h1 id=\"Ignore-built-files-except-build-index-js\"><a href=\"#Ignore-built-files-except-build-index-js\" class=\"headerlink\" title=\"Ignore built files except build/index.js\"></a>Ignore built files except build/index.js</h1><p>build/*<br>!build/index.js</p>\n<p>全局变量<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">globals: &#123;</span><br><span class=\"line\">      MyGlobal: <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>ESLint 一旦发现配置文件中有 “root”: true，它就会停止在父级目录中寻找。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">在整个文件中取消eslint检查：</span><br><span class=\"line\"></span><br><span class=\"line\">/* eslint-disable */</span><br><span class=\"line\"></span><br><span class=\"line\">// Disables all rules for the rest of the file </span><br><span class=\"line\">alert(‘foo’);</span><br><span class=\"line\"></span><br><span class=\"line\">在整个文件中禁用某一项eslint规则的检查：</span><br><span class=\"line\"></span><br><span class=\"line\">/* eslint-disable no-alert */</span><br><span class=\"line\"></span><br><span class=\"line\">// Disables no-alert for the rest of the file </span><br><span class=\"line\">alert(‘foo’);</span><br><span class=\"line\"></span><br><span class=\"line\">针对某一行禁用eslint检查：</span><br><span class=\"line\"></span><br><span class=\"line\">alert(‘foo’); // eslint-disable-line</span><br><span class=\"line\"></span><br><span class=\"line\">// eslint-disable-next-line </span><br><span class=\"line\">alert(‘foo’);</span><br><span class=\"line\"></span><br><span class=\"line\">针对某一行的某一具体规则禁用eslint检查：</span><br><span class=\"line\"></span><br><span class=\"line\">alert(‘foo’); // eslint-disable-line no-alert</span><br><span class=\"line\"></span><br><span class=\"line\">// eslint-disable-next-line no-alert </span><br><span class=\"line\">alert(‘foo’);</span><br><span class=\"line\"></span><br><span class=\"line\">针对某一行禁用多项具体规则的检查：</span><br><span class=\"line\"></span><br><span class=\"line\">alert(‘foo’); // eslint-disable-line no-alert, quotes, semi</span><br><span class=\"line\"></span><br><span class=\"line\">// eslint-disable-next-line no-alert, quotes, semi </span><br><span class=\"line\">alert(‘foo’);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">行内配置</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">/*eslint-disable*/ 和 /*eslint-enable*/</span><br><span class=\"line\"></span><br><span class=\"line\">/*global*/</span><br><span class=\"line\">/*eslint*/</span><br><span class=\"line\">/*eslint-env*/</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">命令行选项：</span><br><span class=\"line\"></span><br><span class=\"line\">--global</span><br><span class=\"line\">--rule</span><br><span class=\"line\">--env</span><br><span class=\"line\"></span><br><span class=\"line\">-c、--config</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">项目级配置：</span><br><span class=\"line\"></span><br><span class=\"line\">与要检测的文件在同一目录下的 .eslintrc.* 或 package.json 文件</span><br><span class=\"line\">继续在父级目录寻找 .eslintrc 或 package.json文件，直到根目录（包括根目录）或直到发现一个有&quot;root&quot;: true的配置。</span><br><span class=\"line\">如果不是（1）到（3）中的任何一种情况，退回到 ~/.eslintrc 中自定义的默认配置。</span><br></pre></td></tr></table></figure>\n<p>glob 模式的配置<br><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"rules\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"quotes\"</span>: [ <span class=\"number\">2</span>, <span class=\"string\">\"double\"</span> ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">\"overrides\"</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"files\"</span>: [ <span class=\"string\">\"bin/*.js\"</span>, <span class=\"string\">\"lib/*.js\"</span> ],</span><br><span class=\"line\">      <span class=\"attr\">\"excludedFiles\"</span>: <span class=\"string\">\"*.test.js\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"rules\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"quotes\"</span>: [ <span class=\"number\">2</span>, <span class=\"string\">\"single\"</span> ]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>ignore 文件配置：</p>\n<h1 id=\"Ignore-built-files-except-build-index-js\"><a href=\"#Ignore-built-files-except-build-index-js\" class=\"headerlink\" title=\"Ignore built files except build/index.js\"></a>Ignore built files except build/index.js</h1><p>build/*<br>!build/index.js</p>\n<p>全局变量<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">globals: &#123;</span><br><span class=\"line\">      MyGlobal: <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"graphql","date":"2019-08-23T08:19:28.000Z","_content":"1. \n```text\nfunction(parent, args, ctx, info) {\n    …\n其中的参数的意义如下：\n\nparent: 当前上一个Resolver的返回值\nargs: 传入某个Query中的函数（比如上面例子中article(id: Int)中的id）\nctx: 在Resolver解析链中不断传递的中间变量（类似中间件架构中的context）\ninfo: 当前Query的AST对象\n}\n```\n2. query（查询）：当获取数据时，应当选取Query类型\n\n   mutation（更改）：当尝试修改数据时，应当使用mutation类型\n   \n   subscription（订阅）：当希望数据更改时，可以进行消息推送，使用subscription类型\n","source":"_posts/graphql.md","raw":"---\ntitle: graphql\ndate: 2019-08-23 16:19:28\ntags:\n---\n1. \n```text\nfunction(parent, args, ctx, info) {\n    …\n其中的参数的意义如下：\n\nparent: 当前上一个Resolver的返回值\nargs: 传入某个Query中的函数（比如上面例子中article(id: Int)中的id）\nctx: 在Resolver解析链中不断传递的中间变量（类似中间件架构中的context）\ninfo: 当前Query的AST对象\n}\n```\n2. query（查询）：当获取数据时，应当选取Query类型\n\n   mutation（更改）：当尝试修改数据时，应当使用mutation类型\n   \n   subscription（订阅）：当希望数据更改时，可以进行消息推送，使用subscription类型\n","slug":"graphql","published":1,"updated":"2019-08-23T08:25:22.505Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2fu41zk000ef18svtcxam0z","content":"<ol>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function(parent, args, ctx, info) &#123;</span><br><span class=\"line\">    …</span><br><span class=\"line\">其中的参数的意义如下：</span><br><span class=\"line\"></span><br><span class=\"line\">parent: 当前上一个Resolver的返回值</span><br><span class=\"line\">args: 传入某个Query中的函数（比如上面例子中article(id: Int)中的id）</span><br><span class=\"line\">ctx: 在Resolver解析链中不断传递的中间变量（类似中间件架构中的context）</span><br><span class=\"line\">info: 当前Query的AST对象</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>query（查询）：当获取数据时，应当选取Query类型</p>\n<p>mutation（更改）：当尝试修改数据时，应当使用mutation类型</p>\n<p>subscription（订阅）：当希望数据更改时，可以进行消息推送，使用subscription类型</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function(parent, args, ctx, info) &#123;</span><br><span class=\"line\">    …</span><br><span class=\"line\">其中的参数的意义如下：</span><br><span class=\"line\"></span><br><span class=\"line\">parent: 当前上一个Resolver的返回值</span><br><span class=\"line\">args: 传入某个Query中的函数（比如上面例子中article(id: Int)中的id）</span><br><span class=\"line\">ctx: 在Resolver解析链中不断传递的中间变量（类似中间件架构中的context）</span><br><span class=\"line\">info: 当前Query的AST对象</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>query（查询）：当获取数据时，应当选取Query类型</p>\n<p>mutation（更改）：当尝试修改数据时，应当使用mutation类型</p>\n<p>subscription（订阅）：当希望数据更改时，可以进行消息推送，使用subscription类型</p>\n</li>\n</ol>\n"},{"title":"gitInfo","date":"2019-02-20T09:58:18.000Z","_content":"\n1. git rm --cached  从git索引和缓存中删除 \n2. git mv 重命名或者移动文件\n3. git reset --soft \"HEAD^\" 留下当前变更内容\n4. git reset head 从当前缓存区删除\n5. git checkout .  撤销当前工作区修改\n6. git commit --amend 修改上次提交信息\n7. git log --oneline/--raw \n8. checkout只会移动HEAD指针，reset会改变HEAD的引用值。\n9. git config --global user.name [user.email]\n10. git tag -a 'annotate' -m 'message'\n11. git remote set-url --add <name> <newurl>  添加多个url\n12. git tag -d <tag-name>  \n13. git status --ignored  显示忽略掉文件\n14. git checkout --orphan <branch-name>  新建没有commit的分支\n1. git push origin :refs/tags/<tag-name>  删除远程tag\n2. git branch -u <origin/mybranch> 设置远程分支 \n2. git branch -vv 查看本地分之关联情况\n2. git checkout -  最近两个分子间切换\n","source":"_posts/gitInfo.md","raw":"---\ntitle: gitInfo\ndate: 2019-02-20 17:58:18\ntags: git\n---\n\n1. git rm --cached  从git索引和缓存中删除 \n2. git mv 重命名或者移动文件\n3. git reset --soft \"HEAD^\" 留下当前变更内容\n4. git reset head 从当前缓存区删除\n5. git checkout .  撤销当前工作区修改\n6. git commit --amend 修改上次提交信息\n7. git log --oneline/--raw \n8. checkout只会移动HEAD指针，reset会改变HEAD的引用值。\n9. git config --global user.name [user.email]\n10. git tag -a 'annotate' -m 'message'\n11. git remote set-url --add <name> <newurl>  添加多个url\n12. git tag -d <tag-name>  \n13. git status --ignored  显示忽略掉文件\n14. git checkout --orphan <branch-name>  新建没有commit的分支\n1. git push origin :refs/tags/<tag-name>  删除远程tag\n2. git branch -u <origin/mybranch> 设置远程分支 \n2. git branch -vv 查看本地分之关联情况\n2. git checkout -  最近两个分子间切换\n","slug":"gitInfo","published":1,"updated":"2019-07-26T08:35:17.303Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2fu41zl000gf18sbfb00dkf","content":"<ol>\n<li>git rm –cached  从git索引和缓存中删除 </li>\n<li>git mv 重命名或者移动文件</li>\n<li>git reset –soft “HEAD^” 留下当前变更内容</li>\n<li>git reset head 从当前缓存区删除</li>\n<li>git checkout .  撤销当前工作区修改</li>\n<li>git commit –amend 修改上次提交信息</li>\n<li>git log –oneline/–raw </li>\n<li>checkout只会移动HEAD指针，reset会改变HEAD的引用值。</li>\n<li>git config –global user.name [user.email]</li>\n<li>git tag -a ‘annotate’ -m ‘message’</li>\n<li>git remote set-url –add <name> <newurl>  添加多个url</newurl></name></li>\n<li>git tag -d <tag-name>  </tag-name></li>\n<li>git status –ignored  显示忽略掉文件</li>\n<li>git checkout –orphan <branch-name>  新建没有commit的分支</branch-name></li>\n<li>git push origin :refs/tags/<tag-name>  删除远程tag</tag-name></li>\n<li>git branch -u &lt;origin/mybranch&gt; 设置远程分支 </li>\n<li>git branch -vv 查看本地分之关联情况</li>\n<li>git checkout -  最近两个分子间切换</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>git rm –cached  从git索引和缓存中删除 </li>\n<li>git mv 重命名或者移动文件</li>\n<li>git reset –soft “HEAD^” 留下当前变更内容</li>\n<li>git reset head 从当前缓存区删除</li>\n<li>git checkout .  撤销当前工作区修改</li>\n<li>git commit –amend 修改上次提交信息</li>\n<li>git log –oneline/–raw </li>\n<li>checkout只会移动HEAD指针，reset会改变HEAD的引用值。</li>\n<li>git config –global user.name [user.email]</li>\n<li>git tag -a ‘annotate’ -m ‘message’</li>\n<li>git remote set-url –add <name> <newurl>  添加多个url</newurl></name></li>\n<li>git tag -d <tag-name>  </tag-name></li>\n<li>git status –ignored  显示忽略掉文件</li>\n<li>git checkout –orphan <branch-name>  新建没有commit的分支</branch-name></li>\n<li>git push origin :refs/tags/<tag-name>  删除远程tag</tag-name></li>\n<li>git branch -u &lt;origin/mybranch&gt; 设置远程分支 </li>\n<li>git branch -vv 查看本地分之关联情况</li>\n<li>git checkout -  最近两个分子间切换</li>\n</ol>\n"},{"title":"hexo","date":"2016-12-21T03:47:39.000Z","_content":"# install\nNode和Git都安装好后,首先创建一个文件夹,如blog,用户存放hexo的配置文件,然后进入blog里安装Hexo。\n\n执行如下命令安装Hexo：\n\nsudo npm install -g hexo\n\n初始化然后，执行init命令初始化hexo,命令：\n\nhexo init\n\n好啦，至此，全部安装工作已经完成！blog就是你的博客根目录，所有的操作都在里面进行。\n\n生成静态页面\n\nhexo generate（hexo g也可以）\n\n本地启动\n\n启动本地服务，进行文章预览调试，命令：\n\nhexo server\n\n浏览器输入http://localhost:4000\n\n我不知道你们能不能，反正我不能，因为我还有环境没配置好\n\n# 配置Github\n建立Repository\n\n建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】，固定写法\n\n然后建立关联，我的blog在本地/Users/leopard/blog，blog是我之前建的东西也全在这里面，有：\n\n    _config.yml    node_modules    public      source\n\n    db.json        package.json    scaffolds  themes\n\n现在我们需要_config.yml文件，来建立关联，命令：\n\nvim _config.yml\n\n翻到最下面，改成我这样子的\n\ndeploy:\n\n     type: git\n\n     repo: https://github.com/leopardpan/leopardpan.github.io.git\n\n     branch: master\n\n然后执行命令：\n\nnpm install hexo-deployer-git --save\n\n \n# 一些常用命令：\n\nhexo new\"postName\" #新建文章\n\nhexo new page\"pageName\" #新建页面\n\nhexo generate #生成静态页面至public目录\n\nhexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\n\nhexo deploy #将.deploy目录部署到GitHub\n\nhexo help # 查看帮助\n\nhexo version #查看Hexo的版本\n\n ","source":"_posts/hexo.md","raw":"---\ntitle: hexo\ndate: 2016-12-21 11:47:39\ntags: hexo \n---\n# install\nNode和Git都安装好后,首先创建一个文件夹,如blog,用户存放hexo的配置文件,然后进入blog里安装Hexo。\n\n执行如下命令安装Hexo：\n\nsudo npm install -g hexo\n\n初始化然后，执行init命令初始化hexo,命令：\n\nhexo init\n\n好啦，至此，全部安装工作已经完成！blog就是你的博客根目录，所有的操作都在里面进行。\n\n生成静态页面\n\nhexo generate（hexo g也可以）\n\n本地启动\n\n启动本地服务，进行文章预览调试，命令：\n\nhexo server\n\n浏览器输入http://localhost:4000\n\n我不知道你们能不能，反正我不能，因为我还有环境没配置好\n\n# 配置Github\n建立Repository\n\n建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】，固定写法\n\n然后建立关联，我的blog在本地/Users/leopard/blog，blog是我之前建的东西也全在这里面，有：\n\n    _config.yml    node_modules    public      source\n\n    db.json        package.json    scaffolds  themes\n\n现在我们需要_config.yml文件，来建立关联，命令：\n\nvim _config.yml\n\n翻到最下面，改成我这样子的\n\ndeploy:\n\n     type: git\n\n     repo: https://github.com/leopardpan/leopardpan.github.io.git\n\n     branch: master\n\n然后执行命令：\n\nnpm install hexo-deployer-git --save\n\n \n# 一些常用命令：\n\nhexo new\"postName\" #新建文章\n\nhexo new page\"pageName\" #新建页面\n\nhexo generate #生成静态页面至public目录\n\nhexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\n\nhexo deploy #将.deploy目录部署到GitHub\n\nhexo help # 查看帮助\n\nhexo version #查看Hexo的版本\n\n ","slug":"hexo","published":1,"updated":"2019-07-26T08:35:17.303Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2fu41zm000if18s5195iu7b","content":"<h1 id=\"install\"><a href=\"#install\" class=\"headerlink\" title=\"install\"></a>install</h1><p>Node和Git都安装好后,首先创建一个文件夹,如blog,用户存放hexo的配置文件,然后进入blog里安装Hexo。</p>\n<p>执行如下命令安装Hexo：</p>\n<p>sudo npm install -g hexo</p>\n<p>初始化然后，执行init命令初始化hexo,命令：</p>\n<p>hexo init</p>\n<p>好啦，至此，全部安装工作已经完成！blog就是你的博客根目录，所有的操作都在里面进行。</p>\n<p>生成静态页面</p>\n<p>hexo generate（hexo g也可以）</p>\n<p>本地启动</p>\n<p>启动本地服务，进行文章预览调试，命令：</p>\n<p>hexo server</p>\n<p>浏览器输入<a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a></p>\n<p>我不知道你们能不能，反正我不能，因为我还有环境没配置好</p>\n<h1 id=\"配置Github\"><a href=\"#配置Github\" class=\"headerlink\" title=\"配置Github\"></a>配置Github</h1><p>建立Repository</p>\n<p>建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】，固定写法</p>\n<p>然后建立关联，我的blog在本地/Users/leopard/blog，blog是我之前建的东西也全在这里面，有：</p>\n<pre><code>_config.yml    node_modules    public      source\n\ndb.json        package.json    scaffolds  themes\n</code></pre><p>现在我们需要_config.yml文件，来建立关联，命令：</p>\n<p>vim _config.yml</p>\n<p>翻到最下面，改成我这样子的</p>\n<p>deploy:</p>\n<pre><code>type: git\n\nrepo: https://github.com/leopardpan/leopardpan.github.io.git\n\nbranch: master\n</code></pre><p>然后执行命令：</p>\n<p>npm install hexo-deployer-git –save</p>\n<h1 id=\"一些常用命令：\"><a href=\"#一些常用命令：\" class=\"headerlink\" title=\"一些常用命令：\"></a>一些常用命令：</h1><p>hexo new”postName” #新建文章</p>\n<p>hexo new page”pageName” #新建页面</p>\n<p>hexo generate #生成静态页面至public目录</p>\n<p>hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）</p>\n<p>hexo deploy #将.deploy目录部署到GitHub</p>\n<p>hexo help # 查看帮助</p>\n<p>hexo version #查看Hexo的版本</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"install\"><a href=\"#install\" class=\"headerlink\" title=\"install\"></a>install</h1><p>Node和Git都安装好后,首先创建一个文件夹,如blog,用户存放hexo的配置文件,然后进入blog里安装Hexo。</p>\n<p>执行如下命令安装Hexo：</p>\n<p>sudo npm install -g hexo</p>\n<p>初始化然后，执行init命令初始化hexo,命令：</p>\n<p>hexo init</p>\n<p>好啦，至此，全部安装工作已经完成！blog就是你的博客根目录，所有的操作都在里面进行。</p>\n<p>生成静态页面</p>\n<p>hexo generate（hexo g也可以）</p>\n<p>本地启动</p>\n<p>启动本地服务，进行文章预览调试，命令：</p>\n<p>hexo server</p>\n<p>浏览器输入<a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a></p>\n<p>我不知道你们能不能，反正我不能，因为我还有环境没配置好</p>\n<h1 id=\"配置Github\"><a href=\"#配置Github\" class=\"headerlink\" title=\"配置Github\"></a>配置Github</h1><p>建立Repository</p>\n<p>建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】，固定写法</p>\n<p>然后建立关联，我的blog在本地/Users/leopard/blog，blog是我之前建的东西也全在这里面，有：</p>\n<pre><code>_config.yml    node_modules    public      source\n\ndb.json        package.json    scaffolds  themes\n</code></pre><p>现在我们需要_config.yml文件，来建立关联，命令：</p>\n<p>vim _config.yml</p>\n<p>翻到最下面，改成我这样子的</p>\n<p>deploy:</p>\n<pre><code>type: git\n\nrepo: https://github.com/leopardpan/leopardpan.github.io.git\n\nbranch: master\n</code></pre><p>然后执行命令：</p>\n<p>npm install hexo-deployer-git –save</p>\n<h1 id=\"一些常用命令：\"><a href=\"#一些常用命令：\" class=\"headerlink\" title=\"一些常用命令：\"></a>一些常用命令：</h1><p>hexo new”postName” #新建文章</p>\n<p>hexo new page”pageName” #新建页面</p>\n<p>hexo generate #生成静态页面至public目录</p>\n<p>hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）</p>\n<p>hexo deploy #将.deploy目录部署到GitHub</p>\n<p>hexo help # 查看帮助</p>\n<p>hexo version #查看Hexo的版本</p>\n"},{"title":"http","date":"2019-05-14T07:17:39.000Z","_content":"\n####XST 的全称是 Cross-Site Tracing\n\n    客户端发 TRACE 请求至服务器，如果服务器按照标准实现了 TRACE 响应，则在 response body 里会返回此次请求的完整头信息。通过这种方式，客户端可以获取某些敏感的头字段，例如 httpOnly 的 Cookie。\n\n    TRACE方法让客户端测试到服务器的网络通路，回路的意思如发送一个请返回一个响应，这就是一个请求响应回路\n\n####Set-Cookie\n    用于设置Cookie。\n    \n    Set-Cookie: name=value; secure; HttpOnly\n    secure 只在进行HTTP通信时发送Cookie。\n    HttpOnly 指定不能从JavaScript脚本代码访问Cookie值。\n    \n ####X-Download-Options: noopen\n    noopen 用于指定IE 8以上版本的用户不打开文件而直接保存文件。在下载对话框中不显示“打开”选项。\n \n ####keepalive \n \n    若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;   \n    http 1.0中默认是关闭的，需要在http头加入\"Connection: Keep-Alive\"，才能启用Keep-Alive；http 1.1中默认启用Keep-Alive，如果加入\"Connection: close \"，才关闭。目前大部分浏览器都是用http1.1协议，也就是说默认都会发起Keep-Alive的连接请求了，所以是否能完成一个完整的Keep-Alive连接就看服务器设置情况。\n    \n ####headers\n \n Accept-Charset： 浏览器申明自己接收的字符集 \n Accept-Encoding： 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate） \n \n  Age：当代理服务器用自己缓存的实体去响应请求时，用该头部表明该实体从产生到现在经过多长时间了。   ","source":"_posts/http.md","raw":"---\ntitle: http\ndate: 2019-05-14 15:17:39\ntags: http\n---\n\n####XST 的全称是 Cross-Site Tracing\n\n    客户端发 TRACE 请求至服务器，如果服务器按照标准实现了 TRACE 响应，则在 response body 里会返回此次请求的完整头信息。通过这种方式，客户端可以获取某些敏感的头字段，例如 httpOnly 的 Cookie。\n\n    TRACE方法让客户端测试到服务器的网络通路，回路的意思如发送一个请返回一个响应，这就是一个请求响应回路\n\n####Set-Cookie\n    用于设置Cookie。\n    \n    Set-Cookie: name=value; secure; HttpOnly\n    secure 只在进行HTTP通信时发送Cookie。\n    HttpOnly 指定不能从JavaScript脚本代码访问Cookie值。\n    \n ####X-Download-Options: noopen\n    noopen 用于指定IE 8以上版本的用户不打开文件而直接保存文件。在下载对话框中不显示“打开”选项。\n \n ####keepalive \n \n    若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;   \n    http 1.0中默认是关闭的，需要在http头加入\"Connection: Keep-Alive\"，才能启用Keep-Alive；http 1.1中默认启用Keep-Alive，如果加入\"Connection: close \"，才关闭。目前大部分浏览器都是用http1.1协议，也就是说默认都会发起Keep-Alive的连接请求了，所以是否能完成一个完整的Keep-Alive连接就看服务器设置情况。\n    \n ####headers\n \n Accept-Charset： 浏览器申明自己接收的字符集 \n Accept-Encoding： 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate） \n \n  Age：当代理服务器用自己缓存的实体去响应请求时，用该头部表明该实体从产生到现在经过多长时间了。   ","slug":"http","published":1,"updated":"2019-07-26T08:35:17.303Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2fu41zn000kf18syzr9c6v3","content":"<p>####XST 的全称是 Cross-Site Tracing</p>\n<pre><code>客户端发 TRACE 请求至服务器，如果服务器按照标准实现了 TRACE 响应，则在 response body 里会返回此次请求的完整头信息。通过这种方式，客户端可以获取某些敏感的头字段，例如 httpOnly 的 Cookie。\n\nTRACE方法让客户端测试到服务器的网络通路，回路的意思如发送一个请返回一个响应，这就是一个请求响应回路\n</code></pre><p>####Set-Cookie<br>    用于设置Cookie。</p>\n<pre><code>Set-Cookie: name=value; secure; HttpOnly\nsecure 只在进行HTTP通信时发送Cookie。\nHttpOnly 指定不能从JavaScript脚本代码访问Cookie值。\n</code></pre><p> ####X-Download-Options: noopen<br>    noopen 用于指定IE 8以上版本的用户不打开文件而直接保存文件。在下载对话框中不显示“打开”选项。</p>\n<p> ####keepalive </p>\n<pre><code>若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;   \nhttp 1.0中默认是关闭的，需要在http头加入&quot;Connection: Keep-Alive&quot;，才能启用Keep-Alive；http 1.1中默认启用Keep-Alive，如果加入&quot;Connection: close &quot;，才关闭。目前大部分浏览器都是用http1.1协议，也就是说默认都会发起Keep-Alive的连接请求了，所以是否能完成一个完整的Keep-Alive连接就看服务器设置情况。\n</code></pre><p> ####headers</p>\n<p> Accept-Charset： 浏览器申明自己接收的字符集<br> Accept-Encoding： 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate） </p>\n<p>  Age：当代理服务器用自己缓存的实体去响应请求时，用该头部表明该实体从产生到现在经过多长时间了。   </p>\n","site":{"data":{}},"excerpt":"","more":"<p>####XST 的全称是 Cross-Site Tracing</p>\n<pre><code>客户端发 TRACE 请求至服务器，如果服务器按照标准实现了 TRACE 响应，则在 response body 里会返回此次请求的完整头信息。通过这种方式，客户端可以获取某些敏感的头字段，例如 httpOnly 的 Cookie。\n\nTRACE方法让客户端测试到服务器的网络通路，回路的意思如发送一个请返回一个响应，这就是一个请求响应回路\n</code></pre><p>####Set-Cookie<br>    用于设置Cookie。</p>\n<pre><code>Set-Cookie: name=value; secure; HttpOnly\nsecure 只在进行HTTP通信时发送Cookie。\nHttpOnly 指定不能从JavaScript脚本代码访问Cookie值。\n</code></pre><p> ####X-Download-Options: noopen<br>    noopen 用于指定IE 8以上版本的用户不打开文件而直接保存文件。在下载对话框中不显示“打开”选项。</p>\n<p> ####keepalive </p>\n<pre><code>若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;   \nhttp 1.0中默认是关闭的，需要在http头加入&quot;Connection: Keep-Alive&quot;，才能启用Keep-Alive；http 1.1中默认启用Keep-Alive，如果加入&quot;Connection: close &quot;，才关闭。目前大部分浏览器都是用http1.1协议，也就是说默认都会发起Keep-Alive的连接请求了，所以是否能完成一个完整的Keep-Alive连接就看服务器设置情况。\n</code></pre><p> ####headers</p>\n<p> Accept-Charset： 浏览器申明自己接收的字符集<br> Accept-Encoding： 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate） </p>\n<p>  Age：当代理服务器用自己缓存的实体去响应请求时，用该头部表明该实体从产生到现在经过多长时间了。   </p>\n"},{"title":"interview","date":"2017-01-23T10:25:52.000Z","_content":" 而在底层，Node.js借助libuv来作为抽象封装层， 从而屏蔽不同操作系统的差异，Node可以借助livuv来来实现多线程。\n \n ![image](http://www.admin10000.com/UploadFiles/Document/201509/30/20150930072020634231.PNG)\n \n 事件循环是单线程的，从下图可以看出\n \n ![image](http://www.admin10000.com/UploadFiles/Document/201509/30/20150930072028113909.PNG)\n \n 所有的同步任务在主线程上执行，形成一个任务栈。所有的异步任务的回调在另一队列中，只有执行完\n \n tTimeout()只是将事件插入了\"任务队列\"，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行。\n \n Node.js也是单线程的Event Loop，但是它的运行机制不同于浏览器环境。\n \n ![image](http://image.beekka.com/blog/2014/bg2014100803.png)\n \n\n```\nprocess.nextTick(function A() {\n  console.log(1);\n  process.nextTick(function B(){console.log(2);});\n});\n\nsetTimeout(function timeout() {\n  console.log('TIMEOUT FIRED');\n}, 0)\n// 1\n// 2\n// TIMEOUT FIRED\n```\n\n上面代码中，由于process.nextTick方法指定的回调函数，总是在当前\"执行栈\"的尾部触发，所以不仅函数A比setTimeout指定的回调函数timeout先执行，而且函数B也比timeout先执行。这说明，如果有多个process.nextTick语句（不管它们是否嵌套），将全部在当前\"执行栈\"执行。   setImmediate总是将事件注册到下一轮Event Loop\n\n\n　测试金字塔指的是： 当我们在编写测试用例时，底层的单元测试应该远比上层的端到端测试要多。\n　\n\n数组的shift和unshift  push 和 pop \n\nnode 优势：非阻塞IO、高并发、丰富的生态环境\n\n node有哪些全局对象?\n参考答案: process, console, Buffer和exports\n![image](https://camo.githubusercontent.com/233315761d49d4c75fe7969e36bda22ecf5bbc0f/687474703a2f2f6a6f616f7073696c76612e6769746875622e696f2f74616c6b732f456e642d746f2d456e642d4a6176615363726970742d776974682d7468652d4d45414e2d537461636b2f696d672f6e6f64656a732d617263682d7070742e706e67)\n\nprocess有哪些常用方法?\n参考答案: process.stdin, process.stdout, process.stderr, process.on, process.env, process.argv, process.arch, process.platform, process.exit\n\n通过domain获取eventemmiter 的异常：\n\n```\nvar domain = require('domain');\n    var myDomain = domain.create();\n    myDomain.on('error', function(err){\n        console.log('domain接收到的错误事件:', err);\n    }); // 接收事件并打印\n    myDomain.run(function(){\n        var emitter1 = new MyEmitter();\n        emitter1.emit('error', '错误事件来自emitter1');\n        emitter2 = new MyEmitter();\n        emitter2.emit('error', '错误事件来自emitter2');\n    });\n```\n\nsupper 代表父类构造函数和原形\n\n\n原生构造函数：\nBoolean()\nNumber()\nString()\nArray()\nDate()\nFunction()\nRegExp()\nError()\nObject()\n\nEs6 可以继承这些原生的构造函数\n \n```\nclass MyArray extends Array {\n  constructor(...args) {\n    super(...args);\n  }\n}\n\nvar arr = new MyArray();\narr[0] = 12;\narr.length // 1\n\narr.length = 0;\narr[0] // undefined\n```\n\n```\nclass ExtendableError extends Error {\n  constructor(message) {\n    super();\n    this.message = message;\n    this.stack = (new Error()).stack;\n    this.name = this.constructor.name;\n  }\n}\n\nclass MyError extends ExtendableError {\n  constructor(m) {\n    super(m);\n  }\n}\n\nvar myerror = new MyError('ll');\nmyerror.message // \"ll\"\nmyerror instanceof Error // true\nmyerror.name // \"MyError\"\nmyerror.stack\n```\n\n定义get set ,可在方法体内部拦截\n\n```\nclass MyClass {\n  constructor() {\n    // ...\n  }\n  get prop() {\n    return 'getter';\n  }\n  set prop(value) {\n    console.log('setter: '+value);\n  }\n  * [Symbol.iterator]() {\n    for (let arg of this.args) {\n      yield arg;\n    }\n  }\n}\n```\n\nStream有什么好处?\n参考答案: 非阻塞式数据处理提升效率，片断处理节省内存，管道处理方便可扩展等.\n\n\nfs.watch和fs.watchFile有什么区别，怎么应用?\n参考答案: 二者主要用来监听文件变动．fs.watch利用操作系统原生机制来监听，可能不适用网络文件系统; fs.watchFile则是定期检查文件状态变更，适用于网络文件系统，但是相比fs.watch有些慢，因为不是实时机制．\n\n实现一个简单的HTTP 服务器。\nrequire('http').createServer(function(req,res){}).listen(300);\n\nspawn应用来运行返回大量数据的子进程，如图像处理，文件读取等。而exec则应用来运行只返回少量返回值的子进程，如只返回一个状态码。\n\n有哪些常用方法可以防止程序崩溃?\n\n参考答案: 1) try-catch-finally 2) EventEmitter/Stream error事件处理 3) domain统一控制 4) jshint静态检查 5) jasmine/mocha进行单元测试\n\n\n要监控nodejs的内存使用的话，需要安装memwathch 模块\n\nnodejs C++ 扩展的实现：\nhttps://my.oschina.net/yushulx/blog/423704\n\nprocess.argv 数组的第一个元素永远都会是 node，并且第二个参数总是指向你的程序的路径，所以，你应该从第三个元素\n\n\n```\nregex test   if (/^\\/api\\/parsetime/.test(req.url))\n```\n\n\n回调函数的规则：err 为第一个参数\n\n文件的总行：\n```\nvar lines = contents.toString().split('\\n').length - 1\n```\n\n\nfs.unlink 删除文件\n\n\n```\n//创建一个tcp 服务器\nvar net = require('net')\n\nvar server = net.createServer(function (socket) {\n\n  // socket 处理逻辑\n\n})\n\nserver.listen(8000)\n```\n\n\n使用 socket.write(data) 可以写数据到 socket 中，用 socket.end() 可以关闭一个 socket。另外， .end() 方法也可以接收一个数据对象作为参数，因此，你可简单地使用 socket.end(data) 来完成写数据和关闭两个操作。\n\nconcat-stream：会连接多个stream,参数中不指定encoding 的话，会自行推断。\n\n```\nvar arrays = concat({ encoding: 'array' }, function(out) {\n    t.deepEqual(out, [1,2,3,4,5,6])\n  })\n  arrays.write([1,2,3])\n  arrays.write([4,5,6])\n  arrays.end()\n```\n\n```\nfs.createReadStream(file).pipe(process.stdout);\n```\n使用through2 对流数据进行转换：\n\n通过split 将流中的数据分行：\n\nYou can use the `split` module to split input by newlines. For example:\n```\n    var split = require('split');\n    process.stdin\n        .pipe(split())\n        .pipe(through2(function (line, _, next) {\n            console.dir(line.toString());\n            next();\n        }))\n    ;\n```","source":"_posts/interview.md","raw":"---\ntitle: interview\ndate: 2017-01-23 18:25:52\ntags: interview\n---\n 而在底层，Node.js借助libuv来作为抽象封装层， 从而屏蔽不同操作系统的差异，Node可以借助livuv来来实现多线程。\n \n ![image](http://www.admin10000.com/UploadFiles/Document/201509/30/20150930072020634231.PNG)\n \n 事件循环是单线程的，从下图可以看出\n \n ![image](http://www.admin10000.com/UploadFiles/Document/201509/30/20150930072028113909.PNG)\n \n 所有的同步任务在主线程上执行，形成一个任务栈。所有的异步任务的回调在另一队列中，只有执行完\n \n tTimeout()只是将事件插入了\"任务队列\"，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行。\n \n Node.js也是单线程的Event Loop，但是它的运行机制不同于浏览器环境。\n \n ![image](http://image.beekka.com/blog/2014/bg2014100803.png)\n \n\n```\nprocess.nextTick(function A() {\n  console.log(1);\n  process.nextTick(function B(){console.log(2);});\n});\n\nsetTimeout(function timeout() {\n  console.log('TIMEOUT FIRED');\n}, 0)\n// 1\n// 2\n// TIMEOUT FIRED\n```\n\n上面代码中，由于process.nextTick方法指定的回调函数，总是在当前\"执行栈\"的尾部触发，所以不仅函数A比setTimeout指定的回调函数timeout先执行，而且函数B也比timeout先执行。这说明，如果有多个process.nextTick语句（不管它们是否嵌套），将全部在当前\"执行栈\"执行。   setImmediate总是将事件注册到下一轮Event Loop\n\n\n　测试金字塔指的是： 当我们在编写测试用例时，底层的单元测试应该远比上层的端到端测试要多。\n　\n\n数组的shift和unshift  push 和 pop \n\nnode 优势：非阻塞IO、高并发、丰富的生态环境\n\n node有哪些全局对象?\n参考答案: process, console, Buffer和exports\n![image](https://camo.githubusercontent.com/233315761d49d4c75fe7969e36bda22ecf5bbc0f/687474703a2f2f6a6f616f7073696c76612e6769746875622e696f2f74616c6b732f456e642d746f2d456e642d4a6176615363726970742d776974682d7468652d4d45414e2d537461636b2f696d672f6e6f64656a732d617263682d7070742e706e67)\n\nprocess有哪些常用方法?\n参考答案: process.stdin, process.stdout, process.stderr, process.on, process.env, process.argv, process.arch, process.platform, process.exit\n\n通过domain获取eventemmiter 的异常：\n\n```\nvar domain = require('domain');\n    var myDomain = domain.create();\n    myDomain.on('error', function(err){\n        console.log('domain接收到的错误事件:', err);\n    }); // 接收事件并打印\n    myDomain.run(function(){\n        var emitter1 = new MyEmitter();\n        emitter1.emit('error', '错误事件来自emitter1');\n        emitter2 = new MyEmitter();\n        emitter2.emit('error', '错误事件来自emitter2');\n    });\n```\n\nsupper 代表父类构造函数和原形\n\n\n原生构造函数：\nBoolean()\nNumber()\nString()\nArray()\nDate()\nFunction()\nRegExp()\nError()\nObject()\n\nEs6 可以继承这些原生的构造函数\n \n```\nclass MyArray extends Array {\n  constructor(...args) {\n    super(...args);\n  }\n}\n\nvar arr = new MyArray();\narr[0] = 12;\narr.length // 1\n\narr.length = 0;\narr[0] // undefined\n```\n\n```\nclass ExtendableError extends Error {\n  constructor(message) {\n    super();\n    this.message = message;\n    this.stack = (new Error()).stack;\n    this.name = this.constructor.name;\n  }\n}\n\nclass MyError extends ExtendableError {\n  constructor(m) {\n    super(m);\n  }\n}\n\nvar myerror = new MyError('ll');\nmyerror.message // \"ll\"\nmyerror instanceof Error // true\nmyerror.name // \"MyError\"\nmyerror.stack\n```\n\n定义get set ,可在方法体内部拦截\n\n```\nclass MyClass {\n  constructor() {\n    // ...\n  }\n  get prop() {\n    return 'getter';\n  }\n  set prop(value) {\n    console.log('setter: '+value);\n  }\n  * [Symbol.iterator]() {\n    for (let arg of this.args) {\n      yield arg;\n    }\n  }\n}\n```\n\nStream有什么好处?\n参考答案: 非阻塞式数据处理提升效率，片断处理节省内存，管道处理方便可扩展等.\n\n\nfs.watch和fs.watchFile有什么区别，怎么应用?\n参考答案: 二者主要用来监听文件变动．fs.watch利用操作系统原生机制来监听，可能不适用网络文件系统; fs.watchFile则是定期检查文件状态变更，适用于网络文件系统，但是相比fs.watch有些慢，因为不是实时机制．\n\n实现一个简单的HTTP 服务器。\nrequire('http').createServer(function(req,res){}).listen(300);\n\nspawn应用来运行返回大量数据的子进程，如图像处理，文件读取等。而exec则应用来运行只返回少量返回值的子进程，如只返回一个状态码。\n\n有哪些常用方法可以防止程序崩溃?\n\n参考答案: 1) try-catch-finally 2) EventEmitter/Stream error事件处理 3) domain统一控制 4) jshint静态检查 5) jasmine/mocha进行单元测试\n\n\n要监控nodejs的内存使用的话，需要安装memwathch 模块\n\nnodejs C++ 扩展的实现：\nhttps://my.oschina.net/yushulx/blog/423704\n\nprocess.argv 数组的第一个元素永远都会是 node，并且第二个参数总是指向你的程序的路径，所以，你应该从第三个元素\n\n\n```\nregex test   if (/^\\/api\\/parsetime/.test(req.url))\n```\n\n\n回调函数的规则：err 为第一个参数\n\n文件的总行：\n```\nvar lines = contents.toString().split('\\n').length - 1\n```\n\n\nfs.unlink 删除文件\n\n\n```\n//创建一个tcp 服务器\nvar net = require('net')\n\nvar server = net.createServer(function (socket) {\n\n  // socket 处理逻辑\n\n})\n\nserver.listen(8000)\n```\n\n\n使用 socket.write(data) 可以写数据到 socket 中，用 socket.end() 可以关闭一个 socket。另外， .end() 方法也可以接收一个数据对象作为参数，因此，你可简单地使用 socket.end(data) 来完成写数据和关闭两个操作。\n\nconcat-stream：会连接多个stream,参数中不指定encoding 的话，会自行推断。\n\n```\nvar arrays = concat({ encoding: 'array' }, function(out) {\n    t.deepEqual(out, [1,2,3,4,5,6])\n  })\n  arrays.write([1,2,3])\n  arrays.write([4,5,6])\n  arrays.end()\n```\n\n```\nfs.createReadStream(file).pipe(process.stdout);\n```\n使用through2 对流数据进行转换：\n\n通过split 将流中的数据分行：\n\nYou can use the `split` module to split input by newlines. For example:\n```\n    var split = require('split');\n    process.stdin\n        .pipe(split())\n        .pipe(through2(function (line, _, next) {\n            console.dir(line.toString());\n            next();\n        }))\n    ;\n```","slug":"interview","published":1,"updated":"2019-07-26T08:35:17.305Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2fu41zo000mf18s0o50tdpi","content":"<p> 而在底层，Node.js借助libuv来作为抽象封装层， 从而屏蔽不同操作系统的差异，Node可以借助livuv来来实现多线程。</p>\n<p> <img src=\"http://www.admin10000.com/UploadFiles/Document/201509/30/20150930072020634231.PNG\" alt=\"image\"></p>\n<p> 事件循环是单线程的，从下图可以看出</p>\n<p> <img src=\"http://www.admin10000.com/UploadFiles/Document/201509/30/20150930072028113909.PNG\" alt=\"image\"></p>\n<p> 所有的同步任务在主线程上执行，形成一个任务栈。所有的异步任务的回调在另一队列中，只有执行完</p>\n<p> tTimeout()只是将事件插入了”任务队列”，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行。</p>\n<p> Node.js也是单线程的Event Loop，但是它的运行机制不同于浏览器环境。</p>\n<p> <img src=\"http://image.beekka.com/blog/2014/bg2014100803.png\" alt=\"image\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">process.nextTick(function A() &#123;</span><br><span class=\"line\">  console.log(1);</span><br><span class=\"line\">  process.nextTick(function B()&#123;console.log(2);&#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(function timeout() &#123;</span><br><span class=\"line\">  console.log(&apos;TIMEOUT FIRED&apos;);</span><br><span class=\"line\">&#125;, 0)</span><br><span class=\"line\">// 1</span><br><span class=\"line\">// 2</span><br><span class=\"line\">// TIMEOUT FIRED</span><br></pre></td></tr></table></figure>\n<p>上面代码中，由于process.nextTick方法指定的回调函数，总是在当前”执行栈”的尾部触发，所以不仅函数A比setTimeout指定的回调函数timeout先执行，而且函数B也比timeout先执行。这说明，如果有多个process.nextTick语句（不管它们是否嵌套），将全部在当前”执行栈”执行。   setImmediate总是将事件注册到下一轮Event Loop</p>\n<p>　测试金字塔指的是： 当我们在编写测试用例时，底层的单元测试应该远比上层的端到端测试要多。\n　</p>\n<p>数组的shift和unshift  push 和 pop </p>\n<p>node 优势：非阻塞IO、高并发、丰富的生态环境</p>\n<p> node有哪些全局对象?<br>参考答案: process, console, Buffer和exports<br><img src=\"https://camo.githubusercontent.com/233315761d49d4c75fe7969e36bda22ecf5bbc0f/687474703a2f2f6a6f616f7073696c76612e6769746875622e696f2f74616c6b732f456e642d746f2d456e642d4a6176615363726970742d776974682d7468652d4d45414e2d537461636b2f696d672f6e6f64656a732d617263682d7070742e706e67\" alt=\"image\"></p>\n<p>process有哪些常用方法?<br>参考答案: process.stdin, process.stdout, process.stderr, process.on, process.env, process.argv, process.arch, process.platform, process.exit</p>\n<p>通过domain获取eventemmiter 的异常：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var domain = require(&apos;domain&apos;);</span><br><span class=\"line\">    var myDomain = domain.create();</span><br><span class=\"line\">    myDomain.on(&apos;error&apos;, function(err)&#123;</span><br><span class=\"line\">        console.log(&apos;domain接收到的错误事件:&apos;, err);</span><br><span class=\"line\">    &#125;); // 接收事件并打印</span><br><span class=\"line\">    myDomain.run(function()&#123;</span><br><span class=\"line\">        var emitter1 = new MyEmitter();</span><br><span class=\"line\">        emitter1.emit(&apos;error&apos;, &apos;错误事件来自emitter1&apos;);</span><br><span class=\"line\">        emitter2 = new MyEmitter();</span><br><span class=\"line\">        emitter2.emit(&apos;error&apos;, &apos;错误事件来自emitter2&apos;);</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>supper 代表父类构造函数和原形</p>\n<p>原生构造函数：<br>Boolean()<br>Number()<br>String()<br>Array()<br>Date()<br>Function()<br>RegExp()<br>Error()<br>Object()</p>\n<p>Es6 可以继承这些原生的构造函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyArray extends Array &#123;</span><br><span class=\"line\">  constructor(...args) &#123;</span><br><span class=\"line\">    super(...args);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var arr = new MyArray();</span><br><span class=\"line\">arr[0] = 12;</span><br><span class=\"line\">arr.length // 1</span><br><span class=\"line\"></span><br><span class=\"line\">arr.length = 0;</span><br><span class=\"line\">arr[0] // undefined</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class ExtendableError extends Error &#123;</span><br><span class=\"line\">  constructor(message) &#123;</span><br><span class=\"line\">    super();</span><br><span class=\"line\">    this.message = message;</span><br><span class=\"line\">    this.stack = (new Error()).stack;</span><br><span class=\"line\">    this.name = this.constructor.name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class MyError extends ExtendableError &#123;</span><br><span class=\"line\">  constructor(m) &#123;</span><br><span class=\"line\">    super(m);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var myerror = new MyError(&apos;ll&apos;);</span><br><span class=\"line\">myerror.message // &quot;ll&quot;</span><br><span class=\"line\">myerror instanceof Error // true</span><br><span class=\"line\">myerror.name // &quot;MyError&quot;</span><br><span class=\"line\">myerror.stack</span><br></pre></td></tr></table></figure>\n<p>定义get set ,可在方法体内部拦截</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyClass &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  get prop() &#123;</span><br><span class=\"line\">    return &apos;getter&apos;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  set prop(value) &#123;</span><br><span class=\"line\">    console.log(&apos;setter: &apos;+value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  * [Symbol.iterator]() &#123;</span><br><span class=\"line\">    for (let arg of this.args) &#123;</span><br><span class=\"line\">      yield arg;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Stream有什么好处?<br>参考答案: 非阻塞式数据处理提升效率，片断处理节省内存，管道处理方便可扩展等.</p>\n<p>fs.watch和fs.watchFile有什么区别，怎么应用?<br>参考答案: 二者主要用来监听文件变动．fs.watch利用操作系统原生机制来监听，可能不适用网络文件系统; fs.watchFile则是定期检查文件状态变更，适用于网络文件系统，但是相比fs.watch有些慢，因为不是实时机制．</p>\n<p>实现一个简单的HTTP 服务器。<br>require(‘http’).createServer(function(req,res){}).listen(300);</p>\n<p>spawn应用来运行返回大量数据的子进程，如图像处理，文件读取等。而exec则应用来运行只返回少量返回值的子进程，如只返回一个状态码。</p>\n<p>有哪些常用方法可以防止程序崩溃?</p>\n<p>参考答案: 1) try-catch-finally 2) EventEmitter/Stream error事件处理 3) domain统一控制 4) jshint静态检查 5) jasmine/mocha进行单元测试</p>\n<p>要监控nodejs的内存使用的话，需要安装memwathch 模块</p>\n<p>nodejs C++ 扩展的实现：<br><a href=\"https://my.oschina.net/yushulx/blog/423704\" target=\"_blank\" rel=\"noopener\">https://my.oschina.net/yushulx/blog/423704</a></p>\n<p>process.argv 数组的第一个元素永远都会是 node，并且第二个参数总是指向你的程序的路径，所以，你应该从第三个元素</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">regex test   if (/^\\/api\\/parsetime/.test(req.url))</span><br></pre></td></tr></table></figure>\n<p>回调函数的规则：err 为第一个参数</p>\n<p>文件的总行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var lines = contents.toString().split(&apos;\\n&apos;).length - 1</span><br></pre></td></tr></table></figure></p>\n<p>fs.unlink 删除文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//创建一个tcp 服务器</span><br><span class=\"line\">var net = require(&apos;net&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">var server = net.createServer(function (socket) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  // socket 处理逻辑</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(8000)</span><br></pre></td></tr></table></figure>\n<p>使用 socket.write(data) 可以写数据到 socket 中，用 socket.end() 可以关闭一个 socket。另外， .end() 方法也可以接收一个数据对象作为参数，因此，你可简单地使用 socket.end(data) 来完成写数据和关闭两个操作。</p>\n<p>concat-stream：会连接多个stream,参数中不指定encoding 的话，会自行推断。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arrays = concat(&#123; encoding: &apos;array&apos; &#125;, function(out) &#123;</span><br><span class=\"line\">    t.deepEqual(out, [1,2,3,4,5,6])</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  arrays.write([1,2,3])</span><br><span class=\"line\">  arrays.write([4,5,6])</span><br><span class=\"line\">  arrays.end()</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fs.createReadStream(file).pipe(process.stdout);</span><br></pre></td></tr></table></figure>\n<p>使用through2 对流数据进行转换：</p>\n<p>通过split 将流中的数据分行：</p>\n<p>You can use the <code>split</code> module to split input by newlines. For example:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var split = require(&apos;split&apos;);</span><br><span class=\"line\">process.stdin</span><br><span class=\"line\">    .pipe(split())</span><br><span class=\"line\">    .pipe(through2(function (line, _, next) &#123;</span><br><span class=\"line\">        console.dir(line.toString());</span><br><span class=\"line\">        next();</span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p> 而在底层，Node.js借助libuv来作为抽象封装层， 从而屏蔽不同操作系统的差异，Node可以借助livuv来来实现多线程。</p>\n<p> <img src=\"http://www.admin10000.com/UploadFiles/Document/201509/30/20150930072020634231.PNG\" alt=\"image\"></p>\n<p> 事件循环是单线程的，从下图可以看出</p>\n<p> <img src=\"http://www.admin10000.com/UploadFiles/Document/201509/30/20150930072028113909.PNG\" alt=\"image\"></p>\n<p> 所有的同步任务在主线程上执行，形成一个任务栈。所有的异步任务的回调在另一队列中，只有执行完</p>\n<p> tTimeout()只是将事件插入了”任务队列”，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行。</p>\n<p> Node.js也是单线程的Event Loop，但是它的运行机制不同于浏览器环境。</p>\n<p> <img src=\"http://image.beekka.com/blog/2014/bg2014100803.png\" alt=\"image\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">process.nextTick(function A() &#123;</span><br><span class=\"line\">  console.log(1);</span><br><span class=\"line\">  process.nextTick(function B()&#123;console.log(2);&#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(function timeout() &#123;</span><br><span class=\"line\">  console.log(&apos;TIMEOUT FIRED&apos;);</span><br><span class=\"line\">&#125;, 0)</span><br><span class=\"line\">// 1</span><br><span class=\"line\">// 2</span><br><span class=\"line\">// TIMEOUT FIRED</span><br></pre></td></tr></table></figure>\n<p>上面代码中，由于process.nextTick方法指定的回调函数，总是在当前”执行栈”的尾部触发，所以不仅函数A比setTimeout指定的回调函数timeout先执行，而且函数B也比timeout先执行。这说明，如果有多个process.nextTick语句（不管它们是否嵌套），将全部在当前”执行栈”执行。   setImmediate总是将事件注册到下一轮Event Loop</p>\n<p>　测试金字塔指的是： 当我们在编写测试用例时，底层的单元测试应该远比上层的端到端测试要多。\n　</p>\n<p>数组的shift和unshift  push 和 pop </p>\n<p>node 优势：非阻塞IO、高并发、丰富的生态环境</p>\n<p> node有哪些全局对象?<br>参考答案: process, console, Buffer和exports<br><img src=\"https://camo.githubusercontent.com/233315761d49d4c75fe7969e36bda22ecf5bbc0f/687474703a2f2f6a6f616f7073696c76612e6769746875622e696f2f74616c6b732f456e642d746f2d456e642d4a6176615363726970742d776974682d7468652d4d45414e2d537461636b2f696d672f6e6f64656a732d617263682d7070742e706e67\" alt=\"image\"></p>\n<p>process有哪些常用方法?<br>参考答案: process.stdin, process.stdout, process.stderr, process.on, process.env, process.argv, process.arch, process.platform, process.exit</p>\n<p>通过domain获取eventemmiter 的异常：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var domain = require(&apos;domain&apos;);</span><br><span class=\"line\">    var myDomain = domain.create();</span><br><span class=\"line\">    myDomain.on(&apos;error&apos;, function(err)&#123;</span><br><span class=\"line\">        console.log(&apos;domain接收到的错误事件:&apos;, err);</span><br><span class=\"line\">    &#125;); // 接收事件并打印</span><br><span class=\"line\">    myDomain.run(function()&#123;</span><br><span class=\"line\">        var emitter1 = new MyEmitter();</span><br><span class=\"line\">        emitter1.emit(&apos;error&apos;, &apos;错误事件来自emitter1&apos;);</span><br><span class=\"line\">        emitter2 = new MyEmitter();</span><br><span class=\"line\">        emitter2.emit(&apos;error&apos;, &apos;错误事件来自emitter2&apos;);</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>supper 代表父类构造函数和原形</p>\n<p>原生构造函数：<br>Boolean()<br>Number()<br>String()<br>Array()<br>Date()<br>Function()<br>RegExp()<br>Error()<br>Object()</p>\n<p>Es6 可以继承这些原生的构造函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyArray extends Array &#123;</span><br><span class=\"line\">  constructor(...args) &#123;</span><br><span class=\"line\">    super(...args);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var arr = new MyArray();</span><br><span class=\"line\">arr[0] = 12;</span><br><span class=\"line\">arr.length // 1</span><br><span class=\"line\"></span><br><span class=\"line\">arr.length = 0;</span><br><span class=\"line\">arr[0] // undefined</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class ExtendableError extends Error &#123;</span><br><span class=\"line\">  constructor(message) &#123;</span><br><span class=\"line\">    super();</span><br><span class=\"line\">    this.message = message;</span><br><span class=\"line\">    this.stack = (new Error()).stack;</span><br><span class=\"line\">    this.name = this.constructor.name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class MyError extends ExtendableError &#123;</span><br><span class=\"line\">  constructor(m) &#123;</span><br><span class=\"line\">    super(m);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var myerror = new MyError(&apos;ll&apos;);</span><br><span class=\"line\">myerror.message // &quot;ll&quot;</span><br><span class=\"line\">myerror instanceof Error // true</span><br><span class=\"line\">myerror.name // &quot;MyError&quot;</span><br><span class=\"line\">myerror.stack</span><br></pre></td></tr></table></figure>\n<p>定义get set ,可在方法体内部拦截</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyClass &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  get prop() &#123;</span><br><span class=\"line\">    return &apos;getter&apos;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  set prop(value) &#123;</span><br><span class=\"line\">    console.log(&apos;setter: &apos;+value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  * [Symbol.iterator]() &#123;</span><br><span class=\"line\">    for (let arg of this.args) &#123;</span><br><span class=\"line\">      yield arg;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Stream有什么好处?<br>参考答案: 非阻塞式数据处理提升效率，片断处理节省内存，管道处理方便可扩展等.</p>\n<p>fs.watch和fs.watchFile有什么区别，怎么应用?<br>参考答案: 二者主要用来监听文件变动．fs.watch利用操作系统原生机制来监听，可能不适用网络文件系统; fs.watchFile则是定期检查文件状态变更，适用于网络文件系统，但是相比fs.watch有些慢，因为不是实时机制．</p>\n<p>实现一个简单的HTTP 服务器。<br>require(‘http’).createServer(function(req,res){}).listen(300);</p>\n<p>spawn应用来运行返回大量数据的子进程，如图像处理，文件读取等。而exec则应用来运行只返回少量返回值的子进程，如只返回一个状态码。</p>\n<p>有哪些常用方法可以防止程序崩溃?</p>\n<p>参考答案: 1) try-catch-finally 2) EventEmitter/Stream error事件处理 3) domain统一控制 4) jshint静态检查 5) jasmine/mocha进行单元测试</p>\n<p>要监控nodejs的内存使用的话，需要安装memwathch 模块</p>\n<p>nodejs C++ 扩展的实现：<br><a href=\"https://my.oschina.net/yushulx/blog/423704\" target=\"_blank\" rel=\"noopener\">https://my.oschina.net/yushulx/blog/423704</a></p>\n<p>process.argv 数组的第一个元素永远都会是 node，并且第二个参数总是指向你的程序的路径，所以，你应该从第三个元素</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">regex test   if (/^\\/api\\/parsetime/.test(req.url))</span><br></pre></td></tr></table></figure>\n<p>回调函数的规则：err 为第一个参数</p>\n<p>文件的总行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var lines = contents.toString().split(&apos;\\n&apos;).length - 1</span><br></pre></td></tr></table></figure></p>\n<p>fs.unlink 删除文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//创建一个tcp 服务器</span><br><span class=\"line\">var net = require(&apos;net&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">var server = net.createServer(function (socket) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  // socket 处理逻辑</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(8000)</span><br></pre></td></tr></table></figure>\n<p>使用 socket.write(data) 可以写数据到 socket 中，用 socket.end() 可以关闭一个 socket。另外， .end() 方法也可以接收一个数据对象作为参数，因此，你可简单地使用 socket.end(data) 来完成写数据和关闭两个操作。</p>\n<p>concat-stream：会连接多个stream,参数中不指定encoding 的话，会自行推断。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arrays = concat(&#123; encoding: &apos;array&apos; &#125;, function(out) &#123;</span><br><span class=\"line\">    t.deepEqual(out, [1,2,3,4,5,6])</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  arrays.write([1,2,3])</span><br><span class=\"line\">  arrays.write([4,5,6])</span><br><span class=\"line\">  arrays.end()</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fs.createReadStream(file).pipe(process.stdout);</span><br></pre></td></tr></table></figure>\n<p>使用through2 对流数据进行转换：</p>\n<p>通过split 将流中的数据分行：</p>\n<p>You can use the <code>split</code> module to split input by newlines. For example:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var split = require(&apos;split&apos;);</span><br><span class=\"line\">process.stdin</span><br><span class=\"line\">    .pipe(split())</span><br><span class=\"line\">    .pipe(through2(function (line, _, next) &#123;</span><br><span class=\"line\">        console.dir(line.toString());</span><br><span class=\"line\">        next();</span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"loadtest","date":"2017-01-17T01:41:01.000Z","_content":"### loadtest 压力测试\n可用powershell 或linux bash \n\n命令行如果加post body 会报错\n\n常用参数：\n\n-T 表示持续时间\n\n-c 并行数量\n\n-n 总的请求\n\n-m  get,put,post\n\n--rps 每秒发送请求数\n\n-P Request body 数据\n\n-p body 数据存在的文件路径\n\n-H header 添加\n\n-C 设置cookie\n```\nparam(\n    [int] $iterations = 6000,\n    [int] $rps = 500,\n    [string][ValidateSet(\"plaintext\")] $variation = \"plaintext\")\n\nif ($variation -eq \"plaintext\")\n{\n    $url = \"http://wh.etao.cn/auth/test\"\n}\n\nWrite-Host -ForegroundColor Green Beginning workload\nWrite-Host \"`& loadtest -k -n $iterations -c 100 --rps $rps $url\"\nWrite-Host\n\n& loadtest -k -n $iterations -c 100 --rps $rps $url\n```\n\n```\nloadtest -c 5 -t 2 -m post -T 'application/json'  -P '{\"message\":\"hello\"}'  -H \"Accept: application/json; q=0.9, application/xml; q=0.6\" http://cttest.etao.cn:8011/api/auth/test\n```\n","source":"_posts/loadtest.md","raw":"---\ntitle: loadtest\ndate: 2017-01-17 09:41:01\ntags: loadtest\n---\n### loadtest 压力测试\n可用powershell 或linux bash \n\n命令行如果加post body 会报错\n\n常用参数：\n\n-T 表示持续时间\n\n-c 并行数量\n\n-n 总的请求\n\n-m  get,put,post\n\n--rps 每秒发送请求数\n\n-P Request body 数据\n\n-p body 数据存在的文件路径\n\n-H header 添加\n\n-C 设置cookie\n```\nparam(\n    [int] $iterations = 6000,\n    [int] $rps = 500,\n    [string][ValidateSet(\"plaintext\")] $variation = \"plaintext\")\n\nif ($variation -eq \"plaintext\")\n{\n    $url = \"http://wh.etao.cn/auth/test\"\n}\n\nWrite-Host -ForegroundColor Green Beginning workload\nWrite-Host \"`& loadtest -k -n $iterations -c 100 --rps $rps $url\"\nWrite-Host\n\n& loadtest -k -n $iterations -c 100 --rps $rps $url\n```\n\n```\nloadtest -c 5 -t 2 -m post -T 'application/json'  -P '{\"message\":\"hello\"}'  -H \"Accept: application/json; q=0.9, application/xml; q=0.6\" http://cttest.etao.cn:8011/api/auth/test\n```\n","slug":"loadtest","published":1,"updated":"2019-07-26T08:35:17.306Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2fu41zq000of18s3757ndkv","content":"<h3 id=\"loadtest-压力测试\"><a href=\"#loadtest-压力测试\" class=\"headerlink\" title=\"loadtest 压力测试\"></a>loadtest 压力测试</h3><p>可用powershell 或linux bash </p>\n<p>命令行如果加post body 会报错</p>\n<p>常用参数：</p>\n<p>-T 表示持续时间</p>\n<p>-c 并行数量</p>\n<p>-n 总的请求</p>\n<p>-m  get,put,post</p>\n<p>–rps 每秒发送请求数</p>\n<p>-P Request body 数据</p>\n<p>-p body 数据存在的文件路径</p>\n<p>-H header 添加</p>\n<p>-C 设置cookie<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">param(</span><br><span class=\"line\">    [int] $iterations = 6000,</span><br><span class=\"line\">    [int] $rps = 500,</span><br><span class=\"line\">    [string][ValidateSet(&quot;plaintext&quot;)] $variation = &quot;plaintext&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">if ($variation -eq &quot;plaintext&quot;)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    $url = &quot;http://wh.etao.cn/auth/test&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Write-Host -ForegroundColor Green Beginning workload</span><br><span class=\"line\">Write-Host &quot;`&amp; loadtest -k -n $iterations -c 100 --rps $rps $url&quot;</span><br><span class=\"line\">Write-Host</span><br><span class=\"line\"></span><br><span class=\"line\">&amp; loadtest -k -n $iterations -c 100 --rps $rps $url</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loadtest -c 5 -t 2 -m post -T &apos;application/json&apos;  -P &apos;&#123;&quot;message&quot;:&quot;hello&quot;&#125;&apos;  -H &quot;Accept: application/json; q=0.9, application/xml; q=0.6&quot; http://cttest.etao.cn:8011/api/auth/test</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"loadtest-压力测试\"><a href=\"#loadtest-压力测试\" class=\"headerlink\" title=\"loadtest 压力测试\"></a>loadtest 压力测试</h3><p>可用powershell 或linux bash </p>\n<p>命令行如果加post body 会报错</p>\n<p>常用参数：</p>\n<p>-T 表示持续时间</p>\n<p>-c 并行数量</p>\n<p>-n 总的请求</p>\n<p>-m  get,put,post</p>\n<p>–rps 每秒发送请求数</p>\n<p>-P Request body 数据</p>\n<p>-p body 数据存在的文件路径</p>\n<p>-H header 添加</p>\n<p>-C 设置cookie<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">param(</span><br><span class=\"line\">    [int] $iterations = 6000,</span><br><span class=\"line\">    [int] $rps = 500,</span><br><span class=\"line\">    [string][ValidateSet(&quot;plaintext&quot;)] $variation = &quot;plaintext&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">if ($variation -eq &quot;plaintext&quot;)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    $url = &quot;http://wh.etao.cn/auth/test&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Write-Host -ForegroundColor Green Beginning workload</span><br><span class=\"line\">Write-Host &quot;`&amp; loadtest -k -n $iterations -c 100 --rps $rps $url&quot;</span><br><span class=\"line\">Write-Host</span><br><span class=\"line\"></span><br><span class=\"line\">&amp; loadtest -k -n $iterations -c 100 --rps $rps $url</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loadtest -c 5 -t 2 -m post -T &apos;application/json&apos;  -P &apos;&#123;&quot;message&quot;:&quot;hello&quot;&#125;&apos;  -H &quot;Accept: application/json; q=0.9, application/xml; q=0.6&quot; http://cttest.etao.cn:8011/api/auth/test</span><br></pre></td></tr></table></figure>\n"},{"title":"linux","date":"2019-07-02T03:39:34.000Z","_content":"\n### vim\n\n","source":"_posts/linux.md","raw":"---\ntitle: linux\ndate: 2019-07-02 11:39:34\ntags: ops\n---\n\n### vim\n\n","slug":"linux","published":1,"updated":"2019-07-26T08:35:17.305Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2fu41zr000pf18soiigrxrx","content":"<h3 id=\"vim\"><a href=\"#vim\" class=\"headerlink\" title=\"vim\"></a>vim</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"vim\"><a href=\"#vim\" class=\"headerlink\" title=\"vim\"></a>vim</h3>"},{"title":"pattern","date":"2016-12-26T06:05:38.000Z","_content":"##  装饰模式\n\n```\n'use strict';\nclass Sale {\n  constructor(price) {\n    [this.decoratorsList, this.price] = [[], price];\n  }\n\n  decorate(decorator) {\n    if (!Sale[decorator]) throw new Error(`decorator not exist: ${decorator}`);\n    this.decoratorsList.push(Sale[decorator]);\n  }\n\n  getPrice() {\n    for (let decorator of this.decoratorsList) {\n      this.price = decorator(this.price);\n    }\n    return this.price.toFixed(2);\n  }\n\n  static quebec(price) {\n    return price + price * 7.5 / 100;\n  }\n\n  static fedtax(price) {\n    return price + price * 5 / 100;\n  }\n}\nmodule.exports=Sale;\n```\n\n## 工厂模式\n\n\n```\n \n'use strict';\nclass CarMaker {\n  constructor() {\n    this.doors = 0;\n  }\n\n  drive() {\n    console.log(`jaja, i have ${this.doors} doors`);\n  }\n\n  static factory(type) {\n    return new CarMaker[type]();\n  }\n}\n\nCarMaker.Compact = class Compact extends CarMaker {\n  constructor() {\n    super();\n    this.doors = 4;\n  }\n};\n\nmodule.exports=CarMaker;\n\n```\n\n## 策略模式 --自行脑补\n## 单例模式\n\n\n```\n'use strict';\nlet __instance = function () {\n  let instance;\n  return (newInstance) => {\n    if (newInstance) instance = newInstance;\n    return instance;\n  }\n}();\n\nclass Universe {\n  constructor() {\n    if (__instance()) return __instance();\n    __instance(this);\n  }\n}\nmodule.exports=Universe;\n\n```\n\n##订阅者模式\n\n\n```\n/**\n * Created by ryan on 2016/8/29.\n */\n'use strict';\nclass Event {\n  constructor() {\n    this.subscribers = new Map([['any', []]]);\n  }\n\n  on(fn, type = 'any') {\n    let subs = this.subscribers;\n    if (!subs.get(type)) return subs.set(type, [fn]);\n    subs.set(type, (subs.get(type).push(fn)));\n  }\n\n  emit(content, type = 'any') {\n    for (let fn of this.subscribers.get(type)) {\n      fn(content);\n    }\n  }\n}\n\nlet event = new Event();\n\nevent.on((content) => console.log(`get published content: ${content}`), 'myEvent');\nevent.emit('jaja', 'myEvent'); //get published content: jaja\n\n```\n","source":"_posts/pattern.md","raw":"---\ntitle: pattern\ndate: 2016-12-26 14:05:38\ntags: pattern\n---\n##  装饰模式\n\n```\n'use strict';\nclass Sale {\n  constructor(price) {\n    [this.decoratorsList, this.price] = [[], price];\n  }\n\n  decorate(decorator) {\n    if (!Sale[decorator]) throw new Error(`decorator not exist: ${decorator}`);\n    this.decoratorsList.push(Sale[decorator]);\n  }\n\n  getPrice() {\n    for (let decorator of this.decoratorsList) {\n      this.price = decorator(this.price);\n    }\n    return this.price.toFixed(2);\n  }\n\n  static quebec(price) {\n    return price + price * 7.5 / 100;\n  }\n\n  static fedtax(price) {\n    return price + price * 5 / 100;\n  }\n}\nmodule.exports=Sale;\n```\n\n## 工厂模式\n\n\n```\n \n'use strict';\nclass CarMaker {\n  constructor() {\n    this.doors = 0;\n  }\n\n  drive() {\n    console.log(`jaja, i have ${this.doors} doors`);\n  }\n\n  static factory(type) {\n    return new CarMaker[type]();\n  }\n}\n\nCarMaker.Compact = class Compact extends CarMaker {\n  constructor() {\n    super();\n    this.doors = 4;\n  }\n};\n\nmodule.exports=CarMaker;\n\n```\n\n## 策略模式 --自行脑补\n## 单例模式\n\n\n```\n'use strict';\nlet __instance = function () {\n  let instance;\n  return (newInstance) => {\n    if (newInstance) instance = newInstance;\n    return instance;\n  }\n}();\n\nclass Universe {\n  constructor() {\n    if (__instance()) return __instance();\n    __instance(this);\n  }\n}\nmodule.exports=Universe;\n\n```\n\n##订阅者模式\n\n\n```\n/**\n * Created by ryan on 2016/8/29.\n */\n'use strict';\nclass Event {\n  constructor() {\n    this.subscribers = new Map([['any', []]]);\n  }\n\n  on(fn, type = 'any') {\n    let subs = this.subscribers;\n    if (!subs.get(type)) return subs.set(type, [fn]);\n    subs.set(type, (subs.get(type).push(fn)));\n  }\n\n  emit(content, type = 'any') {\n    for (let fn of this.subscribers.get(type)) {\n      fn(content);\n    }\n  }\n}\n\nlet event = new Event();\n\nevent.on((content) => console.log(`get published content: ${content}`), 'myEvent');\nevent.emit('jaja', 'myEvent'); //get published content: jaja\n\n```\n","slug":"pattern","published":1,"updated":"2019-07-26T08:35:17.308Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2fu41zt000sf18sjkoiggge","content":"<h2 id=\"装饰模式\"><a href=\"#装饰模式\" class=\"headerlink\" title=\"装饰模式\"></a>装饰模式</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;use strict&apos;;</span><br><span class=\"line\">class Sale &#123;</span><br><span class=\"line\">  constructor(price) &#123;</span><br><span class=\"line\">    [this.decoratorsList, this.price] = [[], price];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  decorate(decorator) &#123;</span><br><span class=\"line\">    if (!Sale[decorator]) throw new Error(`decorator not exist: $&#123;decorator&#125;`);</span><br><span class=\"line\">    this.decoratorsList.push(Sale[decorator]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  getPrice() &#123;</span><br><span class=\"line\">    for (let decorator of this.decoratorsList) &#123;</span><br><span class=\"line\">      this.price = decorator(this.price);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return this.price.toFixed(2);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  static quebec(price) &#123;</span><br><span class=\"line\">    return price + price * 7.5 / 100;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  static fedtax(price) &#123;</span><br><span class=\"line\">    return price + price * 5 / 100;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">module.exports=Sale;</span><br></pre></td></tr></table></figure>\n<h2 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> </span><br><span class=\"line\">&apos;use strict&apos;;</span><br><span class=\"line\">class CarMaker &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    this.doors = 0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  drive() &#123;</span><br><span class=\"line\">    console.log(`jaja, i have $&#123;this.doors&#125; doors`);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  static factory(type) &#123;</span><br><span class=\"line\">    return new CarMaker[type]();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">CarMaker.Compact = class Compact extends CarMaker &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    super();</span><br><span class=\"line\">    this.doors = 4;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports=CarMaker;</span><br></pre></td></tr></table></figure>\n<h2 id=\"策略模式-–自行脑补\"><a href=\"#策略模式-–自行脑补\" class=\"headerlink\" title=\"策略模式 –自行脑补\"></a>策略模式 –自行脑补</h2><h2 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;use strict&apos;;</span><br><span class=\"line\">let __instance = function () &#123;</span><br><span class=\"line\">  let instance;</span><br><span class=\"line\">  return (newInstance) =&gt; &#123;</span><br><span class=\"line\">    if (newInstance) instance = newInstance;</span><br><span class=\"line\">    return instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;();</span><br><span class=\"line\"></span><br><span class=\"line\">class Universe &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    if (__instance()) return __instance();</span><br><span class=\"line\">    __instance(this);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">module.exports=Universe;</span><br></pre></td></tr></table></figure>\n<p>##订阅者模式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Created by ryan on 2016/8/29.</span><br><span class=\"line\"> */</span><br><span class=\"line\">&apos;use strict&apos;;</span><br><span class=\"line\">class Event &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    this.subscribers = new Map([[&apos;any&apos;, []]]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  on(fn, type = &apos;any&apos;) &#123;</span><br><span class=\"line\">    let subs = this.subscribers;</span><br><span class=\"line\">    if (!subs.get(type)) return subs.set(type, [fn]);</span><br><span class=\"line\">    subs.set(type, (subs.get(type).push(fn)));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  emit(content, type = &apos;any&apos;) &#123;</span><br><span class=\"line\">    for (let fn of this.subscribers.get(type)) &#123;</span><br><span class=\"line\">      fn(content);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let event = new Event();</span><br><span class=\"line\"></span><br><span class=\"line\">event.on((content) =&gt; console.log(`get published content: $&#123;content&#125;`), &apos;myEvent&apos;);</span><br><span class=\"line\">event.emit(&apos;jaja&apos;, &apos;myEvent&apos;); //get published content: jaja</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"装饰模式\"><a href=\"#装饰模式\" class=\"headerlink\" title=\"装饰模式\"></a>装饰模式</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;use strict&apos;;</span><br><span class=\"line\">class Sale &#123;</span><br><span class=\"line\">  constructor(price) &#123;</span><br><span class=\"line\">    [this.decoratorsList, this.price] = [[], price];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  decorate(decorator) &#123;</span><br><span class=\"line\">    if (!Sale[decorator]) throw new Error(`decorator not exist: $&#123;decorator&#125;`);</span><br><span class=\"line\">    this.decoratorsList.push(Sale[decorator]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  getPrice() &#123;</span><br><span class=\"line\">    for (let decorator of this.decoratorsList) &#123;</span><br><span class=\"line\">      this.price = decorator(this.price);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return this.price.toFixed(2);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  static quebec(price) &#123;</span><br><span class=\"line\">    return price + price * 7.5 / 100;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  static fedtax(price) &#123;</span><br><span class=\"line\">    return price + price * 5 / 100;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">module.exports=Sale;</span><br></pre></td></tr></table></figure>\n<h2 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> </span><br><span class=\"line\">&apos;use strict&apos;;</span><br><span class=\"line\">class CarMaker &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    this.doors = 0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  drive() &#123;</span><br><span class=\"line\">    console.log(`jaja, i have $&#123;this.doors&#125; doors`);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  static factory(type) &#123;</span><br><span class=\"line\">    return new CarMaker[type]();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">CarMaker.Compact = class Compact extends CarMaker &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    super();</span><br><span class=\"line\">    this.doors = 4;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports=CarMaker;</span><br></pre></td></tr></table></figure>\n<h2 id=\"策略模式-–自行脑补\"><a href=\"#策略模式-–自行脑补\" class=\"headerlink\" title=\"策略模式 –自行脑补\"></a>策略模式 –自行脑补</h2><h2 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;use strict&apos;;</span><br><span class=\"line\">let __instance = function () &#123;</span><br><span class=\"line\">  let instance;</span><br><span class=\"line\">  return (newInstance) =&gt; &#123;</span><br><span class=\"line\">    if (newInstance) instance = newInstance;</span><br><span class=\"line\">    return instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;();</span><br><span class=\"line\"></span><br><span class=\"line\">class Universe &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    if (__instance()) return __instance();</span><br><span class=\"line\">    __instance(this);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">module.exports=Universe;</span><br></pre></td></tr></table></figure>\n<p>##订阅者模式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Created by ryan on 2016/8/29.</span><br><span class=\"line\"> */</span><br><span class=\"line\">&apos;use strict&apos;;</span><br><span class=\"line\">class Event &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    this.subscribers = new Map([[&apos;any&apos;, []]]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  on(fn, type = &apos;any&apos;) &#123;</span><br><span class=\"line\">    let subs = this.subscribers;</span><br><span class=\"line\">    if (!subs.get(type)) return subs.set(type, [fn]);</span><br><span class=\"line\">    subs.set(type, (subs.get(type).push(fn)));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  emit(content, type = &apos;any&apos;) &#123;</span><br><span class=\"line\">    for (let fn of this.subscribers.get(type)) &#123;</span><br><span class=\"line\">      fn(content);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let event = new Event();</span><br><span class=\"line\"></span><br><span class=\"line\">event.on((content) =&gt; console.log(`get published content: $&#123;content&#125;`), &apos;myEvent&apos;);</span><br><span class=\"line\">event.emit(&apos;jaja&apos;, &apos;myEvent&apos;); //get published content: jaja</span><br></pre></td></tr></table></figure>\n"},{"title":"pm2","date":"2016-12-29T09:53:39.000Z","_content":"### pm2 start 启动文件的设置\n\n1. 通过 pm2 ecosystem 生成文件\n2. 在配置文件中配置，主要参数如下：\n　　\n```\nmin_uptime：最小运行时间，这里设置的是60s即如果应用程序在60s内退出，pm2会认为程序异常退出，此时触发重启max_restarts设置数量\n\nexec_mode：应用程序启动模式，这里设置的是cluster_mode（集群），默认是fork\nerror_file：自定义应用程序的错误日志文件\nout_file：自定义应用程序日志文件\npid_file：自定义应用程序的pid文件\nwatch：是否启用监控模式，默认是false。如果设置成true，当应用程序变动时，pm2会自动重载。这里也可以设置你要监控的文件\n\nexec_interpreter：应用程序的脚本类型，这里使用的shell，默认是nodejs\ndefaults to “node”. can be “python”, “ruby”, “bash” or whatever interpreter you wish to use. “none” will execute your app as a binary executable\n\n当使用babel的时候： exec_interpreter:\"babel-node\"\n \nmax_memory_restart  超出这个内存后会重新启动\n\n```\n\n3. 可以设置watch 的目录\n   \n```\n{\n  \"name\"        : \"fis-receiver\",  // 应用名称\n  \"script\"      : \"./bin/www\",  // 实际启动脚本\n  \"cwd\"         : \"./\",  // 当前工作路径\n  \"watch\": [  // 监控变化的目录，一旦变化，自动重启\n    \"bin\",\n    \"routers\"\n  ],\n  \"ignore_watch\" : [  // 从监控目录中排除\n    \"node_modules\", \n    \"logs\",\n    \"public\"\n  ],\n  \"watch_options\": {\n    \"followSymlinks\": false\n  },\n  \"error_file\" : \"./logs/app-err.log\",  // 错误日志路径\n  \"out_file\"   : \"./logs/app-out.log\",  // 普通日志路径\n  \"env\": {\n      \"NODE_ENV\": \"production\"  // 环境参数，当前指定为生产环境\n  }\n}\n```\n\n","source":"_posts/pm2.md","raw":"---\ntitle: pm2\ndate: 2016-12-29 17:53:39\ntags: pm2 \n---\n### pm2 start 启动文件的设置\n\n1. 通过 pm2 ecosystem 生成文件\n2. 在配置文件中配置，主要参数如下：\n　　\n```\nmin_uptime：最小运行时间，这里设置的是60s即如果应用程序在60s内退出，pm2会认为程序异常退出，此时触发重启max_restarts设置数量\n\nexec_mode：应用程序启动模式，这里设置的是cluster_mode（集群），默认是fork\nerror_file：自定义应用程序的错误日志文件\nout_file：自定义应用程序日志文件\npid_file：自定义应用程序的pid文件\nwatch：是否启用监控模式，默认是false。如果设置成true，当应用程序变动时，pm2会自动重载。这里也可以设置你要监控的文件\n\nexec_interpreter：应用程序的脚本类型，这里使用的shell，默认是nodejs\ndefaults to “node”. can be “python”, “ruby”, “bash” or whatever interpreter you wish to use. “none” will execute your app as a binary executable\n\n当使用babel的时候： exec_interpreter:\"babel-node\"\n \nmax_memory_restart  超出这个内存后会重新启动\n\n```\n\n3. 可以设置watch 的目录\n   \n```\n{\n  \"name\"        : \"fis-receiver\",  // 应用名称\n  \"script\"      : \"./bin/www\",  // 实际启动脚本\n  \"cwd\"         : \"./\",  // 当前工作路径\n  \"watch\": [  // 监控变化的目录，一旦变化，自动重启\n    \"bin\",\n    \"routers\"\n  ],\n  \"ignore_watch\" : [  // 从监控目录中排除\n    \"node_modules\", \n    \"logs\",\n    \"public\"\n  ],\n  \"watch_options\": {\n    \"followSymlinks\": false\n  },\n  \"error_file\" : \"./logs/app-err.log\",  // 错误日志路径\n  \"out_file\"   : \"./logs/app-out.log\",  // 普通日志路径\n  \"env\": {\n      \"NODE_ENV\": \"production\"  // 环境参数，当前指定为生产环境\n  }\n}\n```\n\n","slug":"pm2","published":1,"updated":"2019-07-26T08:35:17.309Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2fu41zu000tf18sn8f17gxb","content":"<h3 id=\"pm2-start-启动文件的设置\"><a href=\"#pm2-start-启动文件的设置\" class=\"headerlink\" title=\"pm2 start 启动文件的设置\"></a>pm2 start 启动文件的设置</h3><ol>\n<li>通过 pm2 ecosystem 生成文件</li>\n<li><p>在配置文件中配置，主要参数如下：\n　　</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">min_uptime：最小运行时间，这里设置的是60s即如果应用程序在60s内退出，pm2会认为程序异常退出，此时触发重启max_restarts设置数量</span><br><span class=\"line\"></span><br><span class=\"line\">exec_mode：应用程序启动模式，这里设置的是cluster_mode（集群），默认是fork</span><br><span class=\"line\">error_file：自定义应用程序的错误日志文件</span><br><span class=\"line\">out_file：自定义应用程序日志文件</span><br><span class=\"line\">pid_file：自定义应用程序的pid文件</span><br><span class=\"line\">watch：是否启用监控模式，默认是false。如果设置成true，当应用程序变动时，pm2会自动重载。这里也可以设置你要监控的文件</span><br><span class=\"line\"></span><br><span class=\"line\">exec_interpreter：应用程序的脚本类型，这里使用的shell，默认是nodejs</span><br><span class=\"line\">defaults to “node”. can be “python”, “ruby”, “bash” or whatever interpreter you wish to use. “none” will execute your app as a binary executable</span><br><span class=\"line\"></span><br><span class=\"line\">当使用babel的时候： exec_interpreter:&quot;babel-node&quot;</span><br><span class=\"line\"> </span><br><span class=\"line\">max_memory_restart  超出这个内存后会重新启动</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>可以设置watch 的目录</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;name&quot;        : &quot;fis-receiver&quot;,  // 应用名称</span><br><span class=\"line\">  &quot;script&quot;      : &quot;./bin/www&quot;,  // 实际启动脚本</span><br><span class=\"line\">  &quot;cwd&quot;         : &quot;./&quot;,  // 当前工作路径</span><br><span class=\"line\">  &quot;watch&quot;: [  // 监控变化的目录，一旦变化，自动重启</span><br><span class=\"line\">    &quot;bin&quot;,</span><br><span class=\"line\">    &quot;routers&quot;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  &quot;ignore_watch&quot; : [  // 从监控目录中排除</span><br><span class=\"line\">    &quot;node_modules&quot;, </span><br><span class=\"line\">    &quot;logs&quot;,</span><br><span class=\"line\">    &quot;public&quot;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  &quot;watch_options&quot;: &#123;</span><br><span class=\"line\">    &quot;followSymlinks&quot;: false</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;error_file&quot; : &quot;./logs/app-err.log&quot;,  // 错误日志路径</span><br><span class=\"line\">  &quot;out_file&quot;   : &quot;./logs/app-out.log&quot;,  // 普通日志路径</span><br><span class=\"line\">  &quot;env&quot;: &#123;</span><br><span class=\"line\">      &quot;NODE_ENV&quot;: &quot;production&quot;  // 环境参数，当前指定为生产环境</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"pm2-start-启动文件的设置\"><a href=\"#pm2-start-启动文件的设置\" class=\"headerlink\" title=\"pm2 start 启动文件的设置\"></a>pm2 start 启动文件的设置</h3><ol>\n<li>通过 pm2 ecosystem 生成文件</li>\n<li><p>在配置文件中配置，主要参数如下：\n　　</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">min_uptime：最小运行时间，这里设置的是60s即如果应用程序在60s内退出，pm2会认为程序异常退出，此时触发重启max_restarts设置数量</span><br><span class=\"line\"></span><br><span class=\"line\">exec_mode：应用程序启动模式，这里设置的是cluster_mode（集群），默认是fork</span><br><span class=\"line\">error_file：自定义应用程序的错误日志文件</span><br><span class=\"line\">out_file：自定义应用程序日志文件</span><br><span class=\"line\">pid_file：自定义应用程序的pid文件</span><br><span class=\"line\">watch：是否启用监控模式，默认是false。如果设置成true，当应用程序变动时，pm2会自动重载。这里也可以设置你要监控的文件</span><br><span class=\"line\"></span><br><span class=\"line\">exec_interpreter：应用程序的脚本类型，这里使用的shell，默认是nodejs</span><br><span class=\"line\">defaults to “node”. can be “python”, “ruby”, “bash” or whatever interpreter you wish to use. “none” will execute your app as a binary executable</span><br><span class=\"line\"></span><br><span class=\"line\">当使用babel的时候： exec_interpreter:&quot;babel-node&quot;</span><br><span class=\"line\"> </span><br><span class=\"line\">max_memory_restart  超出这个内存后会重新启动</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>可以设置watch 的目录</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;name&quot;        : &quot;fis-receiver&quot;,  // 应用名称</span><br><span class=\"line\">  &quot;script&quot;      : &quot;./bin/www&quot;,  // 实际启动脚本</span><br><span class=\"line\">  &quot;cwd&quot;         : &quot;./&quot;,  // 当前工作路径</span><br><span class=\"line\">  &quot;watch&quot;: [  // 监控变化的目录，一旦变化，自动重启</span><br><span class=\"line\">    &quot;bin&quot;,</span><br><span class=\"line\">    &quot;routers&quot;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  &quot;ignore_watch&quot; : [  // 从监控目录中排除</span><br><span class=\"line\">    &quot;node_modules&quot;, </span><br><span class=\"line\">    &quot;logs&quot;,</span><br><span class=\"line\">    &quot;public&quot;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  &quot;watch_options&quot;: &#123;</span><br><span class=\"line\">    &quot;followSymlinks&quot;: false</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;error_file&quot; : &quot;./logs/app-err.log&quot;,  // 错误日志路径</span><br><span class=\"line\">  &quot;out_file&quot;   : &quot;./logs/app-out.log&quot;,  // 普通日志路径</span><br><span class=\"line\">  &quot;env&quot;: &#123;</span><br><span class=\"line\">      &quot;NODE_ENV&quot;: &quot;production&quot;  // 环境参数，当前指定为生产环境</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"postgre","date":"2017-02-21T03:18:37.000Z","_content":"\n```\ndb.many(query, values); // expects one or more rows\ndb.one(query, values); // expects a single row\ndb.none(query, values); // expects no rows\ndb.any(query, values); // expects anything, same as `manyOrNone`\ndb.oneOrNone(query, values); // expects 1 or 0 rows\ndb.manyOrNone(query, values); // expects anything, same as `any`\n```\n\nThe library supports named parameters in query formatting, with the syntax of $*propName*, where * is any of the following open-close pairs: {}, (), <>, [], //\n\n\n```\ndb.query('SELECT * FROM users WHERE name=${name} AND active=$/active/', {\n    name: 'John',\n    active: true\n});\n```\n\nthis 的用法：\n```\nvar doc = {\n    id: 123,\n    body: \"some text\"\n};\n\ndb.none(\"INSERT INTO documents(id, doc) VALUES(${id}, ${this})\", doc)\n    .then(function () {\n        // success;\n    })\n    .catch(function (error) {\n        // error;\n    });\n```\n\nwhich will execute:\n\nINSERT INTO documents(id, doc) VALUES(123, '{\"id\":123,\"body\":\"some text\"}')\n\n\n执行函数\n\nAnd when you are not expecting any return results, call db.proc instead. Both methods return a Promise object, but db.proc doesn't take a qrm parameter, always assuming it is one|none.\n```\ndb.func('findAudit', [123, new Date()])\n    .then(function (data) {\n        console.log(data); // printing the data returned \n    })\n    .catch(function (error) {\n        console.log(error); // printing the error \n    });\ndb.proc();\n```\n\n公用一个连接：\n\n```\ndb.task(function (t) {\n    // `t` and `this` here are the same;\n    // execute a chain of queries;\n})\n    .then(function (data) {\n        // success;\n    })\n    .catch(function (error) {\n        // failed;    \n    });\n```\n\n事物：其中可以嵌套事物\n\n```\ndb.tx(function (t) {\n    // t = this;\n    return t.batch([\n        t.one(\"insert into users(name) values($1) returning id\", \"John\"),\n        t.one(\"insert into events(code) values($1) returning id\", 123)\n    ]);\n})\n    .spread(function (user, event) {\n        // print new user id + new event id;\n        console.log(\"DATA:\", user.id, event.id);\n    })\n    .catch(function (error) {\n        console.log(\"ERROR:\", error); // print the error;\n    })\n    .finally(function () {\n    \n\n        pgp.end(); // for immediate app exit, closing the connection pool.   关闭连接池，是的一般不需要\n        \n        If, however you normally exit your application by killing the NodeJS process, then you don't need to use it.\n\n        \n    });\n```\n\n设置隔离级别：\n\n```\nvar TransactionMode = pgp.txMode.TransactionMode;\nvar isolationLevel = pgp.txMode.isolationLevel;\n\n// Create a reusable transaction mode (serializable + read-only + deferrable):\nvar tmSRD = new TransactionMode({\n    tiLevel: isolationLevel.serializable,\n    readOnly: true,\n    deferrable: true\n});\n\nfunction myTransaction() {\n    return this.query('SELECT * FROM table');\n}\n\nmyTransaction.txMode = tmSRD; // assign transaction mode;\n\ndb.tx(myTransaction)\n    .then(function(){\n        // success;\n    });\n```\n重置promise：\n\n```\nvar promise = require('bluebird');\nvar options = {\n    promiseLib: promise\n};\nvar pgp = require('pg-promise')(options);\n```\n\n","source":"_posts/postgre.md","raw":"---\ntitle: postgre\ndate: 2017-02-21 11:18:37\ntags: postgre\n---\n\n```\ndb.many(query, values); // expects one or more rows\ndb.one(query, values); // expects a single row\ndb.none(query, values); // expects no rows\ndb.any(query, values); // expects anything, same as `manyOrNone`\ndb.oneOrNone(query, values); // expects 1 or 0 rows\ndb.manyOrNone(query, values); // expects anything, same as `any`\n```\n\nThe library supports named parameters in query formatting, with the syntax of $*propName*, where * is any of the following open-close pairs: {}, (), <>, [], //\n\n\n```\ndb.query('SELECT * FROM users WHERE name=${name} AND active=$/active/', {\n    name: 'John',\n    active: true\n});\n```\n\nthis 的用法：\n```\nvar doc = {\n    id: 123,\n    body: \"some text\"\n};\n\ndb.none(\"INSERT INTO documents(id, doc) VALUES(${id}, ${this})\", doc)\n    .then(function () {\n        // success;\n    })\n    .catch(function (error) {\n        // error;\n    });\n```\n\nwhich will execute:\n\nINSERT INTO documents(id, doc) VALUES(123, '{\"id\":123,\"body\":\"some text\"}')\n\n\n执行函数\n\nAnd when you are not expecting any return results, call db.proc instead. Both methods return a Promise object, but db.proc doesn't take a qrm parameter, always assuming it is one|none.\n```\ndb.func('findAudit', [123, new Date()])\n    .then(function (data) {\n        console.log(data); // printing the data returned \n    })\n    .catch(function (error) {\n        console.log(error); // printing the error \n    });\ndb.proc();\n```\n\n公用一个连接：\n\n```\ndb.task(function (t) {\n    // `t` and `this` here are the same;\n    // execute a chain of queries;\n})\n    .then(function (data) {\n        // success;\n    })\n    .catch(function (error) {\n        // failed;    \n    });\n```\n\n事物：其中可以嵌套事物\n\n```\ndb.tx(function (t) {\n    // t = this;\n    return t.batch([\n        t.one(\"insert into users(name) values($1) returning id\", \"John\"),\n        t.one(\"insert into events(code) values($1) returning id\", 123)\n    ]);\n})\n    .spread(function (user, event) {\n        // print new user id + new event id;\n        console.log(\"DATA:\", user.id, event.id);\n    })\n    .catch(function (error) {\n        console.log(\"ERROR:\", error); // print the error;\n    })\n    .finally(function () {\n    \n\n        pgp.end(); // for immediate app exit, closing the connection pool.   关闭连接池，是的一般不需要\n        \n        If, however you normally exit your application by killing the NodeJS process, then you don't need to use it.\n\n        \n    });\n```\n\n设置隔离级别：\n\n```\nvar TransactionMode = pgp.txMode.TransactionMode;\nvar isolationLevel = pgp.txMode.isolationLevel;\n\n// Create a reusable transaction mode (serializable + read-only + deferrable):\nvar tmSRD = new TransactionMode({\n    tiLevel: isolationLevel.serializable,\n    readOnly: true,\n    deferrable: true\n});\n\nfunction myTransaction() {\n    return this.query('SELECT * FROM table');\n}\n\nmyTransaction.txMode = tmSRD; // assign transaction mode;\n\ndb.tx(myTransaction)\n    .then(function(){\n        // success;\n    });\n```\n重置promise：\n\n```\nvar promise = require('bluebird');\nvar options = {\n    promiseLib: promise\n};\nvar pgp = require('pg-promise')(options);\n```\n\n","slug":"postgre","published":1,"updated":"2019-07-26T08:35:17.310Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2fu41zv000wf18swm4gokez","content":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.many(query, values); // expects one or more rows</span><br><span class=\"line\">db.one(query, values); // expects a single row</span><br><span class=\"line\">db.none(query, values); // expects no rows</span><br><span class=\"line\">db.any(query, values); // expects anything, same as `manyOrNone`</span><br><span class=\"line\">db.oneOrNone(query, values); // expects 1 or 0 rows</span><br><span class=\"line\">db.manyOrNone(query, values); // expects anything, same as `any`</span><br></pre></td></tr></table></figure>\n<p>The library supports named parameters in query formatting, with the syntax of $<em>propName</em>, where * is any of the following open-close pairs: {}, (), &lt;&gt;, [], //</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.query(&apos;SELECT * FROM users WHERE name=$&#123;name&#125; AND active=$/active/&apos;, &#123;</span><br><span class=\"line\">    name: &apos;John&apos;,</span><br><span class=\"line\">    active: true</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>this 的用法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var doc = &#123;</span><br><span class=\"line\">    id: 123,</span><br><span class=\"line\">    body: &quot;some text&quot;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">db.none(&quot;INSERT INTO documents(id, doc) VALUES($&#123;id&#125;, $&#123;this&#125;)&quot;, doc)</span><br><span class=\"line\">    .then(function () &#123;</span><br><span class=\"line\">        // success;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .catch(function (error) &#123;</span><br><span class=\"line\">        // error;</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>which will execute:</p>\n<p>INSERT INTO documents(id, doc) VALUES(123, ‘{“id”:123,”body”:”some text”}’)</p>\n<p>执行函数</p>\n<p>And when you are not expecting any return results, call db.proc instead. Both methods return a Promise object, but db.proc doesn’t take a qrm parameter, always assuming it is one|none.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.func(&apos;findAudit&apos;, [123, new Date()])</span><br><span class=\"line\">    .then(function (data) &#123;</span><br><span class=\"line\">        console.log(data); // printing the data returned </span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .catch(function (error) &#123;</span><br><span class=\"line\">        console.log(error); // printing the error </span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">db.proc();</span><br></pre></td></tr></table></figure></p>\n<p>公用一个连接：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.task(function (t) &#123;</span><br><span class=\"line\">    // `t` and `this` here are the same;</span><br><span class=\"line\">    // execute a chain of queries;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">    .then(function (data) &#123;</span><br><span class=\"line\">        // success;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .catch(function (error) &#123;</span><br><span class=\"line\">        // failed;    </span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>事物：其中可以嵌套事物</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.tx(function (t) &#123;</span><br><span class=\"line\">    // t = this;</span><br><span class=\"line\">    return t.batch([</span><br><span class=\"line\">        t.one(&quot;insert into users(name) values($1) returning id&quot;, &quot;John&quot;),</span><br><span class=\"line\">        t.one(&quot;insert into events(code) values($1) returning id&quot;, 123)</span><br><span class=\"line\">    ]);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">    .spread(function (user, event) &#123;</span><br><span class=\"line\">        // print new user id + new event id;</span><br><span class=\"line\">        console.log(&quot;DATA:&quot;, user.id, event.id);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .catch(function (error) &#123;</span><br><span class=\"line\">        console.log(&quot;ERROR:&quot;, error); // print the error;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .finally(function () &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">        pgp.end(); // for immediate app exit, closing the connection pool.   关闭连接池，是的一般不需要</span><br><span class=\"line\">        </span><br><span class=\"line\">        If, however you normally exit your application by killing the NodeJS process, then you don&apos;t need to use it.</span><br><span class=\"line\"></span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>设置隔离级别：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var TransactionMode = pgp.txMode.TransactionMode;</span><br><span class=\"line\">var isolationLevel = pgp.txMode.isolationLevel;</span><br><span class=\"line\"></span><br><span class=\"line\">// Create a reusable transaction mode (serializable + read-only + deferrable):</span><br><span class=\"line\">var tmSRD = new TransactionMode(&#123;</span><br><span class=\"line\">    tiLevel: isolationLevel.serializable,</span><br><span class=\"line\">    readOnly: true,</span><br><span class=\"line\">    deferrable: true</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">function myTransaction() &#123;</span><br><span class=\"line\">    return this.query(&apos;SELECT * FROM table&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">myTransaction.txMode = tmSRD; // assign transaction mode;</span><br><span class=\"line\"></span><br><span class=\"line\">db.tx(myTransaction)</span><br><span class=\"line\">    .then(function()&#123;</span><br><span class=\"line\">        // success;</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>重置promise：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var promise = require(&apos;bluebird&apos;);</span><br><span class=\"line\">var options = &#123;</span><br><span class=\"line\">    promiseLib: promise</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var pgp = require(&apos;pg-promise&apos;)(options);</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.many(query, values); // expects one or more rows</span><br><span class=\"line\">db.one(query, values); // expects a single row</span><br><span class=\"line\">db.none(query, values); // expects no rows</span><br><span class=\"line\">db.any(query, values); // expects anything, same as `manyOrNone`</span><br><span class=\"line\">db.oneOrNone(query, values); // expects 1 or 0 rows</span><br><span class=\"line\">db.manyOrNone(query, values); // expects anything, same as `any`</span><br></pre></td></tr></table></figure>\n<p>The library supports named parameters in query formatting, with the syntax of $<em>propName</em>, where * is any of the following open-close pairs: {}, (), &lt;&gt;, [], //</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.query(&apos;SELECT * FROM users WHERE name=$&#123;name&#125; AND active=$/active/&apos;, &#123;</span><br><span class=\"line\">    name: &apos;John&apos;,</span><br><span class=\"line\">    active: true</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>this 的用法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var doc = &#123;</span><br><span class=\"line\">    id: 123,</span><br><span class=\"line\">    body: &quot;some text&quot;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">db.none(&quot;INSERT INTO documents(id, doc) VALUES($&#123;id&#125;, $&#123;this&#125;)&quot;, doc)</span><br><span class=\"line\">    .then(function () &#123;</span><br><span class=\"line\">        // success;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .catch(function (error) &#123;</span><br><span class=\"line\">        // error;</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>which will execute:</p>\n<p>INSERT INTO documents(id, doc) VALUES(123, ‘{“id”:123,”body”:”some text”}’)</p>\n<p>执行函数</p>\n<p>And when you are not expecting any return results, call db.proc instead. Both methods return a Promise object, but db.proc doesn’t take a qrm parameter, always assuming it is one|none.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.func(&apos;findAudit&apos;, [123, new Date()])</span><br><span class=\"line\">    .then(function (data) &#123;</span><br><span class=\"line\">        console.log(data); // printing the data returned </span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .catch(function (error) &#123;</span><br><span class=\"line\">        console.log(error); // printing the error </span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">db.proc();</span><br></pre></td></tr></table></figure></p>\n<p>公用一个连接：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.task(function (t) &#123;</span><br><span class=\"line\">    // `t` and `this` here are the same;</span><br><span class=\"line\">    // execute a chain of queries;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">    .then(function (data) &#123;</span><br><span class=\"line\">        // success;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .catch(function (error) &#123;</span><br><span class=\"line\">        // failed;    </span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>事物：其中可以嵌套事物</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.tx(function (t) &#123;</span><br><span class=\"line\">    // t = this;</span><br><span class=\"line\">    return t.batch([</span><br><span class=\"line\">        t.one(&quot;insert into users(name) values($1) returning id&quot;, &quot;John&quot;),</span><br><span class=\"line\">        t.one(&quot;insert into events(code) values($1) returning id&quot;, 123)</span><br><span class=\"line\">    ]);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">    .spread(function (user, event) &#123;</span><br><span class=\"line\">        // print new user id + new event id;</span><br><span class=\"line\">        console.log(&quot;DATA:&quot;, user.id, event.id);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .catch(function (error) &#123;</span><br><span class=\"line\">        console.log(&quot;ERROR:&quot;, error); // print the error;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .finally(function () &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">        pgp.end(); // for immediate app exit, closing the connection pool.   关闭连接池，是的一般不需要</span><br><span class=\"line\">        </span><br><span class=\"line\">        If, however you normally exit your application by killing the NodeJS process, then you don&apos;t need to use it.</span><br><span class=\"line\"></span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>设置隔离级别：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var TransactionMode = pgp.txMode.TransactionMode;</span><br><span class=\"line\">var isolationLevel = pgp.txMode.isolationLevel;</span><br><span class=\"line\"></span><br><span class=\"line\">// Create a reusable transaction mode (serializable + read-only + deferrable):</span><br><span class=\"line\">var tmSRD = new TransactionMode(&#123;</span><br><span class=\"line\">    tiLevel: isolationLevel.serializable,</span><br><span class=\"line\">    readOnly: true,</span><br><span class=\"line\">    deferrable: true</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">function myTransaction() &#123;</span><br><span class=\"line\">    return this.query(&apos;SELECT * FROM table&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">myTransaction.txMode = tmSRD; // assign transaction mode;</span><br><span class=\"line\"></span><br><span class=\"line\">db.tx(myTransaction)</span><br><span class=\"line\">    .then(function()&#123;</span><br><span class=\"line\">        // success;</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>重置promise：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var promise = require(&apos;bluebird&apos;);</span><br><span class=\"line\">var options = &#123;</span><br><span class=\"line\">    promiseLib: promise</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var pgp = require(&apos;pg-promise&apos;)(options);</span><br></pre></td></tr></table></figure>\n"},{"title":"package","date":"2019-02-14T09:19:12.000Z","_content":"\n1. Opn: A better node-open. Opens stuff like websites, files, executables. Cross-platform.\n2. Ora:进度条和文字。\n3. joi：数据验\n4. satisfies ：版本工具\n5. minimist：简单的参数处理\n6. read-pkg:规范化解析pkg\n7. inquirer:询问时可以给出选项\n8. Resovel:解析包的安装路径\n9. slash:Convert Windows backslash paths to slash paths: foo\\\\bar ➔ foo/bar\n1. klaw-sync:回遍历出所有文件，并返回文件路径和文件夹\n1. mime-types content-type 工具：1. 可以根据文件后缀获取 2. 根据content-type获取charset 3. 根据content-type 获取默认的文件名\n1. CodeMirror是一个运行在浏览器中的在线代码编辑器，支持100多种语言，高度可定制。\n1. @typescript-eslint/eslint-plugin.  eslint 检测typescript \n1. nanoid  A tiny, secure, URL-friendly, unique string ID generator for JavaScript.\n1. mm 对mudule 中的方法mock\n1. numerify  用来格式化数字 \n   \n1. utils-lite  前端提供debounce、thorttling、clone、cloneDeep 等方法\n1. is-type-of   node check 数据类型\n1. on-finished  Execute a callback when a HTTP request closes, finishes, or errors\n1. await-event  封装了promise \n```javascript\nvar PassThrough = require('stream').PassThrough\n \nvar stream = new PassThrough()\n// you attach it directly on an event emitter\nstream.await = require('await-event')\n \nco(function* () {\n  var chunk = yield stream.await('data')\n  var chunk = yield stream.await('data')\n  var chunk = yield stream.await('data')\n}).catch(noop)\n \nstream.write('some chunk’) \n```\n1. get-ready  NodeJS mixin to add one-time ready event\n1. ShellJS 是Unix shell命令在Node.js API上的可移植实现\n1. graceful-process   graceful exit process even parent exit on SIGKILL.\n1. semver.gte(process.version, '7.0.0’)  版本的比对 \n1. pkgfiles  自动再package中添加 npm publish 文件\n1. depd  标注方法deprecating \n1. http-errors   http错误  \n1. Global-tunnel  http请求的全局代理  \n1. humanize-ms  转义为ms  \n```\ntransform humanize time to ms  ms('1s') // 1000\nms(1000) // 1000\n```\n1. Exceljs 一个功能强大的excel 处理包\n1. ready-callback 所有注册的事件完成后，才执行ready中方法\n1. Get-ready  NodeJS mixin to add one-time ready event，ready 后执行相关方法\n1. xml2js  将xml 转换为json \n1. debug  调试状态输出  debug=*  debug=work:*   \n1. delegates  node模块中代理proto中属性的方法、setter和getter\n1. chokidar filewatch \n1. Puppeteer  headless browser\n1. cross-env Run scripts that set and use environment variables across platforms\n1. simplemde  markdown editor \n1. serialize-javascript  Serialize JavaScript to a superset of JSON that includes regular expressions and functions.\n1.route-cache  express router cache\n```javascript\nvar routeCache = require('route-cache');\n \n// cache route for 20 seconds\napp.get('/index', routeCache.cacheSeconds(20), function(req, res){\n  // do your dirty work here...\n  console.log('you will only see this every 20 seconds.');\n  res.send('this response will be cached');\n});\n```\n1. Ws server 端的websoket \n1. fastclick  解决浏览器点击的延迟\n1. Qs  A querystring parsing and stringifying library with some added security.\n1. lru-cache  A cache object that deletes the least-recently-used items.\n1. memory-fs  A simple in-memory filesystem. Holds data in a javascript object\n1. faker.js  generate massive amounts of fake data in the browser and node.js\n1. parseurl 等同node url parse，加了cache\n1. vue-lazy-component   Vue.js 2.x 组件级懒加载方案-Vue.js 2.x component level lazy loading solution\n1. async-validator  数据验证\n1. fast-safe-stringify    Safe and fast serialization alternative to JSON.stringify.\n1. node-notifier   Send cross platform native notifications using Node.js.","source":"_posts/package.md","raw":"---\ntitle: package\ndate: 2019-02-14 17:19:12\ntags: useful package\n---\n\n1. Opn: A better node-open. Opens stuff like websites, files, executables. Cross-platform.\n2. Ora:进度条和文字。\n3. joi：数据验\n4. satisfies ：版本工具\n5. minimist：简单的参数处理\n6. read-pkg:规范化解析pkg\n7. inquirer:询问时可以给出选项\n8. Resovel:解析包的安装路径\n9. slash:Convert Windows backslash paths to slash paths: foo\\\\bar ➔ foo/bar\n1. klaw-sync:回遍历出所有文件，并返回文件路径和文件夹\n1. mime-types content-type 工具：1. 可以根据文件后缀获取 2. 根据content-type获取charset 3. 根据content-type 获取默认的文件名\n1. CodeMirror是一个运行在浏览器中的在线代码编辑器，支持100多种语言，高度可定制。\n1. @typescript-eslint/eslint-plugin.  eslint 检测typescript \n1. nanoid  A tiny, secure, URL-friendly, unique string ID generator for JavaScript.\n1. mm 对mudule 中的方法mock\n1. numerify  用来格式化数字 \n   \n1. utils-lite  前端提供debounce、thorttling、clone、cloneDeep 等方法\n1. is-type-of   node check 数据类型\n1. on-finished  Execute a callback when a HTTP request closes, finishes, or errors\n1. await-event  封装了promise \n```javascript\nvar PassThrough = require('stream').PassThrough\n \nvar stream = new PassThrough()\n// you attach it directly on an event emitter\nstream.await = require('await-event')\n \nco(function* () {\n  var chunk = yield stream.await('data')\n  var chunk = yield stream.await('data')\n  var chunk = yield stream.await('data')\n}).catch(noop)\n \nstream.write('some chunk’) \n```\n1. get-ready  NodeJS mixin to add one-time ready event\n1. ShellJS 是Unix shell命令在Node.js API上的可移植实现\n1. graceful-process   graceful exit process even parent exit on SIGKILL.\n1. semver.gte(process.version, '7.0.0’)  版本的比对 \n1. pkgfiles  自动再package中添加 npm publish 文件\n1. depd  标注方法deprecating \n1. http-errors   http错误  \n1. Global-tunnel  http请求的全局代理  \n1. humanize-ms  转义为ms  \n```\ntransform humanize time to ms  ms('1s') // 1000\nms(1000) // 1000\n```\n1. Exceljs 一个功能强大的excel 处理包\n1. ready-callback 所有注册的事件完成后，才执行ready中方法\n1. Get-ready  NodeJS mixin to add one-time ready event，ready 后执行相关方法\n1. xml2js  将xml 转换为json \n1. debug  调试状态输出  debug=*  debug=work:*   \n1. delegates  node模块中代理proto中属性的方法、setter和getter\n1. chokidar filewatch \n1. Puppeteer  headless browser\n1. cross-env Run scripts that set and use environment variables across platforms\n1. simplemde  markdown editor \n1. serialize-javascript  Serialize JavaScript to a superset of JSON that includes regular expressions and functions.\n1.route-cache  express router cache\n```javascript\nvar routeCache = require('route-cache');\n \n// cache route for 20 seconds\napp.get('/index', routeCache.cacheSeconds(20), function(req, res){\n  // do your dirty work here...\n  console.log('you will only see this every 20 seconds.');\n  res.send('this response will be cached');\n});\n```\n1. Ws server 端的websoket \n1. fastclick  解决浏览器点击的延迟\n1. Qs  A querystring parsing and stringifying library with some added security.\n1. lru-cache  A cache object that deletes the least-recently-used items.\n1. memory-fs  A simple in-memory filesystem. Holds data in a javascript object\n1. faker.js  generate massive amounts of fake data in the browser and node.js\n1. parseurl 等同node url parse，加了cache\n1. vue-lazy-component   Vue.js 2.x 组件级懒加载方案-Vue.js 2.x component level lazy loading solution\n1. async-validator  数据验证\n1. fast-safe-stringify    Safe and fast serialization alternative to JSON.stringify.\n1. node-notifier   Send cross platform native notifications using Node.js.","slug":"package","published":1,"updated":"2019-10-22T02:28:35.947Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2fu41zw000xf18sjgib5w60","content":"<ol>\n<li>Opn: A better node-open. Opens stuff like websites, files, executables. Cross-platform.</li>\n<li>Ora:进度条和文字。</li>\n<li>joi：数据验</li>\n<li>satisfies ：版本工具</li>\n<li>minimist：简单的参数处理</li>\n<li>read-pkg:规范化解析pkg</li>\n<li>inquirer:询问时可以给出选项</li>\n<li>Resovel:解析包的安装路径</li>\n<li>slash:Convert Windows backslash paths to slash paths: foo\\bar ➔ foo/bar</li>\n<li>klaw-sync:回遍历出所有文件，并返回文件路径和文件夹</li>\n<li>mime-types content-type 工具：1. 可以根据文件后缀获取 2. 根据content-type获取charset 3. 根据content-type 获取默认的文件名</li>\n<li>CodeMirror是一个运行在浏览器中的在线代码编辑器，支持100多种语言，高度可定制。</li>\n<li>@typescript-eslint/eslint-plugin.  eslint 检测typescript </li>\n<li>nanoid  A tiny, secure, URL-friendly, unique string ID generator for JavaScript.</li>\n<li>mm 对mudule 中的方法mock</li>\n<li><p>numerify  用来格式化数字 </p>\n</li>\n<li><p>utils-lite  前端提供debounce、thorttling、clone、cloneDeep 等方法</p>\n</li>\n<li>is-type-of   node check 数据类型</li>\n<li>on-finished  Execute a callback when a HTTP request closes, finishes, or errors</li>\n<li><p>await-event  封装了promise </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> PassThrough = <span class=\"built_in\">require</span>(<span class=\"string\">'stream'</span>).PassThrough</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">var</span> stream = <span class=\"keyword\">new</span> PassThrough()</span><br><span class=\"line\"><span class=\"comment\">// you attach it directly on an event emitter</span></span><br><span class=\"line\">stream.await = <span class=\"built_in\">require</span>(<span class=\"string\">'await-event'</span>)</span><br><span class=\"line\"> </span><br><span class=\"line\">co(<span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> chunk = <span class=\"keyword\">yield</span> stream.await(<span class=\"string\">'data'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> chunk = <span class=\"keyword\">yield</span> stream.await(<span class=\"string\">'data'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> chunk = <span class=\"keyword\">yield</span> stream.await(<span class=\"string\">'data'</span>)</span><br><span class=\"line\">&#125;).catch(noop)</span><br><span class=\"line\"> </span><br><span class=\"line\">stream.write(<span class=\"string\">'some chunk’)</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>get-ready  NodeJS mixin to add one-time ready event</p>\n</li>\n<li>ShellJS 是Unix shell命令在Node.js API上的可移植实现</li>\n<li>graceful-process   graceful exit process even parent exit on SIGKILL.</li>\n<li>semver.gte(process.version, ‘7.0.0’)  版本的比对 </li>\n<li>pkgfiles  自动再package中添加 npm publish 文件</li>\n<li>depd  标注方法deprecating </li>\n<li>http-errors   http错误  </li>\n<li>Global-tunnel  http请求的全局代理  </li>\n<li><p>humanize-ms  转义为ms  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">transform humanize time to ms  ms(&apos;1s&apos;) // 1000</span><br><span class=\"line\">ms(1000) // 1000</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Exceljs 一个功能强大的excel 处理包</p>\n</li>\n<li>ready-callback 所有注册的事件完成后，才执行ready中方法</li>\n<li>Get-ready  NodeJS mixin to add one-time ready event，ready 后执行相关方法</li>\n<li>xml2js  将xml 转换为json </li>\n<li>debug  调试状态输出  debug=<em>  debug=work:</em>   </li>\n<li>delegates  node模块中代理proto中属性的方法、setter和getter</li>\n<li>chokidar filewatch </li>\n<li>Puppeteer  headless browser</li>\n<li>cross-env Run scripts that set and use environment variables across platforms</li>\n<li>simplemde  markdown editor </li>\n<li><p>serialize-javascript  Serialize JavaScript to a superset of JSON that includes regular expressions and functions.<br>1.route-cache  express router cache</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> routeCache = <span class=\"built_in\">require</span>(<span class=\"string\">'route-cache'</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// cache route for 20 seconds</span></span><br><span class=\"line\">app.get(<span class=\"string\">'/index'</span>, routeCache.cacheSeconds(<span class=\"number\">20</span>), <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// do your dirty work here...</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'you will only see this every 20 seconds.'</span>);</span><br><span class=\"line\">  res.send(<span class=\"string\">'this response will be cached'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Ws server 端的websoket </p>\n</li>\n<li>fastclick  解决浏览器点击的延迟</li>\n<li>Qs  A querystring parsing and stringifying library with some added security.</li>\n<li>lru-cache  A cache object that deletes the least-recently-used items.</li>\n<li>memory-fs  A simple in-memory filesystem. Holds data in a javascript object</li>\n<li>faker.js  generate massive amounts of fake data in the browser and node.js</li>\n<li>parseurl 等同node url parse，加了cache</li>\n<li>vue-lazy-component   Vue.js 2.x 组件级懒加载方案-Vue.js 2.x component level lazy loading solution</li>\n<li>async-validator  数据验证</li>\n<li>fast-safe-stringify    Safe and fast serialization alternative to JSON.stringify.</li>\n<li>node-notifier   Send cross platform native notifications using Node.js.</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>Opn: A better node-open. Opens stuff like websites, files, executables. Cross-platform.</li>\n<li>Ora:进度条和文字。</li>\n<li>joi：数据验</li>\n<li>satisfies ：版本工具</li>\n<li>minimist：简单的参数处理</li>\n<li>read-pkg:规范化解析pkg</li>\n<li>inquirer:询问时可以给出选项</li>\n<li>Resovel:解析包的安装路径</li>\n<li>slash:Convert Windows backslash paths to slash paths: foo\\bar ➔ foo/bar</li>\n<li>klaw-sync:回遍历出所有文件，并返回文件路径和文件夹</li>\n<li>mime-types content-type 工具：1. 可以根据文件后缀获取 2. 根据content-type获取charset 3. 根据content-type 获取默认的文件名</li>\n<li>CodeMirror是一个运行在浏览器中的在线代码编辑器，支持100多种语言，高度可定制。</li>\n<li>@typescript-eslint/eslint-plugin.  eslint 检测typescript </li>\n<li>nanoid  A tiny, secure, URL-friendly, unique string ID generator for JavaScript.</li>\n<li>mm 对mudule 中的方法mock</li>\n<li><p>numerify  用来格式化数字 </p>\n</li>\n<li><p>utils-lite  前端提供debounce、thorttling、clone、cloneDeep 等方法</p>\n</li>\n<li>is-type-of   node check 数据类型</li>\n<li>on-finished  Execute a callback when a HTTP request closes, finishes, or errors</li>\n<li><p>await-event  封装了promise </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> PassThrough = <span class=\"built_in\">require</span>(<span class=\"string\">'stream'</span>).PassThrough</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">var</span> stream = <span class=\"keyword\">new</span> PassThrough()</span><br><span class=\"line\"><span class=\"comment\">// you attach it directly on an event emitter</span></span><br><span class=\"line\">stream.await = <span class=\"built_in\">require</span>(<span class=\"string\">'await-event'</span>)</span><br><span class=\"line\"> </span><br><span class=\"line\">co(<span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> chunk = <span class=\"keyword\">yield</span> stream.await(<span class=\"string\">'data'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> chunk = <span class=\"keyword\">yield</span> stream.await(<span class=\"string\">'data'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> chunk = <span class=\"keyword\">yield</span> stream.await(<span class=\"string\">'data'</span>)</span><br><span class=\"line\">&#125;).catch(noop)</span><br><span class=\"line\"> </span><br><span class=\"line\">stream.write(<span class=\"string\">'some chunk’)</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>get-ready  NodeJS mixin to add one-time ready event</p>\n</li>\n<li>ShellJS 是Unix shell命令在Node.js API上的可移植实现</li>\n<li>graceful-process   graceful exit process even parent exit on SIGKILL.</li>\n<li>semver.gte(process.version, ‘7.0.0’)  版本的比对 </li>\n<li>pkgfiles  自动再package中添加 npm publish 文件</li>\n<li>depd  标注方法deprecating </li>\n<li>http-errors   http错误  </li>\n<li>Global-tunnel  http请求的全局代理  </li>\n<li><p>humanize-ms  转义为ms  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">transform humanize time to ms  ms(&apos;1s&apos;) // 1000</span><br><span class=\"line\">ms(1000) // 1000</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Exceljs 一个功能强大的excel 处理包</p>\n</li>\n<li>ready-callback 所有注册的事件完成后，才执行ready中方法</li>\n<li>Get-ready  NodeJS mixin to add one-time ready event，ready 后执行相关方法</li>\n<li>xml2js  将xml 转换为json </li>\n<li>debug  调试状态输出  debug=<em>  debug=work:</em>   </li>\n<li>delegates  node模块中代理proto中属性的方法、setter和getter</li>\n<li>chokidar filewatch </li>\n<li>Puppeteer  headless browser</li>\n<li>cross-env Run scripts that set and use environment variables across platforms</li>\n<li>simplemde  markdown editor </li>\n<li><p>serialize-javascript  Serialize JavaScript to a superset of JSON that includes regular expressions and functions.<br>1.route-cache  express router cache</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> routeCache = <span class=\"built_in\">require</span>(<span class=\"string\">'route-cache'</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// cache route for 20 seconds</span></span><br><span class=\"line\">app.get(<span class=\"string\">'/index'</span>, routeCache.cacheSeconds(<span class=\"number\">20</span>), <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// do your dirty work here...</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'you will only see this every 20 seconds.'</span>);</span><br><span class=\"line\">  res.send(<span class=\"string\">'this response will be cached'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Ws server 端的websoket </p>\n</li>\n<li>fastclick  解决浏览器点击的延迟</li>\n<li>Qs  A querystring parsing and stringifying library with some added security.</li>\n<li>lru-cache  A cache object that deletes the least-recently-used items.</li>\n<li>memory-fs  A simple in-memory filesystem. Holds data in a javascript object</li>\n<li>faker.js  generate massive amounts of fake data in the browser and node.js</li>\n<li>parseurl 等同node url parse，加了cache</li>\n<li>vue-lazy-component   Vue.js 2.x 组件级懒加载方案-Vue.js 2.x component level lazy loading solution</li>\n<li>async-validator  数据验证</li>\n<li>fast-safe-stringify    Safe and fast serialization alternative to JSON.stringify.</li>\n<li>node-notifier   Send cross platform native notifications using Node.js.</li>\n</ol>\n"},{"title":"security","date":"2019-04-25T08:49:58.000Z","_content":"```text\n参考： https://juejin.im/post/5bad9140e51d450e935c6d64#heading-9\n\nxss 攻击类型分为：反射、存储和dom \n\n在纯前端渲染中，我们会明确的告诉浏览器：下面要设置的内容是文本（.innerText），还是属性（.setAttribute），还是样式（.style）等等。浏览器不会被轻易的被欺骗，执行预期外的代码了.\n\n在很多内部、管理系统中，采用纯前端渲染是非常合适的。但对于性能要求高，或有 SEO 需求的页面，我们仍然要面对拼接 HTML 的问题。需要html 转义。\n\n利用模板引擎\n开启模板引擎自带的 HTML 转义功能。例如：\n在 ejs 中，尽量使用 <%= data %> 而不是 <%- data %>；\n在 doT.js 中，尽量使用 {{! data } 而不是 {{= data }；\n在 FreeMarker 中，确保引擎版本高于 2.3.24，并且选择正确的 freemarker.core.OutputFormat。\n避免内联事件\n尽量不要使用 onLoad=\"onload('{{data}}')\"、onClick=\"go('{{action}}')\" 这种拼接内联事件的写法。在 JavaScript 中通过 .addEventlistener() 事件绑定会更安全。\n避免拼接 HTML\n前端采用拼接 HTML 的方法比较危险，如果框架允许，使用 createElement、setAttribute 之类的方法实现。或者采用比较成熟的渲染框架，如 Vue/React 等。\n时刻保持警惕\n在插入位置为 DOM 属性、链接等位置时，要打起精神，严加防范。\n增加攻击难度，降低攻击后果\n通过 CSP、输入长度配置、接口安全措施等方法，增加攻击的难度，降低攻击的后果。\n主动检测和发现\n可使用 XSS 攻击字符串和自动扫描工具寻找潜在的 XSS 漏洞。\n\n```\n\n\n\n","source":"_posts/security.md","raw":"---\ntitle: security\ndate: 2019-04-25 16:49:58\ntags: 安全\n---\n```text\n参考： https://juejin.im/post/5bad9140e51d450e935c6d64#heading-9\n\nxss 攻击类型分为：反射、存储和dom \n\n在纯前端渲染中，我们会明确的告诉浏览器：下面要设置的内容是文本（.innerText），还是属性（.setAttribute），还是样式（.style）等等。浏览器不会被轻易的被欺骗，执行预期外的代码了.\n\n在很多内部、管理系统中，采用纯前端渲染是非常合适的。但对于性能要求高，或有 SEO 需求的页面，我们仍然要面对拼接 HTML 的问题。需要html 转义。\n\n利用模板引擎\n开启模板引擎自带的 HTML 转义功能。例如：\n在 ejs 中，尽量使用 <%= data %> 而不是 <%- data %>；\n在 doT.js 中，尽量使用 {{! data } 而不是 {{= data }；\n在 FreeMarker 中，确保引擎版本高于 2.3.24，并且选择正确的 freemarker.core.OutputFormat。\n避免内联事件\n尽量不要使用 onLoad=\"onload('{{data}}')\"、onClick=\"go('{{action}}')\" 这种拼接内联事件的写法。在 JavaScript 中通过 .addEventlistener() 事件绑定会更安全。\n避免拼接 HTML\n前端采用拼接 HTML 的方法比较危险，如果框架允许，使用 createElement、setAttribute 之类的方法实现。或者采用比较成熟的渲染框架，如 Vue/React 等。\n时刻保持警惕\n在插入位置为 DOM 属性、链接等位置时，要打起精神，严加防范。\n增加攻击难度，降低攻击后果\n通过 CSP、输入长度配置、接口安全措施等方法，增加攻击的难度，降低攻击的后果。\n主动检测和发现\n可使用 XSS 攻击字符串和自动扫描工具寻找潜在的 XSS 漏洞。\n\n```\n\n\n\n","slug":"security","published":1,"updated":"2019-07-26T08:35:17.312Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2fu41zx000zf18scbfl2ipx","content":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">参考： https://juejin.im/post/5bad9140e51d450e935c6d64#heading-9</span><br><span class=\"line\"></span><br><span class=\"line\">xss 攻击类型分为：反射、存储和dom </span><br><span class=\"line\"></span><br><span class=\"line\">在纯前端渲染中，我们会明确的告诉浏览器：下面要设置的内容是文本（.innerText），还是属性（.setAttribute），还是样式（.style）等等。浏览器不会被轻易的被欺骗，执行预期外的代码了.</span><br><span class=\"line\"></span><br><span class=\"line\">在很多内部、管理系统中，采用纯前端渲染是非常合适的。但对于性能要求高，或有 SEO 需求的页面，我们仍然要面对拼接 HTML 的问题。需要html 转义。</span><br><span class=\"line\"></span><br><span class=\"line\">利用模板引擎</span><br><span class=\"line\">开启模板引擎自带的 HTML 转义功能。例如：</span><br><span class=\"line\">在 ejs 中，尽量使用 &lt;%= data %&gt; 而不是 &lt;%- data %&gt;；</span><br><span class=\"line\">在 doT.js 中，尽量使用 &#123;&#123;! data &#125; 而不是 &#123;&#123;= data &#125;；</span><br><span class=\"line\">在 FreeMarker 中，确保引擎版本高于 2.3.24，并且选择正确的 freemarker.core.OutputFormat。</span><br><span class=\"line\">避免内联事件</span><br><span class=\"line\">尽量不要使用 onLoad=&quot;onload(&apos;&#123;&#123;data&#125;&#125;&apos;)&quot;、onClick=&quot;go(&apos;&#123;&#123;action&#125;&#125;&apos;)&quot; 这种拼接内联事件的写法。在 JavaScript 中通过 .addEventlistener() 事件绑定会更安全。</span><br><span class=\"line\">避免拼接 HTML</span><br><span class=\"line\">前端采用拼接 HTML 的方法比较危险，如果框架允许，使用 createElement、setAttribute 之类的方法实现。或者采用比较成熟的渲染框架，如 Vue/React 等。</span><br><span class=\"line\">时刻保持警惕</span><br><span class=\"line\">在插入位置为 DOM 属性、链接等位置时，要打起精神，严加防范。</span><br><span class=\"line\">增加攻击难度，降低攻击后果</span><br><span class=\"line\">通过 CSP、输入长度配置、接口安全措施等方法，增加攻击的难度，降低攻击的后果。</span><br><span class=\"line\">主动检测和发现</span><br><span class=\"line\">可使用 XSS 攻击字符串和自动扫描工具寻找潜在的 XSS 漏洞。</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">参考： https://juejin.im/post/5bad9140e51d450e935c6d64#heading-9</span><br><span class=\"line\"></span><br><span class=\"line\">xss 攻击类型分为：反射、存储和dom </span><br><span class=\"line\"></span><br><span class=\"line\">在纯前端渲染中，我们会明确的告诉浏览器：下面要设置的内容是文本（.innerText），还是属性（.setAttribute），还是样式（.style）等等。浏览器不会被轻易的被欺骗，执行预期外的代码了.</span><br><span class=\"line\"></span><br><span class=\"line\">在很多内部、管理系统中，采用纯前端渲染是非常合适的。但对于性能要求高，或有 SEO 需求的页面，我们仍然要面对拼接 HTML 的问题。需要html 转义。</span><br><span class=\"line\"></span><br><span class=\"line\">利用模板引擎</span><br><span class=\"line\">开启模板引擎自带的 HTML 转义功能。例如：</span><br><span class=\"line\">在 ejs 中，尽量使用 &lt;%= data %&gt; 而不是 &lt;%- data %&gt;；</span><br><span class=\"line\">在 doT.js 中，尽量使用 &#123;&#123;! data &#125; 而不是 &#123;&#123;= data &#125;；</span><br><span class=\"line\">在 FreeMarker 中，确保引擎版本高于 2.3.24，并且选择正确的 freemarker.core.OutputFormat。</span><br><span class=\"line\">避免内联事件</span><br><span class=\"line\">尽量不要使用 onLoad=&quot;onload(&apos;&#123;&#123;data&#125;&#125;&apos;)&quot;、onClick=&quot;go(&apos;&#123;&#123;action&#125;&#125;&apos;)&quot; 这种拼接内联事件的写法。在 JavaScript 中通过 .addEventlistener() 事件绑定会更安全。</span><br><span class=\"line\">避免拼接 HTML</span><br><span class=\"line\">前端采用拼接 HTML 的方法比较危险，如果框架允许，使用 createElement、setAttribute 之类的方法实现。或者采用比较成熟的渲染框架，如 Vue/React 等。</span><br><span class=\"line\">时刻保持警惕</span><br><span class=\"line\">在插入位置为 DOM 属性、链接等位置时，要打起精神，严加防范。</span><br><span class=\"line\">增加攻击难度，降低攻击后果</span><br><span class=\"line\">通过 CSP、输入长度配置、接口安全措施等方法，增加攻击的难度，降低攻击的后果。</span><br><span class=\"line\">主动检测和发现</span><br><span class=\"line\">可使用 XSS 攻击字符串和自动扫描工具寻找潜在的 XSS 漏洞。</span><br></pre></td></tr></table></figure>\n"},{"title":"typescript","date":"2019-02-25T02:16:27.000Z","_content":"\n### 只读属性\n```\ninterface Point {\n    readonly x: number;\n    readonly y: number;\n}\n```\n\n###  接口继承  \n    支持多重继承, 比较有意思的事接口可以继承类\n\n### 枚举类型\n ```\n enum Color {Red, Green, Blue}\n let c: Color = Color.Green;\n```\n\n### any \n```angular2html\nlet notSure: any = 4;\nnotSure = \"maybe a string instead\";\nnotSure = false; // okay, definitely a boolean\n\n```\n### 类型断言 \nas 和 <>\n\n### 剩余参数 \n```angular2html\nfunction invokeLater(args: any[], callback: (...args: any[]) => void) {\n    /* ... Invoke callback with 'args' ... */\n}\n\n// Unsound - invokeLater \"might\" provide any number of arguments\ninvokeLater([1, 2], (x, y) => console.log(x + ', ' + y));\n\n```\n\n### 交叉类型 特色\nPerson & Serializable & Loggable同时是 Person 和 Serializable 和 Loggable。 就是说这个类型的对象同时拥有了这三种类型的成员。\n\n### 联合类型 \n 如果一个值的类型是 A | B，我们能够 确定的是它包含了 A 和 B中共有的成员。 -- 用来做代码检查的\n ```\ninterface Bird {\n    fly();\n    layEggs();\n}\n\ninterface Fish {\n    swim();\n    layEggs();\n}\n\nfunction getSmallPet(): Fish | Bird {\n    // ...\n}\n\nlet pet = getSmallPet();\npet.layEggs(); // okay\npet.swim();    // error\n\n需要类型转换：(<Fish>pet).swim()\n\n```\n \n###  谓词为 parameterName is Type这种形式\n```\nfunction isFish(pet: Fish | Bird): pet is Fish {\n    return (<Fish>pet).swim !== undefined;\n}\n```\n### 参数指定默认值 \n```angular2html\nfunction keepWholeObject(wholeObject: { a: string, b?: number }) {\n    let { a, b = 1001 } = wholeObject;\n}\nTypeScript编译器不允许展开泛型函数上的类型参数 。 这个特性会在TypeScript的未来版本中考虑实现。 ...\n\n\nfunction buildName(firstName: string, lastName: string = 'Cat') {\n    return firstName + ' ' + lastName;\n}\n\n```\n### 数组泛型   \nArray<number>  \n\nlet list: any[] = ['Xcat Liu', 25, { website: 'http://xcatliu.com' }];\n\n用接口表示数组：\n\ninterface NumberArray {\n    [index: number]: number;\n}\n\n### 声明语句 \ndeclare var jQuery: (string) => any;\n\n我们约定声明文件以 .d.ts 为后缀。\n### 元组 \n```angular2html\nlet xcatliu: [string, number];\nxcatliu[0] = 'Xcat Liu';\nxcatliu[1] = 25;\n```\n### 命名空间  来源于C# \nnamespace Validation {}\n\nimport 别名\n```angular2html\namespace Shapes {\n    export namespace Polygons {\n        export class Triangle { }\n        export class Square { }\n    }\n}\n\nimport polygons = Shapes.Polygons;\nlet sq = new polygons.Square();\n```\n### index \n```angular2html\ntype Index = 'a' | 'b' | 'c'\ntype FromIndex = { [k in Index]?: number }\n\nconst good: FromIndex = {b:1, c:2}\n\n// Error:\n// Type '{ b: number; c: number; d: number; }' is not assignable to type 'FromIndex'.\n// Object literal may only specify known properties, and 'd' does not exist in type 'FromIndex'.\nconst bad: FromIndex = {b:1, c:2, d:3};\n```\n### this 参数\n```angular2html\ninterface Card {\n    suit: string;\n    card: number;\n}\ninterface Deck {\n    suits: string[];\n    cards: number[];\n    createCardPicker(this: Deck): () => Card;\n}\nlet deck: Deck = {\n    suits: [\"hearts\", \"spades\", \"clubs\", \"diamonds\"],\n    cards: Array(52),\n    // NOTE: The function now explicitly specifies that its callee must be of type Deck\n    createCardPicker: function(this: Deck) {\n        return () => {\n            let pickedCard = Math.floor(Math.random() * 52);\n            let pickedSuit = Math.floor(pickedCard / 13);\n\n            return {suit: this.suits[pickedSuit], card: pickedCard % 13};\n        }\n    }\n}\n```\n\n","source":"_posts/typescript.md","raw":"---\ntitle: typescript\ndate: 2019-02-25 10:16:27\ntags: ts\n---\n\n### 只读属性\n```\ninterface Point {\n    readonly x: number;\n    readonly y: number;\n}\n```\n\n###  接口继承  \n    支持多重继承, 比较有意思的事接口可以继承类\n\n### 枚举类型\n ```\n enum Color {Red, Green, Blue}\n let c: Color = Color.Green;\n```\n\n### any \n```angular2html\nlet notSure: any = 4;\nnotSure = \"maybe a string instead\";\nnotSure = false; // okay, definitely a boolean\n\n```\n### 类型断言 \nas 和 <>\n\n### 剩余参数 \n```angular2html\nfunction invokeLater(args: any[], callback: (...args: any[]) => void) {\n    /* ... Invoke callback with 'args' ... */\n}\n\n// Unsound - invokeLater \"might\" provide any number of arguments\ninvokeLater([1, 2], (x, y) => console.log(x + ', ' + y));\n\n```\n\n### 交叉类型 特色\nPerson & Serializable & Loggable同时是 Person 和 Serializable 和 Loggable。 就是说这个类型的对象同时拥有了这三种类型的成员。\n\n### 联合类型 \n 如果一个值的类型是 A | B，我们能够 确定的是它包含了 A 和 B中共有的成员。 -- 用来做代码检查的\n ```\ninterface Bird {\n    fly();\n    layEggs();\n}\n\ninterface Fish {\n    swim();\n    layEggs();\n}\n\nfunction getSmallPet(): Fish | Bird {\n    // ...\n}\n\nlet pet = getSmallPet();\npet.layEggs(); // okay\npet.swim();    // error\n\n需要类型转换：(<Fish>pet).swim()\n\n```\n \n###  谓词为 parameterName is Type这种形式\n```\nfunction isFish(pet: Fish | Bird): pet is Fish {\n    return (<Fish>pet).swim !== undefined;\n}\n```\n### 参数指定默认值 \n```angular2html\nfunction keepWholeObject(wholeObject: { a: string, b?: number }) {\n    let { a, b = 1001 } = wholeObject;\n}\nTypeScript编译器不允许展开泛型函数上的类型参数 。 这个特性会在TypeScript的未来版本中考虑实现。 ...\n\n\nfunction buildName(firstName: string, lastName: string = 'Cat') {\n    return firstName + ' ' + lastName;\n}\n\n```\n### 数组泛型   \nArray<number>  \n\nlet list: any[] = ['Xcat Liu', 25, { website: 'http://xcatliu.com' }];\n\n用接口表示数组：\n\ninterface NumberArray {\n    [index: number]: number;\n}\n\n### 声明语句 \ndeclare var jQuery: (string) => any;\n\n我们约定声明文件以 .d.ts 为后缀。\n### 元组 \n```angular2html\nlet xcatliu: [string, number];\nxcatliu[0] = 'Xcat Liu';\nxcatliu[1] = 25;\n```\n### 命名空间  来源于C# \nnamespace Validation {}\n\nimport 别名\n```angular2html\namespace Shapes {\n    export namespace Polygons {\n        export class Triangle { }\n        export class Square { }\n    }\n}\n\nimport polygons = Shapes.Polygons;\nlet sq = new polygons.Square();\n```\n### index \n```angular2html\ntype Index = 'a' | 'b' | 'c'\ntype FromIndex = { [k in Index]?: number }\n\nconst good: FromIndex = {b:1, c:2}\n\n// Error:\n// Type '{ b: number; c: number; d: number; }' is not assignable to type 'FromIndex'.\n// Object literal may only specify known properties, and 'd' does not exist in type 'FromIndex'.\nconst bad: FromIndex = {b:1, c:2, d:3};\n```\n### this 参数\n```angular2html\ninterface Card {\n    suit: string;\n    card: number;\n}\ninterface Deck {\n    suits: string[];\n    cards: number[];\n    createCardPicker(this: Deck): () => Card;\n}\nlet deck: Deck = {\n    suits: [\"hearts\", \"spades\", \"clubs\", \"diamonds\"],\n    cards: Array(52),\n    // NOTE: The function now explicitly specifies that its callee must be of type Deck\n    createCardPicker: function(this: Deck) {\n        return () => {\n            let pickedCard = Math.floor(Math.random() * 52);\n            let pickedSuit = Math.floor(pickedCard / 13);\n\n            return {suit: this.suits[pickedSuit], card: pickedCard % 13};\n        }\n    }\n}\n```\n\n","slug":"typescript","published":1,"updated":"2019-07-26T08:35:17.313Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2fu41zy0011f18sjeumh7iq","content":"<h3 id=\"只读属性\"><a href=\"#只读属性\" class=\"headerlink\" title=\"只读属性\"></a>只读属性</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface Point &#123;</span><br><span class=\"line\">    readonly x: number;</span><br><span class=\"line\">    readonly y: number;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"接口继承\"><a href=\"#接口继承\" class=\"headerlink\" title=\"接口继承\"></a>接口继承</h3><pre><code>支持多重继承, 比较有意思的事接口可以继承类\n</code></pre><h3 id=\"枚举类型\"><a href=\"#枚举类型\" class=\"headerlink\" title=\"枚举类型\"></a>枚举类型</h3> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum Color &#123;Red, Green, Blue&#125;</span><br><span class=\"line\">let c: Color = Color.Green;</span><br></pre></td></tr></table></figure>\n<h3 id=\"any\"><a href=\"#any\" class=\"headerlink\" title=\"any\"></a>any</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let notSure: any = 4;</span><br><span class=\"line\">notSure = &quot;maybe a string instead&quot;;</span><br><span class=\"line\">notSure = false; // okay, definitely a boolean</span><br></pre></td></tr></table></figure>\n<h3 id=\"类型断言\"><a href=\"#类型断言\" class=\"headerlink\" title=\"类型断言\"></a>类型断言</h3><p>as 和 &lt;&gt;</p>\n<h3 id=\"剩余参数\"><a href=\"#剩余参数\" class=\"headerlink\" title=\"剩余参数\"></a>剩余参数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function invokeLater(args: any[], callback: (...args: any[]) =&gt; void) &#123;</span><br><span class=\"line\">    /* ... Invoke callback with &apos;args&apos; ... */</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Unsound - invokeLater &quot;might&quot; provide any number of arguments</span><br><span class=\"line\">invokeLater([1, 2], (x, y) =&gt; console.log(x + &apos;, &apos; + y));</span><br></pre></td></tr></table></figure>\n<h3 id=\"交叉类型-特色\"><a href=\"#交叉类型-特色\" class=\"headerlink\" title=\"交叉类型 特色\"></a>交叉类型 特色</h3><p>Person &amp; Serializable &amp; Loggable同时是 Person 和 Serializable 和 Loggable。 就是说这个类型的对象同时拥有了这三种类型的成员。</p>\n<h3 id=\"联合类型\"><a href=\"#联合类型\" class=\"headerlink\" title=\"联合类型\"></a>联合类型</h3><p> 如果一个值的类型是 A | B，我们能够 确定的是它包含了 A 和 B中共有的成员。 – 用来做代码检查的<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface Bird &#123;</span><br><span class=\"line\">    fly();</span><br><span class=\"line\">    layEggs();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">interface Fish &#123;</span><br><span class=\"line\">    swim();</span><br><span class=\"line\">    layEggs();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function getSmallPet(): Fish | Bird &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let pet = getSmallPet();</span><br><span class=\"line\">pet.layEggs(); // okay</span><br><span class=\"line\">pet.swim();    // error</span><br><span class=\"line\"></span><br><span class=\"line\">需要类型转换：(&lt;Fish&gt;pet).swim()</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"谓词为-parameterName-is-Type这种形式\"><a href=\"#谓词为-parameterName-is-Type这种形式\" class=\"headerlink\" title=\"谓词为 parameterName is Type这种形式\"></a>谓词为 parameterName is Type这种形式</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function isFish(pet: Fish | Bird): pet is Fish &#123;</span><br><span class=\"line\">    return (&lt;Fish&gt;pet).swim !== undefined;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"参数指定默认值\"><a href=\"#参数指定默认值\" class=\"headerlink\" title=\"参数指定默认值\"></a>参数指定默认值</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function keepWholeObject(wholeObject: &#123; a: string, b?: number &#125;) &#123;</span><br><span class=\"line\">    let &#123; a, b = 1001 &#125; = wholeObject;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">TypeScript编译器不允许展开泛型函数上的类型参数 。 这个特性会在TypeScript的未来版本中考虑实现。 ...</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">function buildName(firstName: string, lastName: string = &apos;Cat&apos;) &#123;</span><br><span class=\"line\">    return firstName + &apos; &apos; + lastName;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"数组泛型\"><a href=\"#数组泛型\" class=\"headerlink\" title=\"数组泛型\"></a>数组泛型</h3><p>Array<number>  </number></p>\n<p>let list: any[] = [‘Xcat Liu’, 25, { website: ‘<a href=\"http://xcatliu.com&#39;\" target=\"_blank\" rel=\"noopener\">http://xcatliu.com&#39;</a> }];</p>\n<p>用接口表示数组：</p>\n<p>interface NumberArray {<br>    [index: number]: number;<br>}</p>\n<h3 id=\"声明语句\"><a href=\"#声明语句\" class=\"headerlink\" title=\"声明语句\"></a>声明语句</h3><p>declare var jQuery: (string) =&gt; any;</p>\n<p>我们约定声明文件以 .d.ts 为后缀。</p>\n<h3 id=\"元组\"><a href=\"#元组\" class=\"headerlink\" title=\"元组\"></a>元组</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let xcatliu: [string, number];</span><br><span class=\"line\">xcatliu[0] = &apos;Xcat Liu&apos;;</span><br><span class=\"line\">xcatliu[1] = 25;</span><br></pre></td></tr></table></figure>\n<h3 id=\"命名空间-来源于C\"><a href=\"#命名空间-来源于C\" class=\"headerlink\" title=\"命名空间  来源于C\"></a>命名空间  来源于C</h3><p>namespace Validation {}</p>\n<p>import 别名<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">amespace Shapes &#123;</span><br><span class=\"line\">    export namespace Polygons &#123;</span><br><span class=\"line\">        export class Triangle &#123; &#125;</span><br><span class=\"line\">        export class Square &#123; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">import polygons = Shapes.Polygons;</span><br><span class=\"line\">let sq = new polygons.Square();</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"index\"><a href=\"#index\" class=\"headerlink\" title=\"index\"></a>index</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Index = &apos;a&apos; | &apos;b&apos; | &apos;c&apos;</span><br><span class=\"line\">type FromIndex = &#123; [k in Index]?: number &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const good: FromIndex = &#123;b:1, c:2&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Error:</span><br><span class=\"line\">// Type &apos;&#123; b: number; c: number; d: number; &#125;&apos; is not assignable to type &apos;FromIndex&apos;.</span><br><span class=\"line\">// Object literal may only specify known properties, and &apos;d&apos; does not exist in type &apos;FromIndex&apos;.</span><br><span class=\"line\">const bad: FromIndex = &#123;b:1, c:2, d:3&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"this-参数\"><a href=\"#this-参数\" class=\"headerlink\" title=\"this 参数\"></a>this 参数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface Card &#123;</span><br><span class=\"line\">    suit: string;</span><br><span class=\"line\">    card: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">interface Deck &#123;</span><br><span class=\"line\">    suits: string[];</span><br><span class=\"line\">    cards: number[];</span><br><span class=\"line\">    createCardPicker(this: Deck): () =&gt; Card;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let deck: Deck = &#123;</span><br><span class=\"line\">    suits: [&quot;hearts&quot;, &quot;spades&quot;, &quot;clubs&quot;, &quot;diamonds&quot;],</span><br><span class=\"line\">    cards: Array(52),</span><br><span class=\"line\">    // NOTE: The function now explicitly specifies that its callee must be of type Deck</span><br><span class=\"line\">    createCardPicker: function(this: Deck) &#123;</span><br><span class=\"line\">        return () =&gt; &#123;</span><br><span class=\"line\">            let pickedCard = Math.floor(Math.random() * 52);</span><br><span class=\"line\">            let pickedSuit = Math.floor(pickedCard / 13);</span><br><span class=\"line\"></span><br><span class=\"line\">            return &#123;suit: this.suits[pickedSuit], card: pickedCard % 13&#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"只读属性\"><a href=\"#只读属性\" class=\"headerlink\" title=\"只读属性\"></a>只读属性</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface Point &#123;</span><br><span class=\"line\">    readonly x: number;</span><br><span class=\"line\">    readonly y: number;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"接口继承\"><a href=\"#接口继承\" class=\"headerlink\" title=\"接口继承\"></a>接口继承</h3><pre><code>支持多重继承, 比较有意思的事接口可以继承类\n</code></pre><h3 id=\"枚举类型\"><a href=\"#枚举类型\" class=\"headerlink\" title=\"枚举类型\"></a>枚举类型</h3> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum Color &#123;Red, Green, Blue&#125;</span><br><span class=\"line\">let c: Color = Color.Green;</span><br></pre></td></tr></table></figure>\n<h3 id=\"any\"><a href=\"#any\" class=\"headerlink\" title=\"any\"></a>any</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let notSure: any = 4;</span><br><span class=\"line\">notSure = &quot;maybe a string instead&quot;;</span><br><span class=\"line\">notSure = false; // okay, definitely a boolean</span><br></pre></td></tr></table></figure>\n<h3 id=\"类型断言\"><a href=\"#类型断言\" class=\"headerlink\" title=\"类型断言\"></a>类型断言</h3><p>as 和 &lt;&gt;</p>\n<h3 id=\"剩余参数\"><a href=\"#剩余参数\" class=\"headerlink\" title=\"剩余参数\"></a>剩余参数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function invokeLater(args: any[], callback: (...args: any[]) =&gt; void) &#123;</span><br><span class=\"line\">    /* ... Invoke callback with &apos;args&apos; ... */</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Unsound - invokeLater &quot;might&quot; provide any number of arguments</span><br><span class=\"line\">invokeLater([1, 2], (x, y) =&gt; console.log(x + &apos;, &apos; + y));</span><br></pre></td></tr></table></figure>\n<h3 id=\"交叉类型-特色\"><a href=\"#交叉类型-特色\" class=\"headerlink\" title=\"交叉类型 特色\"></a>交叉类型 特色</h3><p>Person &amp; Serializable &amp; Loggable同时是 Person 和 Serializable 和 Loggable。 就是说这个类型的对象同时拥有了这三种类型的成员。</p>\n<h3 id=\"联合类型\"><a href=\"#联合类型\" class=\"headerlink\" title=\"联合类型\"></a>联合类型</h3><p> 如果一个值的类型是 A | B，我们能够 确定的是它包含了 A 和 B中共有的成员。 – 用来做代码检查的<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface Bird &#123;</span><br><span class=\"line\">    fly();</span><br><span class=\"line\">    layEggs();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">interface Fish &#123;</span><br><span class=\"line\">    swim();</span><br><span class=\"line\">    layEggs();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function getSmallPet(): Fish | Bird &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let pet = getSmallPet();</span><br><span class=\"line\">pet.layEggs(); // okay</span><br><span class=\"line\">pet.swim();    // error</span><br><span class=\"line\"></span><br><span class=\"line\">需要类型转换：(&lt;Fish&gt;pet).swim()</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"谓词为-parameterName-is-Type这种形式\"><a href=\"#谓词为-parameterName-is-Type这种形式\" class=\"headerlink\" title=\"谓词为 parameterName is Type这种形式\"></a>谓词为 parameterName is Type这种形式</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function isFish(pet: Fish | Bird): pet is Fish &#123;</span><br><span class=\"line\">    return (&lt;Fish&gt;pet).swim !== undefined;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"参数指定默认值\"><a href=\"#参数指定默认值\" class=\"headerlink\" title=\"参数指定默认值\"></a>参数指定默认值</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function keepWholeObject(wholeObject: &#123; a: string, b?: number &#125;) &#123;</span><br><span class=\"line\">    let &#123; a, b = 1001 &#125; = wholeObject;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">TypeScript编译器不允许展开泛型函数上的类型参数 。 这个特性会在TypeScript的未来版本中考虑实现。 ...</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">function buildName(firstName: string, lastName: string = &apos;Cat&apos;) &#123;</span><br><span class=\"line\">    return firstName + &apos; &apos; + lastName;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"数组泛型\"><a href=\"#数组泛型\" class=\"headerlink\" title=\"数组泛型\"></a>数组泛型</h3><p>Array<number>  </number></p>\n<p>let list: any[] = [‘Xcat Liu’, 25, { website: ‘<a href=\"http://xcatliu.com&#39;\" target=\"_blank\" rel=\"noopener\">http://xcatliu.com&#39;</a> }];</p>\n<p>用接口表示数组：</p>\n<p>interface NumberArray {<br>    [index: number]: number;<br>}</p>\n<h3 id=\"声明语句\"><a href=\"#声明语句\" class=\"headerlink\" title=\"声明语句\"></a>声明语句</h3><p>declare var jQuery: (string) =&gt; any;</p>\n<p>我们约定声明文件以 .d.ts 为后缀。</p>\n<h3 id=\"元组\"><a href=\"#元组\" class=\"headerlink\" title=\"元组\"></a>元组</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let xcatliu: [string, number];</span><br><span class=\"line\">xcatliu[0] = &apos;Xcat Liu&apos;;</span><br><span class=\"line\">xcatliu[1] = 25;</span><br></pre></td></tr></table></figure>\n<h3 id=\"命名空间-来源于C\"><a href=\"#命名空间-来源于C\" class=\"headerlink\" title=\"命名空间  来源于C\"></a>命名空间  来源于C</h3><p>namespace Validation {}</p>\n<p>import 别名<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">amespace Shapes &#123;</span><br><span class=\"line\">    export namespace Polygons &#123;</span><br><span class=\"line\">        export class Triangle &#123; &#125;</span><br><span class=\"line\">        export class Square &#123; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">import polygons = Shapes.Polygons;</span><br><span class=\"line\">let sq = new polygons.Square();</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"index\"><a href=\"#index\" class=\"headerlink\" title=\"index\"></a>index</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Index = &apos;a&apos; | &apos;b&apos; | &apos;c&apos;</span><br><span class=\"line\">type FromIndex = &#123; [k in Index]?: number &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const good: FromIndex = &#123;b:1, c:2&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Error:</span><br><span class=\"line\">// Type &apos;&#123; b: number; c: number; d: number; &#125;&apos; is not assignable to type &apos;FromIndex&apos;.</span><br><span class=\"line\">// Object literal may only specify known properties, and &apos;d&apos; does not exist in type &apos;FromIndex&apos;.</span><br><span class=\"line\">const bad: FromIndex = &#123;b:1, c:2, d:3&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"this-参数\"><a href=\"#this-参数\" class=\"headerlink\" title=\"this 参数\"></a>this 参数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface Card &#123;</span><br><span class=\"line\">    suit: string;</span><br><span class=\"line\">    card: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">interface Deck &#123;</span><br><span class=\"line\">    suits: string[];</span><br><span class=\"line\">    cards: number[];</span><br><span class=\"line\">    createCardPicker(this: Deck): () =&gt; Card;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let deck: Deck = &#123;</span><br><span class=\"line\">    suits: [&quot;hearts&quot;, &quot;spades&quot;, &quot;clubs&quot;, &quot;diamonds&quot;],</span><br><span class=\"line\">    cards: Array(52),</span><br><span class=\"line\">    // NOTE: The function now explicitly specifies that its callee must be of type Deck</span><br><span class=\"line\">    createCardPicker: function(this: Deck) &#123;</span><br><span class=\"line\">        return () =&gt; &#123;</span><br><span class=\"line\">            let pickedCard = Math.floor(Math.random() * 52);</span><br><span class=\"line\">            let pickedSuit = Math.floor(pickedCard / 13);</span><br><span class=\"line\"></span><br><span class=\"line\">            return &#123;suit: this.suits[pickedSuit], card: pickedCard % 13&#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"vue","date":"2017-01-19T07:19:03.000Z","_content":"### js\n1. js 链接 defer 和 async\n```text\ndefer 和 async 都是并行加载的，主要区别在于下载后何时执行。\n每一个 async 属性的脚本都在它下载结束之后立刻执行，所以就有可能出现脚本执行顺序被打乱的情况\n每一个 defer 属性的脚本会在 HTML 解析完成后, DOMContentLoaded 之前，按照 DOM 中的顺序执行（ie>=10）\ndefer 和 async 都只适用于外部脚本文件，对与内联的 script 标签是不起作用\n\n```\n1. preload 用 “as” 或者用 “type” 属性来表示他们请求资源的优先级（比如说 preload 使用 as=\"style\" 属性将获得最高的优先级）。没有 “as” 属性的将被看作异步请求，“Early”意味着在所有未被预加载的图片请求之前被请求（“late”意味着之后）\n1. WebRTC，名称源自网页即时通信（英语：Web Real-Time Communication）的缩写，是一个支持网页浏览器进行实时语音对话或视频对话的API。\n1. Vue-intro  新功能引导  \n1. __proto__ 属性，这是历史遗留的非标准的语法，但在现代浏览器中广泛实现。获得原型的更可靠方法是使用 Object.getPrototypeOf(new Object())；例如：\n ```javascript\nconst car = {}\nconst list = []\n \nconsole.log(Object.getPrototypeOf(car));\nconsole.log(Object.getPrototypeOf(list));\n```\n1. Object.prototype.toString.call(variable) 用这个方法来判断变量类型目前是最可靠的了，它总能返回正确的值。\n   \n   该方法返回 \"[object type]\", 其中type是对象类型。\n1.  document.getElementsByClassName('test');\n1.    \n\n### 内部机制 \n\nvue-loader \n\ncompiler 目录包含 Vue.js 所有编译相关的代码。它包括把模板解析成 ast 语法树，ast 语法树优化，代码生成等功能。\n\n\n微任务的例子：micortask\n\nprocess.nextTick\npromise\nObject.observe\n\n宏任务的例子：\n\nsetTimeout\nsetInterval\nsetImmediate\nI/O\n\n需要注意的是node 和 浏览器的 event loop 是有区别的：\n\n```text\n浏览器的事件循环：\n\n执行全局Script同步代码，这些同步代码有一些是同步语句，有一些是异步语句（比如setTimeout等）；\n全局Script代码执行完毕后，调用栈Stack会清空；\n从微队列microtask queue中取出位于队首的回调任务，放入调用栈Stack中执行，执行完后microtask queue长度减1；\n继续取出位于队首的任务，放入调用栈Stack中执行，以此类推，直到直到把microtask queue中的所有任务都执行完毕。注意，如果在执行microtask的过程中，又产生了microtask，那么会加入到队列的末尾，也会在这个周期被调用执行；\nmicrotask queue中的所有任务都执行完毕，此时microtask queue为空队列，调用栈Stack也为空；\n取出宏队列macrotask queue中位于队首的任务，放入Stack中执行；\n执行完毕后，调用栈Stack为空；\n重复第3-7个步骤；\n重复第3-7个步骤；\n……\n\nNodeJS中微队列主要有2个：\nNext Tick Queue：是放置process.nextTick(callback)的回调任务的\nOther Micro Queue：放置其他microtask，比如Promise等\n\n具体参见： https://segmentfault.com/a/1190000016278115\n\n```\n\n\n``` \ntimers 阶段：这个阶段执行timer（setTimeout、setInterval）的回调\nI/O callbacks 阶段：执行一些系统调用错误，比如网络通信的错误回调\nidle, prepare 阶段：仅node内部使用\npoll 阶段：获取新的I/O事件, 适当的条件下node将阻塞在这里\ncheck 阶段：执行 setImmediate() 的回调\nclose callbacks 阶段：执行 socket 的 close 事件回调\n\ntimers 是事件循环的第一个阶段，Node 会去检查有无已过期的timer，如果有则把它的回调压入timer的任务队列中等待执行，事实上，Node 并不能保证timer在预设时间到了就会立即执行，因为Node对timer的过期检查不一定靠谱，它会受机器上其它运行程序影响，或者那个时间点主线程不空闲。比如下面的代码，setTimeout() 和 setImmediate() 的执行顺序是不确定的。\n\npoll 阶段\npoll 阶段主要有2个功能：\n\n处理 poll 队列的事件\n当有已超时的 timer，执行它的回调函数\neven loop将同步执行poll队列里的回调，直到队列为空或执行的回调达到系统上限（上限具体多少未详），接下来even loop会去检查有无预设的setImmediate()，分两种情况：\n\n若有预设的setImmediate(), event loop将结束poll阶段进入check阶段，并执行check阶段的任务队列\n若没有预设的setImmediate()，event loop将阻塞在该阶段等待\n注意一个细节，没有setImmediate()会导致event loop阻塞在poll阶段，这样之前设置的timer岂不是执行不了了？所以咧，在poll阶段event loop会有一个检查机制，检查timer队列是否为空，如果timer队列非空，event loop就开始下一轮事件循环，即重新进入到timer阶段。\n\ncheck 阶段\nsetImmediate()的回调会被加入check队列中， 从event loop的阶段图可以知道，check阶段的执行顺序在poll阶段之后。\n\n\n回顾上一篇，浏览器环境下，microtask的任务队列是每个macrotask执行完之后执行。而在Node.js中，microtask会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行microtask队列的任务。详见：http://lynnelv.github.io/js-event-loop-nodejs\n\nprocess.nextTick() 会在各个事件阶段之间执行，一旦执行，要直到nextTick队列被清空，才会进入到下一个事件阶段，所以如果递归调用 process.nextTick()，会导致出现I/O starving（饥饿）的问题\n\n官方文档：https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/\n\n```\n\n\n\n###vitual dom\n\n Vue.js 实现响应式的核心是利用了 ES5 的 Object.defineProperty，这也是为什么 Vue.js 不能兼容 IE8 及以下浏览器的原因，我们先来对它有个直观的认识。值改变时会触发set方法。\n \n 核心就是利用 Object.defineProperty 给数据添加了 getter 和 setter，目的就是为了在我们访问数据以及写数据的时候能自动执行一些逻辑：getter 做的事情是依赖收集，setter 做的事情是派发更新\n \n 它会先执行 vm._render() 方法，因为之前分析过这个方法会生成 渲染 VNode，并且在这个过程中会对 vm 上的数据访问，这个时候就触发了数据对象的 getter。\n \n 它并不会每次数据改变都触发 watcher 的回调，而是把这些 watcher 先添加到一个队列里，然后在 nextTick 后执行 flushSchedulerQueue。\n\n \n\nVD 最大的特点是将页面的状态抽象为 JS 对象的形式，配合不同的渲染工具，使跨平台渲染成为可能。如 React 就借助 VD 实现了服务端渲染、浏览器渲染和移动端渲染等功能。\njs计算-》生成渲染树-》渲染页面\n\n通过VD的比较，我们可以将多个操作合并成一个批量的操作，从而减少dom重排的次数，进而缩短了生成渲染树和绘制所花的时间。\n\n在mounted 方法中会将template 编译成为render 方法。这是一个编译过程，render中会调用createElement 创建vnode。\n\n![流程图片](https://ustbhuangyi.github.io/vue-analysis/assets/new-vue.png)\n\n\n回到 mountComponent 函数的过程，我们已经知道 createElement 是如何创建了一个 VNode，接下来就是要把这个 VNode 渲染成一个真实的 DOM 并渲染出来，这个过程是通过 vm._update 完成的\n\nVue 的 _update 是实例的一个私有方法，它被调用的时机有 2 个，一个是首次渲染，一个是数据更新的时候；由于我们这一章节只分析首次渲染部分，数据更新部分会在之后分析响应式原理的时候涉及。_update 方法的作用是把 VNode 渲染成真实的 DOM\n\n\n在我们之前对 setter 的分析过程知道，当响应式数据发送变化后，触发了 watcher.update()，只是把这个 watcher 推送到一个队列中，在 nextTick 后才会真正执行 watcher 的回调函数。而一旦我们设置了 sync，就可以在当前 Tick 中同步执行 watcher 的回调函数。\n\ndeep watcher 和 sync watcher  \n\n\n\n###  router 元数据 \n meta: { requiresAuth: true }  \n \n#####  v-once 指令，你也能执行一次性地插值\n\n#### v-slot 新的用法\nv-slot 的别名是#。因此，可以用#header=\"data\" 来代替 v-slot:header=\"data\"。还可以使用 #header来代替 v-slot:header(前提:不是作用域插槽时)。对于默认插槽，在使用别名时需要指定默认名称。换句话说，需要这样写 #default=\"data\" 而不是#=\"data\"。\n\n\n##### Mustache 不能在 HTML 属性中使用，应使用 v-bind 指令：\n\n```\n<div v-bind:id=\"dynamicId\"></div>\n```\n\n##### 修饰符（Modifiers）是以半角句号 . 指明的特殊后缀，用于指出一个指定应该以特殊方式绑定。例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()\n\n```\n<!-- 阻止单击事件冒泡 -->\n<a v-on:click.stop=\"doThis\"></a>\n<!-- 提交事件不再重载页面 -->\n<form v-on:submit.prevent=\"onSubmit\"></form>\n<!-- 修饰符可以串联  -->\n<a v-on:click.stop.prevent=\"doThat\"></a>\n<!-- 只有修饰符 -->\n<form v-on:submit.prevent></form>\n<!-- 添加事件侦听器时使用事件捕获模式 -->\n<div v-on:click.capture=\"doThis\">...</div>\n<!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 -->\n<div v-on:click.self=\"doThat\">...</div>\n<a v-on:click.once=\"doThis\"></a>\n```\n\n##### 过滤器函数总接受表达式的值作为第一个参数。\n\n```\nnew Vue({\n  // ...\n  filters: {\n    capitalize: function (value) {\n      if (!value) return ''\n      value = value.toString()\n      return value.charAt(0).toUpperCase() + value.slice(1)\n    }\n  }\n})\n过滤器可以串联：\n{{ message | filterA | filterB }}\n```\n\n##### v-bind 缩写\n\n\n```\n<!-- 完整语法 -->\n<a v-bind:href=\"url\"></a>\n<!-- 缩写 -->\n<a :href=\"url\"></a>\nv-on 缩写\n\n<!-- 完整语法 -->\n<a v-on:click=\"doSomething\"></a>\n<!-- 缩写 -->\n<a @click=\"doSomething\"></a>\n```\n \n \n##### 按键修饰符\n记住所有的 keyCode 比较困难，所以 Vue 为最常用的按键提供了别名：\n\n```\n<!-- 同上 -->\n<input v-on:keyup.enter=\"submit\">\n<!-- 缩写语法 -->\n<input @keyup.enter=\"submit\">\n全部的按键别名：\n.enter\n.tab\n.delete (捕获 “删除” 和 “退格” 键)\n.esc\n.space\n.up\n.down\n.left\n.right\n```\n##### 绑定属性值\n\n```\n<input\n  type=\"checkbox\"\n  v-model=\"toggle\"\n  v-bind:true-value=\"a\"\n  v-bind:false-value=\"b\"\n>\n```\n##### 修饰符\n\n```\n在默认情况下， v-model 在 input 事件中同步输入框的值与数据 (除了 上述 IME 部分)，但你可以添加一个修饰符 lazy ，从而转变为在 change 事件中同步：\n<!-- 在 \"change\" 而不是 \"input\" 事件中更新 -->\n<input v-model.lazy=\"msg\" >\n.number\n\n如果想自动将用户的输入值转为 Number 类型（如果原值的转换结果为 NaN 则返回原值），可以添加一个修饰符 number 给 v-model 来处理输入值：\n<input v-model.number=\"age\" type=\"number\">\n这通常很有用，因为在 type=\"number\" 时 HTML 中输入的值也总是会返回字符串类型。\n.trim\n\n如果要自动过滤用户输入的首尾空格，可以添加 trim 修饰符到 v-model 上过滤输入：\n<input v-model.trim=\"msg\">\n```\n","source":"_posts/vue.md","raw":"---\ntitle: vue\ndate: 2017-01-19 15:19:03\ntags: vue eventloop js \n---\n### js\n1. js 链接 defer 和 async\n```text\ndefer 和 async 都是并行加载的，主要区别在于下载后何时执行。\n每一个 async 属性的脚本都在它下载结束之后立刻执行，所以就有可能出现脚本执行顺序被打乱的情况\n每一个 defer 属性的脚本会在 HTML 解析完成后, DOMContentLoaded 之前，按照 DOM 中的顺序执行（ie>=10）\ndefer 和 async 都只适用于外部脚本文件，对与内联的 script 标签是不起作用\n\n```\n1. preload 用 “as” 或者用 “type” 属性来表示他们请求资源的优先级（比如说 preload 使用 as=\"style\" 属性将获得最高的优先级）。没有 “as” 属性的将被看作异步请求，“Early”意味着在所有未被预加载的图片请求之前被请求（“late”意味着之后）\n1. WebRTC，名称源自网页即时通信（英语：Web Real-Time Communication）的缩写，是一个支持网页浏览器进行实时语音对话或视频对话的API。\n1. Vue-intro  新功能引导  \n1. __proto__ 属性，这是历史遗留的非标准的语法，但在现代浏览器中广泛实现。获得原型的更可靠方法是使用 Object.getPrototypeOf(new Object())；例如：\n ```javascript\nconst car = {}\nconst list = []\n \nconsole.log(Object.getPrototypeOf(car));\nconsole.log(Object.getPrototypeOf(list));\n```\n1. Object.prototype.toString.call(variable) 用这个方法来判断变量类型目前是最可靠的了，它总能返回正确的值。\n   \n   该方法返回 \"[object type]\", 其中type是对象类型。\n1.  document.getElementsByClassName('test');\n1.    \n\n### 内部机制 \n\nvue-loader \n\ncompiler 目录包含 Vue.js 所有编译相关的代码。它包括把模板解析成 ast 语法树，ast 语法树优化，代码生成等功能。\n\n\n微任务的例子：micortask\n\nprocess.nextTick\npromise\nObject.observe\n\n宏任务的例子：\n\nsetTimeout\nsetInterval\nsetImmediate\nI/O\n\n需要注意的是node 和 浏览器的 event loop 是有区别的：\n\n```text\n浏览器的事件循环：\n\n执行全局Script同步代码，这些同步代码有一些是同步语句，有一些是异步语句（比如setTimeout等）；\n全局Script代码执行完毕后，调用栈Stack会清空；\n从微队列microtask queue中取出位于队首的回调任务，放入调用栈Stack中执行，执行完后microtask queue长度减1；\n继续取出位于队首的任务，放入调用栈Stack中执行，以此类推，直到直到把microtask queue中的所有任务都执行完毕。注意，如果在执行microtask的过程中，又产生了microtask，那么会加入到队列的末尾，也会在这个周期被调用执行；\nmicrotask queue中的所有任务都执行完毕，此时microtask queue为空队列，调用栈Stack也为空；\n取出宏队列macrotask queue中位于队首的任务，放入Stack中执行；\n执行完毕后，调用栈Stack为空；\n重复第3-7个步骤；\n重复第3-7个步骤；\n……\n\nNodeJS中微队列主要有2个：\nNext Tick Queue：是放置process.nextTick(callback)的回调任务的\nOther Micro Queue：放置其他microtask，比如Promise等\n\n具体参见： https://segmentfault.com/a/1190000016278115\n\n```\n\n\n``` \ntimers 阶段：这个阶段执行timer（setTimeout、setInterval）的回调\nI/O callbacks 阶段：执行一些系统调用错误，比如网络通信的错误回调\nidle, prepare 阶段：仅node内部使用\npoll 阶段：获取新的I/O事件, 适当的条件下node将阻塞在这里\ncheck 阶段：执行 setImmediate() 的回调\nclose callbacks 阶段：执行 socket 的 close 事件回调\n\ntimers 是事件循环的第一个阶段，Node 会去检查有无已过期的timer，如果有则把它的回调压入timer的任务队列中等待执行，事实上，Node 并不能保证timer在预设时间到了就会立即执行，因为Node对timer的过期检查不一定靠谱，它会受机器上其它运行程序影响，或者那个时间点主线程不空闲。比如下面的代码，setTimeout() 和 setImmediate() 的执行顺序是不确定的。\n\npoll 阶段\npoll 阶段主要有2个功能：\n\n处理 poll 队列的事件\n当有已超时的 timer，执行它的回调函数\neven loop将同步执行poll队列里的回调，直到队列为空或执行的回调达到系统上限（上限具体多少未详），接下来even loop会去检查有无预设的setImmediate()，分两种情况：\n\n若有预设的setImmediate(), event loop将结束poll阶段进入check阶段，并执行check阶段的任务队列\n若没有预设的setImmediate()，event loop将阻塞在该阶段等待\n注意一个细节，没有setImmediate()会导致event loop阻塞在poll阶段，这样之前设置的timer岂不是执行不了了？所以咧，在poll阶段event loop会有一个检查机制，检查timer队列是否为空，如果timer队列非空，event loop就开始下一轮事件循环，即重新进入到timer阶段。\n\ncheck 阶段\nsetImmediate()的回调会被加入check队列中， 从event loop的阶段图可以知道，check阶段的执行顺序在poll阶段之后。\n\n\n回顾上一篇，浏览器环境下，microtask的任务队列是每个macrotask执行完之后执行。而在Node.js中，microtask会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行microtask队列的任务。详见：http://lynnelv.github.io/js-event-loop-nodejs\n\nprocess.nextTick() 会在各个事件阶段之间执行，一旦执行，要直到nextTick队列被清空，才会进入到下一个事件阶段，所以如果递归调用 process.nextTick()，会导致出现I/O starving（饥饿）的问题\n\n官方文档：https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/\n\n```\n\n\n\n###vitual dom\n\n Vue.js 实现响应式的核心是利用了 ES5 的 Object.defineProperty，这也是为什么 Vue.js 不能兼容 IE8 及以下浏览器的原因，我们先来对它有个直观的认识。值改变时会触发set方法。\n \n 核心就是利用 Object.defineProperty 给数据添加了 getter 和 setter，目的就是为了在我们访问数据以及写数据的时候能自动执行一些逻辑：getter 做的事情是依赖收集，setter 做的事情是派发更新\n \n 它会先执行 vm._render() 方法，因为之前分析过这个方法会生成 渲染 VNode，并且在这个过程中会对 vm 上的数据访问，这个时候就触发了数据对象的 getter。\n \n 它并不会每次数据改变都触发 watcher 的回调，而是把这些 watcher 先添加到一个队列里，然后在 nextTick 后执行 flushSchedulerQueue。\n\n \n\nVD 最大的特点是将页面的状态抽象为 JS 对象的形式，配合不同的渲染工具，使跨平台渲染成为可能。如 React 就借助 VD 实现了服务端渲染、浏览器渲染和移动端渲染等功能。\njs计算-》生成渲染树-》渲染页面\n\n通过VD的比较，我们可以将多个操作合并成一个批量的操作，从而减少dom重排的次数，进而缩短了生成渲染树和绘制所花的时间。\n\n在mounted 方法中会将template 编译成为render 方法。这是一个编译过程，render中会调用createElement 创建vnode。\n\n![流程图片](https://ustbhuangyi.github.io/vue-analysis/assets/new-vue.png)\n\n\n回到 mountComponent 函数的过程，我们已经知道 createElement 是如何创建了一个 VNode，接下来就是要把这个 VNode 渲染成一个真实的 DOM 并渲染出来，这个过程是通过 vm._update 完成的\n\nVue 的 _update 是实例的一个私有方法，它被调用的时机有 2 个，一个是首次渲染，一个是数据更新的时候；由于我们这一章节只分析首次渲染部分，数据更新部分会在之后分析响应式原理的时候涉及。_update 方法的作用是把 VNode 渲染成真实的 DOM\n\n\n在我们之前对 setter 的分析过程知道，当响应式数据发送变化后，触发了 watcher.update()，只是把这个 watcher 推送到一个队列中，在 nextTick 后才会真正执行 watcher 的回调函数。而一旦我们设置了 sync，就可以在当前 Tick 中同步执行 watcher 的回调函数。\n\ndeep watcher 和 sync watcher  \n\n\n\n###  router 元数据 \n meta: { requiresAuth: true }  \n \n#####  v-once 指令，你也能执行一次性地插值\n\n#### v-slot 新的用法\nv-slot 的别名是#。因此，可以用#header=\"data\" 来代替 v-slot:header=\"data\"。还可以使用 #header来代替 v-slot:header(前提:不是作用域插槽时)。对于默认插槽，在使用别名时需要指定默认名称。换句话说，需要这样写 #default=\"data\" 而不是#=\"data\"。\n\n\n##### Mustache 不能在 HTML 属性中使用，应使用 v-bind 指令：\n\n```\n<div v-bind:id=\"dynamicId\"></div>\n```\n\n##### 修饰符（Modifiers）是以半角句号 . 指明的特殊后缀，用于指出一个指定应该以特殊方式绑定。例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()\n\n```\n<!-- 阻止单击事件冒泡 -->\n<a v-on:click.stop=\"doThis\"></a>\n<!-- 提交事件不再重载页面 -->\n<form v-on:submit.prevent=\"onSubmit\"></form>\n<!-- 修饰符可以串联  -->\n<a v-on:click.stop.prevent=\"doThat\"></a>\n<!-- 只有修饰符 -->\n<form v-on:submit.prevent></form>\n<!-- 添加事件侦听器时使用事件捕获模式 -->\n<div v-on:click.capture=\"doThis\">...</div>\n<!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 -->\n<div v-on:click.self=\"doThat\">...</div>\n<a v-on:click.once=\"doThis\"></a>\n```\n\n##### 过滤器函数总接受表达式的值作为第一个参数。\n\n```\nnew Vue({\n  // ...\n  filters: {\n    capitalize: function (value) {\n      if (!value) return ''\n      value = value.toString()\n      return value.charAt(0).toUpperCase() + value.slice(1)\n    }\n  }\n})\n过滤器可以串联：\n{{ message | filterA | filterB }}\n```\n\n##### v-bind 缩写\n\n\n```\n<!-- 完整语法 -->\n<a v-bind:href=\"url\"></a>\n<!-- 缩写 -->\n<a :href=\"url\"></a>\nv-on 缩写\n\n<!-- 完整语法 -->\n<a v-on:click=\"doSomething\"></a>\n<!-- 缩写 -->\n<a @click=\"doSomething\"></a>\n```\n \n \n##### 按键修饰符\n记住所有的 keyCode 比较困难，所以 Vue 为最常用的按键提供了别名：\n\n```\n<!-- 同上 -->\n<input v-on:keyup.enter=\"submit\">\n<!-- 缩写语法 -->\n<input @keyup.enter=\"submit\">\n全部的按键别名：\n.enter\n.tab\n.delete (捕获 “删除” 和 “退格” 键)\n.esc\n.space\n.up\n.down\n.left\n.right\n```\n##### 绑定属性值\n\n```\n<input\n  type=\"checkbox\"\n  v-model=\"toggle\"\n  v-bind:true-value=\"a\"\n  v-bind:false-value=\"b\"\n>\n```\n##### 修饰符\n\n```\n在默认情况下， v-model 在 input 事件中同步输入框的值与数据 (除了 上述 IME 部分)，但你可以添加一个修饰符 lazy ，从而转变为在 change 事件中同步：\n<!-- 在 \"change\" 而不是 \"input\" 事件中更新 -->\n<input v-model.lazy=\"msg\" >\n.number\n\n如果想自动将用户的输入值转为 Number 类型（如果原值的转换结果为 NaN 则返回原值），可以添加一个修饰符 number 给 v-model 来处理输入值：\n<input v-model.number=\"age\" type=\"number\">\n这通常很有用，因为在 type=\"number\" 时 HTML 中输入的值也总是会返回字符串类型。\n.trim\n\n如果要自动过滤用户输入的首尾空格，可以添加 trim 修饰符到 v-model 上过滤输入：\n<input v-model.trim=\"msg\">\n```\n","slug":"vue","published":1,"updated":"2019-07-31T09:22:09.869Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2fu41zy0013f18s84omiioj","content":"<h3 id=\"js\"><a href=\"#js\" class=\"headerlink\" title=\"js\"></a>js</h3><ol>\n<li><p>js 链接 defer 和 async</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">defer 和 async 都是并行加载的，主要区别在于下载后何时执行。</span><br><span class=\"line\">每一个 async 属性的脚本都在它下载结束之后立刻执行，所以就有可能出现脚本执行顺序被打乱的情况</span><br><span class=\"line\">每一个 defer 属性的脚本会在 HTML 解析完成后, DOMContentLoaded 之前，按照 DOM 中的顺序执行（ie&gt;=10）</span><br><span class=\"line\">defer 和 async 都只适用于外部脚本文件，对与内联的 script 标签是不起作用</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>preload 用 “as” 或者用 “type” 属性来表示他们请求资源的优先级（比如说 preload 使用 as=”style” 属性将获得最高的优先级）。没有 “as” 属性的将被看作异步请求，“Early”意味着在所有未被预加载的图片请求之前被请求（“late”意味着之后）</p>\n</li>\n<li>WebRTC，名称源自网页即时通信（英语：Web Real-Time Communication）的缩写，是一个支持网页浏览器进行实时语音对话或视频对话的API。</li>\n<li>Vue-intro  新功能引导  </li>\n<li><p><strong>proto</strong> 属性，这是历史遗留的非标准的语法，但在现代浏览器中广泛实现。获得原型的更可靠方法是使用 Object.getPrototypeOf(new Object())；例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> car = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> list = []</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(car));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(list));</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Object.prototype.toString.call(variable) 用这个方法来判断变量类型目前是最可靠的了，它总能返回正确的值。</p>\n<p>该方法返回 “[object type]”, 其中type是对象类型。</p>\n</li>\n<li>document.getElementsByClassName(‘test’);</li>\n<li></li>\n</ol>\n<h3 id=\"内部机制\"><a href=\"#内部机制\" class=\"headerlink\" title=\"内部机制\"></a>内部机制</h3><p>vue-loader </p>\n<p>compiler 目录包含 Vue.js 所有编译相关的代码。它包括把模板解析成 ast 语法树，ast 语法树优化，代码生成等功能。</p>\n<p>微任务的例子：micortask</p>\n<p>process.nextTick<br>promise<br>Object.observe</p>\n<p>宏任务的例子：</p>\n<p>setTimeout<br>setInterval<br>setImmediate<br>I/O</p>\n<p>需要注意的是node 和 浏览器的 event loop 是有区别的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">浏览器的事件循环：</span><br><span class=\"line\"></span><br><span class=\"line\">执行全局Script同步代码，这些同步代码有一些是同步语句，有一些是异步语句（比如setTimeout等）；</span><br><span class=\"line\">全局Script代码执行完毕后，调用栈Stack会清空；</span><br><span class=\"line\">从微队列microtask queue中取出位于队首的回调任务，放入调用栈Stack中执行，执行完后microtask queue长度减1；</span><br><span class=\"line\">继续取出位于队首的任务，放入调用栈Stack中执行，以此类推，直到直到把microtask queue中的所有任务都执行完毕。注意，如果在执行microtask的过程中，又产生了microtask，那么会加入到队列的末尾，也会在这个周期被调用执行；</span><br><span class=\"line\">microtask queue中的所有任务都执行完毕，此时microtask queue为空队列，调用栈Stack也为空；</span><br><span class=\"line\">取出宏队列macrotask queue中位于队首的任务，放入Stack中执行；</span><br><span class=\"line\">执行完毕后，调用栈Stack为空；</span><br><span class=\"line\">重复第3-7个步骤；</span><br><span class=\"line\">重复第3-7个步骤；</span><br><span class=\"line\">……</span><br><span class=\"line\"></span><br><span class=\"line\">NodeJS中微队列主要有2个：</span><br><span class=\"line\">Next Tick Queue：是放置process.nextTick(callback)的回调任务的</span><br><span class=\"line\">Other Micro Queue：放置其他microtask，比如Promise等</span><br><span class=\"line\"></span><br><span class=\"line\">具体参见： https://segmentfault.com/a/1190000016278115</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">timers 阶段：这个阶段执行timer（setTimeout、setInterval）的回调</span><br><span class=\"line\">I/O callbacks 阶段：执行一些系统调用错误，比如网络通信的错误回调</span><br><span class=\"line\">idle, prepare 阶段：仅node内部使用</span><br><span class=\"line\">poll 阶段：获取新的I/O事件, 适当的条件下node将阻塞在这里</span><br><span class=\"line\">check 阶段：执行 setImmediate() 的回调</span><br><span class=\"line\">close callbacks 阶段：执行 socket 的 close 事件回调</span><br><span class=\"line\"></span><br><span class=\"line\">timers 是事件循环的第一个阶段，Node 会去检查有无已过期的timer，如果有则把它的回调压入timer的任务队列中等待执行，事实上，Node 并不能保证timer在预设时间到了就会立即执行，因为Node对timer的过期检查不一定靠谱，它会受机器上其它运行程序影响，或者那个时间点主线程不空闲。比如下面的代码，setTimeout() 和 setImmediate() 的执行顺序是不确定的。</span><br><span class=\"line\"></span><br><span class=\"line\">poll 阶段</span><br><span class=\"line\">poll 阶段主要有2个功能：</span><br><span class=\"line\"></span><br><span class=\"line\">处理 poll 队列的事件</span><br><span class=\"line\">当有已超时的 timer，执行它的回调函数</span><br><span class=\"line\">even loop将同步执行poll队列里的回调，直到队列为空或执行的回调达到系统上限（上限具体多少未详），接下来even loop会去检查有无预设的setImmediate()，分两种情况：</span><br><span class=\"line\"></span><br><span class=\"line\">若有预设的setImmediate(), event loop将结束poll阶段进入check阶段，并执行check阶段的任务队列</span><br><span class=\"line\">若没有预设的setImmediate()，event loop将阻塞在该阶段等待</span><br><span class=\"line\">注意一个细节，没有setImmediate()会导致event loop阻塞在poll阶段，这样之前设置的timer岂不是执行不了了？所以咧，在poll阶段event loop会有一个检查机制，检查timer队列是否为空，如果timer队列非空，event loop就开始下一轮事件循环，即重新进入到timer阶段。</span><br><span class=\"line\"></span><br><span class=\"line\">check 阶段</span><br><span class=\"line\">setImmediate()的回调会被加入check队列中， 从event loop的阶段图可以知道，check阶段的执行顺序在poll阶段之后。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">回顾上一篇，浏览器环境下，microtask的任务队列是每个macrotask执行完之后执行。而在Node.js中，microtask会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行microtask队列的任务。详见：http://lynnelv.github.io/js-event-loop-nodejs</span><br><span class=\"line\"></span><br><span class=\"line\">process.nextTick() 会在各个事件阶段之间执行，一旦执行，要直到nextTick队列被清空，才会进入到下一个事件阶段，所以如果递归调用 process.nextTick()，会导致出现I/O starving（饥饿）的问题</span><br><span class=\"line\"></span><br><span class=\"line\">官方文档：https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/</span><br></pre></td></tr></table></figure>\n<p>###vitual dom</p>\n<p> Vue.js 实现响应式的核心是利用了 ES5 的 Object.defineProperty，这也是为什么 Vue.js 不能兼容 IE8 及以下浏览器的原因，我们先来对它有个直观的认识。值改变时会触发set方法。</p>\n<p> 核心就是利用 Object.defineProperty 给数据添加了 getter 和 setter，目的就是为了在我们访问数据以及写数据的时候能自动执行一些逻辑：getter 做的事情是依赖收集，setter 做的事情是派发更新</p>\n<p> 它会先执行 vm._render() 方法，因为之前分析过这个方法会生成 渲染 VNode，并且在这个过程中会对 vm 上的数据访问，这个时候就触发了数据对象的 getter。</p>\n<p> 它并不会每次数据改变都触发 watcher 的回调，而是把这些 watcher 先添加到一个队列里，然后在 nextTick 后执行 flushSchedulerQueue。</p>\n<p>VD 最大的特点是将页面的状态抽象为 JS 对象的形式，配合不同的渲染工具，使跨平台渲染成为可能。如 React 就借助 VD 实现了服务端渲染、浏览器渲染和移动端渲染等功能。<br>js计算-》生成渲染树-》渲染页面</p>\n<p>通过VD的比较，我们可以将多个操作合并成一个批量的操作，从而减少dom重排的次数，进而缩短了生成渲染树和绘制所花的时间。</p>\n<p>在mounted 方法中会将template 编译成为render 方法。这是一个编译过程，render中会调用createElement 创建vnode。</p>\n<p><img src=\"https://ustbhuangyi.github.io/vue-analysis/assets/new-vue.png\" alt=\"流程图片\"></p>\n<p>回到 mountComponent 函数的过程，我们已经知道 createElement 是如何创建了一个 VNode，接下来就是要把这个 VNode 渲染成一个真实的 DOM 并渲染出来，这个过程是通过 vm._update 完成的</p>\n<p>Vue 的 _update 是实例的一个私有方法，它被调用的时机有 2 个，一个是首次渲染，一个是数据更新的时候；由于我们这一章节只分析首次渲染部分，数据更新部分会在之后分析响应式原理的时候涉及。_update 方法的作用是把 VNode 渲染成真实的 DOM</p>\n<p>在我们之前对 setter 的分析过程知道，当响应式数据发送变化后，触发了 watcher.update()，只是把这个 watcher 推送到一个队列中，在 nextTick 后才会真正执行 watcher 的回调函数。而一旦我们设置了 sync，就可以在当前 Tick 中同步执行 watcher 的回调函数。</p>\n<p>deep watcher 和 sync watcher  </p>\n<h3 id=\"router-元数据\"><a href=\"#router-元数据\" class=\"headerlink\" title=\"router 元数据\"></a>router 元数据</h3><p> meta: { requiresAuth: true }  </p>\n<h5 id=\"v-once-指令，你也能执行一次性地插值\"><a href=\"#v-once-指令，你也能执行一次性地插值\" class=\"headerlink\" title=\"v-once 指令，你也能执行一次性地插值\"></a>v-once 指令，你也能执行一次性地插值</h5><h4 id=\"v-slot-新的用法\"><a href=\"#v-slot-新的用法\" class=\"headerlink\" title=\"v-slot 新的用法\"></a>v-slot 新的用法</h4><p>v-slot 的别名是#。因此，可以用#header=”data” 来代替 v-slot:header=”data”。还可以使用 #header来代替 v-slot:header(前提:不是作用域插槽时)。对于默认插槽，在使用别名时需要指定默认名称。换句话说，需要这样写 #default=”data” 而不是#=”data”。</p>\n<h5 id=\"Mustache-不能在-HTML-属性中使用，应使用-v-bind-指令：\"><a href=\"#Mustache-不能在-HTML-属性中使用，应使用-v-bind-指令：\" class=\"headerlink\" title=\"Mustache 不能在 HTML 属性中使用，应使用 v-bind 指令：\"></a>Mustache 不能在 HTML 属性中使用，应使用 v-bind 指令：</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<h5 id=\"修饰符（Modifiers）是以半角句号-指明的特殊后缀，用于指出一个指定应该以特殊方式绑定。例如，-prevent-修饰符告诉-v-on-指令对于触发的事件调用-event-preventDefault\"><a href=\"#修饰符（Modifiers）是以半角句号-指明的特殊后缀，用于指出一个指定应该以特殊方式绑定。例如，-prevent-修饰符告诉-v-on-指令对于触发的事件调用-event-preventDefault\" class=\"headerlink\" title=\"修饰符（Modifiers）是以半角句号 . 指明的特殊后缀，用于指出一个指定应该以特殊方式绑定。例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()\"></a>修饰符（Modifiers）是以半角句号 . 指明的特殊后缀，用于指出一个指定应该以特殊方式绑定。例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 阻止单击事件冒泡 --&gt;</span><br><span class=\"line\">&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">&lt;!-- 提交事件不再重载页面 --&gt;</span><br><span class=\"line\">&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;</span><br><span class=\"line\">&lt;!-- 修饰符可以串联  --&gt;</span><br><span class=\"line\">&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">&lt;!-- 只有修饰符 --&gt;</span><br><span class=\"line\">&lt;form v-on:submit.prevent&gt;&lt;/form&gt;</span><br><span class=\"line\">&lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt;</span><br><span class=\"line\">&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;</span><br><span class=\"line\">&lt;!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 --&gt;</span><br><span class=\"line\">&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;</span><br><span class=\"line\">&lt;a v-on:click.once=&quot;doThis&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n<h5 id=\"过滤器函数总接受表达式的值作为第一个参数。\"><a href=\"#过滤器函数总接受表达式的值作为第一个参数。\" class=\"headerlink\" title=\"过滤器函数总接受表达式的值作为第一个参数。\"></a>过滤器函数总接受表达式的值作为第一个参数。</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">  filters: &#123;</span><br><span class=\"line\">    capitalize: function (value) &#123;</span><br><span class=\"line\">      if (!value) return &apos;&apos;</span><br><span class=\"line\">      value = value.toString()</span><br><span class=\"line\">      return value.charAt(0).toUpperCase() + value.slice(1)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">过滤器可以串联：</span><br><span class=\"line\">&#123;&#123; message | filterA | filterB &#125;&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"v-bind-缩写\"><a href=\"#v-bind-缩写\" class=\"headerlink\" title=\"v-bind 缩写\"></a>v-bind 缩写</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 完整语法 --&gt;</span><br><span class=\"line\">&lt;a v-bind:href=&quot;url&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">&lt;!-- 缩写 --&gt;</span><br><span class=\"line\">&lt;a :href=&quot;url&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">v-on 缩写</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 完整语法 --&gt;</span><br><span class=\"line\">&lt;a v-on:click=&quot;doSomething&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">&lt;!-- 缩写 --&gt;</span><br><span class=\"line\">&lt;a @click=&quot;doSomething&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n<h5 id=\"按键修饰符\"><a href=\"#按键修饰符\" class=\"headerlink\" title=\"按键修饰符\"></a>按键修饰符</h5><p>记住所有的 keyCode 比较困难，所以 Vue 为最常用的按键提供了别名：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 同上 --&gt;</span><br><span class=\"line\">&lt;input v-on:keyup.enter=&quot;submit&quot;&gt;</span><br><span class=\"line\">&lt;!-- 缩写语法 --&gt;</span><br><span class=\"line\">&lt;input @keyup.enter=&quot;submit&quot;&gt;</span><br><span class=\"line\">全部的按键别名：</span><br><span class=\"line\">.enter</span><br><span class=\"line\">.tab</span><br><span class=\"line\">.delete (捕获 “删除” 和 “退格” 键)</span><br><span class=\"line\">.esc</span><br><span class=\"line\">.space</span><br><span class=\"line\">.up</span><br><span class=\"line\">.down</span><br><span class=\"line\">.left</span><br><span class=\"line\">.right</span><br></pre></td></tr></table></figure>\n<h5 id=\"绑定属性值\"><a href=\"#绑定属性值\" class=\"headerlink\" title=\"绑定属性值\"></a>绑定属性值</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input</span><br><span class=\"line\">  type=&quot;checkbox&quot;</span><br><span class=\"line\">  v-model=&quot;toggle&quot;</span><br><span class=\"line\">  v-bind:true-value=&quot;a&quot;</span><br><span class=\"line\">  v-bind:false-value=&quot;b&quot;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n<h5 id=\"修饰符\"><a href=\"#修饰符\" class=\"headerlink\" title=\"修饰符\"></a>修饰符</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在默认情况下， v-model 在 input 事件中同步输入框的值与数据 (除了 上述 IME 部分)，但你可以添加一个修饰符 lazy ，从而转变为在 change 事件中同步：</span><br><span class=\"line\">&lt;!-- 在 &quot;change&quot; 而不是 &quot;input&quot; 事件中更新 --&gt;</span><br><span class=\"line\">&lt;input v-model.lazy=&quot;msg&quot; &gt;</span><br><span class=\"line\">.number</span><br><span class=\"line\"></span><br><span class=\"line\">如果想自动将用户的输入值转为 Number 类型（如果原值的转换结果为 NaN 则返回原值），可以添加一个修饰符 number 给 v-model 来处理输入值：</span><br><span class=\"line\">&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt;</span><br><span class=\"line\">这通常很有用，因为在 type=&quot;number&quot; 时 HTML 中输入的值也总是会返回字符串类型。</span><br><span class=\"line\">.trim</span><br><span class=\"line\"></span><br><span class=\"line\">如果要自动过滤用户输入的首尾空格，可以添加 trim 修饰符到 v-model 上过滤输入：</span><br><span class=\"line\">&lt;input v-model.trim=&quot;msg&quot;&gt;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"js\"><a href=\"#js\" class=\"headerlink\" title=\"js\"></a>js</h3><ol>\n<li><p>js 链接 defer 和 async</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">defer 和 async 都是并行加载的，主要区别在于下载后何时执行。</span><br><span class=\"line\">每一个 async 属性的脚本都在它下载结束之后立刻执行，所以就有可能出现脚本执行顺序被打乱的情况</span><br><span class=\"line\">每一个 defer 属性的脚本会在 HTML 解析完成后, DOMContentLoaded 之前，按照 DOM 中的顺序执行（ie&gt;=10）</span><br><span class=\"line\">defer 和 async 都只适用于外部脚本文件，对与内联的 script 标签是不起作用</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>preload 用 “as” 或者用 “type” 属性来表示他们请求资源的优先级（比如说 preload 使用 as=”style” 属性将获得最高的优先级）。没有 “as” 属性的将被看作异步请求，“Early”意味着在所有未被预加载的图片请求之前被请求（“late”意味着之后）</p>\n</li>\n<li>WebRTC，名称源自网页即时通信（英语：Web Real-Time Communication）的缩写，是一个支持网页浏览器进行实时语音对话或视频对话的API。</li>\n<li>Vue-intro  新功能引导  </li>\n<li><p><strong>proto</strong> 属性，这是历史遗留的非标准的语法，但在现代浏览器中广泛实现。获得原型的更可靠方法是使用 Object.getPrototypeOf(new Object())；例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> car = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> list = []</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(car));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getPrototypeOf(list));</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Object.prototype.toString.call(variable) 用这个方法来判断变量类型目前是最可靠的了，它总能返回正确的值。</p>\n<p>该方法返回 “[object type]”, 其中type是对象类型。</p>\n</li>\n<li>document.getElementsByClassName(‘test’);</li>\n<li></li>\n</ol>\n<h3 id=\"内部机制\"><a href=\"#内部机制\" class=\"headerlink\" title=\"内部机制\"></a>内部机制</h3><p>vue-loader </p>\n<p>compiler 目录包含 Vue.js 所有编译相关的代码。它包括把模板解析成 ast 语法树，ast 语法树优化，代码生成等功能。</p>\n<p>微任务的例子：micortask</p>\n<p>process.nextTick<br>promise<br>Object.observe</p>\n<p>宏任务的例子：</p>\n<p>setTimeout<br>setInterval<br>setImmediate<br>I/O</p>\n<p>需要注意的是node 和 浏览器的 event loop 是有区别的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">浏览器的事件循环：</span><br><span class=\"line\"></span><br><span class=\"line\">执行全局Script同步代码，这些同步代码有一些是同步语句，有一些是异步语句（比如setTimeout等）；</span><br><span class=\"line\">全局Script代码执行完毕后，调用栈Stack会清空；</span><br><span class=\"line\">从微队列microtask queue中取出位于队首的回调任务，放入调用栈Stack中执行，执行完后microtask queue长度减1；</span><br><span class=\"line\">继续取出位于队首的任务，放入调用栈Stack中执行，以此类推，直到直到把microtask queue中的所有任务都执行完毕。注意，如果在执行microtask的过程中，又产生了microtask，那么会加入到队列的末尾，也会在这个周期被调用执行；</span><br><span class=\"line\">microtask queue中的所有任务都执行完毕，此时microtask queue为空队列，调用栈Stack也为空；</span><br><span class=\"line\">取出宏队列macrotask queue中位于队首的任务，放入Stack中执行；</span><br><span class=\"line\">执行完毕后，调用栈Stack为空；</span><br><span class=\"line\">重复第3-7个步骤；</span><br><span class=\"line\">重复第3-7个步骤；</span><br><span class=\"line\">……</span><br><span class=\"line\"></span><br><span class=\"line\">NodeJS中微队列主要有2个：</span><br><span class=\"line\">Next Tick Queue：是放置process.nextTick(callback)的回调任务的</span><br><span class=\"line\">Other Micro Queue：放置其他microtask，比如Promise等</span><br><span class=\"line\"></span><br><span class=\"line\">具体参见： https://segmentfault.com/a/1190000016278115</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">timers 阶段：这个阶段执行timer（setTimeout、setInterval）的回调</span><br><span class=\"line\">I/O callbacks 阶段：执行一些系统调用错误，比如网络通信的错误回调</span><br><span class=\"line\">idle, prepare 阶段：仅node内部使用</span><br><span class=\"line\">poll 阶段：获取新的I/O事件, 适当的条件下node将阻塞在这里</span><br><span class=\"line\">check 阶段：执行 setImmediate() 的回调</span><br><span class=\"line\">close callbacks 阶段：执行 socket 的 close 事件回调</span><br><span class=\"line\"></span><br><span class=\"line\">timers 是事件循环的第一个阶段，Node 会去检查有无已过期的timer，如果有则把它的回调压入timer的任务队列中等待执行，事实上，Node 并不能保证timer在预设时间到了就会立即执行，因为Node对timer的过期检查不一定靠谱，它会受机器上其它运行程序影响，或者那个时间点主线程不空闲。比如下面的代码，setTimeout() 和 setImmediate() 的执行顺序是不确定的。</span><br><span class=\"line\"></span><br><span class=\"line\">poll 阶段</span><br><span class=\"line\">poll 阶段主要有2个功能：</span><br><span class=\"line\"></span><br><span class=\"line\">处理 poll 队列的事件</span><br><span class=\"line\">当有已超时的 timer，执行它的回调函数</span><br><span class=\"line\">even loop将同步执行poll队列里的回调，直到队列为空或执行的回调达到系统上限（上限具体多少未详），接下来even loop会去检查有无预设的setImmediate()，分两种情况：</span><br><span class=\"line\"></span><br><span class=\"line\">若有预设的setImmediate(), event loop将结束poll阶段进入check阶段，并执行check阶段的任务队列</span><br><span class=\"line\">若没有预设的setImmediate()，event loop将阻塞在该阶段等待</span><br><span class=\"line\">注意一个细节，没有setImmediate()会导致event loop阻塞在poll阶段，这样之前设置的timer岂不是执行不了了？所以咧，在poll阶段event loop会有一个检查机制，检查timer队列是否为空，如果timer队列非空，event loop就开始下一轮事件循环，即重新进入到timer阶段。</span><br><span class=\"line\"></span><br><span class=\"line\">check 阶段</span><br><span class=\"line\">setImmediate()的回调会被加入check队列中， 从event loop的阶段图可以知道，check阶段的执行顺序在poll阶段之后。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">回顾上一篇，浏览器环境下，microtask的任务队列是每个macrotask执行完之后执行。而在Node.js中，microtask会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行microtask队列的任务。详见：http://lynnelv.github.io/js-event-loop-nodejs</span><br><span class=\"line\"></span><br><span class=\"line\">process.nextTick() 会在各个事件阶段之间执行，一旦执行，要直到nextTick队列被清空，才会进入到下一个事件阶段，所以如果递归调用 process.nextTick()，会导致出现I/O starving（饥饿）的问题</span><br><span class=\"line\"></span><br><span class=\"line\">官方文档：https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/</span><br></pre></td></tr></table></figure>\n<p>###vitual dom</p>\n<p> Vue.js 实现响应式的核心是利用了 ES5 的 Object.defineProperty，这也是为什么 Vue.js 不能兼容 IE8 及以下浏览器的原因，我们先来对它有个直观的认识。值改变时会触发set方法。</p>\n<p> 核心就是利用 Object.defineProperty 给数据添加了 getter 和 setter，目的就是为了在我们访问数据以及写数据的时候能自动执行一些逻辑：getter 做的事情是依赖收集，setter 做的事情是派发更新</p>\n<p> 它会先执行 vm._render() 方法，因为之前分析过这个方法会生成 渲染 VNode，并且在这个过程中会对 vm 上的数据访问，这个时候就触发了数据对象的 getter。</p>\n<p> 它并不会每次数据改变都触发 watcher 的回调，而是把这些 watcher 先添加到一个队列里，然后在 nextTick 后执行 flushSchedulerQueue。</p>\n<p>VD 最大的特点是将页面的状态抽象为 JS 对象的形式，配合不同的渲染工具，使跨平台渲染成为可能。如 React 就借助 VD 实现了服务端渲染、浏览器渲染和移动端渲染等功能。<br>js计算-》生成渲染树-》渲染页面</p>\n<p>通过VD的比较，我们可以将多个操作合并成一个批量的操作，从而减少dom重排的次数，进而缩短了生成渲染树和绘制所花的时间。</p>\n<p>在mounted 方法中会将template 编译成为render 方法。这是一个编译过程，render中会调用createElement 创建vnode。</p>\n<p><img src=\"https://ustbhuangyi.github.io/vue-analysis/assets/new-vue.png\" alt=\"流程图片\"></p>\n<p>回到 mountComponent 函数的过程，我们已经知道 createElement 是如何创建了一个 VNode，接下来就是要把这个 VNode 渲染成一个真实的 DOM 并渲染出来，这个过程是通过 vm._update 完成的</p>\n<p>Vue 的 _update 是实例的一个私有方法，它被调用的时机有 2 个，一个是首次渲染，一个是数据更新的时候；由于我们这一章节只分析首次渲染部分，数据更新部分会在之后分析响应式原理的时候涉及。_update 方法的作用是把 VNode 渲染成真实的 DOM</p>\n<p>在我们之前对 setter 的分析过程知道，当响应式数据发送变化后，触发了 watcher.update()，只是把这个 watcher 推送到一个队列中，在 nextTick 后才会真正执行 watcher 的回调函数。而一旦我们设置了 sync，就可以在当前 Tick 中同步执行 watcher 的回调函数。</p>\n<p>deep watcher 和 sync watcher  </p>\n<h3 id=\"router-元数据\"><a href=\"#router-元数据\" class=\"headerlink\" title=\"router 元数据\"></a>router 元数据</h3><p> meta: { requiresAuth: true }  </p>\n<h5 id=\"v-once-指令，你也能执行一次性地插值\"><a href=\"#v-once-指令，你也能执行一次性地插值\" class=\"headerlink\" title=\"v-once 指令，你也能执行一次性地插值\"></a>v-once 指令，你也能执行一次性地插值</h5><h4 id=\"v-slot-新的用法\"><a href=\"#v-slot-新的用法\" class=\"headerlink\" title=\"v-slot 新的用法\"></a>v-slot 新的用法</h4><p>v-slot 的别名是#。因此，可以用#header=”data” 来代替 v-slot:header=”data”。还可以使用 #header来代替 v-slot:header(前提:不是作用域插槽时)。对于默认插槽，在使用别名时需要指定默认名称。换句话说，需要这样写 #default=”data” 而不是#=”data”。</p>\n<h5 id=\"Mustache-不能在-HTML-属性中使用，应使用-v-bind-指令：\"><a href=\"#Mustache-不能在-HTML-属性中使用，应使用-v-bind-指令：\" class=\"headerlink\" title=\"Mustache 不能在 HTML 属性中使用，应使用 v-bind 指令：\"></a>Mustache 不能在 HTML 属性中使用，应使用 v-bind 指令：</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<h5 id=\"修饰符（Modifiers）是以半角句号-指明的特殊后缀，用于指出一个指定应该以特殊方式绑定。例如，-prevent-修饰符告诉-v-on-指令对于触发的事件调用-event-preventDefault\"><a href=\"#修饰符（Modifiers）是以半角句号-指明的特殊后缀，用于指出一个指定应该以特殊方式绑定。例如，-prevent-修饰符告诉-v-on-指令对于触发的事件调用-event-preventDefault\" class=\"headerlink\" title=\"修饰符（Modifiers）是以半角句号 . 指明的特殊后缀，用于指出一个指定应该以特殊方式绑定。例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()\"></a>修饰符（Modifiers）是以半角句号 . 指明的特殊后缀，用于指出一个指定应该以特殊方式绑定。例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 阻止单击事件冒泡 --&gt;</span><br><span class=\"line\">&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">&lt;!-- 提交事件不再重载页面 --&gt;</span><br><span class=\"line\">&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;</span><br><span class=\"line\">&lt;!-- 修饰符可以串联  --&gt;</span><br><span class=\"line\">&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">&lt;!-- 只有修饰符 --&gt;</span><br><span class=\"line\">&lt;form v-on:submit.prevent&gt;&lt;/form&gt;</span><br><span class=\"line\">&lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt;</span><br><span class=\"line\">&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;</span><br><span class=\"line\">&lt;!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 --&gt;</span><br><span class=\"line\">&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;</span><br><span class=\"line\">&lt;a v-on:click.once=&quot;doThis&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n<h5 id=\"过滤器函数总接受表达式的值作为第一个参数。\"><a href=\"#过滤器函数总接受表达式的值作为第一个参数。\" class=\"headerlink\" title=\"过滤器函数总接受表达式的值作为第一个参数。\"></a>过滤器函数总接受表达式的值作为第一个参数。</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">  filters: &#123;</span><br><span class=\"line\">    capitalize: function (value) &#123;</span><br><span class=\"line\">      if (!value) return &apos;&apos;</span><br><span class=\"line\">      value = value.toString()</span><br><span class=\"line\">      return value.charAt(0).toUpperCase() + value.slice(1)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">过滤器可以串联：</span><br><span class=\"line\">&#123;&#123; message | filterA | filterB &#125;&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"v-bind-缩写\"><a href=\"#v-bind-缩写\" class=\"headerlink\" title=\"v-bind 缩写\"></a>v-bind 缩写</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 完整语法 --&gt;</span><br><span class=\"line\">&lt;a v-bind:href=&quot;url&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">&lt;!-- 缩写 --&gt;</span><br><span class=\"line\">&lt;a :href=&quot;url&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">v-on 缩写</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 完整语法 --&gt;</span><br><span class=\"line\">&lt;a v-on:click=&quot;doSomething&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">&lt;!-- 缩写 --&gt;</span><br><span class=\"line\">&lt;a @click=&quot;doSomething&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n<h5 id=\"按键修饰符\"><a href=\"#按键修饰符\" class=\"headerlink\" title=\"按键修饰符\"></a>按键修饰符</h5><p>记住所有的 keyCode 比较困难，所以 Vue 为最常用的按键提供了别名：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 同上 --&gt;</span><br><span class=\"line\">&lt;input v-on:keyup.enter=&quot;submit&quot;&gt;</span><br><span class=\"line\">&lt;!-- 缩写语法 --&gt;</span><br><span class=\"line\">&lt;input @keyup.enter=&quot;submit&quot;&gt;</span><br><span class=\"line\">全部的按键别名：</span><br><span class=\"line\">.enter</span><br><span class=\"line\">.tab</span><br><span class=\"line\">.delete (捕获 “删除” 和 “退格” 键)</span><br><span class=\"line\">.esc</span><br><span class=\"line\">.space</span><br><span class=\"line\">.up</span><br><span class=\"line\">.down</span><br><span class=\"line\">.left</span><br><span class=\"line\">.right</span><br></pre></td></tr></table></figure>\n<h5 id=\"绑定属性值\"><a href=\"#绑定属性值\" class=\"headerlink\" title=\"绑定属性值\"></a>绑定属性值</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input</span><br><span class=\"line\">  type=&quot;checkbox&quot;</span><br><span class=\"line\">  v-model=&quot;toggle&quot;</span><br><span class=\"line\">  v-bind:true-value=&quot;a&quot;</span><br><span class=\"line\">  v-bind:false-value=&quot;b&quot;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n<h5 id=\"修饰符\"><a href=\"#修饰符\" class=\"headerlink\" title=\"修饰符\"></a>修饰符</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在默认情况下， v-model 在 input 事件中同步输入框的值与数据 (除了 上述 IME 部分)，但你可以添加一个修饰符 lazy ，从而转变为在 change 事件中同步：</span><br><span class=\"line\">&lt;!-- 在 &quot;change&quot; 而不是 &quot;input&quot; 事件中更新 --&gt;</span><br><span class=\"line\">&lt;input v-model.lazy=&quot;msg&quot; &gt;</span><br><span class=\"line\">.number</span><br><span class=\"line\"></span><br><span class=\"line\">如果想自动将用户的输入值转为 Number 类型（如果原值的转换结果为 NaN 则返回原值），可以添加一个修饰符 number 给 v-model 来处理输入值：</span><br><span class=\"line\">&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt;</span><br><span class=\"line\">这通常很有用，因为在 type=&quot;number&quot; 时 HTML 中输入的值也总是会返回字符串类型。</span><br><span class=\"line\">.trim</span><br><span class=\"line\"></span><br><span class=\"line\">如果要自动过滤用户输入的首尾空格，可以添加 trim 修饰符到 v-model 上过滤输入：</span><br><span class=\"line\">&lt;input v-model.trim=&quot;msg&quot;&gt;</span><br></pre></td></tr></table></figure>\n"},{"title":"webpack","date":"2017-01-17T06:58:02.000Z","_content":"### babel相关\n1. 虽然@babel/polyfill提供了我们想要的所有新方法新类，但是这里依然存在一些问题：\n   \n   体积太大：比如我只用了String的新特性，但是我把整个包都引进来了，，这不是徒增了很多无用的代码。\n   污染全局环境：如果你引用了 @babel/polyfill，那么像Promise这样的新类就是挂载在全局上的，这样就会污染了全局命名空间。可能在一个团建建立的项目问题不太大，但是如果你是一个工具的开发者，你把全局环境污染了，别人用你的工具，就有可能把别人给坑了\n   \n1.  @babel/plugin-transform-runtime会为代码创建一个沙盒环境，为core-js这里内建的实例提供假名，你可以无缝的使用这些新特性，而不需要使用require polyfill。\n    \n    一个解决方案就是引入transform runtime 来替代 @babel/polyfill。\n    幸运的是，我们有env这个preset，它又一个useBuiltIns选项，如果设置成\"usage\"，那么将会自动检测语法帮你require你代码中使用到的功能。  \n1. @babel/core\n   其中最核心的包就是@babel/core，它主要的作用就是编译.\n   \n   Babel-cli \n   光有core是无法在命令行使用这些功能的，@babel/cli支持你直接在命令行中编译代码。\n   这句话会编译你src目录下的所有js代码，并编译成你想要的那样（babel.config.js配置的），并输出到lib目录下。 \n1. @babel/preset-env\n如果useBuiltIns为true，项目中必须引入babel-polyfill。\n\n\n1. Vue Loader 是一个 webpack 的 loader，它允许你以一种名为单文件组件 (SFCs)的格式撰写 Vue 组件.   \n1. autoprefixer 自动补充前缀\n\n1. Hot Module Replacement（以下简称 HMR）是 webpack 发展至今引入的最令人兴奋的特性之一 ，当你对代码进行修改并保存后，webpack 将对代码重新打包，并将新的模块发送到浏览器端，浏览器通过新的模块替换老的模块，这样在不刷新浏览器的前提下就能够对应用进行更新。\n1.  webpack-dev-server 修改了webpack 配置中的 entry 属性，在里面添加了 webpack-dev-client 的代码，这样在最后的 bundle.js 文件中就会有接收 websocket 消息的代码了。\n1. \n1. WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。\n\n1. Webpack splitchunk 将各个模块的交集部分抽离出来 \n\n1. Webpack ProvidePlugin 自动加载js，不必import。\n   new webpack.ProvidePlugin({\n     _map: ['lodash', 'map']\n   })\n\n1. Webpack在打包时可以为我们生成的source maps，这为我们提供了一种对应编译文件和源文件的方法，使得编译后的代码可读性更高，也更容易调试\n\n具体配置参考：http://www.jianshu.com/p/42e11515c10f\n\n感叹号的作用在于使同一文件能够使用不同类型的loader\n\n对css 分模块：\n\n```\n{\n        test: /\\.css$/,\n        loader: 'style!css?modules'//跟前面相比就在后面加上了?modules\n}\n```\n\nLoaders和Plugins常常被弄混，但是他们其实是完全不同的东西，可以这么来说，loaders是在打包构建过程中用来处理源文件的（JSX，Scss，Less..），一次处理一个，插件并不直接操作单个文件，它直接对整个构建过程其作用。\n\n####  常用命令\n\n\n```\n$ webpack --config webpack.min.js //另一份配置文件\n\n$ webpack --display-error-details //显示异常信息\n\n$ webpack --watch   //监听变动并自动打包\n \n$ webpack -p    //压缩混淆脚本，这个非常非常重要！\n \n$ webpack -d    //生成map映射文件，告知哪些模块被最终打包到哪里了\n```\n\n对公共库的封装：\n\n```\nentry: {\n  vendor: [\"jquery\", \"other-lib\"],\n  app: \"./entry\"\n}\nnew CommonsChunkPlugin({\n  name: \"vendor\",\n\n  // filename: \"vendor.js\"\n  // (Give the chunk a different name)\n\n  minChunks: Infinity,\n  // (with more entries, this ensures that no other module\n  //  goes into the vendor chunk)\n})\n```\n\n关于express webpack middleware 的配置\n\nhttp://www.cnblogs.com/linfangshuhellowored/p/5657285.html\n\n给文件自动添加hash后缀\n\n根据chunkhash的定义知道，chunkhash是根据具体模块文件的内容计算所得的hash值，所以某个文件的改动只会影响它本身的hash指纹，不会影响其他文件。配置webpack的output如下：\n```\noutput: {\n    filename: '[name].[chunkhash:8].js',\n    path: __dirname + '/built'\n}\noutput: {\n    filename: '[name].[hash:8].js',\n    path: __dirname + '/built'\n}\n```","source":"_posts/webpack.md","raw":"---\ntitle: webpack\ndate: 2017-01-17 14:58:02\ntags: webpack  \n---\n### babel相关\n1. 虽然@babel/polyfill提供了我们想要的所有新方法新类，但是这里依然存在一些问题：\n   \n   体积太大：比如我只用了String的新特性，但是我把整个包都引进来了，，这不是徒增了很多无用的代码。\n   污染全局环境：如果你引用了 @babel/polyfill，那么像Promise这样的新类就是挂载在全局上的，这样就会污染了全局命名空间。可能在一个团建建立的项目问题不太大，但是如果你是一个工具的开发者，你把全局环境污染了，别人用你的工具，就有可能把别人给坑了\n   \n1.  @babel/plugin-transform-runtime会为代码创建一个沙盒环境，为core-js这里内建的实例提供假名，你可以无缝的使用这些新特性，而不需要使用require polyfill。\n    \n    一个解决方案就是引入transform runtime 来替代 @babel/polyfill。\n    幸运的是，我们有env这个preset，它又一个useBuiltIns选项，如果设置成\"usage\"，那么将会自动检测语法帮你require你代码中使用到的功能。  \n1. @babel/core\n   其中最核心的包就是@babel/core，它主要的作用就是编译.\n   \n   Babel-cli \n   光有core是无法在命令行使用这些功能的，@babel/cli支持你直接在命令行中编译代码。\n   这句话会编译你src目录下的所有js代码，并编译成你想要的那样（babel.config.js配置的），并输出到lib目录下。 \n1. @babel/preset-env\n如果useBuiltIns为true，项目中必须引入babel-polyfill。\n\n\n1. Vue Loader 是一个 webpack 的 loader，它允许你以一种名为单文件组件 (SFCs)的格式撰写 Vue 组件.   \n1. autoprefixer 自动补充前缀\n\n1. Hot Module Replacement（以下简称 HMR）是 webpack 发展至今引入的最令人兴奋的特性之一 ，当你对代码进行修改并保存后，webpack 将对代码重新打包，并将新的模块发送到浏览器端，浏览器通过新的模块替换老的模块，这样在不刷新浏览器的前提下就能够对应用进行更新。\n1.  webpack-dev-server 修改了webpack 配置中的 entry 属性，在里面添加了 webpack-dev-client 的代码，这样在最后的 bundle.js 文件中就会有接收 websocket 消息的代码了。\n1. \n1. WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。\n\n1. Webpack splitchunk 将各个模块的交集部分抽离出来 \n\n1. Webpack ProvidePlugin 自动加载js，不必import。\n   new webpack.ProvidePlugin({\n     _map: ['lodash', 'map']\n   })\n\n1. Webpack在打包时可以为我们生成的source maps，这为我们提供了一种对应编译文件和源文件的方法，使得编译后的代码可读性更高，也更容易调试\n\n具体配置参考：http://www.jianshu.com/p/42e11515c10f\n\n感叹号的作用在于使同一文件能够使用不同类型的loader\n\n对css 分模块：\n\n```\n{\n        test: /\\.css$/,\n        loader: 'style!css?modules'//跟前面相比就在后面加上了?modules\n}\n```\n\nLoaders和Plugins常常被弄混，但是他们其实是完全不同的东西，可以这么来说，loaders是在打包构建过程中用来处理源文件的（JSX，Scss，Less..），一次处理一个，插件并不直接操作单个文件，它直接对整个构建过程其作用。\n\n####  常用命令\n\n\n```\n$ webpack --config webpack.min.js //另一份配置文件\n\n$ webpack --display-error-details //显示异常信息\n\n$ webpack --watch   //监听变动并自动打包\n \n$ webpack -p    //压缩混淆脚本，这个非常非常重要！\n \n$ webpack -d    //生成map映射文件，告知哪些模块被最终打包到哪里了\n```\n\n对公共库的封装：\n\n```\nentry: {\n  vendor: [\"jquery\", \"other-lib\"],\n  app: \"./entry\"\n}\nnew CommonsChunkPlugin({\n  name: \"vendor\",\n\n  // filename: \"vendor.js\"\n  // (Give the chunk a different name)\n\n  minChunks: Infinity,\n  // (with more entries, this ensures that no other module\n  //  goes into the vendor chunk)\n})\n```\n\n关于express webpack middleware 的配置\n\nhttp://www.cnblogs.com/linfangshuhellowored/p/5657285.html\n\n给文件自动添加hash后缀\n\n根据chunkhash的定义知道，chunkhash是根据具体模块文件的内容计算所得的hash值，所以某个文件的改动只会影响它本身的hash指纹，不会影响其他文件。配置webpack的output如下：\n```\noutput: {\n    filename: '[name].[chunkhash:8].js',\n    path: __dirname + '/built'\n}\noutput: {\n    filename: '[name].[hash:8].js',\n    path: __dirname + '/built'\n}\n```","slug":"webpack","published":1,"updated":"2019-10-22T02:37:04.406Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2fu41zz0015f18swiv11hbb","content":"<h3 id=\"babel相关\"><a href=\"#babel相关\" class=\"headerlink\" title=\"babel相关\"></a>babel相关</h3><ol>\n<li><p>虽然@babel/polyfill提供了我们想要的所有新方法新类，但是这里依然存在一些问题：</p>\n<p>体积太大：比如我只用了String的新特性，但是我把整个包都引进来了，，这不是徒增了很多无用的代码。<br>污染全局环境：如果你引用了 @babel/polyfill，那么像Promise这样的新类就是挂载在全局上的，这样就会污染了全局命名空间。可能在一个团建建立的项目问题不太大，但是如果你是一个工具的开发者，你把全局环境污染了，别人用你的工具，就有可能把别人给坑了</p>\n</li>\n<li><p>@babel/plugin-transform-runtime会为代码创建一个沙盒环境，为core-js这里内建的实例提供假名，你可以无缝的使用这些新特性，而不需要使用require polyfill。</p>\n<p>一个解决方案就是引入transform runtime 来替代 @babel/polyfill。<br>幸运的是，我们有env这个preset，它又一个useBuiltIns选项，如果设置成”usage”，那么将会自动检测语法帮你require你代码中使用到的功能。  </p>\n</li>\n<li><p>@babel/core<br>其中最核心的包就是@babel/core，它主要的作用就是编译.</p>\n<p>Babel-cli<br>光有core是无法在命令行使用这些功能的，@babel/cli支持你直接在命令行中编译代码。<br>这句话会编译你src目录下的所有js代码，并编译成你想要的那样（babel.config.js配置的），并输出到lib目录下。 </p>\n</li>\n<li>@babel/preset-env<br>如果useBuiltIns为true，项目中必须引入babel-polyfill。</li>\n</ol>\n<ol>\n<li>Vue Loader 是一个 webpack 的 loader，它允许你以一种名为单文件组件 (SFCs)的格式撰写 Vue 组件.   </li>\n<li><p>autoprefixer 自动补充前缀</p>\n</li>\n<li><p>Hot Module Replacement（以下简称 HMR）是 webpack 发展至今引入的最令人兴奋的特性之一 ，当你对代码进行修改并保存后，webpack 将对代码重新打包，并将新的模块发送到浏览器端，浏览器通过新的模块替换老的模块，这样在不刷新浏览器的前提下就能够对应用进行更新。</p>\n</li>\n<li>webpack-dev-server 修改了webpack 配置中的 entry 属性，在里面添加了 webpack-dev-client 的代码，这样在最后的 bundle.js 文件中就会有接收 websocket 消息的代码了。</li>\n<li></li>\n<li><p>WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。</p>\n</li>\n<li><p>Webpack splitchunk 将各个模块的交集部分抽离出来 </p>\n</li>\n<li><p>Webpack ProvidePlugin 自动加载js，不必import。<br>new webpack.ProvidePlugin({<br>  _map: [‘lodash’, ‘map’]<br>})</p>\n</li>\n<li><p>Webpack在打包时可以为我们生成的source maps，这为我们提供了一种对应编译文件和源文件的方法，使得编译后的代码可读性更高，也更容易调试</p>\n</li>\n</ol>\n<p>具体配置参考：<a href=\"http://www.jianshu.com/p/42e11515c10f\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/42e11515c10f</a></p>\n<p>感叹号的作用在于使同一文件能够使用不同类型的loader</p>\n<p>对css 分模块：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">        test: /\\.css$/,</span><br><span class=\"line\">        loader: &apos;style!css?modules&apos;//跟前面相比就在后面加上了?modules</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Loaders和Plugins常常被弄混，但是他们其实是完全不同的东西，可以这么来说，loaders是在打包构建过程中用来处理源文件的（JSX，Scss，Less..），一次处理一个，插件并不直接操作单个文件，它直接对整个构建过程其作用。</p>\n<h4 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ webpack --config webpack.min.js //另一份配置文件</span><br><span class=\"line\"></span><br><span class=\"line\">$ webpack --display-error-details //显示异常信息</span><br><span class=\"line\"></span><br><span class=\"line\">$ webpack --watch   //监听变动并自动打包</span><br><span class=\"line\"> </span><br><span class=\"line\">$ webpack -p    //压缩混淆脚本，这个非常非常重要！</span><br><span class=\"line\"> </span><br><span class=\"line\">$ webpack -d    //生成map映射文件，告知哪些模块被最终打包到哪里了</span><br></pre></td></tr></table></figure>\n<p>对公共库的封装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">entry: &#123;</span><br><span class=\"line\">  vendor: [&quot;jquery&quot;, &quot;other-lib&quot;],</span><br><span class=\"line\">  app: &quot;./entry&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">new CommonsChunkPlugin(&#123;</span><br><span class=\"line\">  name: &quot;vendor&quot;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // filename: &quot;vendor.js&quot;</span><br><span class=\"line\">  // (Give the chunk a different name)</span><br><span class=\"line\"></span><br><span class=\"line\">  minChunks: Infinity,</span><br><span class=\"line\">  // (with more entries, this ensures that no other module</span><br><span class=\"line\">  //  goes into the vendor chunk)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>关于express webpack middleware 的配置</p>\n<p><a href=\"http://www.cnblogs.com/linfangshuhellowored/p/5657285.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/linfangshuhellowored/p/5657285.html</a></p>\n<p>给文件自动添加hash后缀</p>\n<p>根据chunkhash的定义知道，chunkhash是根据具体模块文件的内容计算所得的hash值，所以某个文件的改动只会影响它本身的hash指纹，不会影响其他文件。配置webpack的output如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">output: &#123;</span><br><span class=\"line\">    filename: &apos;[name].[chunkhash:8].js&apos;,</span><br><span class=\"line\">    path: __dirname + &apos;/built&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">output: &#123;</span><br><span class=\"line\">    filename: &apos;[name].[hash:8].js&apos;,</span><br><span class=\"line\">    path: __dirname + &apos;/built&apos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"babel相关\"><a href=\"#babel相关\" class=\"headerlink\" title=\"babel相关\"></a>babel相关</h3><ol>\n<li><p>虽然@babel/polyfill提供了我们想要的所有新方法新类，但是这里依然存在一些问题：</p>\n<p>体积太大：比如我只用了String的新特性，但是我把整个包都引进来了，，这不是徒增了很多无用的代码。<br>污染全局环境：如果你引用了 @babel/polyfill，那么像Promise这样的新类就是挂载在全局上的，这样就会污染了全局命名空间。可能在一个团建建立的项目问题不太大，但是如果你是一个工具的开发者，你把全局环境污染了，别人用你的工具，就有可能把别人给坑了</p>\n</li>\n<li><p>@babel/plugin-transform-runtime会为代码创建一个沙盒环境，为core-js这里内建的实例提供假名，你可以无缝的使用这些新特性，而不需要使用require polyfill。</p>\n<p>一个解决方案就是引入transform runtime 来替代 @babel/polyfill。<br>幸运的是，我们有env这个preset，它又一个useBuiltIns选项，如果设置成”usage”，那么将会自动检测语法帮你require你代码中使用到的功能。  </p>\n</li>\n<li><p>@babel/core<br>其中最核心的包就是@babel/core，它主要的作用就是编译.</p>\n<p>Babel-cli<br>光有core是无法在命令行使用这些功能的，@babel/cli支持你直接在命令行中编译代码。<br>这句话会编译你src目录下的所有js代码，并编译成你想要的那样（babel.config.js配置的），并输出到lib目录下。 </p>\n</li>\n<li>@babel/preset-env<br>如果useBuiltIns为true，项目中必须引入babel-polyfill。</li>\n</ol>\n<ol>\n<li>Vue Loader 是一个 webpack 的 loader，它允许你以一种名为单文件组件 (SFCs)的格式撰写 Vue 组件.   </li>\n<li><p>autoprefixer 自动补充前缀</p>\n</li>\n<li><p>Hot Module Replacement（以下简称 HMR）是 webpack 发展至今引入的最令人兴奋的特性之一 ，当你对代码进行修改并保存后，webpack 将对代码重新打包，并将新的模块发送到浏览器端，浏览器通过新的模块替换老的模块，这样在不刷新浏览器的前提下就能够对应用进行更新。</p>\n</li>\n<li>webpack-dev-server 修改了webpack 配置中的 entry 属性，在里面添加了 webpack-dev-client 的代码，这样在最后的 bundle.js 文件中就会有接收 websocket 消息的代码了。</li>\n<li></li>\n<li><p>WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。</p>\n</li>\n<li><p>Webpack splitchunk 将各个模块的交集部分抽离出来 </p>\n</li>\n<li><p>Webpack ProvidePlugin 自动加载js，不必import。<br>new webpack.ProvidePlugin({<br>  _map: [‘lodash’, ‘map’]<br>})</p>\n</li>\n<li><p>Webpack在打包时可以为我们生成的source maps，这为我们提供了一种对应编译文件和源文件的方法，使得编译后的代码可读性更高，也更容易调试</p>\n</li>\n</ol>\n<p>具体配置参考：<a href=\"http://www.jianshu.com/p/42e11515c10f\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/42e11515c10f</a></p>\n<p>感叹号的作用在于使同一文件能够使用不同类型的loader</p>\n<p>对css 分模块：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">        test: /\\.css$/,</span><br><span class=\"line\">        loader: &apos;style!css?modules&apos;//跟前面相比就在后面加上了?modules</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Loaders和Plugins常常被弄混，但是他们其实是完全不同的东西，可以这么来说，loaders是在打包构建过程中用来处理源文件的（JSX，Scss，Less..），一次处理一个，插件并不直接操作单个文件，它直接对整个构建过程其作用。</p>\n<h4 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ webpack --config webpack.min.js //另一份配置文件</span><br><span class=\"line\"></span><br><span class=\"line\">$ webpack --display-error-details //显示异常信息</span><br><span class=\"line\"></span><br><span class=\"line\">$ webpack --watch   //监听变动并自动打包</span><br><span class=\"line\"> </span><br><span class=\"line\">$ webpack -p    //压缩混淆脚本，这个非常非常重要！</span><br><span class=\"line\"> </span><br><span class=\"line\">$ webpack -d    //生成map映射文件，告知哪些模块被最终打包到哪里了</span><br></pre></td></tr></table></figure>\n<p>对公共库的封装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">entry: &#123;</span><br><span class=\"line\">  vendor: [&quot;jquery&quot;, &quot;other-lib&quot;],</span><br><span class=\"line\">  app: &quot;./entry&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">new CommonsChunkPlugin(&#123;</span><br><span class=\"line\">  name: &quot;vendor&quot;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // filename: &quot;vendor.js&quot;</span><br><span class=\"line\">  // (Give the chunk a different name)</span><br><span class=\"line\"></span><br><span class=\"line\">  minChunks: Infinity,</span><br><span class=\"line\">  // (with more entries, this ensures that no other module</span><br><span class=\"line\">  //  goes into the vendor chunk)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>关于express webpack middleware 的配置</p>\n<p><a href=\"http://www.cnblogs.com/linfangshuhellowored/p/5657285.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/linfangshuhellowored/p/5657285.html</a></p>\n<p>给文件自动添加hash后缀</p>\n<p>根据chunkhash的定义知道，chunkhash是根据具体模块文件的内容计算所得的hash值，所以某个文件的改动只会影响它本身的hash指纹，不会影响其他文件。配置webpack的output如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">output: &#123;</span><br><span class=\"line\">    filename: &apos;[name].[chunkhash:8].js&apos;,</span><br><span class=\"line\">    path: __dirname + &apos;/built&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">output: &#123;</span><br><span class=\"line\">    filename: &apos;[name].[hash:8].js&apos;,</span><br><span class=\"line\">    path: __dirname + &apos;/built&apos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"regex","date":"2019-06-24T05:56:32.000Z","_content":"\n### s修饰符使得 . 能够匹配任何字符\n \n/foo.bar/s.test('foo\\nbar')\n\n### ? 非贪婪模式\n\n? 非贪婪模式，只匹配最少的数据。 对 \"123abc\" 应用 /\\d+/ 将会返回 \"123\"，如果使用 /\\d+?/,那么就只会匹配到 \"1”。\n\n### 先行断言\n\nx(?=y)  匹配'x'仅仅当'x'后面跟着'y'.这种叫做先行断言。例如，/Jack(?=Sprat)/会匹配到'Jack'仅仅当它后面跟着'Sprat'。/Jack(?=Sprat|Frost)/匹配‘Jack’仅仅当它后面跟着'Sprat'或者是‘Frost’。但是‘Sprat’和‘Frost’都不是匹配结果的一部分。\n\n### 后行断言 \n\n(?<=y)x  匹配'x'仅仅当'x'前面是'y'.这种叫做后行断言。\n\n### 正向否定查找\n\nx(?!y)   匹配'x'仅仅当'x'后面不跟着'y',这个叫做正向否定查找。/\\d+(?!\\.)/匹配一个数字仅仅当这个数字后面没有跟小数点的时候。正则表达式/\\d+(?!\\.)/.exec(\"3.141\")匹配‘141’而不是‘3.141’\n\n### 边界 \n\\b 匹配一个词的边界。  \n\\B 匹配一个非单词边界\n\n### w\n\\w 匹配一个单字字符（字母、数字或者下划线）。\n等价于[A-Za-z0-9_]。\n\n例如, /\\w/ 匹配 \"apple,\" 中的 'a'，\"$5.28,\"中的 '5' 和 \"3D.\" 中的 '3’。\n\n\\W 匹配一个非单字字符。\n\n等价于[^A-Za-z0-9_]。\n\n例如, /\\W/ 或者 /[^A-Za-z0-9_]/ 匹配 \"50%.\" 中的 '%’。\n\n### 子字符串匹配\n```\nvar re = /(\\w+)\\s(\\w+)/;\nvar str = \"John Smith\";\nvar newstr = str.replace(re, \"$2, $1\");\nconsole.log(newstr);\n```\n\n#### 非捕获组\n\n?: 用非捕获组 提升匹配效率。\n\ny修饰符的一个应用，是从字符串提取 token（词元），y修饰符确保了匹配之间不会有漏掉的字符。可以修改regex的 lastIndex 。\n\n### 具名匹配\n\n```\nconst RE_DATE = /(\\d{4})-(\\d{2})-(\\d{2})/;\n\n\n\nconst matchObj = RE_DATE.exec('1999-12-31');\n\nconst year = matchObj[1]; // 1999\n\nconst month = matchObj[2]; // 12\n\nconst day = matchObj[3]; // 31\n\nReplace 函数形式：\n\n'2015-01-02'.replace(re, (\n\n   matched, // 整个匹配结果 2015-01-02\n\n   capture1, // 第一个组匹配 2015\n\n   capture2, // 第二个组匹配 01\n\n   capture3, // 第三个组匹配 02\n\n   position, // 匹配开始的位置 0\n\n   S, // 原字符串 2015-01-02\n\n   groups // 具名组构成的一个对象 {year, month, day}\n\n ) => {\n\n let {day, month, year} = groups;\n\n return `${day}/${month}/${year}`;\n\n});\n```\n\n```javascript\n// 可以直接赋值\nlet {groups: {one, two}} = /^(?<one>.*):(?<two>.*)$/u.exec('foo:bar');\none  // foo\ntwo  // bar\n\n// 直接replace\nlet re = /(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/u;\n\n'2015-01-02'.replace(re, '$<day>/$<month>/$<year>')\n```\n\n### 使用引用\n\n使用引用：const RE_TWICE = /^(?<word>[a-z]+)!\\k<word>$/;\n\nRE_TWICE.test('abc!abc') // true\nRE_TWICE.test('abc!ab') // false\n\n\n","source":"_posts/regex.md","raw":"---\ntitle: regex\ndate: 2019-06-24 13:56:32\ntags: regex\n---\n\n### s修饰符使得 . 能够匹配任何字符\n \n/foo.bar/s.test('foo\\nbar')\n\n### ? 非贪婪模式\n\n? 非贪婪模式，只匹配最少的数据。 对 \"123abc\" 应用 /\\d+/ 将会返回 \"123\"，如果使用 /\\d+?/,那么就只会匹配到 \"1”。\n\n### 先行断言\n\nx(?=y)  匹配'x'仅仅当'x'后面跟着'y'.这种叫做先行断言。例如，/Jack(?=Sprat)/会匹配到'Jack'仅仅当它后面跟着'Sprat'。/Jack(?=Sprat|Frost)/匹配‘Jack’仅仅当它后面跟着'Sprat'或者是‘Frost’。但是‘Sprat’和‘Frost’都不是匹配结果的一部分。\n\n### 后行断言 \n\n(?<=y)x  匹配'x'仅仅当'x'前面是'y'.这种叫做后行断言。\n\n### 正向否定查找\n\nx(?!y)   匹配'x'仅仅当'x'后面不跟着'y',这个叫做正向否定查找。/\\d+(?!\\.)/匹配一个数字仅仅当这个数字后面没有跟小数点的时候。正则表达式/\\d+(?!\\.)/.exec(\"3.141\")匹配‘141’而不是‘3.141’\n\n### 边界 \n\\b 匹配一个词的边界。  \n\\B 匹配一个非单词边界\n\n### w\n\\w 匹配一个单字字符（字母、数字或者下划线）。\n等价于[A-Za-z0-9_]。\n\n例如, /\\w/ 匹配 \"apple,\" 中的 'a'，\"$5.28,\"中的 '5' 和 \"3D.\" 中的 '3’。\n\n\\W 匹配一个非单字字符。\n\n等价于[^A-Za-z0-9_]。\n\n例如, /\\W/ 或者 /[^A-Za-z0-9_]/ 匹配 \"50%.\" 中的 '%’。\n\n### 子字符串匹配\n```\nvar re = /(\\w+)\\s(\\w+)/;\nvar str = \"John Smith\";\nvar newstr = str.replace(re, \"$2, $1\");\nconsole.log(newstr);\n```\n\n#### 非捕获组\n\n?: 用非捕获组 提升匹配效率。\n\ny修饰符的一个应用，是从字符串提取 token（词元），y修饰符确保了匹配之间不会有漏掉的字符。可以修改regex的 lastIndex 。\n\n### 具名匹配\n\n```\nconst RE_DATE = /(\\d{4})-(\\d{2})-(\\d{2})/;\n\n\n\nconst matchObj = RE_DATE.exec('1999-12-31');\n\nconst year = matchObj[1]; // 1999\n\nconst month = matchObj[2]; // 12\n\nconst day = matchObj[3]; // 31\n\nReplace 函数形式：\n\n'2015-01-02'.replace(re, (\n\n   matched, // 整个匹配结果 2015-01-02\n\n   capture1, // 第一个组匹配 2015\n\n   capture2, // 第二个组匹配 01\n\n   capture3, // 第三个组匹配 02\n\n   position, // 匹配开始的位置 0\n\n   S, // 原字符串 2015-01-02\n\n   groups // 具名组构成的一个对象 {year, month, day}\n\n ) => {\n\n let {day, month, year} = groups;\n\n return `${day}/${month}/${year}`;\n\n});\n```\n\n```javascript\n// 可以直接赋值\nlet {groups: {one, two}} = /^(?<one>.*):(?<two>.*)$/u.exec('foo:bar');\none  // foo\ntwo  // bar\n\n// 直接replace\nlet re = /(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/u;\n\n'2015-01-02'.replace(re, '$<day>/$<month>/$<year>')\n```\n\n### 使用引用\n\n使用引用：const RE_TWICE = /^(?<word>[a-z]+)!\\k<word>$/;\n\nRE_TWICE.test('abc!abc') // true\nRE_TWICE.test('abc!ab') // false\n\n\n","slug":"regex","published":1,"updated":"2019-08-14T09:32:10.590Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2fu42000017f18spaekc38g","content":"<h3 id=\"s修饰符使得-能够匹配任何字符\"><a href=\"#s修饰符使得-能够匹配任何字符\" class=\"headerlink\" title=\"s修饰符使得 . 能够匹配任何字符\"></a>s修饰符使得 . 能够匹配任何字符</h3><p>/foo.bar/s.test(‘foo\\nbar’)</p>\n<h3 id=\"非贪婪模式\"><a href=\"#非贪婪模式\" class=\"headerlink\" title=\"? 非贪婪模式\"></a>? 非贪婪模式</h3><p>? 非贪婪模式，只匹配最少的数据。 对 “123abc” 应用 /\\d+/ 将会返回 “123”，如果使用 /\\d+?/,那么就只会匹配到 “1”。</p>\n<h3 id=\"先行断言\"><a href=\"#先行断言\" class=\"headerlink\" title=\"先行断言\"></a>先行断言</h3><p>x(?=y)  匹配’x’仅仅当’x’后面跟着’y’.这种叫做先行断言。例如，/Jack(?=Sprat)/会匹配到’Jack’仅仅当它后面跟着’Sprat’。/Jack(?=Sprat|Frost)/匹配‘Jack’仅仅当它后面跟着’Sprat’或者是‘Frost’。但是‘Sprat’和‘Frost’都不是匹配结果的一部分。</p>\n<h3 id=\"后行断言\"><a href=\"#后行断言\" class=\"headerlink\" title=\"后行断言\"></a>后行断言</h3><p>(?&lt;=y)x  匹配’x’仅仅当’x’前面是’y’.这种叫做后行断言。</p>\n<h3 id=\"正向否定查找\"><a href=\"#正向否定查找\" class=\"headerlink\" title=\"正向否定查找\"></a>正向否定查找</h3><p>x(?!y)   匹配’x’仅仅当’x’后面不跟着’y’,这个叫做正向否定查找。/\\d+(?!.)/匹配一个数字仅仅当这个数字后面没有跟小数点的时候。正则表达式/\\d+(?!.)/.exec(“3.141”)匹配‘141’而不是‘3.141’</p>\n<h3 id=\"边界\"><a href=\"#边界\" class=\"headerlink\" title=\"边界\"></a>边界</h3><p>\\b 匹配一个词的边界。<br>\\B 匹配一个非单词边界</p>\n<h3 id=\"w\"><a href=\"#w\" class=\"headerlink\" title=\"w\"></a>w</h3><p>\\w 匹配一个单字字符（字母、数字或者下划线）。<br>等价于[A-Za-z0-9_]。</p>\n<p>例如, /\\w/ 匹配 “apple,” 中的 ‘a’，”$5.28,”中的 ‘5’ 和 “3D.” 中的 ‘3’。</p>\n<p>\\W 匹配一个非单字字符。</p>\n<p>等价于[^A-Za-z0-9_]。</p>\n<p>例如, /\\W/ 或者 /[^A-Za-z0-9_]/ 匹配 “50%.” 中的 ‘%’。</p>\n<h3 id=\"子字符串匹配\"><a href=\"#子字符串匹配\" class=\"headerlink\" title=\"子字符串匹配\"></a>子字符串匹配</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var re = /(\\w+)\\s(\\w+)/;</span><br><span class=\"line\">var str = &quot;John Smith&quot;;</span><br><span class=\"line\">var newstr = str.replace(re, &quot;$2, $1&quot;);</span><br><span class=\"line\">console.log(newstr);</span><br></pre></td></tr></table></figure>\n<h4 id=\"非捕获组\"><a href=\"#非捕获组\" class=\"headerlink\" title=\"非捕获组\"></a>非捕获组</h4><p>?: 用非捕获组 提升匹配效率。</p>\n<p>y修饰符的一个应用，是从字符串提取 token（词元），y修饰符确保了匹配之间不会有漏掉的字符。可以修改regex的 lastIndex 。</p>\n<h3 id=\"具名匹配\"><a href=\"#具名匹配\" class=\"headerlink\" title=\"具名匹配\"></a>具名匹配</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const RE_DATE = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">const matchObj = RE_DATE.exec(&apos;1999-12-31&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">const year = matchObj[1]; // 1999</span><br><span class=\"line\"></span><br><span class=\"line\">const month = matchObj[2]; // 12</span><br><span class=\"line\"></span><br><span class=\"line\">const day = matchObj[3]; // 31</span><br><span class=\"line\"></span><br><span class=\"line\">Replace 函数形式：</span><br><span class=\"line\"></span><br><span class=\"line\">&apos;2015-01-02&apos;.replace(re, (</span><br><span class=\"line\"></span><br><span class=\"line\">   matched, // 整个匹配结果 2015-01-02</span><br><span class=\"line\"></span><br><span class=\"line\">   capture1, // 第一个组匹配 2015</span><br><span class=\"line\"></span><br><span class=\"line\">   capture2, // 第二个组匹配 01</span><br><span class=\"line\"></span><br><span class=\"line\">   capture3, // 第三个组匹配 02</span><br><span class=\"line\"></span><br><span class=\"line\">   position, // 匹配开始的位置 0</span><br><span class=\"line\"></span><br><span class=\"line\">   S, // 原字符串 2015-01-02</span><br><span class=\"line\"></span><br><span class=\"line\">   groups // 具名组构成的一个对象 &#123;year, month, day&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> ) =&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> let &#123;day, month, year&#125; = groups;</span><br><span class=\"line\"></span><br><span class=\"line\"> return `$&#123;day&#125;/$&#123;month&#125;/$&#123;year&#125;`;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 可以直接赋值</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123;<span class=\"attr\">groups</span>: &#123;one, two&#125;&#125; = <span class=\"regexp\">/^(?&lt;one&gt;.*):(?&lt;two&gt;.*)$/u</span>.exec(<span class=\"string\">'foo:bar'</span>);</span><br><span class=\"line\">one  <span class=\"comment\">// foo</span></span><br><span class=\"line\">two  <span class=\"comment\">// bar</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 直接replace</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> re = <span class=\"regexp\">/(?&lt;year&gt;\\d&#123;4&#125;)-(?&lt;month&gt;\\d&#123;2&#125;)-(?&lt;day&gt;\\d&#123;2&#125;)/u</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">'2015-01-02'</span>.replace(re, <span class=\"string\">'$&lt;day&gt;/$&lt;month&gt;/$&lt;year&gt;'</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用引用\"><a href=\"#使用引用\" class=\"headerlink\" title=\"使用引用\"></a>使用引用</h3><p>使用引用：const RE_TWICE = /^(?<word>[a-z]+)!\\k<word>$/;</word></word></p>\n<p>RE_TWICE.test(‘abc!abc’) // true<br>RE_TWICE.test(‘abc!ab’) // false</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"s修饰符使得-能够匹配任何字符\"><a href=\"#s修饰符使得-能够匹配任何字符\" class=\"headerlink\" title=\"s修饰符使得 . 能够匹配任何字符\"></a>s修饰符使得 . 能够匹配任何字符</h3><p>/foo.bar/s.test(‘foo\\nbar’)</p>\n<h3 id=\"非贪婪模式\"><a href=\"#非贪婪模式\" class=\"headerlink\" title=\"? 非贪婪模式\"></a>? 非贪婪模式</h3><p>? 非贪婪模式，只匹配最少的数据。 对 “123abc” 应用 /\\d+/ 将会返回 “123”，如果使用 /\\d+?/,那么就只会匹配到 “1”。</p>\n<h3 id=\"先行断言\"><a href=\"#先行断言\" class=\"headerlink\" title=\"先行断言\"></a>先行断言</h3><p>x(?=y)  匹配’x’仅仅当’x’后面跟着’y’.这种叫做先行断言。例如，/Jack(?=Sprat)/会匹配到’Jack’仅仅当它后面跟着’Sprat’。/Jack(?=Sprat|Frost)/匹配‘Jack’仅仅当它后面跟着’Sprat’或者是‘Frost’。但是‘Sprat’和‘Frost’都不是匹配结果的一部分。</p>\n<h3 id=\"后行断言\"><a href=\"#后行断言\" class=\"headerlink\" title=\"后行断言\"></a>后行断言</h3><p>(?&lt;=y)x  匹配’x’仅仅当’x’前面是’y’.这种叫做后行断言。</p>\n<h3 id=\"正向否定查找\"><a href=\"#正向否定查找\" class=\"headerlink\" title=\"正向否定查找\"></a>正向否定查找</h3><p>x(?!y)   匹配’x’仅仅当’x’后面不跟着’y’,这个叫做正向否定查找。/\\d+(?!.)/匹配一个数字仅仅当这个数字后面没有跟小数点的时候。正则表达式/\\d+(?!.)/.exec(“3.141”)匹配‘141’而不是‘3.141’</p>\n<h3 id=\"边界\"><a href=\"#边界\" class=\"headerlink\" title=\"边界\"></a>边界</h3><p>\\b 匹配一个词的边界。<br>\\B 匹配一个非单词边界</p>\n<h3 id=\"w\"><a href=\"#w\" class=\"headerlink\" title=\"w\"></a>w</h3><p>\\w 匹配一个单字字符（字母、数字或者下划线）。<br>等价于[A-Za-z0-9_]。</p>\n<p>例如, /\\w/ 匹配 “apple,” 中的 ‘a’，”$5.28,”中的 ‘5’ 和 “3D.” 中的 ‘3’。</p>\n<p>\\W 匹配一个非单字字符。</p>\n<p>等价于[^A-Za-z0-9_]。</p>\n<p>例如, /\\W/ 或者 /[^A-Za-z0-9_]/ 匹配 “50%.” 中的 ‘%’。</p>\n<h3 id=\"子字符串匹配\"><a href=\"#子字符串匹配\" class=\"headerlink\" title=\"子字符串匹配\"></a>子字符串匹配</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var re = /(\\w+)\\s(\\w+)/;</span><br><span class=\"line\">var str = &quot;John Smith&quot;;</span><br><span class=\"line\">var newstr = str.replace(re, &quot;$2, $1&quot;);</span><br><span class=\"line\">console.log(newstr);</span><br></pre></td></tr></table></figure>\n<h4 id=\"非捕获组\"><a href=\"#非捕获组\" class=\"headerlink\" title=\"非捕获组\"></a>非捕获组</h4><p>?: 用非捕获组 提升匹配效率。</p>\n<p>y修饰符的一个应用，是从字符串提取 token（词元），y修饰符确保了匹配之间不会有漏掉的字符。可以修改regex的 lastIndex 。</p>\n<h3 id=\"具名匹配\"><a href=\"#具名匹配\" class=\"headerlink\" title=\"具名匹配\"></a>具名匹配</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const RE_DATE = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">const matchObj = RE_DATE.exec(&apos;1999-12-31&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">const year = matchObj[1]; // 1999</span><br><span class=\"line\"></span><br><span class=\"line\">const month = matchObj[2]; // 12</span><br><span class=\"line\"></span><br><span class=\"line\">const day = matchObj[3]; // 31</span><br><span class=\"line\"></span><br><span class=\"line\">Replace 函数形式：</span><br><span class=\"line\"></span><br><span class=\"line\">&apos;2015-01-02&apos;.replace(re, (</span><br><span class=\"line\"></span><br><span class=\"line\">   matched, // 整个匹配结果 2015-01-02</span><br><span class=\"line\"></span><br><span class=\"line\">   capture1, // 第一个组匹配 2015</span><br><span class=\"line\"></span><br><span class=\"line\">   capture2, // 第二个组匹配 01</span><br><span class=\"line\"></span><br><span class=\"line\">   capture3, // 第三个组匹配 02</span><br><span class=\"line\"></span><br><span class=\"line\">   position, // 匹配开始的位置 0</span><br><span class=\"line\"></span><br><span class=\"line\">   S, // 原字符串 2015-01-02</span><br><span class=\"line\"></span><br><span class=\"line\">   groups // 具名组构成的一个对象 &#123;year, month, day&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> ) =&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> let &#123;day, month, year&#125; = groups;</span><br><span class=\"line\"></span><br><span class=\"line\"> return `$&#123;day&#125;/$&#123;month&#125;/$&#123;year&#125;`;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 可以直接赋值</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123;<span class=\"attr\">groups</span>: &#123;one, two&#125;&#125; = <span class=\"regexp\">/^(?&lt;one&gt;.*):(?&lt;two&gt;.*)$/u</span>.exec(<span class=\"string\">'foo:bar'</span>);</span><br><span class=\"line\">one  <span class=\"comment\">// foo</span></span><br><span class=\"line\">two  <span class=\"comment\">// bar</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 直接replace</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> re = <span class=\"regexp\">/(?&lt;year&gt;\\d&#123;4&#125;)-(?&lt;month&gt;\\d&#123;2&#125;)-(?&lt;day&gt;\\d&#123;2&#125;)/u</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">'2015-01-02'</span>.replace(re, <span class=\"string\">'$&lt;day&gt;/$&lt;month&gt;/$&lt;year&gt;'</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用引用\"><a href=\"#使用引用\" class=\"headerlink\" title=\"使用引用\"></a>使用引用</h3><p>使用引用：const RE_TWICE = /^(?<word>[a-z]+)!\\k<word>$/;</word></word></p>\n<p>RE_TWICE.test(‘abc!abc’) // true<br>RE_TWICE.test(‘abc!ab’) // false</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ck2fu41z60000f18sarcp7dnl","tag_id":"ck2fu41zc0004f18sfgksw41k","_id":"ck2fu41zh000af18sqfsc4kia"},{"post_id":"ck2fu41za0002f18sfblm83je","tag_id":"ck2fu41zg0009f18s6orupxsg","_id":"ck2fu41zl000ff18sitjx16a7"},{"post_id":"ck2fu41zd0005f18s9y1sj839","tag_id":"ck2fu41zk000df18s0e7hp211","_id":"ck2fu41zn000jf18smrbx8wxe"},{"post_id":"ck2fu41zf0007f18swoohlp3h","tag_id":"ck2fu41zm000hf18sltj3p21g","_id":"ck2fu41zp000nf18soa9dsrd0"},{"post_id":"ck2fu41zg0008f18snzsf3riw","tag_id":"ck2fu41zo000lf18sxeqv3idx","_id":"ck2fu41zt000rf18sxdww3gil"},{"post_id":"ck2fu41zh000bf18slzyn0feq","tag_id":"ck2fu41zo000lf18sxeqv3idx","_id":"ck2fu41zv000vf18sggiwv5u6"},{"post_id":"ck2fu41zi000cf18srz445k4b","tag_id":"ck2fu41zv000uf18sldbej38x","_id":"ck2fu41zx0010f18sx8q226dk"},{"post_id":"ck2fu41zl000gf18sbfb00dkf","tag_id":"ck2fu41zw000yf18sd2syd2it","_id":"ck2fu41zz0014f18shggg52v0"},{"post_id":"ck2fu41zm000if18s5195iu7b","tag_id":"ck2fu41zy0012f18s6gf4cnz1","_id":"ck2fu42010018f18sr1z8eufx"},{"post_id":"ck2fu41zn000kf18syzr9c6v3","tag_id":"ck2fu42000016f18syzu1sx8j","_id":"ck2fu4201001af18s991bok5n"},{"post_id":"ck2fu41zo000mf18s0o50tdpi","tag_id":"ck2fu42010019f18s8euc9922","_id":"ck2fu4204001cf18sibcnye0c"},{"post_id":"ck2fu41zq000of18s3757ndkv","tag_id":"ck2fu4201001bf18se2xyzyks","_id":"ck2fu4204001ef18sm3o8shtr"},{"post_id":"ck2fu41zr000pf18soiigrxrx","tag_id":"ck2fu4204001df18szbhigde7","_id":"ck2fu4205001gf18s597v9oyq"},{"post_id":"ck2fu41zt000sf18sjkoiggge","tag_id":"ck2fu4205001ff18sq0nktx2w","_id":"ck2fu4205001if18s2oa7rv7r"},{"post_id":"ck2fu41zu000tf18sn8f17gxb","tag_id":"ck2fu4205001hf18se0ipnp6f","_id":"ck2fu4205001kf18s2xwvcfhl"},{"post_id":"ck2fu41zv000wf18swm4gokez","tag_id":"ck2fu4205001jf18s75bs3dzg","_id":"ck2fu4206001mf18sx1qn7snw"},{"post_id":"ck2fu41zw000xf18sjgib5w60","tag_id":"ck2fu4206001lf18siqa4awsk","_id":"ck2fu4206001of18shu5faii2"},{"post_id":"ck2fu41zx000zf18scbfl2ipx","tag_id":"ck2fu4206001nf18slm0o0ecq","_id":"ck2fu4207001qf18sovc0y0m2"},{"post_id":"ck2fu41zy0011f18sjeumh7iq","tag_id":"ck2fu4206001pf18si1vg8yh2","_id":"ck2fu4207001sf18swuobvs6s"},{"post_id":"ck2fu41zy0013f18s84omiioj","tag_id":"ck2fu4207001rf18se2nluz1s","_id":"ck2fu4208001uf18st7ozybpd"},{"post_id":"ck2fu41zz0015f18swiv11hbb","tag_id":"ck2fu4208001tf18s1ilfle4z","_id":"ck2fu4208001wf18s34py3ec2"},{"post_id":"ck2fu42000017f18spaekc38g","tag_id":"ck2fu4208001vf18spp1g8h0f","_id":"ck2fu4208001xf18sv5ibw8t0"}],"Tag":[{"name":"零碎","_id":"ck2fu41zc0004f18sfgksw41k"},{"name":"https","_id":"ck2fu41zg0009f18s6orupxsg"},{"name":"css","_id":"ck2fu41zk000df18s0e7hp211"},{"name":"docker","_id":"ck2fu41zm000hf18sltj3p21g"},{"name":"es","_id":"ck2fu41zo000lf18sxeqv3idx"},{"name":"eslint","_id":"ck2fu41zv000uf18sldbej38x"},{"name":"git","_id":"ck2fu41zw000yf18sd2syd2it"},{"name":"hexo","_id":"ck2fu41zy0012f18s6gf4cnz1"},{"name":"http","_id":"ck2fu42000016f18syzu1sx8j"},{"name":"interview","_id":"ck2fu42010019f18s8euc9922"},{"name":"loadtest","_id":"ck2fu4201001bf18se2xyzyks"},{"name":"ops","_id":"ck2fu4204001df18szbhigde7"},{"name":"pattern","_id":"ck2fu4205001ff18sq0nktx2w"},{"name":"pm2","_id":"ck2fu4205001hf18se0ipnp6f"},{"name":"postgre","_id":"ck2fu4205001jf18s75bs3dzg"},{"name":"useful package","_id":"ck2fu4206001lf18siqa4awsk"},{"name":"安全","_id":"ck2fu4206001nf18slm0o0ecq"},{"name":"ts","_id":"ck2fu4206001pf18si1vg8yh2"},{"name":"vue eventloop js","_id":"ck2fu4207001rf18se2nluz1s"},{"name":"webpack","_id":"ck2fu4208001tf18s1ilfle4z"},{"name":"regex","_id":"ck2fu4208001vf18spp1g8h0f"}]}}