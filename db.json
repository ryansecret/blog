{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/landscape/.gitignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1550135292198},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1550135292198},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1550135292199},{"_id":"themes/landscape/README.md","hash":"c7e83cfe8f2c724fc9cac32bd71bb5faf9ceeddb","modified":1550135292199},{"_id":"themes/landscape/_config.yml","hash":"fb8c98a0f6ff9f962637f329c22699721854cd73","modified":1550135292199},{"_id":"themes/landscape/package.json","hash":"85358dc34311c6662e841584e206a4679183943f","modified":1550135292207},{"_id":"source/about/index.md","hash":"0330b10bfb69136ccca8e2b04cf01353c89d26cb","modified":1550135292197},{"_id":"source/_posts/Let's Encrypt SSL.md","hash":"5e638f906e622817ab93fe64d640477c06213e6d","modified":1564130117299},{"_id":"source/_posts/cookies.md","hash":"86178730343ef287ff1fe41000a76d5b8ec58c01","modified":1574737387376},{"_id":"source/_posts/css.md","hash":"b4a97fb6a48612d29817c2e965772386982b1c09","modified":1577952757316},{"_id":"source/_posts/docker.md","hash":"b073b3d18f350b12fafb88c094aa65f13d05d40e","modified":1564130117301},{"_id":"source/_posts/encoding.md","hash":"5e0c545a8f40974922640cd0a3900df059f797e9","modified":1573193675771},{"_id":"source/_posts/es8.md","hash":"3bf925cc89354e04c865a4568ec27fa40c46b9ef","modified":1564130117301},{"_id":"source/_posts/es6.md","hash":"cce27d006226882310d98842d33e30d604a7eabf","modified":1564130117301},{"_id":"source/_posts/eslint.md","hash":"f63c0eef0f9062e5850f00bc3435aa02f0261bb8","modified":1564130117302},{"_id":"source/_posts/gitInfo.md","hash":"61a5c750604a8d2b405e7c61651468b234cd79c0","modified":1572834411926},{"_id":"source/_posts/hexo.md","hash":"1010707ca170d6de3a91c19aed39e79558a0bc9a","modified":1564130117303},{"_id":"source/_posts/graphql.md","hash":"89cf554cba1910b0bf8ff13d3bd63816904409b8","modified":1566548722505},{"_id":"source/_posts/http.md","hash":"8340c6d5093153688d9731d3e1e4d0175fa79ca2","modified":1577953110590},{"_id":"source/_posts/interview.md","hash":"394ecfb476307080ae6d7f6927a513402ce87d29","modified":1577951484096},{"_id":"source/_posts/linux.md","hash":"2ece860a2d32d323f18413e44c741b062470c45a","modified":1577953003000},{"_id":"source/_posts/loadtest.md","hash":"430b59a7b6776d600d67a6f6a0051bb0b758338f","modified":1564130117306},{"_id":"source/_posts/package.md","hash":"30f047c635a6d7af479d9d6463a93017f3f8a87d","modified":1577952648330},{"_id":"source/_posts/pattern.md","hash":"85ff08997e08d562362138ed63a097f5b4cf3de6","modified":1564130117308},{"_id":"source/_posts/pm2.md","hash":"c8fc02c5bff7e9dc766e78c52456ccb4f62b7426","modified":1564130117309},{"_id":"source/_posts/postgre.md","hash":"58288a0cd5d4992365d259d095a3b2a469667ff5","modified":1564130117310},{"_id":"source/_posts/regex.md","hash":"d84af5225fe5fd5c4d1c427feb3811c0a7c3a6d8","modified":1574737727063},{"_id":"source/_posts/security-1.md","hash":"1793db36167b31517ed2036a01f47c1cc236b1db","modified":1577951381657},{"_id":"source/_posts/security.md","hash":"c9ed6d135e5dbe5d523a994f1facfba49fff9887","modified":1564130117312},{"_id":"source/_posts/stringencode.md","hash":"21cc6e8ad9bfcb53e431c8c7a603852868493c9c","modified":1575969250304},{"_id":"source/_posts/vue.md","hash":"ab408866827ad354c8258a310d3eb1a27453749e","modified":1577953407666},{"_id":"source/_posts/typescript.md","hash":"7de3284a07085eb11fd734aaca0b65780f8f566f","modified":1564130117313},{"_id":"source/_posts/webpack.md","hash":"f80eba87eecfa8f15efecbf5d626b59da7ced99b","modified":1577949080123},{"_id":"source/categories/index.md","hash":"d51db580efc1edca02813a5939b51abb9333c3c2","modified":1550135292197},{"_id":"source/tags/index.md","hash":"ba27695f1572dff9ace58e82b5a66c43840fe56c","modified":1550135292198},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1550135292200},{"_id":"themes/landscape/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1550135292200},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1550135292200},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1550135292200},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1550135292201},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1550135292201},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1550135292201},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1550135292206},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1550135292206},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1550135292206},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1550135292206},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1550135292206},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1550135292207},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1550135292207},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1550135292207},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1550135292205},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1550135292205},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1550135292205},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1550135292206},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1550135292206},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"dc5d69f1bef3499d7d56c03727e178f3d56b40f7","modified":1564130117316},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1550135292202},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"931aaaffa0910a48199388ede576184ff15793ee","modified":1550135292202},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1550135292202},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1550135292202},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1550135292203},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"83a1ab12eb2a871bddf0620f611a97f13ebd731d","modified":1564130117317},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"c21ca56f419d01a9f49c27b6be9f4a98402b2aa3","modified":1550135292203},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1550135292203},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1550135292205},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1550135292208},{"_id":"themes/landscape/source/css/_variables.styl","hash":"5e37a6571caf87149af83ac1cc0cdef99f117350","modified":1550135292210},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1550135292215},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1550135292216},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1550135292216},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1550135292216},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1550135292217},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1550135292217},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1550135292217},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1550135292219},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1550135292219},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1550135292219},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1550135292220},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1550135292204},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1550135292204},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1550135292204},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1550135292204},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1550135292204},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1550135292205},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1550135292208},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1550135292208},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1550135292208},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1550135292208},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1550135292209},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1550135292209},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1550135292208},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1550135292209},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1550135292209},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1550135292209},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1550135292210},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1550135292210},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1550135292211},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1550135292211},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1550135292213},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1550135292217},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1550135292218},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1550135292218},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1550135292218},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1550135292218},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1550135292219},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1550135292213},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1550135292212},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1550135292215},{"_id":"public/about/index.html","hash":"168a1d6cf6355db4d21301f5d4ac9560f8d1c26b","modified":1578886766841},{"_id":"public/categories/index.html","hash":"707af916a0d7713612b4ce135e393b00c92281ee","modified":1578886766841},{"_id":"public/tags/index.html","hash":"a69ffb38ba0da1d23cb500bbb70f9218b96f4a10","modified":1578886766841},{"_id":"public/2019/12/10/stringencode/index.html","hash":"2a2348f0d0bd4a64649d75b6ae1c24197f09ced9","modified":1578886766842},{"_id":"public/2019/11/08/encoding/index.html","hash":"db90a79a2e99cac91ae93ae117bf70fb542b53ad","modified":1578886766842},{"_id":"public/2019/08/23/graphql/index.html","hash":"fa1bbfb543a907ac326f0818e545c4317c6a03cc","modified":1578886766842},{"_id":"public/2019/07/02/linux/index.html","hash":"77aae7270308ac7d97208c8c9dcd5e60a0d3ac8c","modified":1578886766842},{"_id":"public/2019/07/02/es8/index.html","hash":"69aec7a577f76aab527b157ef48db9c379c003d3","modified":1578886766842},{"_id":"public/2019/04/25/security/index.html","hash":"0d87a3cc1077ad47abaf80d6b6f4c6c7d8b85687","modified":1578886766842},{"_id":"public/2019/02/20/gitInfo/index.html","hash":"95659832a272842c1c34ec7415416e67fa8b36d9","modified":1578886766842},{"_id":"public/2017/01/17/loadtest/index.html","hash":"6c84d05e79671fa26b2f175ac8d4e466c0fb17d9","modified":1578886766842},{"_id":"public/2016/12/29/pm2/index.html","hash":"e673c0e5de5776a57a951a32c3680369c0b8fa5e","modified":1578886766842},{"_id":"public/2016/12/21/hexo/index.html","hash":"3a9571959af560b658eb53f8e9157d5674b7a13b","modified":1578886766842},{"_id":"public/tags/https/index.html","hash":"f1509507de710394d76a98aad88919559f5a29eb","modified":1578886766842},{"_id":"public/tags/零碎/index.html","hash":"ebab120eaa6f728c2f7a1d770ae5ed17bca34c31","modified":1578886766842},{"_id":"public/tags/css/index.html","hash":"6fca57fa5ac4297091b0252f565679555f3aff33","modified":1578886766842},{"_id":"public/tags/docker/index.html","hash":"7c0651b57d23b6748bfcb30e76781ab93906803e","modified":1578886766842},{"_id":"public/tags/es/index.html","hash":"b769a9377189ef550daa2f8714443353dc8f7d18","modified":1578886766842},{"_id":"public/tags/eslint/index.html","hash":"efdfa46d2b05ae87db9f936dcba3360deca968a0","modified":1578886766842},{"_id":"public/tags/git/index.html","hash":"89f59a9fe911efa85dc1c2ebef6d145008502a5e","modified":1578886766842},{"_id":"public/tags/hexo/index.html","hash":"a72748912ed3ff07e3c7bf66bbfa6ccf2be7499e","modified":1578886766842},{"_id":"public/tags/http/index.html","hash":"268ca4ffa4fb48551d43c6b25ed43b3114d36e87","modified":1578886766842},{"_id":"public/tags/interview/index.html","hash":"d536db14c99619c93b4d3788f478b60cbd5dadde","modified":1578886766842},{"_id":"public/tags/ops/index.html","hash":"05c1e0d583371629a6f8cd81f3bab7329c936c62","modified":1578886766843},{"_id":"public/tags/loadtest/index.html","hash":"2f43916428856891995cdc617a0f7b3037e816aa","modified":1578886766843},{"_id":"public/tags/useful-package/index.html","hash":"b6d57d24ef47bb6531ee09f3eb0812bd65c1295a","modified":1578886766843},{"_id":"public/tags/pattern/index.html","hash":"8f9df12dd079f9c3bd5274986cb17dda288f822b","modified":1578886766843},{"_id":"public/tags/pm2/index.html","hash":"f9add342f86dba36e6c349f738b645305114a8d8","modified":1578886766843},{"_id":"public/tags/postgre/index.html","hash":"10dfb4b1e217b990872b2a8859395f89bc513a8b","modified":1578886766843},{"_id":"public/tags/regex/index.html","hash":"b38f2a7ded73e02ea6c2c01f8fedcbea0746dac3","modified":1578886766843},{"_id":"public/tags/web-安全/index.html","hash":"61c3dbbbcc926a48317927d33b0a7286866fcee7","modified":1578886766843},{"_id":"public/tags/安全/index.html","hash":"53de2f25bec3c441501041463a050ae85d1a66c3","modified":1578886766843},{"_id":"public/tags/encode-decode/index.html","hash":"66298aa535bd329b2703a079b6dc4392b48d2a27","modified":1578886766843},{"_id":"public/tags/vue-eventloop-js/index.html","hash":"fbadea84800b45f14626a58a813cf7fd36d274a4","modified":1578886766843},{"_id":"public/tags/ts/index.html","hash":"194d6ffd4344d9b4493cfef7f3ddb5134a9e8571","modified":1578886766843},{"_id":"public/tags/webpack/index.html","hash":"ff4cc64cf02c6e5f3789152dd6228bc632c43632","modified":1578886766843},{"_id":"public/archives/index.html","hash":"f4857036d662c339fe473345c80e0fe9eb361845","modified":1578886766843},{"_id":"public/archives/page/2/index.html","hash":"86eb05207cc2611648500d65547db6b488089039","modified":1578886766843},{"_id":"public/archives/page/3/index.html","hash":"032b808877d7013eca01c5f833fc37a8df330371","modified":1578886766843},{"_id":"public/archives/2016/index.html","hash":"7f01272ac6289da68ecda0ffe0d26faf695641a9","modified":1578886766843},{"_id":"public/archives/2016/12/index.html","hash":"5d0cd181c26f00e66689013108a0e087091753c8","modified":1578886766843},{"_id":"public/archives/2017/index.html","hash":"e95725fdb81b3b61dfb9bc4908ff35b21f161fe3","modified":1578886766843},{"_id":"public/archives/2017/01/index.html","hash":"eba69950a294c12feef8d4cb522a3c8f6c8b9c43","modified":1578886766843},{"_id":"public/archives/2017/02/index.html","hash":"d6c833c0f2e3fc4a8653c44f6c1c20f434495290","modified":1578886766844},{"_id":"public/archives/2019/index.html","hash":"930662b7a1bd6954bc5f455c51baf7040306fe16","modified":1578886766844},{"_id":"public/archives/2019/page/2/index.html","hash":"fea902e6304d3f2818d05c2326e1c97ceed52bce","modified":1578886766844},{"_id":"public/archives/2019/02/index.html","hash":"b183029d19e65a75e981a004e8f3804293a4db56","modified":1578886766844},{"_id":"public/archives/2019/04/index.html","hash":"770f66c9013510aa053ae86fe390ea3e14e5c91b","modified":1578886766844},{"_id":"public/archives/2019/05/index.html","hash":"f1518b0a94bfb6cad3c5adc55d9415e7d87dd436","modified":1578886766844},{"_id":"public/archives/2019/06/index.html","hash":"4396a39e9aa8121d4963fa2b321ef0edd67202f6","modified":1578886766844},{"_id":"public/archives/2019/07/index.html","hash":"0908f5f3ca25c3c19bb531d572649ec045ac6cac","modified":1578886766844},{"_id":"public/archives/2019/08/index.html","hash":"2ca856f1cef078d59e8b583abdb4a3ca1f97028a","modified":1578886766844},{"_id":"public/archives/2019/11/index.html","hash":"37cfe2eaebf09db5d356e2d6ce21b74eb513a1b0","modified":1578886766844},{"_id":"public/archives/2019/12/index.html","hash":"9ffa399415697a51c387bc9c17363c59b62021c6","modified":1578886766844},{"_id":"public/2019/12/09/security-1/index.html","hash":"18cb208f897474a986903dfa3ca5a1f15b2adddc","modified":1578886766844},{"_id":"public/2019/06/28/es6/index.html","hash":"71d3edf2378fe4e52c24a6c7e85192af485277ff","modified":1578886766844},{"_id":"public/2019/06/24/cookies/index.html","hash":"908cf9b99b5f4eed6c07ca51622cc2cd5a15b2e7","modified":1578886766844},{"_id":"public/2019/06/24/regex/index.html","hash":"0f844fbd6cc773ddbfe487b0f64ea99f5eb5665d","modified":1578886766844},{"_id":"public/2019/05/14/http/index.html","hash":"7d690682f29dc4b11d217075a6178db4595f1e6c","modified":1578886766844},{"_id":"public/2019/05/07/css/index.html","hash":"3945587c1bfa54c16af9a9c543647e23e44967ea","modified":1578886766844},{"_id":"public/2019/02/25/typescript/index.html","hash":"459a8514883ffdd317266a8f2194442c8ee35c16","modified":1578886766844},{"_id":"public/2019/02/14/package/index.html","hash":"0f29ed1f831b39761828407b9f07df91c2a8d809","modified":1578886766845},{"_id":"public/2017/02/21/postgre/index.html","hash":"de9225eebc9b3749d43f7c983c08ad1bf9d7c89e","modified":1578886766845},{"_id":"public/2017/01/23/interview/index.html","hash":"98c5c4345820fa4bef39e34bd556642e3d557943","modified":1578886766845},{"_id":"public/2017/01/19/vue/index.html","hash":"220f36e51a450c423331b45400daf0ca44083ece","modified":1578886766845},{"_id":"public/2017/01/17/webpack/index.html","hash":"5e64b747ba95e6129170bc48c0f57011ebf9bdb1","modified":1578886766845},{"_id":"public/2016/12/26/pattern/index.html","hash":"d854934e814d8cb1a0ebd8eb3b14da5d0bd730a4","modified":1578886766845},{"_id":"public/2016/12/25/eslint/index.html","hash":"45e02169d020c552330ba46f947c207713aadf4c","modified":1578886766845},{"_id":"public/2016/12/21/Let's Encrypt SSL/index.html","hash":"8fe92dee88f08757918aeb26d7427e1d49e5dbd6","modified":1578886766845},{"_id":"public/2016/12/14/docker/index.html","hash":"cd871da5022447dfd2de6726e804794f45026d22","modified":1578886766845},{"_id":"public/index.html","hash":"19b634fdf6cbecac988d506fa54b33047345b729","modified":1578886766845},{"_id":"public/page/2/index.html","hash":"45d52d7b758fa9d988cf0e4713dd49c73c885876","modified":1578886766845},{"_id":"public/page/3/index.html","hash":"7345846eed4a3a290a35beed73e53d7be7153336","modified":1578886766845},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1578886766849},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1578886766849},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1578886766849},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1578886766849},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1578886766849},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1578886766849},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1578886766849},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1578886766849},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1578886766849},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1578886767153},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1578886767154},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1578886767157},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1578886767157},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1578886767157},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1578886767157},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1578886767157},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1578886767157},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1578886767157},{"_id":"public/css/style.css","hash":"fffb3966bf36057a325498aba9ce3a2ea7bd79e1","modified":1578886767157},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1578886767157},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1578886767157},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1578886767161},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1578886767162}],"Category":[],"Data":[],"Page":[{"title":"about","date":"2017-01-19T08:44:34.000Z","_content":"adfsdfffffffff","source":"about/index.md","raw":"---\ntitle: about\ndate: 2017-01-19 16:44:34\n---\nadfsdfffffffff","updated":"2019-02-14T09:08:12.197Z","path":"about/index.html","comments":1,"layout":"page","_id":"ck5bwexc90000998so09glkc2","content":"<p>adfsdfffffffff</p>\n","site":{"data":{}},"excerpt":"","more":"<p>adfsdfffffffff</p>\n"},{"title":"categories","date":"2017-01-19T08:52:48.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2017-01-19 16:52:48\ntype: \"categories\"\n---\n","updated":"2019-02-14T09:08:12.197Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ck5bwexdr0021998sfi17zwbp","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2017-01-19T08:53:34.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2017-01-19 16:53:34\ntype: \"tags\"\n---\n","updated":"2019-02-14T09:08:12.198Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ck5bwexds0022998siz8w7okn","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Let's Encrypt","date":"2016-12-21T03:47:39.000Z","_content":"\n### 使用Let's Encrypt生成免费SSL证书\n\n官网：[Let's Encrypt](https://letsencrypt.org/)\n\nLet's Encrypt是由互联网安全研究小组（ISRG，一个公益组织）提供的服务。提供免费、自动化、开放的证书签发服务。\n\nLet's Encrypt颁发的证书有期是90天，需要在过期前进行续期，好在Let's Encrypt已经提供了自动续期的脚本。\n\n官网推荐使用[Certbot](https://certbot.eff.org/)工具来部署Https证书。在Certbot首页上选择Web服务器及服务器OS类型，我们在这里以Nginx + CentOS 6为例来说明。\n\n原文链接：[https://certbot.eff.org/#centos6-nginx](https://certbot.eff.org/#centos6-nginx)\n\n0. #### 生成证书\n\n\t0. 安装证书生成工具certbot-auto：\n\n\t\t```\n\t\twget https://dl.eff.org/certbot-auto\n\t\tchmod a+x certbot-auto\n\t\t```\n\t0. 安装依赖\n\n\t\t运行```./certbot-auto```，安装所有依赖项。过程中可能会提示```Virtualenv Command Not Found```，需要[安装pip](https://pip.pypa.io/en/stable/installing/)、virtualenv包：```pip install virtualenv```。\n\n\t0. 配置Nginx\n\t\t\n\t\t为需要配置https的站点添加以下配置，将访问/.well-known的请求指向本地目录。Let's Encrypt在生成证书的过程中，会在/var/www/www.xxx.com/.well-known目录生成一个临时文件，并且会访问类似于http://www.xxx.com/.well-known/acme-challenge/HGr8U1IeTW4kY_Z6UIyaakzOkyQgPr_7ArlLgtZE8SX的url，来检查域名配置是否有效。\n\n\t\t添加以下配置，并重启Nginx：nginx -s reload，如果reload不生效，可以试试restart。\n\t\t\n\t\t```\n\t\tserver {\n\n\t\t\t...\t\t\t\n\n\t\t\tlocation /.well-known {\n\t        \talias /var/www/www.xxx.com/.well-known;\n\t    \t}\n\n\t\t\t...\n\n\t\t}\n\t\t```\n\n\t\t*即使证书生成之后，也需要保留Nginx的这一个配置，因为证书的续期还需要这一个配置。*\n\n\t0. 通过向导生成证书\n\n\t\t运行```./certbot-auto certonly```，会通过向导方式一步一步来生成证书。过程中间会用到上一步在Nginx中配置的本地目录。\n\n\t\t**对证书生成过程和原理比较熟悉的话，可以不使用向导方式，直接使用certbot-auto命令```./certbot-auto certonly --webroot -w /var/www/www.xxx.com -d xxx.com -d www.xxx.com -w /var/www/thing -d thing.is -d m.thing.is```可以快速高效地生成证书**\n\n\t\t生成的证书默认在/etc/letsencrypt/live/www.xxx.com/目录。\n\n0. #### 配置Nginx使用证书\n\n\t添加以下配置，并重启Nginx：```nginx -s reload```，如果reload不生效，可以试试restart。\n\n\t```\n\tserver {\n\n\t\t...\n\t\tlisten 443;\n\n\t    ssl on;\n        ssl_stapling_verify on;\n        ssl_certificate         /etc/letsencrypt/live/www.xxx.com/fullchain.pem;\n        ssl_certificate_key     /etc/letsencrypt/live/www.xxx.com/privkey.pem;\n\n\t\t...\n\n\t}\n\t```\n\n0. #### 检查证书的有效性\n\n\t打开浏览器，检查证书的有效性。\n\n0. #### 证书续期\n\n\tLet's Encrypt颁发的证书有期是90天，需要在过期前进行续期，好在Let's Encrypt已经提供了自动续期的脚本。\n\n\t官网说明，可以一天调用两次，如果检测到证书不需要更新，是什么都不做的，以减少意外造成的故障。\n\n\t先运行```certbot-auto renew --dry-run```命令检查证书自动续期是否正常，如果正常，将```certbot-auto renew --quiet```命令添加到系统的计划任务cron中，就可以实现证书自动续期了。\n\n\t```\n\t01 1 * * * ./path/to/certbot-auto renew --quiet\n\t```\n\t表示每天的1点1分自动执行续期脚本。\n\n\n\n\n\n","source":"_posts/Let's Encrypt SSL.md","raw":"---\ntitle: Let's Encrypt\ndate: 2016-12-21 11:47:39\ntags: https\n---\n\n### 使用Let's Encrypt生成免费SSL证书\n\n官网：[Let's Encrypt](https://letsencrypt.org/)\n\nLet's Encrypt是由互联网安全研究小组（ISRG，一个公益组织）提供的服务。提供免费、自动化、开放的证书签发服务。\n\nLet's Encrypt颁发的证书有期是90天，需要在过期前进行续期，好在Let's Encrypt已经提供了自动续期的脚本。\n\n官网推荐使用[Certbot](https://certbot.eff.org/)工具来部署Https证书。在Certbot首页上选择Web服务器及服务器OS类型，我们在这里以Nginx + CentOS 6为例来说明。\n\n原文链接：[https://certbot.eff.org/#centos6-nginx](https://certbot.eff.org/#centos6-nginx)\n\n0. #### 生成证书\n\n\t0. 安装证书生成工具certbot-auto：\n\n\t\t```\n\t\twget https://dl.eff.org/certbot-auto\n\t\tchmod a+x certbot-auto\n\t\t```\n\t0. 安装依赖\n\n\t\t运行```./certbot-auto```，安装所有依赖项。过程中可能会提示```Virtualenv Command Not Found```，需要[安装pip](https://pip.pypa.io/en/stable/installing/)、virtualenv包：```pip install virtualenv```。\n\n\t0. 配置Nginx\n\t\t\n\t\t为需要配置https的站点添加以下配置，将访问/.well-known的请求指向本地目录。Let's Encrypt在生成证书的过程中，会在/var/www/www.xxx.com/.well-known目录生成一个临时文件，并且会访问类似于http://www.xxx.com/.well-known/acme-challenge/HGr8U1IeTW4kY_Z6UIyaakzOkyQgPr_7ArlLgtZE8SX的url，来检查域名配置是否有效。\n\n\t\t添加以下配置，并重启Nginx：nginx -s reload，如果reload不生效，可以试试restart。\n\t\t\n\t\t```\n\t\tserver {\n\n\t\t\t...\t\t\t\n\n\t\t\tlocation /.well-known {\n\t        \talias /var/www/www.xxx.com/.well-known;\n\t    \t}\n\n\t\t\t...\n\n\t\t}\n\t\t```\n\n\t\t*即使证书生成之后，也需要保留Nginx的这一个配置，因为证书的续期还需要这一个配置。*\n\n\t0. 通过向导生成证书\n\n\t\t运行```./certbot-auto certonly```，会通过向导方式一步一步来生成证书。过程中间会用到上一步在Nginx中配置的本地目录。\n\n\t\t**对证书生成过程和原理比较熟悉的话，可以不使用向导方式，直接使用certbot-auto命令```./certbot-auto certonly --webroot -w /var/www/www.xxx.com -d xxx.com -d www.xxx.com -w /var/www/thing -d thing.is -d m.thing.is```可以快速高效地生成证书**\n\n\t\t生成的证书默认在/etc/letsencrypt/live/www.xxx.com/目录。\n\n0. #### 配置Nginx使用证书\n\n\t添加以下配置，并重启Nginx：```nginx -s reload```，如果reload不生效，可以试试restart。\n\n\t```\n\tserver {\n\n\t\t...\n\t\tlisten 443;\n\n\t    ssl on;\n        ssl_stapling_verify on;\n        ssl_certificate         /etc/letsencrypt/live/www.xxx.com/fullchain.pem;\n        ssl_certificate_key     /etc/letsencrypt/live/www.xxx.com/privkey.pem;\n\n\t\t...\n\n\t}\n\t```\n\n0. #### 检查证书的有效性\n\n\t打开浏览器，检查证书的有效性。\n\n0. #### 证书续期\n\n\tLet's Encrypt颁发的证书有期是90天，需要在过期前进行续期，好在Let's Encrypt已经提供了自动续期的脚本。\n\n\t官网说明，可以一天调用两次，如果检测到证书不需要更新，是什么都不做的，以减少意外造成的故障。\n\n\t先运行```certbot-auto renew --dry-run```命令检查证书自动续期是否正常，如果正常，将```certbot-auto renew --quiet```命令添加到系统的计划任务cron中，就可以实现证书自动续期了。\n\n\t```\n\t01 1 * * * ./path/to/certbot-auto renew --quiet\n\t```\n\t表示每天的1点1分自动执行续期脚本。\n\n\n\n\n\n","slug":"Let's Encrypt SSL","published":1,"updated":"2019-07-26T08:35:17.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5bwexcb0001998su8twhddl","content":"<h3 id=\"使用Let’s-Encrypt生成免费SSL证书\"><a href=\"#使用Let’s-Encrypt生成免费SSL证书\" class=\"headerlink\" title=\"使用Let’s Encrypt生成免费SSL证书\"></a>使用Let’s Encrypt生成免费SSL证书</h3><p>官网：<a href=\"https://letsencrypt.org/\" target=\"_blank\" rel=\"noopener\">Let’s Encrypt</a></p>\n<p>Let’s Encrypt是由互联网安全研究小组（ISRG，一个公益组织）提供的服务。提供免费、自动化、开放的证书签发服务。</p>\n<p>Let’s Encrypt颁发的证书有期是90天，需要在过期前进行续期，好在Let’s Encrypt已经提供了自动续期的脚本。</p>\n<p>官网推荐使用<a href=\"https://certbot.eff.org/\" target=\"_blank\" rel=\"noopener\">Certbot</a>工具来部署Https证书。在Certbot首页上选择Web服务器及服务器OS类型，我们在这里以Nginx + CentOS 6为例来说明。</p>\n<p>原文链接：<a href=\"https://certbot.eff.org/#centos6-nginx\" target=\"_blank\" rel=\"noopener\">https://certbot.eff.org/#centos6-nginx</a></p>\n<ol start=\"0\">\n<li><h4 id=\"生成证书\"><a href=\"#生成证书\" class=\"headerlink\" title=\"生成证书\"></a>生成证书</h4><ol start=\"0\">\n<li><p>安装证书生成工具certbot-auto：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://dl.eff.org/certbot-auto</span><br><span class=\"line\">chmod a+x certbot-auto</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>安装依赖</p>\n<p> 运行<figure class=\"highlight plain\"><figcaption><span>Command Not Found```，需要[安装pip](https://pip.pypa.io/en/stable/installing/)、virtualenv包：```pip install virtualenv```。</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">0. 配置Nginx</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t为需要配置https的站点添加以下配置，将访问/.well-known的请求指向本地目录。Let&apos;s Encrypt在生成证书的过程中，会在/var/www/www.xxx.com/.well-known目录生成一个临时文件，并且会访问类似于http://www.xxx.com/.well-known/acme-challenge/HGr8U1IeTW4kY_Z6UIyaakzOkyQgPr_7ArlLgtZE8SX的url，来检查域名配置是否有效。</span><br><span class=\"line\"></span><br><span class=\"line\">\t添加以下配置，并重启Nginx：nginx -s reload，如果reload不生效，可以试试restart。</span><br></pre></td></tr></table></figure></p>\n<p> server {</p>\n<pre><code>...            \n\nlocation /.well-known {\n    alias /var/www/www.xxx.com/.well-known;\n}\n\n...\n</code></pre><p> }</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">\t\t*即使证书生成之后，也需要保留Nginx的这一个配置，因为证书的续期还需要这一个配置。*</span><br><span class=\"line\"></span><br><span class=\"line\">\t0. 通过向导生成证书</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t运行```./certbot-auto certonly```，会通过向导方式一步一步来生成证书。过程中间会用到上一步在Nginx中配置的本地目录。</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t**对证书生成过程和原理比较熟悉的话，可以不使用向导方式，直接使用certbot-auto命令```./certbot-auto certonly --webroot -w /var/www/www.xxx.com -d xxx.com -d www.xxx.com -w /var/www/thing -d thing.is -d m.thing.is```可以快速高效地生成证书**</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t生成的证书默认在/etc/letsencrypt/live/www.xxx.com/目录。</span><br><span class=\"line\"></span><br><span class=\"line\">0. #### 配置Nginx使用证书</span><br><span class=\"line\"></span><br><span class=\"line\">\t添加以下配置，并重启Nginx：```nginx -s reload```，如果reload不生效，可以试试restart。</span><br></pre></td></tr></table></figure>\n<p>server {</p>\n<p> …<br> listen 443;</p>\n<p> ssl on;<br> ssl_stapling_verify on;<br> ssl_certificate         /etc/letsencrypt/live/<a href=\"http://www.xxx.com/fullchain.pem\" target=\"_blank\" rel=\"noopener\">www.xxx.com/fullchain.pem</a>;<br> ssl_certificate_key     /etc/letsencrypt/live/<a href=\"http://www.xxx.com/privkey.pem\" target=\"_blank\" rel=\"noopener\">www.xxx.com/privkey.pem</a>;</p>\n<p> …</p>\n<p>}</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">0. #### 检查证书的有效性</span><br><span class=\"line\"></span><br><span class=\"line\">\t打开浏览器，检查证书的有效性。</span><br><span class=\"line\"></span><br><span class=\"line\">0. #### 证书续期</span><br><span class=\"line\"></span><br><span class=\"line\">\tLet&apos;s Encrypt颁发的证书有期是90天，需要在过期前进行续期，好在Let&apos;s Encrypt已经提供了自动续期的脚本。</span><br><span class=\"line\"></span><br><span class=\"line\">\t官网说明，可以一天调用两次，如果检测到证书不需要更新，是什么都不做的，以减少意外造成的故障。</span><br><span class=\"line\"></span><br><span class=\"line\">\t先运行```certbot-auto renew --dry-run```命令检查证书自动续期是否正常，如果正常，将```certbot-auto renew --quiet```命令添加到系统的计划任务cron中，就可以实现证书自动续期了。</span><br></pre></td></tr></table></figure>\n<p>01 1 <em> </em> * ./path/to/certbot-auto renew –quiet<br><code>`</code><br>表示每天的1点1分自动执行续期脚本。</p>\n</li>\n</ol>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"使用Let’s-Encrypt生成免费SSL证书\"><a href=\"#使用Let’s-Encrypt生成免费SSL证书\" class=\"headerlink\" title=\"使用Let’s Encrypt生成免费SSL证书\"></a>使用Let’s Encrypt生成免费SSL证书</h3><p>官网：<a href=\"https://letsencrypt.org/\" target=\"_blank\" rel=\"noopener\">Let’s Encrypt</a></p>\n<p>Let’s Encrypt是由互联网安全研究小组（ISRG，一个公益组织）提供的服务。提供免费、自动化、开放的证书签发服务。</p>\n<p>Let’s Encrypt颁发的证书有期是90天，需要在过期前进行续期，好在Let’s Encrypt已经提供了自动续期的脚本。</p>\n<p>官网推荐使用<a href=\"https://certbot.eff.org/\" target=\"_blank\" rel=\"noopener\">Certbot</a>工具来部署Https证书。在Certbot首页上选择Web服务器及服务器OS类型，我们在这里以Nginx + CentOS 6为例来说明。</p>\n<p>原文链接：<a href=\"https://certbot.eff.org/#centos6-nginx\" target=\"_blank\" rel=\"noopener\">https://certbot.eff.org/#centos6-nginx</a></p>\n<ol start=\"0\">\n<li><h4 id=\"生成证书\"><a href=\"#生成证书\" class=\"headerlink\" title=\"生成证书\"></a>生成证书</h4><ol start=\"0\">\n<li><p>安装证书生成工具certbot-auto：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://dl.eff.org/certbot-auto</span><br><span class=\"line\">chmod a+x certbot-auto</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>安装依赖</p>\n<p> 运行<figure class=\"highlight plain\"><figcaption><span>Command Not Found```，需要[安装pip](https://pip.pypa.io/en/stable/installing/)、virtualenv包：```pip install virtualenv```。</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">0. 配置Nginx</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t为需要配置https的站点添加以下配置，将访问/.well-known的请求指向本地目录。Let&apos;s Encrypt在生成证书的过程中，会在/var/www/www.xxx.com/.well-known目录生成一个临时文件，并且会访问类似于http://www.xxx.com/.well-known/acme-challenge/HGr8U1IeTW4kY_Z6UIyaakzOkyQgPr_7ArlLgtZE8SX的url，来检查域名配置是否有效。</span><br><span class=\"line\"></span><br><span class=\"line\">\t添加以下配置，并重启Nginx：nginx -s reload，如果reload不生效，可以试试restart。</span><br></pre></td></tr></table></figure></p>\n<p> server {</p>\n<pre><code>...            \n\nlocation /.well-known {\n    alias /var/www/www.xxx.com/.well-known;\n}\n\n...\n</code></pre><p> }</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">\t\t*即使证书生成之后，也需要保留Nginx的这一个配置，因为证书的续期还需要这一个配置。*</span><br><span class=\"line\"></span><br><span class=\"line\">\t0. 通过向导生成证书</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t运行```./certbot-auto certonly```，会通过向导方式一步一步来生成证书。过程中间会用到上一步在Nginx中配置的本地目录。</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t**对证书生成过程和原理比较熟悉的话，可以不使用向导方式，直接使用certbot-auto命令```./certbot-auto certonly --webroot -w /var/www/www.xxx.com -d xxx.com -d www.xxx.com -w /var/www/thing -d thing.is -d m.thing.is```可以快速高效地生成证书**</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t生成的证书默认在/etc/letsencrypt/live/www.xxx.com/目录。</span><br><span class=\"line\"></span><br><span class=\"line\">0. #### 配置Nginx使用证书</span><br><span class=\"line\"></span><br><span class=\"line\">\t添加以下配置，并重启Nginx：```nginx -s reload```，如果reload不生效，可以试试restart。</span><br></pre></td></tr></table></figure>\n<p>server {</p>\n<p> …<br> listen 443;</p>\n<p> ssl on;<br> ssl_stapling_verify on;<br> ssl_certificate         /etc/letsencrypt/live/<a href=\"http://www.xxx.com/fullchain.pem\" target=\"_blank\" rel=\"noopener\">www.xxx.com/fullchain.pem</a>;<br> ssl_certificate_key     /etc/letsencrypt/live/<a href=\"http://www.xxx.com/privkey.pem\" target=\"_blank\" rel=\"noopener\">www.xxx.com/privkey.pem</a>;</p>\n<p> …</p>\n<p>}</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">0. #### 检查证书的有效性</span><br><span class=\"line\"></span><br><span class=\"line\">\t打开浏览器，检查证书的有效性。</span><br><span class=\"line\"></span><br><span class=\"line\">0. #### 证书续期</span><br><span class=\"line\"></span><br><span class=\"line\">\tLet&apos;s Encrypt颁发的证书有期是90天，需要在过期前进行续期，好在Let&apos;s Encrypt已经提供了自动续期的脚本。</span><br><span class=\"line\"></span><br><span class=\"line\">\t官网说明，可以一天调用两次，如果检测到证书不需要更新，是什么都不做的，以减少意外造成的故障。</span><br><span class=\"line\"></span><br><span class=\"line\">\t先运行```certbot-auto renew --dry-run```命令检查证书自动续期是否正常，如果正常，将```certbot-auto renew --quiet```命令添加到系统的计划任务cron中，就可以实现证书自动续期了。</span><br></pre></td></tr></table></figure>\n<p>01 1 <em> </em> * ./path/to/certbot-auto renew –quiet<br><code>`</code><br>表示每天的1点1分自动执行续期脚本。</p>\n</li>\n</ol>\n</li>\n</ol>\n"},{"title":"cookies","date":"2019-06-24T06:40:18.000Z","_content":"\n:smile:\n### 发版\n1. 发布阶段：更新chagelog ,打 git tag 。\n\n### word\n1. deflate 放气，紧缩\n1. Sanitize 消毒，净化\n1. \n### js\n\n1. 随机字符串 Math.random().toString(36).substr(2));\n\n2. Babel pollyfy 的作用 ：https://zhuanlan.zhihu.com/p/29058936\n\n3. Babel stag2 的功能  https://github.com/babel/babel/tree/master/packages/babel-preset-stage-2\n1. 所有的babel 包  https://github.com/babel/babel/tree/master/packages\n1.  npx babel-upgrade\n1. ES2019 中为Symbol对象添加了只读属性 description ，该对象返回包含Symbol描述的字符串。\n1. 变量的临时死区  \n1. SET 操作的时间复杂度\n1. 如果你传的 context 就 null 或者 undefined，那么 window 对象就是默认的 context（严格模式下默认 context 是 undefined）\n1. 高阶函数的定义\n1. 作用域以及作用域链  函数作用域 —闭包\n1. ES6 模块功能是它的导入模块是导出时模块的实时只读视图。（相比起 CommonJS，导入的是导出模块的拷贝副本，因此也不是实时的）。只读视图和内存拷贝的区别。\n1. atob() 对经过 base-64 编码的字符串进行解码,btoa() base64加吗\n1. Console.dir  显示对象所有的属性和方法\n1. Broadcast Channel API 允许同一原始域和用户代理下的所有窗口,iFrames 等进行交互。也就是说，如果用户打开了同一个网站的的两个标签窗口，如果网站内容发生了变化，那么两个窗口会同时得到更新通知。\n1. escape 在处理 0xff 之外字符的时候，是直接使用字符的 unicode 在前面加上一个 「%u」，而encodeURI则是先进行 UTF-8，再在 UTF-8 的每个字节码前加上一个 「%」； 所以通过encodeUrI 可以获取utf-8 字节长度\n1. js value\n1. Prototype 包含constructor 和 __proto__. 原型链存储共有的属性和方法，减少内存\n1. 基本的数据类型 \n```text\n基本的数据类型\nundefined\nnull\nstring\nboolean\nnumber\nsymbol(ES6)\n\n```\n1. navigator.userAgent: 返回当前浏览器的user agent字符串\n1. 懒加载：\n   Javascript 脚步通常要等到 DOM 加载完后才会执行，如果加载的资源过多，可能会影响网页的正常使用。\n   能够节省流量和减轻服务器压力，更近一步就是能够为公司省成本。\n1. String 和 new String 区别\n1. \n\n```text\n对象转原始类型，会调用内置的[ToPrimitive]函数，对于该函数而言，其逻辑如下：\n\n如果Symbol.toPrimitive()方法，优先调用再返回\n调用valueOf()，如果转换为原始类型，则返回\n调用toString()，如果转换为原始类型，则返回\n如果都没有返回原始类型，会报错\nvar a = {\n  value: 0,\n  valueOf: function() {\n    this.value++;\n    return this.value;\n  }\n};\nconsole.log(a == 1 && a == 2);//true\n\n```\n1. Same origin 可以使用broadcast channel 两页面间通信。\n1. 注意闭包内this的指向\n1. \n\n#### 编译\n1. 无论你使用的是解释型语言(JavaScript、Python、Ruby)还是编译型语言(c#、Java、Rust)，都有一个共同的部分:将源代码作为纯文本解析为 抽象语法树(abstract syntax tree, AST) 的数据结构。\n1. AST 不仅以结构化的方式显示源代码，而且在语义分析中扮演着重要角色。在语义分析中，编译器验证程序和语言元素的语法使用是否正确。之后，使用 AST 来生成实际的字节码或者机器码。\n1. 转义的过程：\n   ```text\n   编写ES6代码\n   babylon 进行解析\n   解析得到 AST\n   plugin 用 babel-traverse 对 AST 树进行遍历转译\n   得到新的 AST树\n   用 babel-generator 通过 AST 树生成 ES5 代码\n   ```\n1. 要应用更新，Virtual DOM核心功能将发挥作用，即 协调算法，它的工作是提供最优的解决方案来解决以前和当前虚拟DOM 状态之间的差异。\n\n## opentracing\n1. Opentracing 的carrier 有多种实现，tracer 的inject（客户端进程） 和 extract（服务端进程），这样 客户端和服务端 就可以拥有相同的trace context。\n1. Server 首先extract check 有没有注入的span，没有的话启动一个新的span\n\n## mac\n1. Mac 设置path  export PATH=$PATH:\n1.  查看端口占用：lsof -i:3001\n1. export http_proxy=\"http://localhost:8899\"\n1. Grep -A 5 显示后面5行信息\n\n## npm\n1. npm config edit\n1. npm config set init.author.name \"ryansecreat\"\n1. npm config set init.email='chenjingnan@jd.com’\n1. npm config set init.license \"MIT\"\n1. npm start --prefix path/to/your/folder   //指定目录下运行\n1. npm repo   浏览器中打开repo\n1. npm publish --registry=http://registry.npmjs.org  --registry=https://registry.npm.taobao.org\n1. npm outdated  查看过时package\n1. npm publish --tag=beta.\n1. npm version patch -m \"Upgrade to %s for reasons”\n1. npm dist-tag add n-n-n-n@1.0.2-1 latest  将某个预发版本更新为最新   \n1. npm ping [--registry <registry>]\n\n### node\n1. Stream cork uncork\n1. escape-html  This function will escape the following characters: \", ', &, <, and >.\n1. domain模块，把处理多个不同的IO的操作作为一个组。注册事件和回调到domain，当发生一个错误事件或抛出一个错误时，domain对象会被通知，不会丢失上下文环境，也不导致程序错误立即退出，与process.on('uncaughtException')不同。\n1. stream tranform\n```text\nconst { Transform } = require('stream');\n\nconst myTransform = new Transform({\n  transform(chunk, encoding, callback) {\n    // ...\n  }\n});\n```\n1. 可以引入corejs实现feature\n1. 性能分析\nNode 性能分析，抓取火焰图 node --inspect app.js\nNode  --prof-process  https://github.com/nswbmw/node-in-debugging/blob/master/1.3%20Tick%20Processor.md\n \n1. 一个promise类 \n```javascript\nclass Sleep {\nthen(resolve, reject){\n\n}\n}\n```\n1. Node 内置了pipeline  const { pipeline } = require('stream');\n1. Elastic APM 是 Elastic 公司开源的一款 APM 工具\n1. Error.prepareStackTrace:定制化堆栈信息    Error.captureStackTrace:隐藏内部的实现细节，优化错误栈。\n1. const { EventEmitter } = require('events’);  EventEmitter 的继承\n1. Require.resovle() 获取模块的绝对路径  \n1. peerDependencies 相关模块安装\n1. websocket \n1. cors 新浏览器\nSameSite=Strict: The cookie is only sent if you are currently on the site that the cookie is set for. If you are on a different site and you click a link to a site that the cookie is set for, the cookie is not sent with the first request.\n1. \n1. \n\n```text\nWebSocket 使用了自定义的二进制分帧格式，把每个应用消息切分成一或多个帧，发送到目的地之后再组装起来，等到接收到完整的消息后再通知接收端。基本的成帧协议定义了帧类型有操作码、有效载荷的长度，指定位置的Extension data和Application data，统称为Payload data，保留了一些特殊位和操作码供后期扩展。在打开握手完成后，终端发送一个关闭帧之前的任何时间里，数据帧可能由客户端或服务器的任何一方发送。\n\n• 帧：最小的通信单位，包含可变长度的帧首部和净荷部分，净荷可能包含完整或部分应用消息。\n• 消息：一系列帧，与应用消息对等。\n```\n1. jwt 签名算法\n```text\nHS256 使用密钥生成固定的签名，RS256 使用成非对称进行签名。简单地说，HS256 必须与任何想要验证 JWT的 客户端或 API 共享秘密。\nRS256 生成非对称签名，这意味着必须使用私钥来签签名 JWT，并且必须使用对应的公钥来验证签名。与对称算法不同，使用 RS256 可以保证服务端是 JWT 的签名者，因为服务端是唯一拥有私钥的一方。这样做将不再需要在许多应用程序之间共享私钥\n\n这种方法可以让我们分离开签发与验证，签发时需要用一个密钥，验证时使用公钥，也就是有公钥的地方只能做验证，但不能签发 JWT。\n```\n### egg\n1. 启动顺序\n```text\nMaster 启动后先 fork Agent 进程\nAgent 初始化成功后，通过 IPC 通道通知 Master\nMaster 再 fork 多个 App Worker\nApp Worker 初始化成功，通知 Master\n所有的进程初始化成功后，Master 通知 Agent 和 Worker 应用启动成功\n```\n### 网络\n1. 子网是所属VPC IP地址范围内的 IP 地址块。目前私有网络中的云资源部署在子网内，如云主机、容器、负载均衡等。子网：子网是对VPC地址空间的再一次划分，用户可以在子网中创建云主机。\n\n1. 可用区（Availability Zone）是电力及网络之间互相独立的物理区域，相同可用区内的实例之间较之同地域不同可用区内实例之间的网络延时更小。同地域内不同可用区之间提供内网互通环境，可用区之间可做到故障隔离。\n  若您的业务要求有较低网络时延，建议将实例或者Pod部署在同一可用区内。\n1. VPC：VPC是用户网络在京东云上的表现形式，包含了一系列的网络功能，与其他的VPC逻辑隔离。VPC有一个网络地址空间，用户可以在其中继续划分子网。\n1. NAT 地址网络转换，通过在路由器上安装 NAT 软件，它至少有一个有效的公网 IP 地址，通过 NAT 路由器将内部私有 IP 转换成公网 IP。它的问题在于 NAT 设备自动屏蔽了非内网主机主动发起的连接，也就是说，从外网发往内网的数据包将被 NAT 设备丢弃，这使得位于不同 NAT 设备之后的主机之间无法直接交换信息.\n  \n1. 503 服务器资源不足问题导致的拒绝服务，比如熔断。\n1. Options  \n```text\n   1. 检测服务支持的method\n   2. Cors 预检\n```\n1. HTTP HEAD 方法 请求资源的头部信息, 并且这些头部与 HTTP GET 方法请求时返回的一致. 该请求方法的一个使用场景是在下载一个大文件前先获取其大小再决定是否要下载, 以此可以节约带宽资源.\n1. WebSocket是基于Http协议的，或者说借用了Http协议来完成一部分握手，在握手阶段与Http是相同的。我们来看一个websocket握手协议的实现，基本是2个属性，upgrade，connection。\n```text\nUpgrade:webSocket\nConnection:Upgrade\n```\n\n### html\n1. Web quality  : alt\n1. 该WindowEventHandlers.onstorage属性包含一个在storage事件触发时运行的事件处理程序。当更改存储区域时会发生这种情况（例如，存储新项目）。\n```javascript\n   window.onstorage = function(e) { console.log('The ' + e.key + ' key has been changed from ' + e.oldValue + ' to ' + e.newValue + '.'); };\n```\n1. navigator.sendBeacon() 方法可用于通过HTTP将少量数据异步传输到Web服务器。\n  \n### vim \nj: 下移一行；\n\nk: 上移一行；\n\nw: 前移一个单词，光标停在下一个单词开头；\n\ne: 前移一个单词，光标停在下一个单词末尾；\n\n0: 移动到行首。\n\n$: 移动到行尾。\n\nn|: 把光标移到递n列上\n\nzz: 将当前行移动到屏幕中央。\n\no: 在下面新建一行插入；\n\nO: 在上面新建一行插入；\n\na: 在光标后插入；\n\nA: 在当前行最后插入；\n\nu: 取消一(n)个改动。\n\nctrl + r: 重做最后的改动。","source":"_posts/cookies.md","raw":"---\ntitle: cookies\ndate: 2019-06-24 14:40:18\ntags: 零碎\n---\n\n:smile:\n### 发版\n1. 发布阶段：更新chagelog ,打 git tag 。\n\n### word\n1. deflate 放气，紧缩\n1. Sanitize 消毒，净化\n1. \n### js\n\n1. 随机字符串 Math.random().toString(36).substr(2));\n\n2. Babel pollyfy 的作用 ：https://zhuanlan.zhihu.com/p/29058936\n\n3. Babel stag2 的功能  https://github.com/babel/babel/tree/master/packages/babel-preset-stage-2\n1. 所有的babel 包  https://github.com/babel/babel/tree/master/packages\n1.  npx babel-upgrade\n1. ES2019 中为Symbol对象添加了只读属性 description ，该对象返回包含Symbol描述的字符串。\n1. 变量的临时死区  \n1. SET 操作的时间复杂度\n1. 如果你传的 context 就 null 或者 undefined，那么 window 对象就是默认的 context（严格模式下默认 context 是 undefined）\n1. 高阶函数的定义\n1. 作用域以及作用域链  函数作用域 —闭包\n1. ES6 模块功能是它的导入模块是导出时模块的实时只读视图。（相比起 CommonJS，导入的是导出模块的拷贝副本，因此也不是实时的）。只读视图和内存拷贝的区别。\n1. atob() 对经过 base-64 编码的字符串进行解码,btoa() base64加吗\n1. Console.dir  显示对象所有的属性和方法\n1. Broadcast Channel API 允许同一原始域和用户代理下的所有窗口,iFrames 等进行交互。也就是说，如果用户打开了同一个网站的的两个标签窗口，如果网站内容发生了变化，那么两个窗口会同时得到更新通知。\n1. escape 在处理 0xff 之外字符的时候，是直接使用字符的 unicode 在前面加上一个 「%u」，而encodeURI则是先进行 UTF-8，再在 UTF-8 的每个字节码前加上一个 「%」； 所以通过encodeUrI 可以获取utf-8 字节长度\n1. js value\n1. Prototype 包含constructor 和 __proto__. 原型链存储共有的属性和方法，减少内存\n1. 基本的数据类型 \n```text\n基本的数据类型\nundefined\nnull\nstring\nboolean\nnumber\nsymbol(ES6)\n\n```\n1. navigator.userAgent: 返回当前浏览器的user agent字符串\n1. 懒加载：\n   Javascript 脚步通常要等到 DOM 加载完后才会执行，如果加载的资源过多，可能会影响网页的正常使用。\n   能够节省流量和减轻服务器压力，更近一步就是能够为公司省成本。\n1. String 和 new String 区别\n1. \n\n```text\n对象转原始类型，会调用内置的[ToPrimitive]函数，对于该函数而言，其逻辑如下：\n\n如果Symbol.toPrimitive()方法，优先调用再返回\n调用valueOf()，如果转换为原始类型，则返回\n调用toString()，如果转换为原始类型，则返回\n如果都没有返回原始类型，会报错\nvar a = {\n  value: 0,\n  valueOf: function() {\n    this.value++;\n    return this.value;\n  }\n};\nconsole.log(a == 1 && a == 2);//true\n\n```\n1. Same origin 可以使用broadcast channel 两页面间通信。\n1. 注意闭包内this的指向\n1. \n\n#### 编译\n1. 无论你使用的是解释型语言(JavaScript、Python、Ruby)还是编译型语言(c#、Java、Rust)，都有一个共同的部分:将源代码作为纯文本解析为 抽象语法树(abstract syntax tree, AST) 的数据结构。\n1. AST 不仅以结构化的方式显示源代码，而且在语义分析中扮演着重要角色。在语义分析中，编译器验证程序和语言元素的语法使用是否正确。之后，使用 AST 来生成实际的字节码或者机器码。\n1. 转义的过程：\n   ```text\n   编写ES6代码\n   babylon 进行解析\n   解析得到 AST\n   plugin 用 babel-traverse 对 AST 树进行遍历转译\n   得到新的 AST树\n   用 babel-generator 通过 AST 树生成 ES5 代码\n   ```\n1. 要应用更新，Virtual DOM核心功能将发挥作用，即 协调算法，它的工作是提供最优的解决方案来解决以前和当前虚拟DOM 状态之间的差异。\n\n## opentracing\n1. Opentracing 的carrier 有多种实现，tracer 的inject（客户端进程） 和 extract（服务端进程），这样 客户端和服务端 就可以拥有相同的trace context。\n1. Server 首先extract check 有没有注入的span，没有的话启动一个新的span\n\n## mac\n1. Mac 设置path  export PATH=$PATH:\n1.  查看端口占用：lsof -i:3001\n1. export http_proxy=\"http://localhost:8899\"\n1. Grep -A 5 显示后面5行信息\n\n## npm\n1. npm config edit\n1. npm config set init.author.name \"ryansecreat\"\n1. npm config set init.email='chenjingnan@jd.com’\n1. npm config set init.license \"MIT\"\n1. npm start --prefix path/to/your/folder   //指定目录下运行\n1. npm repo   浏览器中打开repo\n1. npm publish --registry=http://registry.npmjs.org  --registry=https://registry.npm.taobao.org\n1. npm outdated  查看过时package\n1. npm publish --tag=beta.\n1. npm version patch -m \"Upgrade to %s for reasons”\n1. npm dist-tag add n-n-n-n@1.0.2-1 latest  将某个预发版本更新为最新   \n1. npm ping [--registry <registry>]\n\n### node\n1. Stream cork uncork\n1. escape-html  This function will escape the following characters: \", ', &, <, and >.\n1. domain模块，把处理多个不同的IO的操作作为一个组。注册事件和回调到domain，当发生一个错误事件或抛出一个错误时，domain对象会被通知，不会丢失上下文环境，也不导致程序错误立即退出，与process.on('uncaughtException')不同。\n1. stream tranform\n```text\nconst { Transform } = require('stream');\n\nconst myTransform = new Transform({\n  transform(chunk, encoding, callback) {\n    // ...\n  }\n});\n```\n1. 可以引入corejs实现feature\n1. 性能分析\nNode 性能分析，抓取火焰图 node --inspect app.js\nNode  --prof-process  https://github.com/nswbmw/node-in-debugging/blob/master/1.3%20Tick%20Processor.md\n \n1. 一个promise类 \n```javascript\nclass Sleep {\nthen(resolve, reject){\n\n}\n}\n```\n1. Node 内置了pipeline  const { pipeline } = require('stream');\n1. Elastic APM 是 Elastic 公司开源的一款 APM 工具\n1. Error.prepareStackTrace:定制化堆栈信息    Error.captureStackTrace:隐藏内部的实现细节，优化错误栈。\n1. const { EventEmitter } = require('events’);  EventEmitter 的继承\n1. Require.resovle() 获取模块的绝对路径  \n1. peerDependencies 相关模块安装\n1. websocket \n1. cors 新浏览器\nSameSite=Strict: The cookie is only sent if you are currently on the site that the cookie is set for. If you are on a different site and you click a link to a site that the cookie is set for, the cookie is not sent with the first request.\n1. \n1. \n\n```text\nWebSocket 使用了自定义的二进制分帧格式，把每个应用消息切分成一或多个帧，发送到目的地之后再组装起来，等到接收到完整的消息后再通知接收端。基本的成帧协议定义了帧类型有操作码、有效载荷的长度，指定位置的Extension data和Application data，统称为Payload data，保留了一些特殊位和操作码供后期扩展。在打开握手完成后，终端发送一个关闭帧之前的任何时间里，数据帧可能由客户端或服务器的任何一方发送。\n\n• 帧：最小的通信单位，包含可变长度的帧首部和净荷部分，净荷可能包含完整或部分应用消息。\n• 消息：一系列帧，与应用消息对等。\n```\n1. jwt 签名算法\n```text\nHS256 使用密钥生成固定的签名，RS256 使用成非对称进行签名。简单地说，HS256 必须与任何想要验证 JWT的 客户端或 API 共享秘密。\nRS256 生成非对称签名，这意味着必须使用私钥来签签名 JWT，并且必须使用对应的公钥来验证签名。与对称算法不同，使用 RS256 可以保证服务端是 JWT 的签名者，因为服务端是唯一拥有私钥的一方。这样做将不再需要在许多应用程序之间共享私钥\n\n这种方法可以让我们分离开签发与验证，签发时需要用一个密钥，验证时使用公钥，也就是有公钥的地方只能做验证，但不能签发 JWT。\n```\n### egg\n1. 启动顺序\n```text\nMaster 启动后先 fork Agent 进程\nAgent 初始化成功后，通过 IPC 通道通知 Master\nMaster 再 fork 多个 App Worker\nApp Worker 初始化成功，通知 Master\n所有的进程初始化成功后，Master 通知 Agent 和 Worker 应用启动成功\n```\n### 网络\n1. 子网是所属VPC IP地址范围内的 IP 地址块。目前私有网络中的云资源部署在子网内，如云主机、容器、负载均衡等。子网：子网是对VPC地址空间的再一次划分，用户可以在子网中创建云主机。\n\n1. 可用区（Availability Zone）是电力及网络之间互相独立的物理区域，相同可用区内的实例之间较之同地域不同可用区内实例之间的网络延时更小。同地域内不同可用区之间提供内网互通环境，可用区之间可做到故障隔离。\n  若您的业务要求有较低网络时延，建议将实例或者Pod部署在同一可用区内。\n1. VPC：VPC是用户网络在京东云上的表现形式，包含了一系列的网络功能，与其他的VPC逻辑隔离。VPC有一个网络地址空间，用户可以在其中继续划分子网。\n1. NAT 地址网络转换，通过在路由器上安装 NAT 软件，它至少有一个有效的公网 IP 地址，通过 NAT 路由器将内部私有 IP 转换成公网 IP。它的问题在于 NAT 设备自动屏蔽了非内网主机主动发起的连接，也就是说，从外网发往内网的数据包将被 NAT 设备丢弃，这使得位于不同 NAT 设备之后的主机之间无法直接交换信息.\n  \n1. 503 服务器资源不足问题导致的拒绝服务，比如熔断。\n1. Options  \n```text\n   1. 检测服务支持的method\n   2. Cors 预检\n```\n1. HTTP HEAD 方法 请求资源的头部信息, 并且这些头部与 HTTP GET 方法请求时返回的一致. 该请求方法的一个使用场景是在下载一个大文件前先获取其大小再决定是否要下载, 以此可以节约带宽资源.\n1. WebSocket是基于Http协议的，或者说借用了Http协议来完成一部分握手，在握手阶段与Http是相同的。我们来看一个websocket握手协议的实现，基本是2个属性，upgrade，connection。\n```text\nUpgrade:webSocket\nConnection:Upgrade\n```\n\n### html\n1. Web quality  : alt\n1. 该WindowEventHandlers.onstorage属性包含一个在storage事件触发时运行的事件处理程序。当更改存储区域时会发生这种情况（例如，存储新项目）。\n```javascript\n   window.onstorage = function(e) { console.log('The ' + e.key + ' key has been changed from ' + e.oldValue + ' to ' + e.newValue + '.'); };\n```\n1. navigator.sendBeacon() 方法可用于通过HTTP将少量数据异步传输到Web服务器。\n  \n### vim \nj: 下移一行；\n\nk: 上移一行；\n\nw: 前移一个单词，光标停在下一个单词开头；\n\ne: 前移一个单词，光标停在下一个单词末尾；\n\n0: 移动到行首。\n\n$: 移动到行尾。\n\nn|: 把光标移到递n列上\n\nzz: 将当前行移动到屏幕中央。\n\no: 在下面新建一行插入；\n\nO: 在上面新建一行插入；\n\na: 在光标后插入；\n\nA: 在当前行最后插入；\n\nu: 取消一(n)个改动。\n\nctrl + r: 重做最后的改动。","slug":"cookies","published":1,"updated":"2019-11-26T03:03:07.376Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5bwexce0002998s4use0sf2","content":"<p>:smile:</p>\n<h3 id=\"发版\"><a href=\"#发版\" class=\"headerlink\" title=\"发版\"></a>发版</h3><ol>\n<li>发布阶段：更新chagelog ,打 git tag 。</li>\n</ol>\n<h3 id=\"word\"><a href=\"#word\" class=\"headerlink\" title=\"word\"></a>word</h3><ol>\n<li>deflate 放气，紧缩</li>\n<li>Sanitize 消毒，净化</li>\n<li><h3 id=\"js\"><a href=\"#js\" class=\"headerlink\" title=\"js\"></a>js</h3></li>\n<li><p>随机字符串 Math.random().toString(36).substr(2));</p>\n</li>\n<li><p>Babel pollyfy 的作用 ：<a href=\"https://zhuanlan.zhihu.com/p/29058936\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/29058936</a></p>\n</li>\n<li><p>Babel stag2 的功能  <a href=\"https://github.com/babel/babel/tree/master/packages/babel-preset-stage-2\" target=\"_blank\" rel=\"noopener\">https://github.com/babel/babel/tree/master/packages/babel-preset-stage-2</a></p>\n</li>\n<li>所有的babel 包  <a href=\"https://github.com/babel/babel/tree/master/packages\" target=\"_blank\" rel=\"noopener\">https://github.com/babel/babel/tree/master/packages</a></li>\n<li>npx babel-upgrade</li>\n<li>ES2019 中为Symbol对象添加了只读属性 description ，该对象返回包含Symbol描述的字符串。</li>\n<li>变量的临时死区  </li>\n<li>SET 操作的时间复杂度</li>\n<li>如果你传的 context 就 null 或者 undefined，那么 window 对象就是默认的 context（严格模式下默认 context 是 undefined）</li>\n<li>高阶函数的定义</li>\n<li>作用域以及作用域链  函数作用域 —闭包</li>\n<li>ES6 模块功能是它的导入模块是导出时模块的实时只读视图。（相比起 CommonJS，导入的是导出模块的拷贝副本，因此也不是实时的）。只读视图和内存拷贝的区别。</li>\n<li>atob() 对经过 base-64 编码的字符串进行解码,btoa() base64加吗</li>\n<li>Console.dir  显示对象所有的属性和方法</li>\n<li>Broadcast Channel API 允许同一原始域和用户代理下的所有窗口,iFrames 等进行交互。也就是说，如果用户打开了同一个网站的的两个标签窗口，如果网站内容发生了变化，那么两个窗口会同时得到更新通知。</li>\n<li>escape 在处理 0xff 之外字符的时候，是直接使用字符的 unicode 在前面加上一个 「%u」，而encodeURI则是先进行 UTF-8，再在 UTF-8 的每个字节码前加上一个 「%」； 所以通过encodeUrI 可以获取utf-8 字节长度</li>\n<li>js value</li>\n<li>Prototype 包含constructor 和 <strong>proto</strong>. 原型链存储共有的属性和方法，减少内存</li>\n<li><p>基本的数据类型 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">基本的数据类型</span><br><span class=\"line\">undefined</span><br><span class=\"line\">null</span><br><span class=\"line\">string</span><br><span class=\"line\">boolean</span><br><span class=\"line\">number</span><br><span class=\"line\">symbol(ES6)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>navigator.userAgent: 返回当前浏览器的user agent字符串</p>\n</li>\n<li>懒加载：<br>Javascript 脚步通常要等到 DOM 加载完后才会执行，如果加载的资源过多，可能会影响网页的正常使用。<br>能够节省流量和减轻服务器压力，更近一步就是能够为公司省成本。</li>\n<li>String 和 new String 区别</li>\n<li></li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">对象转原始类型，会调用内置的[ToPrimitive]函数，对于该函数而言，其逻辑如下：</span><br><span class=\"line\"></span><br><span class=\"line\">如果Symbol.toPrimitive()方法，优先调用再返回</span><br><span class=\"line\">调用valueOf()，如果转换为原始类型，则返回</span><br><span class=\"line\">调用toString()，如果转换为原始类型，则返回</span><br><span class=\"line\">如果都没有返回原始类型，会报错</span><br><span class=\"line\">var a = &#123;</span><br><span class=\"line\">  value: 0,</span><br><span class=\"line\">  valueOf: function() &#123;</span><br><span class=\"line\">    this.value++;</span><br><span class=\"line\">    return this.value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">console.log(a == 1 &amp;&amp; a == 2);//true</span><br></pre></td></tr></table></figure>\n<ol>\n<li>Same origin 可以使用broadcast channel 两页面间通信。</li>\n<li>注意闭包内this的指向</li>\n<li></li>\n</ol>\n<h4 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h4><ol>\n<li>无论你使用的是解释型语言(JavaScript、Python、Ruby)还是编译型语言(c#、Java、Rust)，都有一个共同的部分:将源代码作为纯文本解析为 抽象语法树(abstract syntax tree, AST) 的数据结构。</li>\n<li>AST 不仅以结构化的方式显示源代码，而且在语义分析中扮演着重要角色。在语义分析中，编译器验证程序和语言元素的语法使用是否正确。之后，使用 AST 来生成实际的字节码或者机器码。</li>\n<li><p>转义的过程：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">编写ES6代码</span><br><span class=\"line\">babylon 进行解析</span><br><span class=\"line\">解析得到 AST</span><br><span class=\"line\">plugin 用 babel-traverse 对 AST 树进行遍历转译</span><br><span class=\"line\">得到新的 AST树</span><br><span class=\"line\">用 babel-generator 通过 AST 树生成 ES5 代码</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>要应用更新，Virtual DOM核心功能将发挥作用，即 协调算法，它的工作是提供最优的解决方案来解决以前和当前虚拟DOM 状态之间的差异。</p>\n</li>\n</ol>\n<h2 id=\"opentracing\"><a href=\"#opentracing\" class=\"headerlink\" title=\"opentracing\"></a>opentracing</h2><ol>\n<li>Opentracing 的carrier 有多种实现，tracer 的inject（客户端进程） 和 extract（服务端进程），这样 客户端和服务端 就可以拥有相同的trace context。</li>\n<li>Server 首先extract check 有没有注入的span，没有的话启动一个新的span</li>\n</ol>\n<h2 id=\"mac\"><a href=\"#mac\" class=\"headerlink\" title=\"mac\"></a>mac</h2><ol>\n<li>Mac 设置path  export PATH=$PATH:</li>\n<li>查看端口占用：lsof -i:3001</li>\n<li>export http_proxy=”<a href=\"http://localhost:8899&quot;\" target=\"_blank\" rel=\"noopener\">http://localhost:8899&quot;</a></li>\n<li>Grep -A 5 显示后面5行信息</li>\n</ol>\n<h2 id=\"npm\"><a href=\"#npm\" class=\"headerlink\" title=\"npm\"></a>npm</h2><ol>\n<li>npm config edit</li>\n<li>npm config set init.author.name “ryansecreat”</li>\n<li>npm config set <a href=\"mailto:init.email=&#39;chenjingnan@jd.com\" target=\"_blank\" rel=\"noopener\">init.email=&#39;chenjingnan@jd.com</a>’</li>\n<li>npm config set init.license “MIT”</li>\n<li>npm start –prefix path/to/your/folder   //指定目录下运行</li>\n<li>npm repo   浏览器中打开repo</li>\n<li>npm publish –registry=<a href=\"http://registry.npmjs.org\" target=\"_blank\" rel=\"noopener\">http://registry.npmjs.org</a>  –registry=<a href=\"https://registry.npm.taobao.org\" target=\"_blank\" rel=\"noopener\">https://registry.npm.taobao.org</a></li>\n<li>npm outdated  查看过时package</li>\n<li>npm publish –tag=beta.</li>\n<li>npm version patch -m “Upgrade to %s for reasons”</li>\n<li>npm dist-tag add <a href=\"mailto:n-n-n-n@1.0.2-1\" target=\"_blank\" rel=\"noopener\">n-n-n-n@1.0.2-1</a> latest  将某个预发版本更新为最新   </li>\n<li>npm ping [–registry <registry>]</registry></li>\n</ol>\n<h3 id=\"node\"><a href=\"#node\" class=\"headerlink\" title=\"node\"></a>node</h3><ol>\n<li>Stream cork uncork</li>\n<li>escape-html  This function will escape the following characters: “, ‘, &amp;, &lt;, and &gt;.</li>\n<li>domain模块，把处理多个不同的IO的操作作为一个组。注册事件和回调到domain，当发生一个错误事件或抛出一个错误时，domain对象会被通知，不会丢失上下文环境，也不导致程序错误立即退出，与process.on(‘uncaughtException’)不同。</li>\n<li><p>stream tranform</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const &#123; Transform &#125; = require(&apos;stream&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">const myTransform = new Transform(&#123;</span><br><span class=\"line\">  transform(chunk, encoding, callback) &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>可以引入corejs实现feature</p>\n</li>\n<li><p>性能分析<br>Node 性能分析，抓取火焰图 node –inspect app.js<br>Node  –prof-process  <a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/1.3%20Tick%20Processor.md\" target=\"_blank\" rel=\"noopener\">https://github.com/nswbmw/node-in-debugging/blob/master/1.3%20Tick%20Processor.md</a></p>\n</li>\n<li><p>一个promise类 </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sleep</span> </span>&#123;</span><br><span class=\"line\">then(resolve, reject)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Node 内置了pipeline  const { pipeline } = require(‘stream’);</p>\n</li>\n<li>Elastic APM 是 Elastic 公司开源的一款 APM 工具</li>\n<li>Error.prepareStackTrace:定制化堆栈信息    Error.captureStackTrace:隐藏内部的实现细节，优化错误栈。</li>\n<li>const { EventEmitter } = require(‘events’);  EventEmitter 的继承</li>\n<li>Require.resovle() 获取模块的绝对路径  </li>\n<li>peerDependencies 相关模块安装</li>\n<li>websocket </li>\n<li>cors 新浏览器<br>SameSite=Strict: The cookie is only sent if you are currently on the site that the cookie is set for. If you are on a different site and you click a link to a site that the cookie is set for, the cookie is not sent with the first request.</li>\n<li></li>\n<li></li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WebSocket 使用了自定义的二进制分帧格式，把每个应用消息切分成一或多个帧，发送到目的地之后再组装起来，等到接收到完整的消息后再通知接收端。基本的成帧协议定义了帧类型有操作码、有效载荷的长度，指定位置的Extension data和Application data，统称为Payload data，保留了一些特殊位和操作码供后期扩展。在打开握手完成后，终端发送一个关闭帧之前的任何时间里，数据帧可能由客户端或服务器的任何一方发送。</span><br><span class=\"line\"></span><br><span class=\"line\">• 帧：最小的通信单位，包含可变长度的帧首部和净荷部分，净荷可能包含完整或部分应用消息。</span><br><span class=\"line\">• 消息：一系列帧，与应用消息对等。</span><br></pre></td></tr></table></figure>\n<ol>\n<li>jwt 签名算法<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HS256 使用密钥生成固定的签名，RS256 使用成非对称进行签名。简单地说，HS256 必须与任何想要验证 JWT的 客户端或 API 共享秘密。</span><br><span class=\"line\">RS256 生成非对称签名，这意味着必须使用私钥来签签名 JWT，并且必须使用对应的公钥来验证签名。与对称算法不同，使用 RS256 可以保证服务端是 JWT 的签名者，因为服务端是唯一拥有私钥的一方。这样做将不再需要在许多应用程序之间共享私钥</span><br><span class=\"line\"></span><br><span class=\"line\">这种方法可以让我们分离开签发与验证，签发时需要用一个密钥，验证时使用公钥，也就是有公钥的地方只能做验证，但不能签发 JWT。</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"egg\"><a href=\"#egg\" class=\"headerlink\" title=\"egg\"></a>egg</h3><ol>\n<li>启动顺序<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Master 启动后先 fork Agent 进程</span><br><span class=\"line\">Agent 初始化成功后，通过 IPC 通道通知 Master</span><br><span class=\"line\">Master 再 fork 多个 App Worker</span><br><span class=\"line\">App Worker 初始化成功，通知 Master</span><br><span class=\"line\">所有的进程初始化成功后，Master 通知 Agent 和 Worker 应用启动成功</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h3><ol>\n<li><p>子网是所属VPC IP地址范围内的 IP 地址块。目前私有网络中的云资源部署在子网内，如云主机、容器、负载均衡等。子网：子网是对VPC地址空间的再一次划分，用户可以在子网中创建云主机。</p>\n</li>\n<li><p>可用区（Availability Zone）是电力及网络之间互相独立的物理区域，相同可用区内的实例之间较之同地域不同可用区内实例之间的网络延时更小。同地域内不同可用区之间提供内网互通环境，可用区之间可做到故障隔离。<br>若您的业务要求有较低网络时延，建议将实例或者Pod部署在同一可用区内。</p>\n</li>\n<li>VPC：VPC是用户网络在京东云上的表现形式，包含了一系列的网络功能，与其他的VPC逻辑隔离。VPC有一个网络地址空间，用户可以在其中继续划分子网。</li>\n<li><p>NAT 地址网络转换，通过在路由器上安装 NAT 软件，它至少有一个有效的公网 IP 地址，通过 NAT 路由器将内部私有 IP 转换成公网 IP。它的问题在于 NAT 设备自动屏蔽了非内网主机主动发起的连接，也就是说，从外网发往内网的数据包将被 NAT 设备丢弃，这使得位于不同 NAT 设备之后的主机之间无法直接交换信息.</p>\n</li>\n<li><p>503 服务器资源不足问题导致的拒绝服务，比如熔断。</p>\n</li>\n<li><p>Options  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 检测服务支持的method</span><br><span class=\"line\">2. Cors 预检</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>HTTP HEAD 方法 请求资源的头部信息, 并且这些头部与 HTTP GET 方法请求时返回的一致. 该请求方法的一个使用场景是在下载一个大文件前先获取其大小再决定是否要下载, 以此可以节约带宽资源.</p>\n</li>\n<li>WebSocket是基于Http协议的，或者说借用了Http协议来完成一部分握手，在握手阶段与Http是相同的。我们来看一个websocket握手协议的实现，基本是2个属性，upgrade，connection。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Upgrade:webSocket</span><br><span class=\"line\">Connection:Upgrade</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"html\"><a href=\"#html\" class=\"headerlink\" title=\"html\"></a>html</h3><ol>\n<li>Web quality  : alt</li>\n<li><p>该WindowEventHandlers.onstorage属性包含一个在storage事件触发时运行的事件处理程序。当更改存储区域时会发生这种情况（例如，存储新项目）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.onstorage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">'The '</span> + e.key + <span class=\"string\">' key has been changed from '</span> + e.oldValue + <span class=\"string\">' to '</span> + e.newValue + <span class=\"string\">'.'</span>); &#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>navigator.sendBeacon() 方法可用于通过HTTP将少量数据异步传输到Web服务器。</p>\n</li>\n</ol>\n<h3 id=\"vim\"><a href=\"#vim\" class=\"headerlink\" title=\"vim\"></a>vim</h3><p>j: 下移一行；</p>\n<p>k: 上移一行；</p>\n<p>w: 前移一个单词，光标停在下一个单词开头；</p>\n<p>e: 前移一个单词，光标停在下一个单词末尾；</p>\n<p>0: 移动到行首。</p>\n<p>$: 移动到行尾。</p>\n<p>n|: 把光标移到递n列上</p>\n<p>zz: 将当前行移动到屏幕中央。</p>\n<p>o: 在下面新建一行插入；</p>\n<p>O: 在上面新建一行插入；</p>\n<p>a: 在光标后插入；</p>\n<p>A: 在当前行最后插入；</p>\n<p>u: 取消一(n)个改动。</p>\n<p>ctrl + r: 重做最后的改动。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>:smile:</p>\n<h3 id=\"发版\"><a href=\"#发版\" class=\"headerlink\" title=\"发版\"></a>发版</h3><ol>\n<li>发布阶段：更新chagelog ,打 git tag 。</li>\n</ol>\n<h3 id=\"word\"><a href=\"#word\" class=\"headerlink\" title=\"word\"></a>word</h3><ol>\n<li>deflate 放气，紧缩</li>\n<li>Sanitize 消毒，净化</li>\n<li><h3 id=\"js\"><a href=\"#js\" class=\"headerlink\" title=\"js\"></a>js</h3></li>\n<li><p>随机字符串 Math.random().toString(36).substr(2));</p>\n</li>\n<li><p>Babel pollyfy 的作用 ：<a href=\"https://zhuanlan.zhihu.com/p/29058936\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/29058936</a></p>\n</li>\n<li><p>Babel stag2 的功能  <a href=\"https://github.com/babel/babel/tree/master/packages/babel-preset-stage-2\" target=\"_blank\" rel=\"noopener\">https://github.com/babel/babel/tree/master/packages/babel-preset-stage-2</a></p>\n</li>\n<li>所有的babel 包  <a href=\"https://github.com/babel/babel/tree/master/packages\" target=\"_blank\" rel=\"noopener\">https://github.com/babel/babel/tree/master/packages</a></li>\n<li>npx babel-upgrade</li>\n<li>ES2019 中为Symbol对象添加了只读属性 description ，该对象返回包含Symbol描述的字符串。</li>\n<li>变量的临时死区  </li>\n<li>SET 操作的时间复杂度</li>\n<li>如果你传的 context 就 null 或者 undefined，那么 window 对象就是默认的 context（严格模式下默认 context 是 undefined）</li>\n<li>高阶函数的定义</li>\n<li>作用域以及作用域链  函数作用域 —闭包</li>\n<li>ES6 模块功能是它的导入模块是导出时模块的实时只读视图。（相比起 CommonJS，导入的是导出模块的拷贝副本，因此也不是实时的）。只读视图和内存拷贝的区别。</li>\n<li>atob() 对经过 base-64 编码的字符串进行解码,btoa() base64加吗</li>\n<li>Console.dir  显示对象所有的属性和方法</li>\n<li>Broadcast Channel API 允许同一原始域和用户代理下的所有窗口,iFrames 等进行交互。也就是说，如果用户打开了同一个网站的的两个标签窗口，如果网站内容发生了变化，那么两个窗口会同时得到更新通知。</li>\n<li>escape 在处理 0xff 之外字符的时候，是直接使用字符的 unicode 在前面加上一个 「%u」，而encodeURI则是先进行 UTF-8，再在 UTF-8 的每个字节码前加上一个 「%」； 所以通过encodeUrI 可以获取utf-8 字节长度</li>\n<li>js value</li>\n<li>Prototype 包含constructor 和 <strong>proto</strong>. 原型链存储共有的属性和方法，减少内存</li>\n<li><p>基本的数据类型 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">基本的数据类型</span><br><span class=\"line\">undefined</span><br><span class=\"line\">null</span><br><span class=\"line\">string</span><br><span class=\"line\">boolean</span><br><span class=\"line\">number</span><br><span class=\"line\">symbol(ES6)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>navigator.userAgent: 返回当前浏览器的user agent字符串</p>\n</li>\n<li>懒加载：<br>Javascript 脚步通常要等到 DOM 加载完后才会执行，如果加载的资源过多，可能会影响网页的正常使用。<br>能够节省流量和减轻服务器压力，更近一步就是能够为公司省成本。</li>\n<li>String 和 new String 区别</li>\n<li></li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">对象转原始类型，会调用内置的[ToPrimitive]函数，对于该函数而言，其逻辑如下：</span><br><span class=\"line\"></span><br><span class=\"line\">如果Symbol.toPrimitive()方法，优先调用再返回</span><br><span class=\"line\">调用valueOf()，如果转换为原始类型，则返回</span><br><span class=\"line\">调用toString()，如果转换为原始类型，则返回</span><br><span class=\"line\">如果都没有返回原始类型，会报错</span><br><span class=\"line\">var a = &#123;</span><br><span class=\"line\">  value: 0,</span><br><span class=\"line\">  valueOf: function() &#123;</span><br><span class=\"line\">    this.value++;</span><br><span class=\"line\">    return this.value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">console.log(a == 1 &amp;&amp; a == 2);//true</span><br></pre></td></tr></table></figure>\n<ol>\n<li>Same origin 可以使用broadcast channel 两页面间通信。</li>\n<li>注意闭包内this的指向</li>\n<li></li>\n</ol>\n<h4 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h4><ol>\n<li>无论你使用的是解释型语言(JavaScript、Python、Ruby)还是编译型语言(c#、Java、Rust)，都有一个共同的部分:将源代码作为纯文本解析为 抽象语法树(abstract syntax tree, AST) 的数据结构。</li>\n<li>AST 不仅以结构化的方式显示源代码，而且在语义分析中扮演着重要角色。在语义分析中，编译器验证程序和语言元素的语法使用是否正确。之后，使用 AST 来生成实际的字节码或者机器码。</li>\n<li><p>转义的过程：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">编写ES6代码</span><br><span class=\"line\">babylon 进行解析</span><br><span class=\"line\">解析得到 AST</span><br><span class=\"line\">plugin 用 babel-traverse 对 AST 树进行遍历转译</span><br><span class=\"line\">得到新的 AST树</span><br><span class=\"line\">用 babel-generator 通过 AST 树生成 ES5 代码</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>要应用更新，Virtual DOM核心功能将发挥作用，即 协调算法，它的工作是提供最优的解决方案来解决以前和当前虚拟DOM 状态之间的差异。</p>\n</li>\n</ol>\n<h2 id=\"opentracing\"><a href=\"#opentracing\" class=\"headerlink\" title=\"opentracing\"></a>opentracing</h2><ol>\n<li>Opentracing 的carrier 有多种实现，tracer 的inject（客户端进程） 和 extract（服务端进程），这样 客户端和服务端 就可以拥有相同的trace context。</li>\n<li>Server 首先extract check 有没有注入的span，没有的话启动一个新的span</li>\n</ol>\n<h2 id=\"mac\"><a href=\"#mac\" class=\"headerlink\" title=\"mac\"></a>mac</h2><ol>\n<li>Mac 设置path  export PATH=$PATH:</li>\n<li>查看端口占用：lsof -i:3001</li>\n<li>export http_proxy=”<a href=\"http://localhost:8899&quot;\" target=\"_blank\" rel=\"noopener\">http://localhost:8899&quot;</a></li>\n<li>Grep -A 5 显示后面5行信息</li>\n</ol>\n<h2 id=\"npm\"><a href=\"#npm\" class=\"headerlink\" title=\"npm\"></a>npm</h2><ol>\n<li>npm config edit</li>\n<li>npm config set init.author.name “ryansecreat”</li>\n<li>npm config set <a href=\"mailto:init.email=&#39;chenjingnan@jd.com\" target=\"_blank\" rel=\"noopener\">init.email=&#39;chenjingnan@jd.com</a>’</li>\n<li>npm config set init.license “MIT”</li>\n<li>npm start –prefix path/to/your/folder   //指定目录下运行</li>\n<li>npm repo   浏览器中打开repo</li>\n<li>npm publish –registry=<a href=\"http://registry.npmjs.org\" target=\"_blank\" rel=\"noopener\">http://registry.npmjs.org</a>  –registry=<a href=\"https://registry.npm.taobao.org\" target=\"_blank\" rel=\"noopener\">https://registry.npm.taobao.org</a></li>\n<li>npm outdated  查看过时package</li>\n<li>npm publish –tag=beta.</li>\n<li>npm version patch -m “Upgrade to %s for reasons”</li>\n<li>npm dist-tag add <a href=\"mailto:n-n-n-n@1.0.2-1\" target=\"_blank\" rel=\"noopener\">n-n-n-n@1.0.2-1</a> latest  将某个预发版本更新为最新   </li>\n<li>npm ping [–registry <registry>]</registry></li>\n</ol>\n<h3 id=\"node\"><a href=\"#node\" class=\"headerlink\" title=\"node\"></a>node</h3><ol>\n<li>Stream cork uncork</li>\n<li>escape-html  This function will escape the following characters: “, ‘, &amp;, &lt;, and &gt;.</li>\n<li>domain模块，把处理多个不同的IO的操作作为一个组。注册事件和回调到domain，当发生一个错误事件或抛出一个错误时，domain对象会被通知，不会丢失上下文环境，也不导致程序错误立即退出，与process.on(‘uncaughtException’)不同。</li>\n<li><p>stream tranform</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const &#123; Transform &#125; = require(&apos;stream&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">const myTransform = new Transform(&#123;</span><br><span class=\"line\">  transform(chunk, encoding, callback) &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>可以引入corejs实现feature</p>\n</li>\n<li><p>性能分析<br>Node 性能分析，抓取火焰图 node –inspect app.js<br>Node  –prof-process  <a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/1.3%20Tick%20Processor.md\" target=\"_blank\" rel=\"noopener\">https://github.com/nswbmw/node-in-debugging/blob/master/1.3%20Tick%20Processor.md</a></p>\n</li>\n<li><p>一个promise类 </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sleep</span> </span>&#123;</span><br><span class=\"line\">then(resolve, reject)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Node 内置了pipeline  const { pipeline } = require(‘stream’);</p>\n</li>\n<li>Elastic APM 是 Elastic 公司开源的一款 APM 工具</li>\n<li>Error.prepareStackTrace:定制化堆栈信息    Error.captureStackTrace:隐藏内部的实现细节，优化错误栈。</li>\n<li>const { EventEmitter } = require(‘events’);  EventEmitter 的继承</li>\n<li>Require.resovle() 获取模块的绝对路径  </li>\n<li>peerDependencies 相关模块安装</li>\n<li>websocket </li>\n<li>cors 新浏览器<br>SameSite=Strict: The cookie is only sent if you are currently on the site that the cookie is set for. If you are on a different site and you click a link to a site that the cookie is set for, the cookie is not sent with the first request.</li>\n<li></li>\n<li></li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WebSocket 使用了自定义的二进制分帧格式，把每个应用消息切分成一或多个帧，发送到目的地之后再组装起来，等到接收到完整的消息后再通知接收端。基本的成帧协议定义了帧类型有操作码、有效载荷的长度，指定位置的Extension data和Application data，统称为Payload data，保留了一些特殊位和操作码供后期扩展。在打开握手完成后，终端发送一个关闭帧之前的任何时间里，数据帧可能由客户端或服务器的任何一方发送。</span><br><span class=\"line\"></span><br><span class=\"line\">• 帧：最小的通信单位，包含可变长度的帧首部和净荷部分，净荷可能包含完整或部分应用消息。</span><br><span class=\"line\">• 消息：一系列帧，与应用消息对等。</span><br></pre></td></tr></table></figure>\n<ol>\n<li>jwt 签名算法<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HS256 使用密钥生成固定的签名，RS256 使用成非对称进行签名。简单地说，HS256 必须与任何想要验证 JWT的 客户端或 API 共享秘密。</span><br><span class=\"line\">RS256 生成非对称签名，这意味着必须使用私钥来签签名 JWT，并且必须使用对应的公钥来验证签名。与对称算法不同，使用 RS256 可以保证服务端是 JWT 的签名者，因为服务端是唯一拥有私钥的一方。这样做将不再需要在许多应用程序之间共享私钥</span><br><span class=\"line\"></span><br><span class=\"line\">这种方法可以让我们分离开签发与验证，签发时需要用一个密钥，验证时使用公钥，也就是有公钥的地方只能做验证，但不能签发 JWT。</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"egg\"><a href=\"#egg\" class=\"headerlink\" title=\"egg\"></a>egg</h3><ol>\n<li>启动顺序<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Master 启动后先 fork Agent 进程</span><br><span class=\"line\">Agent 初始化成功后，通过 IPC 通道通知 Master</span><br><span class=\"line\">Master 再 fork 多个 App Worker</span><br><span class=\"line\">App Worker 初始化成功，通知 Master</span><br><span class=\"line\">所有的进程初始化成功后，Master 通知 Agent 和 Worker 应用启动成功</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h3><ol>\n<li><p>子网是所属VPC IP地址范围内的 IP 地址块。目前私有网络中的云资源部署在子网内，如云主机、容器、负载均衡等。子网：子网是对VPC地址空间的再一次划分，用户可以在子网中创建云主机。</p>\n</li>\n<li><p>可用区（Availability Zone）是电力及网络之间互相独立的物理区域，相同可用区内的实例之间较之同地域不同可用区内实例之间的网络延时更小。同地域内不同可用区之间提供内网互通环境，可用区之间可做到故障隔离。<br>若您的业务要求有较低网络时延，建议将实例或者Pod部署在同一可用区内。</p>\n</li>\n<li>VPC：VPC是用户网络在京东云上的表现形式，包含了一系列的网络功能，与其他的VPC逻辑隔离。VPC有一个网络地址空间，用户可以在其中继续划分子网。</li>\n<li><p>NAT 地址网络转换，通过在路由器上安装 NAT 软件，它至少有一个有效的公网 IP 地址，通过 NAT 路由器将内部私有 IP 转换成公网 IP。它的问题在于 NAT 设备自动屏蔽了非内网主机主动发起的连接，也就是说，从外网发往内网的数据包将被 NAT 设备丢弃，这使得位于不同 NAT 设备之后的主机之间无法直接交换信息.</p>\n</li>\n<li><p>503 服务器资源不足问题导致的拒绝服务，比如熔断。</p>\n</li>\n<li><p>Options  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 检测服务支持的method</span><br><span class=\"line\">2. Cors 预检</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>HTTP HEAD 方法 请求资源的头部信息, 并且这些头部与 HTTP GET 方法请求时返回的一致. 该请求方法的一个使用场景是在下载一个大文件前先获取其大小再决定是否要下载, 以此可以节约带宽资源.</p>\n</li>\n<li>WebSocket是基于Http协议的，或者说借用了Http协议来完成一部分握手，在握手阶段与Http是相同的。我们来看一个websocket握手协议的实现，基本是2个属性，upgrade，connection。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Upgrade:webSocket</span><br><span class=\"line\">Connection:Upgrade</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"html\"><a href=\"#html\" class=\"headerlink\" title=\"html\"></a>html</h3><ol>\n<li>Web quality  : alt</li>\n<li><p>该WindowEventHandlers.onstorage属性包含一个在storage事件触发时运行的事件处理程序。当更改存储区域时会发生这种情况（例如，存储新项目）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.onstorage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">'The '</span> + e.key + <span class=\"string\">' key has been changed from '</span> + e.oldValue + <span class=\"string\">' to '</span> + e.newValue + <span class=\"string\">'.'</span>); &#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>navigator.sendBeacon() 方法可用于通过HTTP将少量数据异步传输到Web服务器。</p>\n</li>\n</ol>\n<h3 id=\"vim\"><a href=\"#vim\" class=\"headerlink\" title=\"vim\"></a>vim</h3><p>j: 下移一行；</p>\n<p>k: 上移一行；</p>\n<p>w: 前移一个单词，光标停在下一个单词开头；</p>\n<p>e: 前移一个单词，光标停在下一个单词末尾；</p>\n<p>0: 移动到行首。</p>\n<p>$: 移动到行尾。</p>\n<p>n|: 把光标移到递n列上</p>\n<p>zz: 将当前行移动到屏幕中央。</p>\n<p>o: 在下面新建一行插入；</p>\n<p>O: 在上面新建一行插入；</p>\n<p>a: 在光标后插入；</p>\n<p>A: 在当前行最后插入；</p>\n<p>u: 取消一(n)个改动。</p>\n<p>ctrl + r: 重做最后的改动。</p>\n"},{"title":"css","date":"2019-05-07T07:12:57.000Z","_content":"1. Flex 主轴（x）、交叉轴(y)\n1.  calc函数是css3新增的功能，可以使用calc()计算border、margin、pading、font-size和width等属性设置动态值。\n1.触发BFC条件  BFC（Block Formatting Context）格式化上下文，\n  ```text\n  根元素\n  float的值不为none\n  overflow的值不为visible\n  display的值为inline-block、table-cell、table-caption\n  position的值为absolute、fixed\n```\n\n1. 使用vw设置，vw也是一个相对单位，100vw等于屏幕宽度\n1. Flex-shrink、flex-grow   溢出空间和剩余空间\n1. max-width/min-width > flex-basis > width > box\n1. &:nth-child(odd)  选择器\n1. writing-mode: vertical-rl;  设置文字方向\n1. text-align-last  描述的是一段文本中最后一行在被强制换行之前的对齐规则\n```text\njustify\n\n最后一行文字的开头与内容盒子的左侧对齐，末尾与右侧对齐\n\n```\n1.设置打印样式\n  \n  @media print {\n    /* print styles here. */\n  }. \n1. line-clamp 定义文字显示行数\n1. pointer-events: none; 禁用点击事件\n1. focus-within是一个伪类，现在已经被列入到CSS选择器中。当元素本身或其后代元素获得焦点时，:focus-within伪类的元素就会有效。 \n1. 单冒号(:)用于 CSS3 伪类，双冒号(::)用于 CSS3 伪元素。\n1. 但是有个好处是当元素没有内容时候，设置height:100%该元素不会被撑开，\n   \n   但是设置height:100vh，该元素会被撑开屏幕高度一致。 \n\n1. 伪类：\n   https://user-gold-cdn.xitu.io/2019/12/12/16ef8eecad4f1adb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\n   \n1. 伪元素用于创建一些不在文档树中的元素，并为其添加样式。比如说，我们可以通过:before来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。常见的伪元素有：::before，::after，::first-line，::first-letter，::selection、::placeholder等. 伪类和伪元素的区别在于有没有创建一个文档书之外的元素。\n1.    \n1. 这是一个叫做@font-face 的CSS @规则 ，它允许网页开发者为其网页指定在线字体。 通过这种作者自备字体的方式，@font-face 可以消除对用户电脑字体的依赖。\n1. overflow:https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow\n\n1. Element.scrollTop 属性可以获取或设置一个元素的内容垂直滚动的像素数。\n\noffsetTop: 当前元素顶部距离最近父元素顶部的距离,和有没有滚动条没有关系。单位px，只读元素。\n\n  scrollHeight: 因为子元素比父元素高，父元素不想被子元素撑的一样高就显示出了滚动条，在滚动的过程中本元素有部分被隐藏了，scrollHeight代表包括当前不可见部分的元素的高度。而可见部分的高度其实就是clientHeight，也就是scrollHeight>=clientHeight恒成立。在有滚动条时讨论scrollHeight才有意义，在没有滚动条时scrollHeight==clientHeight恒成立。单位px，只读元素。\n\n   https://imweb.io/topic/57c5409e808fd2fb204eef52\n\n   clientheight offsetheight \n\n\n1. 相对位置：\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/position\n\n1. Image alt 属性是一个必需的属性，它规定在图像无法显示时的替代文本。\n\n\ntext-decoration 设置下划线等\nhttps://jsfiddle.net/ryansecreat/58um7k43/\n\ndocument​.active​Element\n\n 返回当前页面中获得焦点的元素,也就是说,如果此时用户按下了键盘上某个键,会在该元素上触发键盘事件.该属性是只读的.\n \n #### 性能  \n1. 尽量使用 flexbox 而不是老的布局模型。它运行速度更快，可为你的应用程序创造巨大的性能优势。\n1. 根据 Google Developer，渲染线程分为 主线程 (main thread) 和 合成线程 (compositor thread)。如果 CSS 动画只是改变 transforms 和 opacity，这时整个 CSS 动画得以在 合成线程完成（而JS动画则会在 主线程 执行，然后触发合成线程进行下一步操作），在 JS 执行一些昂贵的任务时，主线程繁忙，CSS 动画由于使用了合成线程可以保持流畅\n1. CSS动画有天然事件支持（TransitionEnd、AnimationEnd，但是它们都需要针对浏览器加前缀），JS则需要自己写事件。\n1. 在实现一些小的交互动效的时候，就多考虑考虑 CSS 动画。对于一些复杂控制的动画，使用 javascript 比较可靠。\n\n#### 块元素是一个元素，占用了全部宽度，在前后都是换行符。\n   ```text\n   块元素的例子：\n   \n   <h1>\n   <p>\n   <div>\n   内联元素只需要必要的宽度，不强制换行。\n   \n   内联元素的例子：\n   \n   <span>\n   <a>\n   \n```\n\n#### 内容对齐（justify-content）属性应用在弹性容器上，把弹性项沿着弹性容器的主轴线（main axis）对齐。\n       \n   align-items 设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式。\n   设置\"margin\"值为\"auto\"值，自动获取弹性容器中剩余的空间。所以设置垂直方向margin值为\"auto\"，可以使弹性子元素在弹性容器的两上轴方向都完全居中。 当容器为flex时会自动居中。\n   \n   如果在元素上设置了 box-sizing: border-box; 则 padding(内边距) 和 border(边框) 也包含在 width 和 height 中:\n   \n   transform: rotateX(120deg);  x轴旋转 \n   \n#### 不被选中\nbody{\n\n-webkit-touch-callout: none;\n\n-webkit-user-select: none;\n\n-khtml-user-select: none;\n\n-moz-user-select: none;\n\n-ms-user-select: none;\n\nuser-select: none;\n\n}\n\n#### 隐藏\n\n1.opacity：0,该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定了一些事件，如click事件也能触发 2.visibility:hidden,该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件 3.display:node, 把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删掉\n#### html 生成\n将html代码按照深度优先遍历来生成DOM树。 css文件下载完后也会进行渲染，生成相应的CSSOM。 当所有的css文件下载完且所有的CSSOM构建结束后，就会和DOM一起生成Render Tree。 接下来，浏览器就会进入Layout环节，将所有的节点位置计算出来。 最后，通过Painting环节将所有的节点内容呈现到屏幕上。\n #### base64\n TMLCanvasElement.toDataURL() 方法返回一个包含图片展示的 data URI 。可以使用 type 参数其类型，默认为 PNG 格式。图片的分辨率为96dpi。\n \n#### base64 渲染图片\n\n使用 Base64 编码渲染图片有以下优点：\n\n有效减少 HTTP 请求次数\n可对数据进行简单加密，无法肉眼获取信息\n没有跨域问题，无需考虑图片缓存\n凡事皆有利弊，使用 Base64 编码同时也会带来一些问题：\n\n编码后文件体积增大，仅适用于小体积图片编码\n增加了编码和解码的工作量\n不支持 IE 8.0 以下版本   ","source":"_posts/css.md","raw":"---\ntitle: css\ndate: 2019-05-07 15:12:57\ntags: css\n---\n1. Flex 主轴（x）、交叉轴(y)\n1.  calc函数是css3新增的功能，可以使用calc()计算border、margin、pading、font-size和width等属性设置动态值。\n1.触发BFC条件  BFC（Block Formatting Context）格式化上下文，\n  ```text\n  根元素\n  float的值不为none\n  overflow的值不为visible\n  display的值为inline-block、table-cell、table-caption\n  position的值为absolute、fixed\n```\n\n1. 使用vw设置，vw也是一个相对单位，100vw等于屏幕宽度\n1. Flex-shrink、flex-grow   溢出空间和剩余空间\n1. max-width/min-width > flex-basis > width > box\n1. &:nth-child(odd)  选择器\n1. writing-mode: vertical-rl;  设置文字方向\n1. text-align-last  描述的是一段文本中最后一行在被强制换行之前的对齐规则\n```text\njustify\n\n最后一行文字的开头与内容盒子的左侧对齐，末尾与右侧对齐\n\n```\n1.设置打印样式\n  \n  @media print {\n    /* print styles here. */\n  }. \n1. line-clamp 定义文字显示行数\n1. pointer-events: none; 禁用点击事件\n1. focus-within是一个伪类，现在已经被列入到CSS选择器中。当元素本身或其后代元素获得焦点时，:focus-within伪类的元素就会有效。 \n1. 单冒号(:)用于 CSS3 伪类，双冒号(::)用于 CSS3 伪元素。\n1. 但是有个好处是当元素没有内容时候，设置height:100%该元素不会被撑开，\n   \n   但是设置height:100vh，该元素会被撑开屏幕高度一致。 \n\n1. 伪类：\n   https://user-gold-cdn.xitu.io/2019/12/12/16ef8eecad4f1adb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\n   \n1. 伪元素用于创建一些不在文档树中的元素，并为其添加样式。比如说，我们可以通过:before来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。常见的伪元素有：::before，::after，::first-line，::first-letter，::selection、::placeholder等. 伪类和伪元素的区别在于有没有创建一个文档书之外的元素。\n1.    \n1. 这是一个叫做@font-face 的CSS @规则 ，它允许网页开发者为其网页指定在线字体。 通过这种作者自备字体的方式，@font-face 可以消除对用户电脑字体的依赖。\n1. overflow:https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow\n\n1. Element.scrollTop 属性可以获取或设置一个元素的内容垂直滚动的像素数。\n\noffsetTop: 当前元素顶部距离最近父元素顶部的距离,和有没有滚动条没有关系。单位px，只读元素。\n\n  scrollHeight: 因为子元素比父元素高，父元素不想被子元素撑的一样高就显示出了滚动条，在滚动的过程中本元素有部分被隐藏了，scrollHeight代表包括当前不可见部分的元素的高度。而可见部分的高度其实就是clientHeight，也就是scrollHeight>=clientHeight恒成立。在有滚动条时讨论scrollHeight才有意义，在没有滚动条时scrollHeight==clientHeight恒成立。单位px，只读元素。\n\n   https://imweb.io/topic/57c5409e808fd2fb204eef52\n\n   clientheight offsetheight \n\n\n1. 相对位置：\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/position\n\n1. Image alt 属性是一个必需的属性，它规定在图像无法显示时的替代文本。\n\n\ntext-decoration 设置下划线等\nhttps://jsfiddle.net/ryansecreat/58um7k43/\n\ndocument​.active​Element\n\n 返回当前页面中获得焦点的元素,也就是说,如果此时用户按下了键盘上某个键,会在该元素上触发键盘事件.该属性是只读的.\n \n #### 性能  \n1. 尽量使用 flexbox 而不是老的布局模型。它运行速度更快，可为你的应用程序创造巨大的性能优势。\n1. 根据 Google Developer，渲染线程分为 主线程 (main thread) 和 合成线程 (compositor thread)。如果 CSS 动画只是改变 transforms 和 opacity，这时整个 CSS 动画得以在 合成线程完成（而JS动画则会在 主线程 执行，然后触发合成线程进行下一步操作），在 JS 执行一些昂贵的任务时，主线程繁忙，CSS 动画由于使用了合成线程可以保持流畅\n1. CSS动画有天然事件支持（TransitionEnd、AnimationEnd，但是它们都需要针对浏览器加前缀），JS则需要自己写事件。\n1. 在实现一些小的交互动效的时候，就多考虑考虑 CSS 动画。对于一些复杂控制的动画，使用 javascript 比较可靠。\n\n#### 块元素是一个元素，占用了全部宽度，在前后都是换行符。\n   ```text\n   块元素的例子：\n   \n   <h1>\n   <p>\n   <div>\n   内联元素只需要必要的宽度，不强制换行。\n   \n   内联元素的例子：\n   \n   <span>\n   <a>\n   \n```\n\n#### 内容对齐（justify-content）属性应用在弹性容器上，把弹性项沿着弹性容器的主轴线（main axis）对齐。\n       \n   align-items 设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式。\n   设置\"margin\"值为\"auto\"值，自动获取弹性容器中剩余的空间。所以设置垂直方向margin值为\"auto\"，可以使弹性子元素在弹性容器的两上轴方向都完全居中。 当容器为flex时会自动居中。\n   \n   如果在元素上设置了 box-sizing: border-box; 则 padding(内边距) 和 border(边框) 也包含在 width 和 height 中:\n   \n   transform: rotateX(120deg);  x轴旋转 \n   \n#### 不被选中\nbody{\n\n-webkit-touch-callout: none;\n\n-webkit-user-select: none;\n\n-khtml-user-select: none;\n\n-moz-user-select: none;\n\n-ms-user-select: none;\n\nuser-select: none;\n\n}\n\n#### 隐藏\n\n1.opacity：0,该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定了一些事件，如click事件也能触发 2.visibility:hidden,该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件 3.display:node, 把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删掉\n#### html 生成\n将html代码按照深度优先遍历来生成DOM树。 css文件下载完后也会进行渲染，生成相应的CSSOM。 当所有的css文件下载完且所有的CSSOM构建结束后，就会和DOM一起生成Render Tree。 接下来，浏览器就会进入Layout环节，将所有的节点位置计算出来。 最后，通过Painting环节将所有的节点内容呈现到屏幕上。\n #### base64\n TMLCanvasElement.toDataURL() 方法返回一个包含图片展示的 data URI 。可以使用 type 参数其类型，默认为 PNG 格式。图片的分辨率为96dpi。\n \n#### base64 渲染图片\n\n使用 Base64 编码渲染图片有以下优点：\n\n有效减少 HTTP 请求次数\n可对数据进行简单加密，无法肉眼获取信息\n没有跨域问题，无需考虑图片缓存\n凡事皆有利弊，使用 Base64 编码同时也会带来一些问题：\n\n编码后文件体积增大，仅适用于小体积图片编码\n增加了编码和解码的工作量\n不支持 IE 8.0 以下版本   ","slug":"css","published":1,"updated":"2020-01-02T08:12:37.316Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5bwexch0004998sw7oa50y5","content":"<ol>\n<li>Flex 主轴（x）、交叉轴(y)</li>\n<li><p>calc函数是css3新增的功能，可以使用calc()计算border、margin、pading、font-size和width等属性设置动态值。<br>1.触发BFC条件  BFC（Block Formatting Context）格式化上下文，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">根元素</span><br><span class=\"line\">float的值不为none</span><br><span class=\"line\">overflow的值不为visible</span><br><span class=\"line\">display的值为inline-block、table-cell、table-caption</span><br><span class=\"line\">position的值为absolute、fixed</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用vw设置，vw也是一个相对单位，100vw等于屏幕宽度</p>\n</li>\n<li>Flex-shrink、flex-grow   溢出空间和剩余空间</li>\n<li>max-width/min-width &gt; flex-basis &gt; width &gt; box</li>\n<li>&amp;:nth-child(odd)  选择器</li>\n<li>writing-mode: vertical-rl;  设置文字方向</li>\n<li>text-align-last  描述的是一段文本中最后一行在被强制换行之前的对齐规则<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">justify</span><br><span class=\"line\"></span><br><span class=\"line\">最后一行文字的开头与内容盒子的左侧对齐，末尾与右侧对齐</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>1.设置打印样式</p>\n<p>  @media print {<br>    /<em> print styles here. </em>/<br>  }. </p>\n<ol>\n<li>line-clamp 定义文字显示行数</li>\n<li>pointer-events: none; 禁用点击事件</li>\n<li>focus-within是一个伪类，现在已经被列入到CSS选择器中。当元素本身或其后代元素获得焦点时，:focus-within伪类的元素就会有效。 </li>\n<li>单冒号(:)用于 CSS3 伪类，双冒号(::)用于 CSS3 伪元素。</li>\n<li><p>但是有个好处是当元素没有内容时候，设置height:100%该元素不会被撑开，</p>\n<p>但是设置height:100vh，该元素会被撑开屏幕高度一致。 </p>\n</li>\n<li><p>伪类：<br><a href=\"https://user-gold-cdn.xitu.io/2019/12/12/16ef8eecad4f1adb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" target=\"_blank\" rel=\"noopener\">https://user-gold-cdn.xitu.io/2019/12/12/16ef8eecad4f1adb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1</a></p>\n</li>\n<li><p>伪元素用于创建一些不在文档树中的元素，并为其添加样式。比如说，我们可以通过:before来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。常见的伪元素有：::before，::after，::first-line，::first-letter，::selection、::placeholder等. 伪类和伪元素的区别在于有没有创建一个文档书之外的元素。</p>\n</li>\n<li></li>\n<li>这是一个叫做@font-face 的CSS @规则 ，它允许网页开发者为其网页指定在线字体。 通过这种作者自备字体的方式，@font-face 可以消除对用户电脑字体的依赖。</li>\n<li><p>overflow:<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow</a></p>\n</li>\n<li><p>Element.scrollTop 属性可以获取或设置一个元素的内容垂直滚动的像素数。</p>\n</li>\n</ol>\n<p>offsetTop: 当前元素顶部距离最近父元素顶部的距离,和有没有滚动条没有关系。单位px，只读元素。</p>\n<p>  scrollHeight: 因为子元素比父元素高，父元素不想被子元素撑的一样高就显示出了滚动条，在滚动的过程中本元素有部分被隐藏了，scrollHeight代表包括当前不可见部分的元素的高度。而可见部分的高度其实就是clientHeight，也就是scrollHeight&gt;=clientHeight恒成立。在有滚动条时讨论scrollHeight才有意义，在没有滚动条时scrollHeight==clientHeight恒成立。单位px，只读元素。</p>\n<p>   <a href=\"https://imweb.io/topic/57c5409e808fd2fb204eef52\" target=\"_blank\" rel=\"noopener\">https://imweb.io/topic/57c5409e808fd2fb204eef52</a></p>\n<p>   clientheight offsetheight </p>\n<ol>\n<li><p>相对位置：<br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/position\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/position</a></p>\n</li>\n<li><p>Image alt 属性是一个必需的属性，它规定在图像无法显示时的替代文本。</p>\n</li>\n</ol>\n<p>text-decoration 设置下划线等<br><a href=\"https://jsfiddle.net/ryansecreat/58um7k43/\" target=\"_blank\" rel=\"noopener\">https://jsfiddle.net/ryansecreat/58um7k43/</a></p>\n<p>document​.active​Element</p>\n<p> 返回当前页面中获得焦点的元素,也就是说,如果此时用户按下了键盘上某个键,会在该元素上触发键盘事件.该属性是只读的.</p>\n<h4 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h4><ol>\n<li>尽量使用 flexbox 而不是老的布局模型。它运行速度更快，可为你的应用程序创造巨大的性能优势。</li>\n<li>根据 Google Developer，渲染线程分为 主线程 (main thread) 和 合成线程 (compositor thread)。如果 CSS 动画只是改变 transforms 和 opacity，这时整个 CSS 动画得以在 合成线程完成（而JS动画则会在 主线程 执行，然后触发合成线程进行下一步操作），在 JS 执行一些昂贵的任务时，主线程繁忙，CSS 动画由于使用了合成线程可以保持流畅</li>\n<li>CSS动画有天然事件支持（TransitionEnd、AnimationEnd，但是它们都需要针对浏览器加前缀），JS则需要自己写事件。</li>\n<li>在实现一些小的交互动效的时候，就多考虑考虑 CSS 动画。对于一些复杂控制的动画，使用 javascript 比较可靠。</li>\n</ol>\n<h4 id=\"块元素是一个元素，占用了全部宽度，在前后都是换行符。\"><a href=\"#块元素是一个元素，占用了全部宽度，在前后都是换行符。\" class=\"headerlink\" title=\"块元素是一个元素，占用了全部宽度，在前后都是换行符。\"></a>块元素是一个元素，占用了全部宽度，在前后都是换行符。</h4>   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">块元素的例子：</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;h1&gt;</span><br><span class=\"line\">&lt;p&gt;</span><br><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">内联元素只需要必要的宽度，不强制换行。</span><br><span class=\"line\"></span><br><span class=\"line\">内联元素的例子：</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;span&gt;</span><br><span class=\"line\">&lt;a&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"内容对齐（justify-content）属性应用在弹性容器上，把弹性项沿着弹性容器的主轴线（main-axis）对齐。\"><a href=\"#内容对齐（justify-content）属性应用在弹性容器上，把弹性项沿着弹性容器的主轴线（main-axis）对齐。\" class=\"headerlink\" title=\"内容对齐（justify-content）属性应用在弹性容器上，把弹性项沿着弹性容器的主轴线（main axis）对齐。\"></a>内容对齐（justify-content）属性应用在弹性容器上，把弹性项沿着弹性容器的主轴线（main axis）对齐。</h4><p>   align-items 设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式。<br>   设置”margin”值为”auto”值，自动获取弹性容器中剩余的空间。所以设置垂直方向margin值为”auto”，可以使弹性子元素在弹性容器的两上轴方向都完全居中。 当容器为flex时会自动居中。</p>\n<p>   如果在元素上设置了 box-sizing: border-box; 则 padding(内边距) 和 border(边框) 也包含在 width 和 height 中:</p>\n<p>   transform: rotateX(120deg);  x轴旋转 </p>\n<h4 id=\"不被选中\"><a href=\"#不被选中\" class=\"headerlink\" title=\"不被选中\"></a>不被选中</h4><p>body{</p>\n<p>-webkit-touch-callout: none;</p>\n<p>-webkit-user-select: none;</p>\n<p>-khtml-user-select: none;</p>\n<p>-moz-user-select: none;</p>\n<p>-ms-user-select: none;</p>\n<p>user-select: none;</p>\n<p>}</p>\n<h4 id=\"隐藏\"><a href=\"#隐藏\" class=\"headerlink\" title=\"隐藏\"></a>隐藏</h4><p>1.opacity：0,该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定了一些事件，如click事件也能触发 2.visibility:hidden,该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件 3.display:node, 把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删掉</p>\n<h4 id=\"html-生成\"><a href=\"#html-生成\" class=\"headerlink\" title=\"html 生成\"></a>html 生成</h4><p>将html代码按照深度优先遍历来生成DOM树。 css文件下载完后也会进行渲染，生成相应的CSSOM。 当所有的css文件下载完且所有的CSSOM构建结束后，就会和DOM一起生成Render Tree。 接下来，浏览器就会进入Layout环节，将所有的节点位置计算出来。 最后，通过Painting环节将所有的节点内容呈现到屏幕上。</p>\n<h4 id=\"base64\"><a href=\"#base64\" class=\"headerlink\" title=\"base64\"></a>base64</h4><p> TMLCanvasElement.toDataURL() 方法返回一个包含图片展示的 data URI 。可以使用 type 参数其类型，默认为 PNG 格式。图片的分辨率为96dpi。</p>\n<h4 id=\"base64-渲染图片\"><a href=\"#base64-渲染图片\" class=\"headerlink\" title=\"base64 渲染图片\"></a>base64 渲染图片</h4><p>使用 Base64 编码渲染图片有以下优点：</p>\n<p>有效减少 HTTP 请求次数<br>可对数据进行简单加密，无法肉眼获取信息<br>没有跨域问题，无需考虑图片缓存<br>凡事皆有利弊，使用 Base64 编码同时也会带来一些问题：</p>\n<p>编码后文件体积增大，仅适用于小体积图片编码<br>增加了编码和解码的工作量<br>不支持 IE 8.0 以下版本   </p>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>Flex 主轴（x）、交叉轴(y)</li>\n<li><p>calc函数是css3新增的功能，可以使用calc()计算border、margin、pading、font-size和width等属性设置动态值。<br>1.触发BFC条件  BFC（Block Formatting Context）格式化上下文，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">根元素</span><br><span class=\"line\">float的值不为none</span><br><span class=\"line\">overflow的值不为visible</span><br><span class=\"line\">display的值为inline-block、table-cell、table-caption</span><br><span class=\"line\">position的值为absolute、fixed</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用vw设置，vw也是一个相对单位，100vw等于屏幕宽度</p>\n</li>\n<li>Flex-shrink、flex-grow   溢出空间和剩余空间</li>\n<li>max-width/min-width &gt; flex-basis &gt; width &gt; box</li>\n<li>&amp;:nth-child(odd)  选择器</li>\n<li>writing-mode: vertical-rl;  设置文字方向</li>\n<li>text-align-last  描述的是一段文本中最后一行在被强制换行之前的对齐规则<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">justify</span><br><span class=\"line\"></span><br><span class=\"line\">最后一行文字的开头与内容盒子的左侧对齐，末尾与右侧对齐</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>1.设置打印样式</p>\n<p>  @media print {<br>    /<em> print styles here. </em>/<br>  }. </p>\n<ol>\n<li>line-clamp 定义文字显示行数</li>\n<li>pointer-events: none; 禁用点击事件</li>\n<li>focus-within是一个伪类，现在已经被列入到CSS选择器中。当元素本身或其后代元素获得焦点时，:focus-within伪类的元素就会有效。 </li>\n<li>单冒号(:)用于 CSS3 伪类，双冒号(::)用于 CSS3 伪元素。</li>\n<li><p>但是有个好处是当元素没有内容时候，设置height:100%该元素不会被撑开，</p>\n<p>但是设置height:100vh，该元素会被撑开屏幕高度一致。 </p>\n</li>\n<li><p>伪类：<br><a href=\"https://user-gold-cdn.xitu.io/2019/12/12/16ef8eecad4f1adb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" target=\"_blank\" rel=\"noopener\">https://user-gold-cdn.xitu.io/2019/12/12/16ef8eecad4f1adb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1</a></p>\n</li>\n<li><p>伪元素用于创建一些不在文档树中的元素，并为其添加样式。比如说，我们可以通过:before来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。常见的伪元素有：::before，::after，::first-line，::first-letter，::selection、::placeholder等. 伪类和伪元素的区别在于有没有创建一个文档书之外的元素。</p>\n</li>\n<li></li>\n<li>这是一个叫做@font-face 的CSS @规则 ，它允许网页开发者为其网页指定在线字体。 通过这种作者自备字体的方式，@font-face 可以消除对用户电脑字体的依赖。</li>\n<li><p>overflow:<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow</a></p>\n</li>\n<li><p>Element.scrollTop 属性可以获取或设置一个元素的内容垂直滚动的像素数。</p>\n</li>\n</ol>\n<p>offsetTop: 当前元素顶部距离最近父元素顶部的距离,和有没有滚动条没有关系。单位px，只读元素。</p>\n<p>  scrollHeight: 因为子元素比父元素高，父元素不想被子元素撑的一样高就显示出了滚动条，在滚动的过程中本元素有部分被隐藏了，scrollHeight代表包括当前不可见部分的元素的高度。而可见部分的高度其实就是clientHeight，也就是scrollHeight&gt;=clientHeight恒成立。在有滚动条时讨论scrollHeight才有意义，在没有滚动条时scrollHeight==clientHeight恒成立。单位px，只读元素。</p>\n<p>   <a href=\"https://imweb.io/topic/57c5409e808fd2fb204eef52\" target=\"_blank\" rel=\"noopener\">https://imweb.io/topic/57c5409e808fd2fb204eef52</a></p>\n<p>   clientheight offsetheight </p>\n<ol>\n<li><p>相对位置：<br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/position\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/position</a></p>\n</li>\n<li><p>Image alt 属性是一个必需的属性，它规定在图像无法显示时的替代文本。</p>\n</li>\n</ol>\n<p>text-decoration 设置下划线等<br><a href=\"https://jsfiddle.net/ryansecreat/58um7k43/\" target=\"_blank\" rel=\"noopener\">https://jsfiddle.net/ryansecreat/58um7k43/</a></p>\n<p>document​.active​Element</p>\n<p> 返回当前页面中获得焦点的元素,也就是说,如果此时用户按下了键盘上某个键,会在该元素上触发键盘事件.该属性是只读的.</p>\n<h4 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h4><ol>\n<li>尽量使用 flexbox 而不是老的布局模型。它运行速度更快，可为你的应用程序创造巨大的性能优势。</li>\n<li>根据 Google Developer，渲染线程分为 主线程 (main thread) 和 合成线程 (compositor thread)。如果 CSS 动画只是改变 transforms 和 opacity，这时整个 CSS 动画得以在 合成线程完成（而JS动画则会在 主线程 执行，然后触发合成线程进行下一步操作），在 JS 执行一些昂贵的任务时，主线程繁忙，CSS 动画由于使用了合成线程可以保持流畅</li>\n<li>CSS动画有天然事件支持（TransitionEnd、AnimationEnd，但是它们都需要针对浏览器加前缀），JS则需要自己写事件。</li>\n<li>在实现一些小的交互动效的时候，就多考虑考虑 CSS 动画。对于一些复杂控制的动画，使用 javascript 比较可靠。</li>\n</ol>\n<h4 id=\"块元素是一个元素，占用了全部宽度，在前后都是换行符。\"><a href=\"#块元素是一个元素，占用了全部宽度，在前后都是换行符。\" class=\"headerlink\" title=\"块元素是一个元素，占用了全部宽度，在前后都是换行符。\"></a>块元素是一个元素，占用了全部宽度，在前后都是换行符。</h4>   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">块元素的例子：</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;h1&gt;</span><br><span class=\"line\">&lt;p&gt;</span><br><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">内联元素只需要必要的宽度，不强制换行。</span><br><span class=\"line\"></span><br><span class=\"line\">内联元素的例子：</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;span&gt;</span><br><span class=\"line\">&lt;a&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"内容对齐（justify-content）属性应用在弹性容器上，把弹性项沿着弹性容器的主轴线（main-axis）对齐。\"><a href=\"#内容对齐（justify-content）属性应用在弹性容器上，把弹性项沿着弹性容器的主轴线（main-axis）对齐。\" class=\"headerlink\" title=\"内容对齐（justify-content）属性应用在弹性容器上，把弹性项沿着弹性容器的主轴线（main axis）对齐。\"></a>内容对齐（justify-content）属性应用在弹性容器上，把弹性项沿着弹性容器的主轴线（main axis）对齐。</h4><p>   align-items 设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式。<br>   设置”margin”值为”auto”值，自动获取弹性容器中剩余的空间。所以设置垂直方向margin值为”auto”，可以使弹性子元素在弹性容器的两上轴方向都完全居中。 当容器为flex时会自动居中。</p>\n<p>   如果在元素上设置了 box-sizing: border-box; 则 padding(内边距) 和 border(边框) 也包含在 width 和 height 中:</p>\n<p>   transform: rotateX(120deg);  x轴旋转 </p>\n<h4 id=\"不被选中\"><a href=\"#不被选中\" class=\"headerlink\" title=\"不被选中\"></a>不被选中</h4><p>body{</p>\n<p>-webkit-touch-callout: none;</p>\n<p>-webkit-user-select: none;</p>\n<p>-khtml-user-select: none;</p>\n<p>-moz-user-select: none;</p>\n<p>-ms-user-select: none;</p>\n<p>user-select: none;</p>\n<p>}</p>\n<h4 id=\"隐藏\"><a href=\"#隐藏\" class=\"headerlink\" title=\"隐藏\"></a>隐藏</h4><p>1.opacity：0,该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定了一些事件，如click事件也能触发 2.visibility:hidden,该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件 3.display:node, 把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删掉</p>\n<h4 id=\"html-生成\"><a href=\"#html-生成\" class=\"headerlink\" title=\"html 生成\"></a>html 生成</h4><p>将html代码按照深度优先遍历来生成DOM树。 css文件下载完后也会进行渲染，生成相应的CSSOM。 当所有的css文件下载完且所有的CSSOM构建结束后，就会和DOM一起生成Render Tree。 接下来，浏览器就会进入Layout环节，将所有的节点位置计算出来。 最后，通过Painting环节将所有的节点内容呈现到屏幕上。</p>\n<h4 id=\"base64\"><a href=\"#base64\" class=\"headerlink\" title=\"base64\"></a>base64</h4><p> TMLCanvasElement.toDataURL() 方法返回一个包含图片展示的 data URI 。可以使用 type 参数其类型，默认为 PNG 格式。图片的分辨率为96dpi。</p>\n<h4 id=\"base64-渲染图片\"><a href=\"#base64-渲染图片\" class=\"headerlink\" title=\"base64 渲染图片\"></a>base64 渲染图片</h4><p>使用 Base64 编码渲染图片有以下优点：</p>\n<p>有效减少 HTTP 请求次数<br>可对数据进行简单加密，无法肉眼获取信息<br>没有跨域问题，无需考虑图片缓存<br>凡事皆有利弊，使用 Base64 编码同时也会带来一些问题：</p>\n<p>编码后文件体积增大，仅适用于小体积图片编码<br>增加了编码和解码的工作量<br>不支持 IE 8.0 以下版本   </p>\n"},{"title":"docker 常用命令","date":"2016-12-14T09:56:03.000Z","_content":"总结一下常用命令:\n\n其中<>阔起来的参数为必选，[]阔起来为可选\n\ndocker version 查看docker的版本号，包括客户端、服务端、依赖的Go等\ndocker info 查看系统(docker)层面信息，包括管理的images, containers数等\ndocker search <image> 在docker index中搜索image\ndocker pull <image> 从docker registry server 中下拉image\ndocker push <image|repository> 推送一个image或repository到registry\ndocker push <image|repository>:TAG 同上，指定tag\ndocker inspect <image|container> 查看image或container的底层信息\ndocker images TODO filter out the intermediate image layers (intermediate image layers 是什么)\ndocker images -a 列出所有的images\ndocker ps 默认显示正在运行中的container\ndocker ps -l 显示最后一次创建的container，包括未运行的\ndocker ps -a 显示所有的container，包括未运行的\ndocker logs <container> 查看container的日志，也就是执行命令的一些输出\ndocker rm <container...> 删除一个或多个container\ndocker rm `docker ps -a -q` 删除所有的container\ndocker ps -a -q | xargs docker rm 同上, 删除所有的container\ndocker rmi <image...> 删除一个或多个image\ndocker start/stop/restart <container> 开启/停止/重启container\ndocker start -i <container> 启动一个container并进入交互模式\ndocker attach <container> attach一个运行中的container\ndocker run <image> <command> 使用image创建container并执行相应命令，然后停止\ndocker run -i -t <image> /bin/bash 使用image创建container并进入交互模式, login shell是/bin/bash\ndocker run -i -t -p <host_port:contain_port> 将container的端口映射到宿主机的端口\ndocker commit <container> [repo:tag] 将一个container固化为一个新的image，后面的repo:tag可选\ndocker build <path> 寻找path路径下名为的Dockerfile的配置文件，使用此配置生成新的image\ndocker build -t repo[:tag] 同上，可以指定repo和可选的tag\ndocker build - < <dockerfile> 使用指定的dockerfile配置文件，docker以stdin方式获取内容，使用此配置生成新的image\ndocker port <container> <container port> 查看本地哪个端口映射到container的指定端口，其实用docker ps 也可以看到\n\n\n### 安装docker\n1. 利用官方脚本：\n\n```\n$ sudo yum update\n$ sudo curl -sSL https://get.docker.com/ | sh\n```\n2.  用黄狗安装：\n\n```\n$ sudo yum update\n$ sudo yum -y install docker\n$ sudo systemctl start docker\n```\n### 删除操作\n##### 删除所有已经停止的continer  -q 列出所有id\n\n```\ndocker rm $(docker ps -a -q)\n```\n##### 删除所有镜像\n\n```\ndocker rmi $(docker images | grep none | awk '{print $3}' | sort -r)\n```\n### 命令说明\n1. 其中go的语法模板\n \n```\ndocker images --format \"{{.ID}}: {{.Repository}}\"\ndocker images --format \"table {{.ID}}\\t{{.Repository}}\\t{{.Tag}}\"\n```\n2. filter 过滤参数\n \n```\ndocker images -f since=mongo:3.2\n```\n 表示自从3.2 版本以来所有的镜像。\n3. docker run -it --rm --name ryanserver ubuntu:14.04 bash \n   \n   it 表示交互终端 \n   rm 推出后删除\n   ubuntu  镜像名称\n   bash bash命令\n   naem 指定container名称\n```\ndocker run --name webserver -d -p 85:80 nginx\n```\n\n4. docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]\n- -a :提交的镜像作者；\n- -c :使用Dockerfile指令来创建镜像；\n- -m :提交时的说明文字；\n- -p :在commit时，将容器暂停。\n如：\n\n```\n$ docker commit \\\n    --author \"Tao Wang <twang2218@gmail.com>\" \\\n    --message \"修改了默认网页\" \\\n    webserver \\\n    nginx:v2\n```\n5.通过dockfile制作镜像\n\n```\nFROM nginx\nRUN echo '<h1>Hello, Docker!</h1>' > /usr/share/nginx/html/index.html\n```\nfrom 指定基础镜像 \n\nDockerfile中每次运行run 都执行了一层。&& 将各个所需命令串联起来\n\nDockerfile 支持 Shell 类的行尾添加 \\ 的命令换行方式，以及行首# 进行注释的格式\n一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。\n\ncopy 文件时可使用通配符，其通配符规则要满足 Go 的 filepath.Match 规则，如：\n\n```\nCOPY hom* /mydir/\nCOPY hom?.txt /mydir/\n```\nAdd 功能和copy 类似，不过自带解压功能：\n\n```\nFROM scratch\nADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /\n```\n###### 环境变量的配置\n格式有两种：\n  ● ENV <key> <value>\n  ● ENV <key1>=<value1> <key2>=<value2>...\n例如 ENV VERSION=1.0 DEBUG=on \\\n     NAME=\"Happy Feet\n######  匿名卷\n在 Dockerfile 中，我们可以事先指定某些目录挂载为匿名卷，\n任何向 /data 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如：\ndocker run -d -v mydata:/data xxxx\n###### 挂载host目录\n将host机中的文件挂载到container中：\ndocker可以支持把一个宿主机上的目录挂载到镜像里。\n\n```\ndocker run -it -v /home/dock/Downloads:/usr/Downloads ubuntu64 /bin/bash\n```\n\n通过-v参数，冒号前为宿主机目录，必须为绝对路径，冒号后为镜像内挂载的路径。\n\n一个dockfile:\n \n```\nMAINTAINER Anna Doe <anna@example.com>\nnodejs pm2:\nFROM node:0.11.13\n# or just node, without tag\n\nRUN npm install -g pm2\nRUN pm2 dump\n# dump will start pm2 daemon and create everything needed\n\nVOLUME [\"/srv/apps\", \"/srv/logs\", \"/srv/server.json\"]\n# don't put the files in docker container, user -v\n\nEXPOSE 3000\n\nCMD [\"pm2\", \"start\", \"/srv/server.json\", \"--no-daemon\"]\n# no daemon mode for docker\n```\n\n6. docker build -t repo[:tag] . \n   \n可以指定repo和可选的tag\n如果注意，会看到 docker build 命令最后有一个 .。. 表示当前目录\ncopy命令只有在当前上下文有有效\n\n7. 从container中导出\n导出(Export)\nExport命令用于持久化容器（不是镜像）\n接着执行导出：\nsudo docker export <CONTAINER ID> > /home/export.tar\n\n导出后，可以通过docker import   导入，如\n\n```\ncat busy.tar | sudo docker import - busy:v1.0\n\n```\n\n8. 保存镜像\n   sudo docker save busybox-1 > /home/save.tar\n\n\n```\n用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以使用 docker import 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。\n```\n\n9. docker 自启动配置\n\n自动启动container 如下：\n\n```\ndocker run -ti --restart=on-failure:3   \n失败后会启动三次\n```\n10. 用非root用户操作docker\n下面是使用非root用户操作的步骤\n\n```\n创建docker组\nsudo groupadd docker\n将当前用户加入docker组\nsudo gpasswd -a ${USER} docker\n重新启动docker服务（下面是CentOS7的命令）\nsudo systemctl restart docker\n当前用户退出系统重新登陆\n运行docker命令\ndocker ps\n```\n\n11.用docker 启动zookeeper \n\n```\nps -aux | grep docker\ndocker run  --name alizookeeper --restart always -d -P zookeeper\n```\n\n ","source":"_posts/docker.md","raw":"---\ntitle: docker 常用命令\ndate: 2016-12-14 17:56:03\ntags: docker\n---\n总结一下常用命令:\n\n其中<>阔起来的参数为必选，[]阔起来为可选\n\ndocker version 查看docker的版本号，包括客户端、服务端、依赖的Go等\ndocker info 查看系统(docker)层面信息，包括管理的images, containers数等\ndocker search <image> 在docker index中搜索image\ndocker pull <image> 从docker registry server 中下拉image\ndocker push <image|repository> 推送一个image或repository到registry\ndocker push <image|repository>:TAG 同上，指定tag\ndocker inspect <image|container> 查看image或container的底层信息\ndocker images TODO filter out the intermediate image layers (intermediate image layers 是什么)\ndocker images -a 列出所有的images\ndocker ps 默认显示正在运行中的container\ndocker ps -l 显示最后一次创建的container，包括未运行的\ndocker ps -a 显示所有的container，包括未运行的\ndocker logs <container> 查看container的日志，也就是执行命令的一些输出\ndocker rm <container...> 删除一个或多个container\ndocker rm `docker ps -a -q` 删除所有的container\ndocker ps -a -q | xargs docker rm 同上, 删除所有的container\ndocker rmi <image...> 删除一个或多个image\ndocker start/stop/restart <container> 开启/停止/重启container\ndocker start -i <container> 启动一个container并进入交互模式\ndocker attach <container> attach一个运行中的container\ndocker run <image> <command> 使用image创建container并执行相应命令，然后停止\ndocker run -i -t <image> /bin/bash 使用image创建container并进入交互模式, login shell是/bin/bash\ndocker run -i -t -p <host_port:contain_port> 将container的端口映射到宿主机的端口\ndocker commit <container> [repo:tag] 将一个container固化为一个新的image，后面的repo:tag可选\ndocker build <path> 寻找path路径下名为的Dockerfile的配置文件，使用此配置生成新的image\ndocker build -t repo[:tag] 同上，可以指定repo和可选的tag\ndocker build - < <dockerfile> 使用指定的dockerfile配置文件，docker以stdin方式获取内容，使用此配置生成新的image\ndocker port <container> <container port> 查看本地哪个端口映射到container的指定端口，其实用docker ps 也可以看到\n\n\n### 安装docker\n1. 利用官方脚本：\n\n```\n$ sudo yum update\n$ sudo curl -sSL https://get.docker.com/ | sh\n```\n2.  用黄狗安装：\n\n```\n$ sudo yum update\n$ sudo yum -y install docker\n$ sudo systemctl start docker\n```\n### 删除操作\n##### 删除所有已经停止的continer  -q 列出所有id\n\n```\ndocker rm $(docker ps -a -q)\n```\n##### 删除所有镜像\n\n```\ndocker rmi $(docker images | grep none | awk '{print $3}' | sort -r)\n```\n### 命令说明\n1. 其中go的语法模板\n \n```\ndocker images --format \"{{.ID}}: {{.Repository}}\"\ndocker images --format \"table {{.ID}}\\t{{.Repository}}\\t{{.Tag}}\"\n```\n2. filter 过滤参数\n \n```\ndocker images -f since=mongo:3.2\n```\n 表示自从3.2 版本以来所有的镜像。\n3. docker run -it --rm --name ryanserver ubuntu:14.04 bash \n   \n   it 表示交互终端 \n   rm 推出后删除\n   ubuntu  镜像名称\n   bash bash命令\n   naem 指定container名称\n```\ndocker run --name webserver -d -p 85:80 nginx\n```\n\n4. docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]\n- -a :提交的镜像作者；\n- -c :使用Dockerfile指令来创建镜像；\n- -m :提交时的说明文字；\n- -p :在commit时，将容器暂停。\n如：\n\n```\n$ docker commit \\\n    --author \"Tao Wang <twang2218@gmail.com>\" \\\n    --message \"修改了默认网页\" \\\n    webserver \\\n    nginx:v2\n```\n5.通过dockfile制作镜像\n\n```\nFROM nginx\nRUN echo '<h1>Hello, Docker!</h1>' > /usr/share/nginx/html/index.html\n```\nfrom 指定基础镜像 \n\nDockerfile中每次运行run 都执行了一层。&& 将各个所需命令串联起来\n\nDockerfile 支持 Shell 类的行尾添加 \\ 的命令换行方式，以及行首# 进行注释的格式\n一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。\n\ncopy 文件时可使用通配符，其通配符规则要满足 Go 的 filepath.Match 规则，如：\n\n```\nCOPY hom* /mydir/\nCOPY hom?.txt /mydir/\n```\nAdd 功能和copy 类似，不过自带解压功能：\n\n```\nFROM scratch\nADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /\n```\n###### 环境变量的配置\n格式有两种：\n  ● ENV <key> <value>\n  ● ENV <key1>=<value1> <key2>=<value2>...\n例如 ENV VERSION=1.0 DEBUG=on \\\n     NAME=\"Happy Feet\n######  匿名卷\n在 Dockerfile 中，我们可以事先指定某些目录挂载为匿名卷，\n任何向 /data 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如：\ndocker run -d -v mydata:/data xxxx\n###### 挂载host目录\n将host机中的文件挂载到container中：\ndocker可以支持把一个宿主机上的目录挂载到镜像里。\n\n```\ndocker run -it -v /home/dock/Downloads:/usr/Downloads ubuntu64 /bin/bash\n```\n\n通过-v参数，冒号前为宿主机目录，必须为绝对路径，冒号后为镜像内挂载的路径。\n\n一个dockfile:\n \n```\nMAINTAINER Anna Doe <anna@example.com>\nnodejs pm2:\nFROM node:0.11.13\n# or just node, without tag\n\nRUN npm install -g pm2\nRUN pm2 dump\n# dump will start pm2 daemon and create everything needed\n\nVOLUME [\"/srv/apps\", \"/srv/logs\", \"/srv/server.json\"]\n# don't put the files in docker container, user -v\n\nEXPOSE 3000\n\nCMD [\"pm2\", \"start\", \"/srv/server.json\", \"--no-daemon\"]\n# no daemon mode for docker\n```\n\n6. docker build -t repo[:tag] . \n   \n可以指定repo和可选的tag\n如果注意，会看到 docker build 命令最后有一个 .。. 表示当前目录\ncopy命令只有在当前上下文有有效\n\n7. 从container中导出\n导出(Export)\nExport命令用于持久化容器（不是镜像）\n接着执行导出：\nsudo docker export <CONTAINER ID> > /home/export.tar\n\n导出后，可以通过docker import   导入，如\n\n```\ncat busy.tar | sudo docker import - busy:v1.0\n\n```\n\n8. 保存镜像\n   sudo docker save busybox-1 > /home/save.tar\n\n\n```\n用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以使用 docker import 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。\n```\n\n9. docker 自启动配置\n\n自动启动container 如下：\n\n```\ndocker run -ti --restart=on-failure:3   \n失败后会启动三次\n```\n10. 用非root用户操作docker\n下面是使用非root用户操作的步骤\n\n```\n创建docker组\nsudo groupadd docker\n将当前用户加入docker组\nsudo gpasswd -a ${USER} docker\n重新启动docker服务（下面是CentOS7的命令）\nsudo systemctl restart docker\n当前用户退出系统重新登陆\n运行docker命令\ndocker ps\n```\n\n11.用docker 启动zookeeper \n\n```\nps -aux | grep docker\ndocker run  --name alizookeeper --restart always -d -P zookeeper\n```\n\n ","slug":"docker","published":1,"updated":"2019-07-26T08:35:17.301Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5bwexci0005998sg7qxv23y","content":"<p>总结一下常用命令:</p>\n<p>其中&lt;&gt;阔起来的参数为必选，[]阔起来为可选</p>\n<p>docker version 查看docker的版本号，包括客户端、服务端、依赖的Go等<br>docker info 查看系统(docker)层面信息，包括管理的images, containers数等<br>docker search <image> 在docker index中搜索image<br>docker pull <image> 从docker registry server 中下拉image<br>docker push &lt;image|repository&gt; 推送一个image或repository到registry<br>docker push &lt;image|repository&gt;:TAG 同上，指定tag<br>docker inspect &lt;image|container&gt; 查看image或container的底层信息<br>docker images TODO filter out the intermediate image layers (intermediate image layers 是什么)<br>docker images -a 列出所有的images<br>docker ps 默认显示正在运行中的container<br>docker ps -l 显示最后一次创建的container，包括未运行的<br>docker ps -a 显示所有的container，包括未运行的<br>docker logs <container> 查看container的日志，也就是执行命令的一些输出<br>docker rm &lt;container…&gt; 删除一个或多个container<br>docker rm <code>docker ps -a -q</code> 删除所有的container<br>docker ps -a -q | xargs docker rm 同上, 删除所有的container<br>docker rmi &lt;image…&gt; 删除一个或多个image<br>docker start/stop/restart <container> 开启/停止/重启container<br>docker start -i <container> 启动一个container并进入交互模式<br>docker attach <container> attach一个运行中的container<br>docker run <image> <command> 使用image创建container并执行相应命令，然后停止<br>docker run -i -t <image> /bin/bash 使用image创建container并进入交互模式, login shell是/bin/bash<br>docker run -i -t -p &lt;host_port:contain_port&gt; 将container的端口映射到宿主机的端口<br>docker commit <container> [repo:tag] 将一个container固化为一个新的image，后面的repo:tag可选<br>docker build <path> 寻找path路径下名为的Dockerfile的配置文件，使用此配置生成新的image<br>docker build -t repo[:tag] 同上，可以指定repo和可选的tag<br>docker build - &lt; <dockerfile> 使用指定的dockerfile配置文件，docker以stdin方式获取内容，使用此配置生成新的image<br>docker port <container> <container port=\"\"> 查看本地哪个端口映射到container的指定端口，其实用docker ps 也可以看到</container></container></dockerfile></path></container></image></image></container></container></container></container></image></image></p>\n<h3 id=\"安装docker\"><a href=\"#安装docker\" class=\"headerlink\" title=\"安装docker\"></a>安装docker</h3><ol>\n<li>利用官方脚本：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo yum update</span><br><span class=\"line\">$ sudo curl -sSL https://get.docker.com/ | sh</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>用黄狗安装：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo yum update</span><br><span class=\"line\">$ sudo yum -y install docker</span><br><span class=\"line\">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除操作\"><a href=\"#删除操作\" class=\"headerlink\" title=\"删除操作\"></a>删除操作</h3><h5 id=\"删除所有已经停止的continer-q-列出所有id\"><a href=\"#删除所有已经停止的continer-q-列出所有id\" class=\"headerlink\" title=\"删除所有已经停止的continer  -q 列出所有id\"></a>删除所有已经停止的continer  -q 列出所有id</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker rm $(docker ps -a -q)</span><br></pre></td></tr></table></figure>\n<h5 id=\"删除所有镜像\"><a href=\"#删除所有镜像\" class=\"headerlink\" title=\"删除所有镜像\"></a>删除所有镜像</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker rmi $(docker images | grep none | awk &apos;&#123;print $3&#125;&apos; | sort -r)</span><br></pre></td></tr></table></figure>\n<h3 id=\"命令说明\"><a href=\"#命令说明\" class=\"headerlink\" title=\"命令说明\"></a>命令说明</h3><ol>\n<li>其中go的语法模板</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker images --format &quot;&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;&quot;</span><br><span class=\"line\">docker images --format &quot;table &#123;&#123;.ID&#125;&#125;\\t&#123;&#123;.Repository&#125;&#125;\\t&#123;&#123;.Tag&#125;&#125;&quot;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>filter 过滤参数</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker images -f since=mongo:3.2</span><br></pre></td></tr></table></figure>\n<p> 表示自从3.2 版本以来所有的镜像。</p>\n<ol start=\"3\">\n<li><p>docker run -it –rm –name ryanserver ubuntu:14.04 bash </p>\n<p>it 表示交互终端<br>rm 推出后删除<br>ubuntu  镜像名称<br>bash bash命令<br>naem 指定container名称</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run --name webserver -d -p 85:80 nginx</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</p>\n</li>\n</ol>\n<ul>\n<li>-a :提交的镜像作者；</li>\n<li>-c :使用Dockerfile指令来创建镜像；</li>\n<li>-m :提交时的说明文字；</li>\n<li>-p :在commit时，将容器暂停。<br>如：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker commit \\</span><br><span class=\"line\">    --author &quot;Tao Wang &lt;twang2218@gmail.com&gt;&quot; \\</span><br><span class=\"line\">    --message &quot;修改了默认网页&quot; \\</span><br><span class=\"line\">    webserver \\</span><br><span class=\"line\">    nginx:v2</span><br></pre></td></tr></table></figure>\n<p>5.通过dockfile制作镜像</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM nginx</span><br><span class=\"line\">RUN echo &apos;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure>\n<p>from 指定基础镜像 </p>\n<p>Dockerfile中每次运行run 都执行了一层。&amp;&amp; 将各个所需命令串联起来</p>\n<p>Dockerfile 支持 Shell 类的行尾添加 \\ 的命令换行方式，以及行首# 进行注释的格式<br>一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p>\n<p>copy 文件时可使用通配符，其通配符规则要满足 Go 的 filepath.Match 规则，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">COPY hom* /mydir/</span><br><span class=\"line\">COPY hom?.txt /mydir/</span><br></pre></td></tr></table></figure>\n<p>Add 功能和copy 类似，不过自带解压功能：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM scratch</span><br><span class=\"line\">ADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /</span><br></pre></td></tr></table></figure>\n<h6 id=\"环境变量的配置\"><a href=\"#环境变量的配置\" class=\"headerlink\" title=\"环境变量的配置\"></a>环境变量的配置</h6><p>格式有两种：<br>  ● ENV <key> <value><br>  ● ENV <key1>=<value1> <key2>=<value2>…<br>例如 ENV VERSION=1.0 DEBUG=on \\<br>     NAME=”Happy Feet</value2></key2></value1></key1></value></key></p>\n<h6 id=\"匿名卷\"><a href=\"#匿名卷\" class=\"headerlink\" title=\"匿名卷\"></a>匿名卷</h6><p>在 Dockerfile 中，我们可以事先指定某些目录挂载为匿名卷，<br>任何向 /data 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如：<br>docker run -d -v mydata:/data xxxx</p>\n<h6 id=\"挂载host目录\"><a href=\"#挂载host目录\" class=\"headerlink\" title=\"挂载host目录\"></a>挂载host目录</h6><p>将host机中的文件挂载到container中：<br>docker可以支持把一个宿主机上的目录挂载到镜像里。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -it -v /home/dock/Downloads:/usr/Downloads ubuntu64 /bin/bash</span><br></pre></td></tr></table></figure>\n<p>通过-v参数，冒号前为宿主机目录，必须为绝对路径，冒号后为镜像内挂载的路径。</p>\n<p>一个dockfile:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MAINTAINER Anna Doe &lt;anna@example.com&gt;</span><br><span class=\"line\">nodejs pm2:</span><br><span class=\"line\">FROM node:0.11.13</span><br><span class=\"line\"># or just node, without tag</span><br><span class=\"line\"></span><br><span class=\"line\">RUN npm install -g pm2</span><br><span class=\"line\">RUN pm2 dump</span><br><span class=\"line\"># dump will start pm2 daemon and create everything needed</span><br><span class=\"line\"></span><br><span class=\"line\">VOLUME [&quot;/srv/apps&quot;, &quot;/srv/logs&quot;, &quot;/srv/server.json&quot;]</span><br><span class=\"line\"># don&apos;t put the files in docker container, user -v</span><br><span class=\"line\"></span><br><span class=\"line\">EXPOSE 3000</span><br><span class=\"line\"></span><br><span class=\"line\">CMD [&quot;pm2&quot;, &quot;start&quot;, &quot;/srv/server.json&quot;, &quot;--no-daemon&quot;]</span><br><span class=\"line\"># no daemon mode for docker</span><br></pre></td></tr></table></figure>\n<ol start=\"6\">\n<li>docker build -t repo[:tag] . </li>\n</ol>\n<p>可以指定repo和可选的tag<br>如果注意，会看到 docker build 命令最后有一个 .。. 表示当前目录<br>copy命令只有在当前上下文有有效</p>\n<ol start=\"7\">\n<li>从container中导出<br>导出(Export)<br>Export命令用于持久化容器（不是镜像）<br>接着执行导出：<br>sudo docker export <container id=\"\"> &gt; /home/export.tar</container></li>\n</ol>\n<p>导出后，可以通过docker import   导入，如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat busy.tar | sudo docker import - busy:v1.0</span><br></pre></td></tr></table></figure>\n<ol start=\"8\">\n<li>保存镜像<br>sudo docker save busybox-1 &gt; /home/save.tar</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以使用 docker import 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</span><br></pre></td></tr></table></figure>\n<ol start=\"9\">\n<li>docker 自启动配置</li>\n</ol>\n<p>自动启动container 如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -ti --restart=on-failure:3   </span><br><span class=\"line\">失败后会启动三次</span><br></pre></td></tr></table></figure>\n<ol start=\"10\">\n<li>用非root用户操作docker<br>下面是使用非root用户操作的步骤</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">创建docker组</span><br><span class=\"line\">sudo groupadd docker</span><br><span class=\"line\">将当前用户加入docker组</span><br><span class=\"line\">sudo gpasswd -a $&#123;USER&#125; docker</span><br><span class=\"line\">重新启动docker服务（下面是CentOS7的命令）</span><br><span class=\"line\">sudo systemctl restart docker</span><br><span class=\"line\">当前用户退出系统重新登陆</span><br><span class=\"line\">运行docker命令</span><br><span class=\"line\">docker ps</span><br></pre></td></tr></table></figure>\n<p>11.用docker 启动zookeeper </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ps -aux | grep docker</span><br><span class=\"line\">docker run  --name alizookeeper --restart always -d -P zookeeper</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>总结一下常用命令:</p>\n<p>其中&lt;&gt;阔起来的参数为必选，[]阔起来为可选</p>\n<p>docker version 查看docker的版本号，包括客户端、服务端、依赖的Go等<br>docker info 查看系统(docker)层面信息，包括管理的images, containers数等<br>docker search <image> 在docker index中搜索image<br>docker pull <image> 从docker registry server 中下拉image<br>docker push &lt;image|repository&gt; 推送一个image或repository到registry<br>docker push &lt;image|repository&gt;:TAG 同上，指定tag<br>docker inspect &lt;image|container&gt; 查看image或container的底层信息<br>docker images TODO filter out the intermediate image layers (intermediate image layers 是什么)<br>docker images -a 列出所有的images<br>docker ps 默认显示正在运行中的container<br>docker ps -l 显示最后一次创建的container，包括未运行的<br>docker ps -a 显示所有的container，包括未运行的<br>docker logs <container> 查看container的日志，也就是执行命令的一些输出<br>docker rm &lt;container…&gt; 删除一个或多个container<br>docker rm <code>docker ps -a -q</code> 删除所有的container<br>docker ps -a -q | xargs docker rm 同上, 删除所有的container<br>docker rmi &lt;image…&gt; 删除一个或多个image<br>docker start/stop/restart <container> 开启/停止/重启container<br>docker start -i <container> 启动一个container并进入交互模式<br>docker attach <container> attach一个运行中的container<br>docker run <image> <command> 使用image创建container并执行相应命令，然后停止<br>docker run -i -t <image> /bin/bash 使用image创建container并进入交互模式, login shell是/bin/bash<br>docker run -i -t -p &lt;host_port:contain_port&gt; 将container的端口映射到宿主机的端口<br>docker commit <container> [repo:tag] 将一个container固化为一个新的image，后面的repo:tag可选<br>docker build <path> 寻找path路径下名为的Dockerfile的配置文件，使用此配置生成新的image<br>docker build -t repo[:tag] 同上，可以指定repo和可选的tag<br>docker build - &lt; <dockerfile> 使用指定的dockerfile配置文件，docker以stdin方式获取内容，使用此配置生成新的image<br>docker port <container> <container port=\"\"> 查看本地哪个端口映射到container的指定端口，其实用docker ps 也可以看到</container></container></dockerfile></path></container></image></image></container></container></container></container></image></image></p>\n<h3 id=\"安装docker\"><a href=\"#安装docker\" class=\"headerlink\" title=\"安装docker\"></a>安装docker</h3><ol>\n<li>利用官方脚本：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo yum update</span><br><span class=\"line\">$ sudo curl -sSL https://get.docker.com/ | sh</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>用黄狗安装：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo yum update</span><br><span class=\"line\">$ sudo yum -y install docker</span><br><span class=\"line\">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除操作\"><a href=\"#删除操作\" class=\"headerlink\" title=\"删除操作\"></a>删除操作</h3><h5 id=\"删除所有已经停止的continer-q-列出所有id\"><a href=\"#删除所有已经停止的continer-q-列出所有id\" class=\"headerlink\" title=\"删除所有已经停止的continer  -q 列出所有id\"></a>删除所有已经停止的continer  -q 列出所有id</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker rm $(docker ps -a -q)</span><br></pre></td></tr></table></figure>\n<h5 id=\"删除所有镜像\"><a href=\"#删除所有镜像\" class=\"headerlink\" title=\"删除所有镜像\"></a>删除所有镜像</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker rmi $(docker images | grep none | awk &apos;&#123;print $3&#125;&apos; | sort -r)</span><br></pre></td></tr></table></figure>\n<h3 id=\"命令说明\"><a href=\"#命令说明\" class=\"headerlink\" title=\"命令说明\"></a>命令说明</h3><ol>\n<li>其中go的语法模板</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker images --format &quot;&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;&quot;</span><br><span class=\"line\">docker images --format &quot;table &#123;&#123;.ID&#125;&#125;\\t&#123;&#123;.Repository&#125;&#125;\\t&#123;&#123;.Tag&#125;&#125;&quot;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>filter 过滤参数</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker images -f since=mongo:3.2</span><br></pre></td></tr></table></figure>\n<p> 表示自从3.2 版本以来所有的镜像。</p>\n<ol start=\"3\">\n<li><p>docker run -it –rm –name ryanserver ubuntu:14.04 bash </p>\n<p>it 表示交互终端<br>rm 推出后删除<br>ubuntu  镜像名称<br>bash bash命令<br>naem 指定container名称</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run --name webserver -d -p 85:80 nginx</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</p>\n</li>\n</ol>\n<ul>\n<li>-a :提交的镜像作者；</li>\n<li>-c :使用Dockerfile指令来创建镜像；</li>\n<li>-m :提交时的说明文字；</li>\n<li>-p :在commit时，将容器暂停。<br>如：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker commit \\</span><br><span class=\"line\">    --author &quot;Tao Wang &lt;twang2218@gmail.com&gt;&quot; \\</span><br><span class=\"line\">    --message &quot;修改了默认网页&quot; \\</span><br><span class=\"line\">    webserver \\</span><br><span class=\"line\">    nginx:v2</span><br></pre></td></tr></table></figure>\n<p>5.通过dockfile制作镜像</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM nginx</span><br><span class=\"line\">RUN echo &apos;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure>\n<p>from 指定基础镜像 </p>\n<p>Dockerfile中每次运行run 都执行了一层。&amp;&amp; 将各个所需命令串联起来</p>\n<p>Dockerfile 支持 Shell 类的行尾添加 \\ 的命令换行方式，以及行首# 进行注释的格式<br>一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p>\n<p>copy 文件时可使用通配符，其通配符规则要满足 Go 的 filepath.Match 规则，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">COPY hom* /mydir/</span><br><span class=\"line\">COPY hom?.txt /mydir/</span><br></pre></td></tr></table></figure>\n<p>Add 功能和copy 类似，不过自带解压功能：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM scratch</span><br><span class=\"line\">ADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /</span><br></pre></td></tr></table></figure>\n<h6 id=\"环境变量的配置\"><a href=\"#环境变量的配置\" class=\"headerlink\" title=\"环境变量的配置\"></a>环境变量的配置</h6><p>格式有两种：<br>  ● ENV <key> <value><br>  ● ENV <key1>=<value1> <key2>=<value2>…<br>例如 ENV VERSION=1.0 DEBUG=on \\<br>     NAME=”Happy Feet</value2></key2></value1></key1></value></key></p>\n<h6 id=\"匿名卷\"><a href=\"#匿名卷\" class=\"headerlink\" title=\"匿名卷\"></a>匿名卷</h6><p>在 Dockerfile 中，我们可以事先指定某些目录挂载为匿名卷，<br>任何向 /data 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如：<br>docker run -d -v mydata:/data xxxx</p>\n<h6 id=\"挂载host目录\"><a href=\"#挂载host目录\" class=\"headerlink\" title=\"挂载host目录\"></a>挂载host目录</h6><p>将host机中的文件挂载到container中：<br>docker可以支持把一个宿主机上的目录挂载到镜像里。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -it -v /home/dock/Downloads:/usr/Downloads ubuntu64 /bin/bash</span><br></pre></td></tr></table></figure>\n<p>通过-v参数，冒号前为宿主机目录，必须为绝对路径，冒号后为镜像内挂载的路径。</p>\n<p>一个dockfile:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MAINTAINER Anna Doe &lt;anna@example.com&gt;</span><br><span class=\"line\">nodejs pm2:</span><br><span class=\"line\">FROM node:0.11.13</span><br><span class=\"line\"># or just node, without tag</span><br><span class=\"line\"></span><br><span class=\"line\">RUN npm install -g pm2</span><br><span class=\"line\">RUN pm2 dump</span><br><span class=\"line\"># dump will start pm2 daemon and create everything needed</span><br><span class=\"line\"></span><br><span class=\"line\">VOLUME [&quot;/srv/apps&quot;, &quot;/srv/logs&quot;, &quot;/srv/server.json&quot;]</span><br><span class=\"line\"># don&apos;t put the files in docker container, user -v</span><br><span class=\"line\"></span><br><span class=\"line\">EXPOSE 3000</span><br><span class=\"line\"></span><br><span class=\"line\">CMD [&quot;pm2&quot;, &quot;start&quot;, &quot;/srv/server.json&quot;, &quot;--no-daemon&quot;]</span><br><span class=\"line\"># no daemon mode for docker</span><br></pre></td></tr></table></figure>\n<ol start=\"6\">\n<li>docker build -t repo[:tag] . </li>\n</ol>\n<p>可以指定repo和可选的tag<br>如果注意，会看到 docker build 命令最后有一个 .。. 表示当前目录<br>copy命令只有在当前上下文有有效</p>\n<ol start=\"7\">\n<li>从container中导出<br>导出(Export)<br>Export命令用于持久化容器（不是镜像）<br>接着执行导出：<br>sudo docker export <container id=\"\"> &gt; /home/export.tar</container></li>\n</ol>\n<p>导出后，可以通过docker import   导入，如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat busy.tar | sudo docker import - busy:v1.0</span><br></pre></td></tr></table></figure>\n<ol start=\"8\">\n<li>保存镜像<br>sudo docker save busybox-1 &gt; /home/save.tar</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以使用 docker import 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</span><br></pre></td></tr></table></figure>\n<ol start=\"9\">\n<li>docker 自启动配置</li>\n</ol>\n<p>自动启动container 如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -ti --restart=on-failure:3   </span><br><span class=\"line\">失败后会启动三次</span><br></pre></td></tr></table></figure>\n<ol start=\"10\">\n<li>用非root用户操作docker<br>下面是使用非root用户操作的步骤</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">创建docker组</span><br><span class=\"line\">sudo groupadd docker</span><br><span class=\"line\">将当前用户加入docker组</span><br><span class=\"line\">sudo gpasswd -a $&#123;USER&#125; docker</span><br><span class=\"line\">重新启动docker服务（下面是CentOS7的命令）</span><br><span class=\"line\">sudo systemctl restart docker</span><br><span class=\"line\">当前用户退出系统重新登陆</span><br><span class=\"line\">运行docker命令</span><br><span class=\"line\">docker ps</span><br></pre></td></tr></table></figure>\n<p>11.用docker 启动zookeeper </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ps -aux | grep docker</span><br><span class=\"line\">docker run  --name alizookeeper --restart always -d -P zookeeper</span><br></pre></td></tr></table></figure>\n"},{"title":"encoding","date":"2019-11-08T06:11:43.000Z","_content":"1. charCodeAt() 返回表示给定索引的字符的Unicode的值。 codePointAt() 返回使用UTF-16编码的给定位置的值的非负整数。\n1. Transfer-Encoding   数据以一系列分块的形式进行发送。 Content-Length 首部在这种情况下不被发送。。在每一个分块的开头需要添加当前分块的长度，以十六进制的形式表示，后面紧跟着 '\\r\\n' ，之后是分块本身，后面也是'\\r\\n' 。终止块是一个常规的分块，不同之处在于其长度为0。终止块后面是一个挂载（trailer），由一系列（或者为空）的实体消息首部构成。\n1. ascii 第一个bit为0，也就是当第一个bit是0时仍表示之前那些常用的字符.当为1时就表示其他补充的字符，例如西欧国家的文字。\n1. utf-8  Refer:https://segmentfault.com/a/1190000014324711\n```text\n0xxxxxxx,如果是这样的01串,也就是以0开头后面是啥就不用管了XX代表任意bit.就表示把一个字节做为一个单元.就跟ASCII完全一样.\n   110xxxxx 10xxxxxx.如果是这样的格式,则把两个字节当一个单元\n   \n   1110xxxx 10xxxxxx 10xxxxxx 如果是这种格式则是三个字节当一个单元\n```   \n\n1. ","source":"_posts/encoding.md","raw":"---\ntitle: encoding\ndate: 2019-11-08 14:11:43\ntags:\n---\n1. charCodeAt() 返回表示给定索引的字符的Unicode的值。 codePointAt() 返回使用UTF-16编码的给定位置的值的非负整数。\n1. Transfer-Encoding   数据以一系列分块的形式进行发送。 Content-Length 首部在这种情况下不被发送。。在每一个分块的开头需要添加当前分块的长度，以十六进制的形式表示，后面紧跟着 '\\r\\n' ，之后是分块本身，后面也是'\\r\\n' 。终止块是一个常规的分块，不同之处在于其长度为0。终止块后面是一个挂载（trailer），由一系列（或者为空）的实体消息首部构成。\n1. ascii 第一个bit为0，也就是当第一个bit是0时仍表示之前那些常用的字符.当为1时就表示其他补充的字符，例如西欧国家的文字。\n1. utf-8  Refer:https://segmentfault.com/a/1190000014324711\n```text\n0xxxxxxx,如果是这样的01串,也就是以0开头后面是啥就不用管了XX代表任意bit.就表示把一个字节做为一个单元.就跟ASCII完全一样.\n   110xxxxx 10xxxxxx.如果是这样的格式,则把两个字节当一个单元\n   \n   1110xxxx 10xxxxxx 10xxxxxx 如果是这种格式则是三个字节当一个单元\n```   \n\n1. ","slug":"encoding","published":1,"updated":"2019-11-08T06:14:35.771Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5bwexcj0006998swacponsd","content":"<ol>\n<li>charCodeAt() 返回表示给定索引的字符的Unicode的值。 codePointAt() 返回使用UTF-16编码的给定位置的值的非负整数。</li>\n<li>Transfer-Encoding   数据以一系列分块的形式进行发送。 Content-Length 首部在这种情况下不被发送。。在每一个分块的开头需要添加当前分块的长度，以十六进制的形式表示，后面紧跟着 ‘\\r\\n’ ，之后是分块本身，后面也是’\\r\\n’ 。终止块是一个常规的分块，不同之处在于其长度为0。终止块后面是一个挂载（trailer），由一系列（或者为空）的实体消息首部构成。</li>\n<li>ascii 第一个bit为0，也就是当第一个bit是0时仍表示之前那些常用的字符.当为1时就表示其他补充的字符，例如西欧国家的文字。</li>\n<li><p>utf-8  Refer:<a href=\"https://segmentfault.com/a/1190000014324711\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000014324711</a></p>\n<pre><code class=\"text\">0xxxxxxx,如果是这样的01串,也就是以0开头后面是啥就不用管了XX代表任意bit.就表示把一个字节做为一个单元.就跟ASCII完全一样.\n110xxxxx 10xxxxxx.如果是这样的格式,则把两个字节当一个单元\n\n1110xxxx 10xxxxxx 10xxxxxx 如果是这种格式则是三个字节当一个单元\n</code></pre>\n</li>\n<li></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>charCodeAt() 返回表示给定索引的字符的Unicode的值。 codePointAt() 返回使用UTF-16编码的给定位置的值的非负整数。</li>\n<li>Transfer-Encoding   数据以一系列分块的形式进行发送。 Content-Length 首部在这种情况下不被发送。。在每一个分块的开头需要添加当前分块的长度，以十六进制的形式表示，后面紧跟着 ‘\\r\\n’ ，之后是分块本身，后面也是’\\r\\n’ 。终止块是一个常规的分块，不同之处在于其长度为0。终止块后面是一个挂载（trailer），由一系列（或者为空）的实体消息首部构成。</li>\n<li>ascii 第一个bit为0，也就是当第一个bit是0时仍表示之前那些常用的字符.当为1时就表示其他补充的字符，例如西欧国家的文字。</li>\n<li><p>utf-8  Refer:<a href=\"https://segmentfault.com/a/1190000014324711\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000014324711</a></p>\n<pre><code class=\"text\">0xxxxxxx,如果是这样的01串,也就是以0开头后面是啥就不用管了XX代表任意bit.就表示把一个字节做为一个单元.就跟ASCII完全一样.\n110xxxxx 10xxxxxx.如果是这样的格式,则把两个字节当一个单元\n\n1110xxxx 10xxxxxx 10xxxxxx 如果是这种格式则是三个字节当一个单元\n</code></pre>\n</li>\n<li></li>\n</ol>\n"},{"title":"es6","date":"2019-06-28T03:58:20.000Z","_content":"### reflect \n1. 修改某些Object方法的返回结果，让其变得更合理\n```javascript\n// 老写法\ntry {\n  Object.defineProperty(target, property, attributes);\n  // success\n} catch (e) {\n  // failure\n}\n\n// 新写法\nif (Reflect.defineProperty(target, property, attributes)) {\n  // success\n} else {\n  // failure\n}\n```\n\n1. 命令式改为函数式\n```javascript\n// 老写法\n'assign' in Object // true\n\n// 新写法\nReflect.has(Object, 'assign') // true\n```\n\n1. Reflect对象的方法与Proxy对象的方法一一对应\n```javascript\nProxy(target, {\n  set: function(target, name, value, receiver) {\n    var success = Reflect.set(target, name, value, receiver);\n    if (success) {\n      console.log('property ' + name + ' on ' + target + ' set to ' + value);\n    }\n    return success;\n  }\n});\n```\n####async 函数是什么？一句话，它就是 Generator 函数的语法糖。\n```javascript\nconst fs = require('fs');\n\nconst readFile = function (fileName) {\n  return new Promise(function (resolve, reject) {\n    fs.readFile(fileName, function(error, data) {\n      if (error) return reject(error);\n      resolve(data);\n    });\n  });\n};\n\nconst gen = function* () {\n  const f1 = yield readFile('/etc/fstab');\n  const f2 = yield readFile('/etc/shells');\n  console.log(f1.toString());\n  console.log(f2.toString());\n};\n```\n### module \n1. CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。\n```javascript\n\nvar counter = 3;\nfunction incCounter() {\n  counter++;\n}\nmodule.exports = {\n  counter: counter,\n  incCounter: incCounter,\n};\n\n// main.js\nvar mod = require('./lib');\n\nconsole.log(mod.counter);  // 3\nmod.incCounter();\nconsole.log(mod.counter); // 3\n```\n可以使用Es6 加载commonjs 模块。 CommonJS 模块的输出缓存机制，在 ES6 加载方式下依然有效。\n\n\nCommonJS 模块加载 ES6 模块，不能使用require命令，而要使用import()函数。\n\n```javascript\n// es.mjs\nlet foo = { bar: 'my-default' };\nexport default foo;\n\n// cjs.js\nconst es_namespace = await import('./es.mjs');\n// es_namespace = {\n//   get default() {\n//     ...\n//   }\n// }\nconsole.log(es_namespace.default);\n// { bar:'my-default' }\n```\n\n### lit\n1. 数组的空位 [,,,]\n\n1. parentheses to be omitted, as in\n\ntry {\n  // ...\n} catch {\n  // ...\n}\n\n### generator\n1. Generator  yield表达式后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。\n  yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。\n\n1. Co 模块相关于一个generator 的执行器。co 模块其实就是将两种自动执行器（Thunk 函数和 Promise 对象），包装成一个模块。使用 co 的前提条件是，Generator 函数的yield命令后面，只能是 Thunk 函数或 Promise 对象。\n1. 代码中，虽然map方法的参数是async函数，但它是并发执行的，因为只有async函数内部是继发执行，外部不受影响。后面的for..of循环内部使用了await，因此实现了按顺序输出\n```javascript\nasync function logInOrder(urls) {\n  // 并发读取远程URL\n  const textPromises = urls.map(async url => {\n    const response = await fetch(url);\n    return response.text();\n  });\n\n  // 按次序输出\n  for (const textPromise of textPromises) {\n    console.log(await textPromise);\n  }\n}\n```\n1. 对象的Symbol.iterator\n  \n  由于 Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的Symbol.iterator属性，从而使得该对象具有 Iterator 接口。\n```javascript\nvar myIterable = {};\nmyIterable[Symbol.iterator] = function* () {\n  yield 1;\n  yield 2;\n  yield 3;\n};\n\n[...myIterable]\n\n```\n   Iterator 接口和generator 函数：\n   ```javascript\nlet obj = {\n  * [Symbol.iterator]() {\n    yield 'hello';\n    yield 'world';\n  }\n};\n```\n\n1. 只要 Generator 函数内部部署了try...catch代码块，那么遍历器的throw方法抛出的错误，不影响下一次遍历。\n   \n   Gnerator 嵌套：\n   \n```javascript\nfunction* inner() {\n       yield 'hello!';\n   }\n   \n   function* outer1() {\n       yield 'open';\n       yield *inner();\n       yield 'close';\n   }\n```\n1. 异步的同步表达：\n    \n```javascript\n   function* main() {\n     var result = yield request(\"http://some.url\");\n     var resp = JSON.parse(result);\n       console.log(resp.value);\n   }\n   \n   function request(url) {\n     makeAjaxCall(url, function(response){\n       it.next(response);\n     });\n   }\n   \n   var it = main();\n   it.next();\n   \n```\n\n### proxy\n\n1. Proxy 的 construct 用于拦截 new()\n   isExtensible方法拦截Object.isExtensible操作。\n   ownKeys方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作。\n   \n   Object.getOwnPropertyNames()\n   Object.getOwnPropertySymbols()\n   Object.keys()\n   for...in循环\n```javascript\nvar obj = new Proxy({}, {\n     get: function (target, key, receiver) {\n       console.log(`getting ${key}!`);\n       return Reflect.get(target, key, receiver);\n     },\n     set: function (target, key, value, receiver) {\n       console.log(`setting ${key}!`);\n       return Reflect.set(target, key, value, receiver);\n     }\n   });\n```\n\n1. Class 的generator :\n```javascript\nclass Foo {\n     constructor(...args) {\n       this.args = args;\n     }\n     * [Symbol.iterator]() {\n       for (let arg of this.args) {\n         yield arg;\n       }\n     }\n   }\n\n```\n1. 绑定上下文\n\n```javascript\nfunction selfish (target) {\n  const cache = new WeakMap();\n  const handler = {\n    get (target, key) {\n      const value = Reflect.get(target, key);\n      if (typeof value !== 'function') {\n        return value;\n      }\n      if (!cache.has(value)) {\n        cache.set(value, value.bind(target));\n      }\n      return cache.get(value);\n    }\n  };\n  const proxy = new Proxy(target, handler);\n  return proxy;\n}\n\nconst logger = selfish(new Logger());\n```   \n\n#### 类型转换 \n1. 转换为数字\n```javascript\nlet int = \"15\";\nint = +int;\nconsole.log(int); // Result: 15\nconsole.log(typeof int); Result: \"number\"\n\n//这也可以用于将布尔值转换为数字，如下所示\n console.log(+true);  // Return: 1\n console.log(+false); // Return: 0\n\n```\n#### console \n```javascript\n\nconsole.table()\nconsole.dir()\nconsole.count()\nConsole.time() \nconsoel.timeLog()\n console.time(\"answer time\");\nalert(\"Click to continue\");\nconsole.timeEnd(\"answer time”);\n\n```\n\n#### 对象的结构 \n1. 对象的解构：let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };\n```javascript\nlet obj = {   p: [     'Hello',     { y: 'World' }   ] }; \nlet { p: [x, { y }] } = obj; x // \"Hello\"\n```\n\n2. 展开运算符的妙用 \n```javascript\n\n//需要根据一个条件创建两个不同的对象，可以使用展开运算符号来处理。\n\nconst getUser = (emailIncluded) => {\n  return {\n    name: 'John',\n    surname: 'Doe',\n    ...emailIncluded && { email : 'john@doe.com' }\n  }\n}\n\n```\n####\n","source":"_posts/es6.md","raw":"---\ntitle: es6\ndate: 2019-06-28 11:58:20\ntags: es\n---\n### reflect \n1. 修改某些Object方法的返回结果，让其变得更合理\n```javascript\n// 老写法\ntry {\n  Object.defineProperty(target, property, attributes);\n  // success\n} catch (e) {\n  // failure\n}\n\n// 新写法\nif (Reflect.defineProperty(target, property, attributes)) {\n  // success\n} else {\n  // failure\n}\n```\n\n1. 命令式改为函数式\n```javascript\n// 老写法\n'assign' in Object // true\n\n// 新写法\nReflect.has(Object, 'assign') // true\n```\n\n1. Reflect对象的方法与Proxy对象的方法一一对应\n```javascript\nProxy(target, {\n  set: function(target, name, value, receiver) {\n    var success = Reflect.set(target, name, value, receiver);\n    if (success) {\n      console.log('property ' + name + ' on ' + target + ' set to ' + value);\n    }\n    return success;\n  }\n});\n```\n####async 函数是什么？一句话，它就是 Generator 函数的语法糖。\n```javascript\nconst fs = require('fs');\n\nconst readFile = function (fileName) {\n  return new Promise(function (resolve, reject) {\n    fs.readFile(fileName, function(error, data) {\n      if (error) return reject(error);\n      resolve(data);\n    });\n  });\n};\n\nconst gen = function* () {\n  const f1 = yield readFile('/etc/fstab');\n  const f2 = yield readFile('/etc/shells');\n  console.log(f1.toString());\n  console.log(f2.toString());\n};\n```\n### module \n1. CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。\n```javascript\n\nvar counter = 3;\nfunction incCounter() {\n  counter++;\n}\nmodule.exports = {\n  counter: counter,\n  incCounter: incCounter,\n};\n\n// main.js\nvar mod = require('./lib');\n\nconsole.log(mod.counter);  // 3\nmod.incCounter();\nconsole.log(mod.counter); // 3\n```\n可以使用Es6 加载commonjs 模块。 CommonJS 模块的输出缓存机制，在 ES6 加载方式下依然有效。\n\n\nCommonJS 模块加载 ES6 模块，不能使用require命令，而要使用import()函数。\n\n```javascript\n// es.mjs\nlet foo = { bar: 'my-default' };\nexport default foo;\n\n// cjs.js\nconst es_namespace = await import('./es.mjs');\n// es_namespace = {\n//   get default() {\n//     ...\n//   }\n// }\nconsole.log(es_namespace.default);\n// { bar:'my-default' }\n```\n\n### lit\n1. 数组的空位 [,,,]\n\n1. parentheses to be omitted, as in\n\ntry {\n  // ...\n} catch {\n  // ...\n}\n\n### generator\n1. Generator  yield表达式后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。\n  yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。\n\n1. Co 模块相关于一个generator 的执行器。co 模块其实就是将两种自动执行器（Thunk 函数和 Promise 对象），包装成一个模块。使用 co 的前提条件是，Generator 函数的yield命令后面，只能是 Thunk 函数或 Promise 对象。\n1. 代码中，虽然map方法的参数是async函数，但它是并发执行的，因为只有async函数内部是继发执行，外部不受影响。后面的for..of循环内部使用了await，因此实现了按顺序输出\n```javascript\nasync function logInOrder(urls) {\n  // 并发读取远程URL\n  const textPromises = urls.map(async url => {\n    const response = await fetch(url);\n    return response.text();\n  });\n\n  // 按次序输出\n  for (const textPromise of textPromises) {\n    console.log(await textPromise);\n  }\n}\n```\n1. 对象的Symbol.iterator\n  \n  由于 Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的Symbol.iterator属性，从而使得该对象具有 Iterator 接口。\n```javascript\nvar myIterable = {};\nmyIterable[Symbol.iterator] = function* () {\n  yield 1;\n  yield 2;\n  yield 3;\n};\n\n[...myIterable]\n\n```\n   Iterator 接口和generator 函数：\n   ```javascript\nlet obj = {\n  * [Symbol.iterator]() {\n    yield 'hello';\n    yield 'world';\n  }\n};\n```\n\n1. 只要 Generator 函数内部部署了try...catch代码块，那么遍历器的throw方法抛出的错误，不影响下一次遍历。\n   \n   Gnerator 嵌套：\n   \n```javascript\nfunction* inner() {\n       yield 'hello!';\n   }\n   \n   function* outer1() {\n       yield 'open';\n       yield *inner();\n       yield 'close';\n   }\n```\n1. 异步的同步表达：\n    \n```javascript\n   function* main() {\n     var result = yield request(\"http://some.url\");\n     var resp = JSON.parse(result);\n       console.log(resp.value);\n   }\n   \n   function request(url) {\n     makeAjaxCall(url, function(response){\n       it.next(response);\n     });\n   }\n   \n   var it = main();\n   it.next();\n   \n```\n\n### proxy\n\n1. Proxy 的 construct 用于拦截 new()\n   isExtensible方法拦截Object.isExtensible操作。\n   ownKeys方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作。\n   \n   Object.getOwnPropertyNames()\n   Object.getOwnPropertySymbols()\n   Object.keys()\n   for...in循环\n```javascript\nvar obj = new Proxy({}, {\n     get: function (target, key, receiver) {\n       console.log(`getting ${key}!`);\n       return Reflect.get(target, key, receiver);\n     },\n     set: function (target, key, value, receiver) {\n       console.log(`setting ${key}!`);\n       return Reflect.set(target, key, value, receiver);\n     }\n   });\n```\n\n1. Class 的generator :\n```javascript\nclass Foo {\n     constructor(...args) {\n       this.args = args;\n     }\n     * [Symbol.iterator]() {\n       for (let arg of this.args) {\n         yield arg;\n       }\n     }\n   }\n\n```\n1. 绑定上下文\n\n```javascript\nfunction selfish (target) {\n  const cache = new WeakMap();\n  const handler = {\n    get (target, key) {\n      const value = Reflect.get(target, key);\n      if (typeof value !== 'function') {\n        return value;\n      }\n      if (!cache.has(value)) {\n        cache.set(value, value.bind(target));\n      }\n      return cache.get(value);\n    }\n  };\n  const proxy = new Proxy(target, handler);\n  return proxy;\n}\n\nconst logger = selfish(new Logger());\n```   \n\n#### 类型转换 \n1. 转换为数字\n```javascript\nlet int = \"15\";\nint = +int;\nconsole.log(int); // Result: 15\nconsole.log(typeof int); Result: \"number\"\n\n//这也可以用于将布尔值转换为数字，如下所示\n console.log(+true);  // Return: 1\n console.log(+false); // Return: 0\n\n```\n#### console \n```javascript\n\nconsole.table()\nconsole.dir()\nconsole.count()\nConsole.time() \nconsoel.timeLog()\n console.time(\"answer time\");\nalert(\"Click to continue\");\nconsole.timeEnd(\"answer time”);\n\n```\n\n#### 对象的结构 \n1. 对象的解构：let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };\n```javascript\nlet obj = {   p: [     'Hello',     { y: 'World' }   ] }; \nlet { p: [x, { y }] } = obj; x // \"Hello\"\n```\n\n2. 展开运算符的妙用 \n```javascript\n\n//需要根据一个条件创建两个不同的对象，可以使用展开运算符号来处理。\n\nconst getUser = (emailIncluded) => {\n  return {\n    name: 'John',\n    surname: 'Doe',\n    ...emailIncluded && { email : 'john@doe.com' }\n  }\n}\n\n```\n####\n","slug":"es6","published":1,"updated":"2019-07-26T08:35:17.301Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5bwexck0009998s2ca5h83a","content":"<h3 id=\"reflect\"><a href=\"#reflect\" class=\"headerlink\" title=\"reflect\"></a>reflect</h3><ol>\n<li><p>修改某些Object方法的返回结果，让其变得更合理</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 老写法</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.defineProperty(target, property, attributes);</span><br><span class=\"line\">  <span class=\"comment\">// success</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// failure</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 新写法</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">Reflect</span>.defineProperty(target, property, attributes)) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// success</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// failure</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>命令式改为函数式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 老写法</span></span><br><span class=\"line\"><span class=\"string\">'assign'</span> <span class=\"keyword\">in</span> <span class=\"built_in\">Object</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 新写法</span></span><br><span class=\"line\"><span class=\"built_in\">Reflect</span>.has(<span class=\"built_in\">Object</span>, <span class=\"string\">'assign'</span>) <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Reflect对象的方法与Proxy对象的方法一一对应</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Proxy</span>(target, &#123;</span><br><span class=\"line\">  <span class=\"keyword\">set</span>: function(target, name, value, receiver) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> success = <span class=\"built_in\">Reflect</span>.set(target, name, value, receiver);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (success) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'property '</span> + name + <span class=\"string\">' on '</span> + target + <span class=\"string\">' set to '</span> + value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> success;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>####async 函数是什么？一句话，它就是 Generator 函数的语法糖。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> readFile = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fileName</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    fs.readFile(fileName, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error, data</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (error) <span class=\"keyword\">return</span> reject(error);</span><br><span class=\"line\">      resolve(data);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> gen = <span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> f1 = <span class=\"keyword\">yield</span> readFile(<span class=\"string\">'/etc/fstab'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> f2 = <span class=\"keyword\">yield</span> readFile(<span class=\"string\">'/etc/shells'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(f1.toString());</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(f2.toString());</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"module\"><a href=\"#module\" class=\"headerlink\" title=\"module\"></a>module</h3><ol>\n<li>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> counter = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">incCounter</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  counter++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  counter: counter,</span><br><span class=\"line\">  incCounter: incCounter,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// main.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> mod = <span class=\"built_in\">require</span>(<span class=\"string\">'./lib'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(mod.counter);  <span class=\"comment\">// 3</span></span><br><span class=\"line\">mod.incCounter();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(mod.counter); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>可以使用Es6 加载commonjs 模块。 CommonJS 模块的输出缓存机制，在 ES6 加载方式下依然有效。</p>\n<p>CommonJS 模块加载 ES6 模块，不能使用require命令，而要使用import()函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// es.mjs</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> foo = &#123; <span class=\"attr\">bar</span>: <span class=\"string\">'my-default'</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> foo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// cjs.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> es_namespace = <span class=\"keyword\">await</span> <span class=\"keyword\">import</span>(<span class=\"string\">'./es.mjs'</span>);</span><br><span class=\"line\"><span class=\"comment\">// es_namespace = &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   get default() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     ...</span></span><br><span class=\"line\"><span class=\"comment\">//   &#125;</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(es_namespace.default);</span><br><span class=\"line\"><span class=\"comment\">// &#123; bar:'my-default' &#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"lit\"><a href=\"#lit\" class=\"headerlink\" title=\"lit\"></a>lit</h3><ol>\n<li><p>数组的空位 [,,,]</p>\n</li>\n<li><p>parentheses to be omitted, as in</p>\n</li>\n</ol>\n<p>try {<br>  // …<br>} catch {<br>  // …<br>}</p>\n<h3 id=\"generator\"><a href=\"#generator\" class=\"headerlink\" title=\"generator\"></a>generator</h3><ol>\n<li><p>Generator  yield表达式后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。<br>yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。</p>\n</li>\n<li><p>Co 模块相关于一个generator 的执行器。co 模块其实就是将两种自动执行器（Thunk 函数和 Promise 对象），包装成一个模块。使用 co 的前提条件是，Generator 函数的yield命令后面，只能是 Thunk 函数或 Promise 对象。</p>\n</li>\n<li><p>代码中，虽然map方法的参数是async函数，但它是并发执行的，因为只有async函数内部是继发执行，外部不受影响。后面的for..of循环内部使用了await，因此实现了按顺序输出</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">logInOrder</span>(<span class=\"params\">urls</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 并发读取远程URL</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> textPromises = urls.map(<span class=\"keyword\">async</span> url =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> response = <span class=\"keyword\">await</span> fetch(url);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> response.text();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 按次序输出</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> textPromise <span class=\"keyword\">of</span> textPromises) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">await</span> textPromise);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>对象的Symbol.iterator</p>\n<p>由于 Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的Symbol.iterator属性，从而使得该对象具有 Iterator 接口。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myIterable = &#123;&#125;;</span><br><span class=\"line\">myIterable[<span class=\"built_in\">Symbol</span>.iterator] = <span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">[...myIterable]</span><br></pre></td></tr></table></figure>\n<p>Iterator 接口和generator 函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">  * [<span class=\"built_in\">Symbol</span>.iterator]() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"string\">'hello'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"string\">'world'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>只要 Generator 函数内部部署了try…catch代码块，那么遍历器的throw方法抛出的错误，不影响下一次遍历。</p>\n<p>Gnerator 嵌套：</p>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">inner</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">yield</span> <span class=\"string\">'hello!'</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">outer1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">yield</span> <span class=\"string\">'open'</span>;</span><br><span class=\"line\">       <span class=\"keyword\">yield</span> *inner();</span><br><span class=\"line\">       <span class=\"keyword\">yield</span> <span class=\"string\">'close'</span>;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>异步的同步表达：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">main</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = <span class=\"keyword\">yield</span> request(<span class=\"string\">\"http://some.url\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> resp = <span class=\"built_in\">JSON</span>.parse(result);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(resp.value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">request</span>(<span class=\"params\">url</span>) </span>&#123;</span><br><span class=\"line\">  makeAjaxCall(url, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">response</span>)</span>&#123;</span><br><span class=\"line\">    it.next(response);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> it = main();</span><br><span class=\"line\">it.next();</span><br></pre></td></tr></table></figure>\n<h3 id=\"proxy\"><a href=\"#proxy\" class=\"headerlink\" title=\"proxy\"></a>proxy</h3><ol>\n<li><p>Proxy 的 construct 用于拦截 new()<br>isExtensible方法拦截Object.isExtensible操作。<br>ownKeys方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作。</p>\n<p>Object.getOwnPropertyNames()<br>Object.getOwnPropertySymbols()<br>Object.keys()<br>for…in循环</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(&#123;&#125;, &#123;</span><br><span class=\"line\">     <span class=\"keyword\">get</span>: function (target, key, receiver) &#123;</span><br><span class=\"line\">       <span class=\"built_in\">console</span>.log(<span class=\"string\">`getting <span class=\"subst\">$&#123;key&#125;</span>!`</span>);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.get(target, key, receiver);</span><br><span class=\"line\">     &#125;,</span><br><span class=\"line\">     <span class=\"keyword\">set</span>: function (target, key, value, receiver) &#123;</span><br><span class=\"line\">       <span class=\"built_in\">console</span>.log(<span class=\"string\">`setting <span class=\"subst\">$&#123;key&#125;</span>!`</span>);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.set(target, key, value, receiver);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Class 的generator :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">constructor</span>(...args) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">this</span>.args = args;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     * [<span class=\"built_in\">Symbol</span>.iterator]() &#123;</span><br><span class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> arg <span class=\"keyword\">of</span> <span class=\"keyword\">this</span>.args) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">yield</span> arg;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>绑定上下文</p>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">selfish</span> (<span class=\"params\">target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> cache = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> handler = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span> (target, key) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> value = <span class=\"built_in\">Reflect</span>.get(target, key);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> value !== <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!cache.has(value)) &#123;</span><br><span class=\"line\">        cache.set(value, value.bind(target));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> cache.get(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> proxy = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target, handler);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> proxy;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> logger = selfish(<span class=\"keyword\">new</span> Logger());</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`   </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">#### 类型转换 </span></span><br><span class=\"line\"><span class=\"string\">1. 转换为数字</span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>javascript</span><br><span class=\"line\"><span class=\"keyword\">let</span> int = <span class=\"string\">\"15\"</span>;</span><br><span class=\"line\">int = +int;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(int); <span class=\"comment\">// Result: 15</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> int); Result: <span class=\"string\">\"number\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这也可以用于将布尔值转换为数字，如下所示</span></span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(+<span class=\"literal\">true</span>);  <span class=\"comment\">// Return: 1</span></span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(+<span class=\"literal\">false</span>); <span class=\"comment\">// Return: 0</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"console\"><a href=\"#console\" class=\"headerlink\" title=\"console\"></a>console</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.table()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.dir()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.count()</span><br><span class=\"line\">Console.time() </span><br><span class=\"line\">consoel.timeLog()</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.time(<span class=\"string\">\"answer time\"</span>);</span><br><span class=\"line\">alert(<span class=\"string\">\"Click to continue\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">\"answer time”);</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"对象的结构\"><a href=\"#对象的结构\" class=\"headerlink\" title=\"对象的结构\"></a>对象的结构</h4><ol>\n<li><p>对象的解构：let { x, y, …z } = { x: 1, y: 2, a: 3, b: 4 };</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;   <span class=\"attr\">p</span>: [     <span class=\"string\">'Hello'</span>,     &#123; <span class=\"attr\">y</span>: <span class=\"string\">'World'</span> &#125;   ] &#125;; </span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; <span class=\"attr\">p</span>: [x, &#123; y &#125;] &#125; = obj; x <span class=\"comment\">// \"Hello\"</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>展开运算符的妙用 </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//需要根据一个条件创建两个不同的对象，可以使用展开运算符号来处理。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> getUser = <span class=\"function\">(<span class=\"params\">emailIncluded</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'John'</span>,</span><br><span class=\"line\">    surname: <span class=\"string\">'Doe'</span>,</span><br><span class=\"line\">    ...emailIncluded &amp;&amp; &#123; <span class=\"attr\">email</span> : <span class=\"string\">'john@doe.com'</span> &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>####</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"reflect\"><a href=\"#reflect\" class=\"headerlink\" title=\"reflect\"></a>reflect</h3><ol>\n<li><p>修改某些Object方法的返回结果，让其变得更合理</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 老写法</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.defineProperty(target, property, attributes);</span><br><span class=\"line\">  <span class=\"comment\">// success</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// failure</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 新写法</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">Reflect</span>.defineProperty(target, property, attributes)) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// success</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// failure</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>命令式改为函数式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 老写法</span></span><br><span class=\"line\"><span class=\"string\">'assign'</span> <span class=\"keyword\">in</span> <span class=\"built_in\">Object</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 新写法</span></span><br><span class=\"line\"><span class=\"built_in\">Reflect</span>.has(<span class=\"built_in\">Object</span>, <span class=\"string\">'assign'</span>) <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Reflect对象的方法与Proxy对象的方法一一对应</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Proxy</span>(target, &#123;</span><br><span class=\"line\">  <span class=\"keyword\">set</span>: function(target, name, value, receiver) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> success = <span class=\"built_in\">Reflect</span>.set(target, name, value, receiver);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (success) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'property '</span> + name + <span class=\"string\">' on '</span> + target + <span class=\"string\">' set to '</span> + value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> success;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>####async 函数是什么？一句话，它就是 Generator 函数的语法糖。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> readFile = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fileName</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    fs.readFile(fileName, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error, data</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (error) <span class=\"keyword\">return</span> reject(error);</span><br><span class=\"line\">      resolve(data);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> gen = <span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> f1 = <span class=\"keyword\">yield</span> readFile(<span class=\"string\">'/etc/fstab'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> f2 = <span class=\"keyword\">yield</span> readFile(<span class=\"string\">'/etc/shells'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(f1.toString());</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(f2.toString());</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"module\"><a href=\"#module\" class=\"headerlink\" title=\"module\"></a>module</h3><ol>\n<li>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> counter = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">incCounter</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  counter++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  counter: counter,</span><br><span class=\"line\">  incCounter: incCounter,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// main.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> mod = <span class=\"built_in\">require</span>(<span class=\"string\">'./lib'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(mod.counter);  <span class=\"comment\">// 3</span></span><br><span class=\"line\">mod.incCounter();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(mod.counter); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>可以使用Es6 加载commonjs 模块。 CommonJS 模块的输出缓存机制，在 ES6 加载方式下依然有效。</p>\n<p>CommonJS 模块加载 ES6 模块，不能使用require命令，而要使用import()函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// es.mjs</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> foo = &#123; <span class=\"attr\">bar</span>: <span class=\"string\">'my-default'</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> foo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// cjs.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> es_namespace = <span class=\"keyword\">await</span> <span class=\"keyword\">import</span>(<span class=\"string\">'./es.mjs'</span>);</span><br><span class=\"line\"><span class=\"comment\">// es_namespace = &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   get default() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     ...</span></span><br><span class=\"line\"><span class=\"comment\">//   &#125;</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(es_namespace.default);</span><br><span class=\"line\"><span class=\"comment\">// &#123; bar:'my-default' &#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"lit\"><a href=\"#lit\" class=\"headerlink\" title=\"lit\"></a>lit</h3><ol>\n<li><p>数组的空位 [,,,]</p>\n</li>\n<li><p>parentheses to be omitted, as in</p>\n</li>\n</ol>\n<p>try {<br>  // …<br>} catch {<br>  // …<br>}</p>\n<h3 id=\"generator\"><a href=\"#generator\" class=\"headerlink\" title=\"generator\"></a>generator</h3><ol>\n<li><p>Generator  yield表达式后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。<br>yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。</p>\n</li>\n<li><p>Co 模块相关于一个generator 的执行器。co 模块其实就是将两种自动执行器（Thunk 函数和 Promise 对象），包装成一个模块。使用 co 的前提条件是，Generator 函数的yield命令后面，只能是 Thunk 函数或 Promise 对象。</p>\n</li>\n<li><p>代码中，虽然map方法的参数是async函数，但它是并发执行的，因为只有async函数内部是继发执行，外部不受影响。后面的for..of循环内部使用了await，因此实现了按顺序输出</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">logInOrder</span>(<span class=\"params\">urls</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 并发读取远程URL</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> textPromises = urls.map(<span class=\"keyword\">async</span> url =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> response = <span class=\"keyword\">await</span> fetch(url);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> response.text();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 按次序输出</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> textPromise <span class=\"keyword\">of</span> textPromises) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">await</span> textPromise);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>对象的Symbol.iterator</p>\n<p>由于 Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的Symbol.iterator属性，从而使得该对象具有 Iterator 接口。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myIterable = &#123;&#125;;</span><br><span class=\"line\">myIterable[<span class=\"built_in\">Symbol</span>.iterator] = <span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">[...myIterable]</span><br></pre></td></tr></table></figure>\n<p>Iterator 接口和generator 函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">  * [<span class=\"built_in\">Symbol</span>.iterator]() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"string\">'hello'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"string\">'world'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>只要 Generator 函数内部部署了try…catch代码块，那么遍历器的throw方法抛出的错误，不影响下一次遍历。</p>\n<p>Gnerator 嵌套：</p>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">inner</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">yield</span> <span class=\"string\">'hello!'</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">outer1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">yield</span> <span class=\"string\">'open'</span>;</span><br><span class=\"line\">       <span class=\"keyword\">yield</span> *inner();</span><br><span class=\"line\">       <span class=\"keyword\">yield</span> <span class=\"string\">'close'</span>;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>异步的同步表达：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">main</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = <span class=\"keyword\">yield</span> request(<span class=\"string\">\"http://some.url\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> resp = <span class=\"built_in\">JSON</span>.parse(result);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(resp.value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">request</span>(<span class=\"params\">url</span>) </span>&#123;</span><br><span class=\"line\">  makeAjaxCall(url, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">response</span>)</span>&#123;</span><br><span class=\"line\">    it.next(response);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> it = main();</span><br><span class=\"line\">it.next();</span><br></pre></td></tr></table></figure>\n<h3 id=\"proxy\"><a href=\"#proxy\" class=\"headerlink\" title=\"proxy\"></a>proxy</h3><ol>\n<li><p>Proxy 的 construct 用于拦截 new()<br>isExtensible方法拦截Object.isExtensible操作。<br>ownKeys方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作。</p>\n<p>Object.getOwnPropertyNames()<br>Object.getOwnPropertySymbols()<br>Object.keys()<br>for…in循环</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(&#123;&#125;, &#123;</span><br><span class=\"line\">     <span class=\"keyword\">get</span>: function (target, key, receiver) &#123;</span><br><span class=\"line\">       <span class=\"built_in\">console</span>.log(<span class=\"string\">`getting <span class=\"subst\">$&#123;key&#125;</span>!`</span>);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.get(target, key, receiver);</span><br><span class=\"line\">     &#125;,</span><br><span class=\"line\">     <span class=\"keyword\">set</span>: function (target, key, value, receiver) &#123;</span><br><span class=\"line\">       <span class=\"built_in\">console</span>.log(<span class=\"string\">`setting <span class=\"subst\">$&#123;key&#125;</span>!`</span>);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.set(target, key, value, receiver);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Class 的generator :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">constructor</span>(...args) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">this</span>.args = args;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     * [<span class=\"built_in\">Symbol</span>.iterator]() &#123;</span><br><span class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> arg <span class=\"keyword\">of</span> <span class=\"keyword\">this</span>.args) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">yield</span> arg;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>绑定上下文</p>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">selfish</span> (<span class=\"params\">target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> cache = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> handler = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span> (target, key) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> value = <span class=\"built_in\">Reflect</span>.get(target, key);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> value !== <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!cache.has(value)) &#123;</span><br><span class=\"line\">        cache.set(value, value.bind(target));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> cache.get(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> proxy = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target, handler);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> proxy;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> logger = selfish(<span class=\"keyword\">new</span> Logger());</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`   </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">#### 类型转换 </span></span><br><span class=\"line\"><span class=\"string\">1. 转换为数字</span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>javascript</span><br><span class=\"line\"><span class=\"keyword\">let</span> int = <span class=\"string\">\"15\"</span>;</span><br><span class=\"line\">int = +int;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(int); <span class=\"comment\">// Result: 15</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> int); Result: <span class=\"string\">\"number\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这也可以用于将布尔值转换为数字，如下所示</span></span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(+<span class=\"literal\">true</span>);  <span class=\"comment\">// Return: 1</span></span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(+<span class=\"literal\">false</span>); <span class=\"comment\">// Return: 0</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"console\"><a href=\"#console\" class=\"headerlink\" title=\"console\"></a>console</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.table()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.dir()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.count()</span><br><span class=\"line\">Console.time() </span><br><span class=\"line\">consoel.timeLog()</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.time(<span class=\"string\">\"answer time\"</span>);</span><br><span class=\"line\">alert(<span class=\"string\">\"Click to continue\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">\"answer time”);</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"对象的结构\"><a href=\"#对象的结构\" class=\"headerlink\" title=\"对象的结构\"></a>对象的结构</h4><ol>\n<li><p>对象的解构：let { x, y, …z } = { x: 1, y: 2, a: 3, b: 4 };</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;   <span class=\"attr\">p</span>: [     <span class=\"string\">'Hello'</span>,     &#123; <span class=\"attr\">y</span>: <span class=\"string\">'World'</span> &#125;   ] &#125;; </span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; <span class=\"attr\">p</span>: [x, &#123; y &#125;] &#125; = obj; x <span class=\"comment\">// \"Hello\"</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>展开运算符的妙用 </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//需要根据一个条件创建两个不同的对象，可以使用展开运算符号来处理。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> getUser = <span class=\"function\">(<span class=\"params\">emailIncluded</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'John'</span>,</span><br><span class=\"line\">    surname: <span class=\"string\">'Doe'</span>,</span><br><span class=\"line\">    ...emailIncluded &amp;&amp; &#123; <span class=\"attr\">email</span> : <span class=\"string\">'john@doe.com'</span> &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>####</p>\n"},{"title":"eslint","date":"2016-12-25T05:31:39.000Z","_content":"\nESLint 一旦发现配置文件中有 \"root\": true，它就会停止在父级目录中寻找。\n\n```\n\n在整个文件中取消eslint检查：\n\n/* eslint-disable */\n\n// Disables all rules for the rest of the file \nalert(‘foo’);\n\n在整个文件中禁用某一项eslint规则的检查：\n\n/* eslint-disable no-alert */\n\n// Disables no-alert for the rest of the file \nalert(‘foo’);\n\n针对某一行禁用eslint检查：\n\nalert(‘foo’); // eslint-disable-line\n\n// eslint-disable-next-line \nalert(‘foo’);\n\n针对某一行的某一具体规则禁用eslint检查：\n\nalert(‘foo’); // eslint-disable-line no-alert\n\n// eslint-disable-next-line no-alert \nalert(‘foo’);\n\n针对某一行禁用多项具体规则的检查：\n\nalert(‘foo’); // eslint-disable-line no-alert, quotes, semi\n\n// eslint-disable-next-line no-alert, quotes, semi \nalert(‘foo’);\n```\n\n```\n行内配置\n\n\n/*eslint-disable*/ 和 /*eslint-enable*/\n\n/*global*/\n/*eslint*/\n/*eslint-env*/\n\n\n命令行选项：\n\n--global\n--rule\n--env\n\n-c、--config\n\n\n\n项目级配置：\n\n与要检测的文件在同一目录下的 .eslintrc.* 或 package.json 文件\n继续在父级目录寻找 .eslintrc 或 package.json文件，直到根目录（包括根目录）或直到发现一个有\"root\": true的配置。\n如果不是（1）到（3）中的任何一种情况，退回到 ~/.eslintrc 中自定义的默认配置。\n\n```\n\nglob 模式的配置\n```json  \n{\n  \"rules\": {\n    \"quotes\": [ 2, \"double\" ]\n  },\n\n  \"overrides\": [\n    {\n      \"files\": [ \"bin/*.js\", \"lib/*.js\" ],\n      \"excludedFiles\": \"*.test.js\",\n      \"rules\": {\n        \"quotes\": [ 2, \"single\" ]\n      }\n    }\n  ]\n}\n\n```\n\nignore 文件配置：\n\n# Ignore built files except build/index.js\nbuild/*\n!build/index.js\n\n全局变量\n```javascript\n  globals: {\n        MyGlobal: true\n    }\n```\n\n\n ","source":"_posts/eslint.md","raw":"---\ntitle: eslint\ndate: 2016-12-25 13:31:39\ntags: eslint\n---\n\nESLint 一旦发现配置文件中有 \"root\": true，它就会停止在父级目录中寻找。\n\n```\n\n在整个文件中取消eslint检查：\n\n/* eslint-disable */\n\n// Disables all rules for the rest of the file \nalert(‘foo’);\n\n在整个文件中禁用某一项eslint规则的检查：\n\n/* eslint-disable no-alert */\n\n// Disables no-alert for the rest of the file \nalert(‘foo’);\n\n针对某一行禁用eslint检查：\n\nalert(‘foo’); // eslint-disable-line\n\n// eslint-disable-next-line \nalert(‘foo’);\n\n针对某一行的某一具体规则禁用eslint检查：\n\nalert(‘foo’); // eslint-disable-line no-alert\n\n// eslint-disable-next-line no-alert \nalert(‘foo’);\n\n针对某一行禁用多项具体规则的检查：\n\nalert(‘foo’); // eslint-disable-line no-alert, quotes, semi\n\n// eslint-disable-next-line no-alert, quotes, semi \nalert(‘foo’);\n```\n\n```\n行内配置\n\n\n/*eslint-disable*/ 和 /*eslint-enable*/\n\n/*global*/\n/*eslint*/\n/*eslint-env*/\n\n\n命令行选项：\n\n--global\n--rule\n--env\n\n-c、--config\n\n\n\n项目级配置：\n\n与要检测的文件在同一目录下的 .eslintrc.* 或 package.json 文件\n继续在父级目录寻找 .eslintrc 或 package.json文件，直到根目录（包括根目录）或直到发现一个有\"root\": true的配置。\n如果不是（1）到（3）中的任何一种情况，退回到 ~/.eslintrc 中自定义的默认配置。\n\n```\n\nglob 模式的配置\n```json  \n{\n  \"rules\": {\n    \"quotes\": [ 2, \"double\" ]\n  },\n\n  \"overrides\": [\n    {\n      \"files\": [ \"bin/*.js\", \"lib/*.js\" ],\n      \"excludedFiles\": \"*.test.js\",\n      \"rules\": {\n        \"quotes\": [ 2, \"single\" ]\n      }\n    }\n  ]\n}\n\n```\n\nignore 文件配置：\n\n# Ignore built files except build/index.js\nbuild/*\n!build/index.js\n\n全局变量\n```javascript\n  globals: {\n        MyGlobal: true\n    }\n```\n\n\n ","slug":"eslint","published":1,"updated":"2019-07-26T08:35:17.302Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5bwexcl000a998s6k9mm8ca","content":"<p>ESLint 一旦发现配置文件中有 “root”: true，它就会停止在父级目录中寻找。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">在整个文件中取消eslint检查：</span><br><span class=\"line\"></span><br><span class=\"line\">/* eslint-disable */</span><br><span class=\"line\"></span><br><span class=\"line\">// Disables all rules for the rest of the file </span><br><span class=\"line\">alert(‘foo’);</span><br><span class=\"line\"></span><br><span class=\"line\">在整个文件中禁用某一项eslint规则的检查：</span><br><span class=\"line\"></span><br><span class=\"line\">/* eslint-disable no-alert */</span><br><span class=\"line\"></span><br><span class=\"line\">// Disables no-alert for the rest of the file </span><br><span class=\"line\">alert(‘foo’);</span><br><span class=\"line\"></span><br><span class=\"line\">针对某一行禁用eslint检查：</span><br><span class=\"line\"></span><br><span class=\"line\">alert(‘foo’); // eslint-disable-line</span><br><span class=\"line\"></span><br><span class=\"line\">// eslint-disable-next-line </span><br><span class=\"line\">alert(‘foo’);</span><br><span class=\"line\"></span><br><span class=\"line\">针对某一行的某一具体规则禁用eslint检查：</span><br><span class=\"line\"></span><br><span class=\"line\">alert(‘foo’); // eslint-disable-line no-alert</span><br><span class=\"line\"></span><br><span class=\"line\">// eslint-disable-next-line no-alert </span><br><span class=\"line\">alert(‘foo’);</span><br><span class=\"line\"></span><br><span class=\"line\">针对某一行禁用多项具体规则的检查：</span><br><span class=\"line\"></span><br><span class=\"line\">alert(‘foo’); // eslint-disable-line no-alert, quotes, semi</span><br><span class=\"line\"></span><br><span class=\"line\">// eslint-disable-next-line no-alert, quotes, semi </span><br><span class=\"line\">alert(‘foo’);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">行内配置</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">/*eslint-disable*/ 和 /*eslint-enable*/</span><br><span class=\"line\"></span><br><span class=\"line\">/*global*/</span><br><span class=\"line\">/*eslint*/</span><br><span class=\"line\">/*eslint-env*/</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">命令行选项：</span><br><span class=\"line\"></span><br><span class=\"line\">--global</span><br><span class=\"line\">--rule</span><br><span class=\"line\">--env</span><br><span class=\"line\"></span><br><span class=\"line\">-c、--config</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">项目级配置：</span><br><span class=\"line\"></span><br><span class=\"line\">与要检测的文件在同一目录下的 .eslintrc.* 或 package.json 文件</span><br><span class=\"line\">继续在父级目录寻找 .eslintrc 或 package.json文件，直到根目录（包括根目录）或直到发现一个有&quot;root&quot;: true的配置。</span><br><span class=\"line\">如果不是（1）到（3）中的任何一种情况，退回到 ~/.eslintrc 中自定义的默认配置。</span><br></pre></td></tr></table></figure>\n<p>glob 模式的配置<br><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"rules\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"quotes\"</span>: [ <span class=\"number\">2</span>, <span class=\"string\">\"double\"</span> ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">\"overrides\"</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"files\"</span>: [ <span class=\"string\">\"bin/*.js\"</span>, <span class=\"string\">\"lib/*.js\"</span> ],</span><br><span class=\"line\">      <span class=\"attr\">\"excludedFiles\"</span>: <span class=\"string\">\"*.test.js\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"rules\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"quotes\"</span>: [ <span class=\"number\">2</span>, <span class=\"string\">\"single\"</span> ]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>ignore 文件配置：</p>\n<h1 id=\"Ignore-built-files-except-build-index-js\"><a href=\"#Ignore-built-files-except-build-index-js\" class=\"headerlink\" title=\"Ignore built files except build/index.js\"></a>Ignore built files except build/index.js</h1><p>build/*<br>!build/index.js</p>\n<p>全局变量<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">globals: &#123;</span><br><span class=\"line\">      MyGlobal: <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>ESLint 一旦发现配置文件中有 “root”: true，它就会停止在父级目录中寻找。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">在整个文件中取消eslint检查：</span><br><span class=\"line\"></span><br><span class=\"line\">/* eslint-disable */</span><br><span class=\"line\"></span><br><span class=\"line\">// Disables all rules for the rest of the file </span><br><span class=\"line\">alert(‘foo’);</span><br><span class=\"line\"></span><br><span class=\"line\">在整个文件中禁用某一项eslint规则的检查：</span><br><span class=\"line\"></span><br><span class=\"line\">/* eslint-disable no-alert */</span><br><span class=\"line\"></span><br><span class=\"line\">// Disables no-alert for the rest of the file </span><br><span class=\"line\">alert(‘foo’);</span><br><span class=\"line\"></span><br><span class=\"line\">针对某一行禁用eslint检查：</span><br><span class=\"line\"></span><br><span class=\"line\">alert(‘foo’); // eslint-disable-line</span><br><span class=\"line\"></span><br><span class=\"line\">// eslint-disable-next-line </span><br><span class=\"line\">alert(‘foo’);</span><br><span class=\"line\"></span><br><span class=\"line\">针对某一行的某一具体规则禁用eslint检查：</span><br><span class=\"line\"></span><br><span class=\"line\">alert(‘foo’); // eslint-disable-line no-alert</span><br><span class=\"line\"></span><br><span class=\"line\">// eslint-disable-next-line no-alert </span><br><span class=\"line\">alert(‘foo’);</span><br><span class=\"line\"></span><br><span class=\"line\">针对某一行禁用多项具体规则的检查：</span><br><span class=\"line\"></span><br><span class=\"line\">alert(‘foo’); // eslint-disable-line no-alert, quotes, semi</span><br><span class=\"line\"></span><br><span class=\"line\">// eslint-disable-next-line no-alert, quotes, semi </span><br><span class=\"line\">alert(‘foo’);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">行内配置</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">/*eslint-disable*/ 和 /*eslint-enable*/</span><br><span class=\"line\"></span><br><span class=\"line\">/*global*/</span><br><span class=\"line\">/*eslint*/</span><br><span class=\"line\">/*eslint-env*/</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">命令行选项：</span><br><span class=\"line\"></span><br><span class=\"line\">--global</span><br><span class=\"line\">--rule</span><br><span class=\"line\">--env</span><br><span class=\"line\"></span><br><span class=\"line\">-c、--config</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">项目级配置：</span><br><span class=\"line\"></span><br><span class=\"line\">与要检测的文件在同一目录下的 .eslintrc.* 或 package.json 文件</span><br><span class=\"line\">继续在父级目录寻找 .eslintrc 或 package.json文件，直到根目录（包括根目录）或直到发现一个有&quot;root&quot;: true的配置。</span><br><span class=\"line\">如果不是（1）到（3）中的任何一种情况，退回到 ~/.eslintrc 中自定义的默认配置。</span><br></pre></td></tr></table></figure>\n<p>glob 模式的配置<br><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"rules\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"quotes\"</span>: [ <span class=\"number\">2</span>, <span class=\"string\">\"double\"</span> ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">\"overrides\"</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"files\"</span>: [ <span class=\"string\">\"bin/*.js\"</span>, <span class=\"string\">\"lib/*.js\"</span> ],</span><br><span class=\"line\">      <span class=\"attr\">\"excludedFiles\"</span>: <span class=\"string\">\"*.test.js\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"rules\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"quotes\"</span>: [ <span class=\"number\">2</span>, <span class=\"string\">\"single\"</span> ]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>ignore 文件配置：</p>\n<h1 id=\"Ignore-built-files-except-build-index-js\"><a href=\"#Ignore-built-files-except-build-index-js\" class=\"headerlink\" title=\"Ignore built files except build/index.js\"></a>Ignore built files except build/index.js</h1><p>build/*<br>!build/index.js</p>\n<p>全局变量<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">globals: &#123;</span><br><span class=\"line\">      MyGlobal: <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"es8","date":"2019-07-02T03:37:11.000Z","_content":"\n1. Stage 0: strawman——最初想法的提交。\n   Stage 1: proposal（提案）——由TC39至少一名成员倡导的正式提案文件，该文件包括API事例。\n   Stage 2: draft（草案）——功能规范的初始版本，该版本包含功能规范的两个实验实现。\n   Stage 3: candidate（候选）——提案规范通过审查并从厂商那里收集反馈\n   Stage 4: finished（完成）——提案准备加入ECMAScript，但是到浏览器或者Nodejs中可能需要更长的时间\n   \n2. es2018(es9) \n promise.finally  正则表达式匹配组 \n regex 先行断言和反向断言、dotall  \n \n1. Template Literals\n\n1. \n \n","source":"_posts/es8.md","raw":"---\ntitle: es8\ndate: 2019-07-02 11:37:11\ntags: es\n---\n\n1. Stage 0: strawman——最初想法的提交。\n   Stage 1: proposal（提案）——由TC39至少一名成员倡导的正式提案文件，该文件包括API事例。\n   Stage 2: draft（草案）——功能规范的初始版本，该版本包含功能规范的两个实验实现。\n   Stage 3: candidate（候选）——提案规范通过审查并从厂商那里收集反馈\n   Stage 4: finished（完成）——提案准备加入ECMAScript，但是到浏览器或者Nodejs中可能需要更长的时间\n   \n2. es2018(es9) \n promise.finally  正则表达式匹配组 \n regex 先行断言和反向断言、dotall  \n \n1. Template Literals\n\n1. \n \n","slug":"es8","published":1,"updated":"2019-07-26T08:35:17.301Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5bwexcn000c998sfz5cw5rf","content":"<ol>\n<li><p>Stage 0: strawman——最初想法的提交。<br>Stage 1: proposal（提案）——由TC39至少一名成员倡导的正式提案文件，该文件包括API事例。<br>Stage 2: draft（草案）——功能规范的初始版本，该版本包含功能规范的两个实验实现。<br>Stage 3: candidate（候选）——提案规范通过审查并从厂商那里收集反馈<br>Stage 4: finished（完成）——提案准备加入ECMAScript，但是到浏览器或者Nodejs中可能需要更长的时间</p>\n</li>\n<li><p>es2018(es9)<br>promise.finally  正则表达式匹配组<br>regex 先行断言和反向断言、dotall  </p>\n</li>\n<li><p>Template Literals</p>\n</li>\n<li></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><p>Stage 0: strawman——最初想法的提交。<br>Stage 1: proposal（提案）——由TC39至少一名成员倡导的正式提案文件，该文件包括API事例。<br>Stage 2: draft（草案）——功能规范的初始版本，该版本包含功能规范的两个实验实现。<br>Stage 3: candidate（候选）——提案规范通过审查并从厂商那里收集反馈<br>Stage 4: finished（完成）——提案准备加入ECMAScript，但是到浏览器或者Nodejs中可能需要更长的时间</p>\n</li>\n<li><p>es2018(es9)<br>promise.finally  正则表达式匹配组<br>regex 先行断言和反向断言、dotall  </p>\n</li>\n<li><p>Template Literals</p>\n</li>\n<li></li>\n</ol>\n"},{"title":"gitInfo","date":"2019-02-20T09:58:18.000Z","_content":"\n1. git rm --cached  从git索引和缓存中删除 \n2. git mv 重命名或者移动文件\n3. git reset --soft \"HEAD^\" 留下当前变更内容\n4. git reset head 从当前缓存区删除\n5. git checkout .  撤销当前工作区修改\n6. git commit --amend 修改上次提交信息\n7. git log --oneline/--raw \n8. checkout只会移动HEAD指针，reset会改变HEAD的引用值。\n9. git config --global user.name [user.email]\n10. git tag -a 'annotate' -m 'message'\n11. git remote set-url --add <name> <newurl>  添加多个url\n12. git tag -d <tag-name>  \n13. git status --ignored  显示忽略掉文件\n14. git checkout --orphan <branch-name>  新建没有commit的分支\n1. git push origin :refs/tags/<tag-name>  删除远程tag\n2. git branch -u <origin/mybranch> 设置远程分支 \n2. git branch -vv 查看本地分之关联情况\n2. git checkout -  最近两个分子间切换\n1. git commit -m \"Big-ass commit\" --allow-empty\n","source":"_posts/gitInfo.md","raw":"---\ntitle: gitInfo\ndate: 2019-02-20 17:58:18\ntags: git\n---\n\n1. git rm --cached  从git索引和缓存中删除 \n2. git mv 重命名或者移动文件\n3. git reset --soft \"HEAD^\" 留下当前变更内容\n4. git reset head 从当前缓存区删除\n5. git checkout .  撤销当前工作区修改\n6. git commit --amend 修改上次提交信息\n7. git log --oneline/--raw \n8. checkout只会移动HEAD指针，reset会改变HEAD的引用值。\n9. git config --global user.name [user.email]\n10. git tag -a 'annotate' -m 'message'\n11. git remote set-url --add <name> <newurl>  添加多个url\n12. git tag -d <tag-name>  \n13. git status --ignored  显示忽略掉文件\n14. git checkout --orphan <branch-name>  新建没有commit的分支\n1. git push origin :refs/tags/<tag-name>  删除远程tag\n2. git branch -u <origin/mybranch> 设置远程分支 \n2. git branch -vv 查看本地分之关联情况\n2. git checkout -  最近两个分子间切换\n1. git commit -m \"Big-ass commit\" --allow-empty\n","slug":"gitInfo","published":1,"updated":"2019-11-04T02:26:51.926Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5bwexco000e998siarb0mr7","content":"<ol>\n<li>git rm –cached  从git索引和缓存中删除 </li>\n<li>git mv 重命名或者移动文件</li>\n<li>git reset –soft “HEAD^” 留下当前变更内容</li>\n<li>git reset head 从当前缓存区删除</li>\n<li>git checkout .  撤销当前工作区修改</li>\n<li>git commit –amend 修改上次提交信息</li>\n<li>git log –oneline/–raw </li>\n<li>checkout只会移动HEAD指针，reset会改变HEAD的引用值。</li>\n<li>git config –global user.name [user.email]</li>\n<li>git tag -a ‘annotate’ -m ‘message’</li>\n<li>git remote set-url –add <name> <newurl>  添加多个url</newurl></name></li>\n<li>git tag -d <tag-name>  </tag-name></li>\n<li>git status –ignored  显示忽略掉文件</li>\n<li>git checkout –orphan <branch-name>  新建没有commit的分支</branch-name></li>\n<li>git push origin :refs/tags/<tag-name>  删除远程tag</tag-name></li>\n<li>git branch -u &lt;origin/mybranch&gt; 设置远程分支 </li>\n<li>git branch -vv 查看本地分之关联情况</li>\n<li>git checkout -  最近两个分子间切换</li>\n<li>git commit -m “Big-ass commit” –allow-empty</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>git rm –cached  从git索引和缓存中删除 </li>\n<li>git mv 重命名或者移动文件</li>\n<li>git reset –soft “HEAD^” 留下当前变更内容</li>\n<li>git reset head 从当前缓存区删除</li>\n<li>git checkout .  撤销当前工作区修改</li>\n<li>git commit –amend 修改上次提交信息</li>\n<li>git log –oneline/–raw </li>\n<li>checkout只会移动HEAD指针，reset会改变HEAD的引用值。</li>\n<li>git config –global user.name [user.email]</li>\n<li>git tag -a ‘annotate’ -m ‘message’</li>\n<li>git remote set-url –add <name> <newurl>  添加多个url</newurl></name></li>\n<li>git tag -d <tag-name>  </tag-name></li>\n<li>git status –ignored  显示忽略掉文件</li>\n<li>git checkout –orphan <branch-name>  新建没有commit的分支</branch-name></li>\n<li>git push origin :refs/tags/<tag-name>  删除远程tag</tag-name></li>\n<li>git branch -u &lt;origin/mybranch&gt; 设置远程分支 </li>\n<li>git branch -vv 查看本地分之关联情况</li>\n<li>git checkout -  最近两个分子间切换</li>\n<li>git commit -m “Big-ass commit” –allow-empty</li>\n</ol>\n"},{"title":"hexo","date":"2016-12-21T03:47:39.000Z","_content":"# install\nNode和Git都安装好后,首先创建一个文件夹,如blog,用户存放hexo的配置文件,然后进入blog里安装Hexo。\n\n执行如下命令安装Hexo：\n\nsudo npm install -g hexo\n\n初始化然后，执行init命令初始化hexo,命令：\n\nhexo init\n\n好啦，至此，全部安装工作已经完成！blog就是你的博客根目录，所有的操作都在里面进行。\n\n生成静态页面\n\nhexo generate（hexo g也可以）\n\n本地启动\n\n启动本地服务，进行文章预览调试，命令：\n\nhexo server\n\n浏览器输入http://localhost:4000\n\n我不知道你们能不能，反正我不能，因为我还有环境没配置好\n\n# 配置Github\n建立Repository\n\n建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】，固定写法\n\n然后建立关联，我的blog在本地/Users/leopard/blog，blog是我之前建的东西也全在这里面，有：\n\n    _config.yml    node_modules    public      source\n\n    db.json        package.json    scaffolds  themes\n\n现在我们需要_config.yml文件，来建立关联，命令：\n\nvim _config.yml\n\n翻到最下面，改成我这样子的\n\ndeploy:\n\n     type: git\n\n     repo: https://github.com/leopardpan/leopardpan.github.io.git\n\n     branch: master\n\n然后执行命令：\n\nnpm install hexo-deployer-git --save\n\n \n# 一些常用命令：\n\nhexo new\"postName\" #新建文章\n\nhexo new page\"pageName\" #新建页面\n\nhexo generate #生成静态页面至public目录\n\nhexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\n\nhexo deploy #将.deploy目录部署到GitHub\n\nhexo help # 查看帮助\n\nhexo version #查看Hexo的版本\n\n ","source":"_posts/hexo.md","raw":"---\ntitle: hexo\ndate: 2016-12-21 11:47:39\ntags: hexo \n---\n# install\nNode和Git都安装好后,首先创建一个文件夹,如blog,用户存放hexo的配置文件,然后进入blog里安装Hexo。\n\n执行如下命令安装Hexo：\n\nsudo npm install -g hexo\n\n初始化然后，执行init命令初始化hexo,命令：\n\nhexo init\n\n好啦，至此，全部安装工作已经完成！blog就是你的博客根目录，所有的操作都在里面进行。\n\n生成静态页面\n\nhexo generate（hexo g也可以）\n\n本地启动\n\n启动本地服务，进行文章预览调试，命令：\n\nhexo server\n\n浏览器输入http://localhost:4000\n\n我不知道你们能不能，反正我不能，因为我还有环境没配置好\n\n# 配置Github\n建立Repository\n\n建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】，固定写法\n\n然后建立关联，我的blog在本地/Users/leopard/blog，blog是我之前建的东西也全在这里面，有：\n\n    _config.yml    node_modules    public      source\n\n    db.json        package.json    scaffolds  themes\n\n现在我们需要_config.yml文件，来建立关联，命令：\n\nvim _config.yml\n\n翻到最下面，改成我这样子的\n\ndeploy:\n\n     type: git\n\n     repo: https://github.com/leopardpan/leopardpan.github.io.git\n\n     branch: master\n\n然后执行命令：\n\nnpm install hexo-deployer-git --save\n\n \n# 一些常用命令：\n\nhexo new\"postName\" #新建文章\n\nhexo new page\"pageName\" #新建页面\n\nhexo generate #生成静态页面至public目录\n\nhexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\n\nhexo deploy #将.deploy目录部署到GitHub\n\nhexo help # 查看帮助\n\nhexo version #查看Hexo的版本\n\n ","slug":"hexo","published":1,"updated":"2019-07-26T08:35:17.303Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5bwexcr000g998suijeun2o","content":"<h1 id=\"install\"><a href=\"#install\" class=\"headerlink\" title=\"install\"></a>install</h1><p>Node和Git都安装好后,首先创建一个文件夹,如blog,用户存放hexo的配置文件,然后进入blog里安装Hexo。</p>\n<p>执行如下命令安装Hexo：</p>\n<p>sudo npm install -g hexo</p>\n<p>初始化然后，执行init命令初始化hexo,命令：</p>\n<p>hexo init</p>\n<p>好啦，至此，全部安装工作已经完成！blog就是你的博客根目录，所有的操作都在里面进行。</p>\n<p>生成静态页面</p>\n<p>hexo generate（hexo g也可以）</p>\n<p>本地启动</p>\n<p>启动本地服务，进行文章预览调试，命令：</p>\n<p>hexo server</p>\n<p>浏览器输入<a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a></p>\n<p>我不知道你们能不能，反正我不能，因为我还有环境没配置好</p>\n<h1 id=\"配置Github\"><a href=\"#配置Github\" class=\"headerlink\" title=\"配置Github\"></a>配置Github</h1><p>建立Repository</p>\n<p>建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】，固定写法</p>\n<p>然后建立关联，我的blog在本地/Users/leopard/blog，blog是我之前建的东西也全在这里面，有：</p>\n<pre><code>_config.yml    node_modules    public      source\n\ndb.json        package.json    scaffolds  themes\n</code></pre><p>现在我们需要_config.yml文件，来建立关联，命令：</p>\n<p>vim _config.yml</p>\n<p>翻到最下面，改成我这样子的</p>\n<p>deploy:</p>\n<pre><code>type: git\n\nrepo: https://github.com/leopardpan/leopardpan.github.io.git\n\nbranch: master\n</code></pre><p>然后执行命令：</p>\n<p>npm install hexo-deployer-git –save</p>\n<h1 id=\"一些常用命令：\"><a href=\"#一些常用命令：\" class=\"headerlink\" title=\"一些常用命令：\"></a>一些常用命令：</h1><p>hexo new”postName” #新建文章</p>\n<p>hexo new page”pageName” #新建页面</p>\n<p>hexo generate #生成静态页面至public目录</p>\n<p>hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）</p>\n<p>hexo deploy #将.deploy目录部署到GitHub</p>\n<p>hexo help # 查看帮助</p>\n<p>hexo version #查看Hexo的版本</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"install\"><a href=\"#install\" class=\"headerlink\" title=\"install\"></a>install</h1><p>Node和Git都安装好后,首先创建一个文件夹,如blog,用户存放hexo的配置文件,然后进入blog里安装Hexo。</p>\n<p>执行如下命令安装Hexo：</p>\n<p>sudo npm install -g hexo</p>\n<p>初始化然后，执行init命令初始化hexo,命令：</p>\n<p>hexo init</p>\n<p>好啦，至此，全部安装工作已经完成！blog就是你的博客根目录，所有的操作都在里面进行。</p>\n<p>生成静态页面</p>\n<p>hexo generate（hexo g也可以）</p>\n<p>本地启动</p>\n<p>启动本地服务，进行文章预览调试，命令：</p>\n<p>hexo server</p>\n<p>浏览器输入<a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a></p>\n<p>我不知道你们能不能，反正我不能，因为我还有环境没配置好</p>\n<h1 id=\"配置Github\"><a href=\"#配置Github\" class=\"headerlink\" title=\"配置Github\"></a>配置Github</h1><p>建立Repository</p>\n<p>建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】，固定写法</p>\n<p>然后建立关联，我的blog在本地/Users/leopard/blog，blog是我之前建的东西也全在这里面，有：</p>\n<pre><code>_config.yml    node_modules    public      source\n\ndb.json        package.json    scaffolds  themes\n</code></pre><p>现在我们需要_config.yml文件，来建立关联，命令：</p>\n<p>vim _config.yml</p>\n<p>翻到最下面，改成我这样子的</p>\n<p>deploy:</p>\n<pre><code>type: git\n\nrepo: https://github.com/leopardpan/leopardpan.github.io.git\n\nbranch: master\n</code></pre><p>然后执行命令：</p>\n<p>npm install hexo-deployer-git –save</p>\n<h1 id=\"一些常用命令：\"><a href=\"#一些常用命令：\" class=\"headerlink\" title=\"一些常用命令：\"></a>一些常用命令：</h1><p>hexo new”postName” #新建文章</p>\n<p>hexo new page”pageName” #新建页面</p>\n<p>hexo generate #生成静态页面至public目录</p>\n<p>hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）</p>\n<p>hexo deploy #将.deploy目录部署到GitHub</p>\n<p>hexo help # 查看帮助</p>\n<p>hexo version #查看Hexo的版本</p>\n"},{"title":"graphql","date":"2019-08-23T08:19:28.000Z","_content":"1. \n```text\nfunction(parent, args, ctx, info) {\n    …\n其中的参数的意义如下：\n\nparent: 当前上一个Resolver的返回值\nargs: 传入某个Query中的函数（比如上面例子中article(id: Int)中的id）\nctx: 在Resolver解析链中不断传递的中间变量（类似中间件架构中的context）\ninfo: 当前Query的AST对象\n}\n```\n2. query（查询）：当获取数据时，应当选取Query类型\n\n   mutation（更改）：当尝试修改数据时，应当使用mutation类型\n   \n   subscription（订阅）：当希望数据更改时，可以进行消息推送，使用subscription类型\n","source":"_posts/graphql.md","raw":"---\ntitle: graphql\ndate: 2019-08-23 16:19:28\ntags:\n---\n1. \n```text\nfunction(parent, args, ctx, info) {\n    …\n其中的参数的意义如下：\n\nparent: 当前上一个Resolver的返回值\nargs: 传入某个Query中的函数（比如上面例子中article(id: Int)中的id）\nctx: 在Resolver解析链中不断传递的中间变量（类似中间件架构中的context）\ninfo: 当前Query的AST对象\n}\n```\n2. query（查询）：当获取数据时，应当选取Query类型\n\n   mutation（更改）：当尝试修改数据时，应当使用mutation类型\n   \n   subscription（订阅）：当希望数据更改时，可以进行消息推送，使用subscription类型\n","slug":"graphql","published":1,"updated":"2019-08-23T08:25:22.505Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5bwexct000i998sgc078ldr","content":"<ol>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function(parent, args, ctx, info) &#123;</span><br><span class=\"line\">    …</span><br><span class=\"line\">其中的参数的意义如下：</span><br><span class=\"line\"></span><br><span class=\"line\">parent: 当前上一个Resolver的返回值</span><br><span class=\"line\">args: 传入某个Query中的函数（比如上面例子中article(id: Int)中的id）</span><br><span class=\"line\">ctx: 在Resolver解析链中不断传递的中间变量（类似中间件架构中的context）</span><br><span class=\"line\">info: 当前Query的AST对象</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>query（查询）：当获取数据时，应当选取Query类型</p>\n<p>mutation（更改）：当尝试修改数据时，应当使用mutation类型</p>\n<p>subscription（订阅）：当希望数据更改时，可以进行消息推送，使用subscription类型</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function(parent, args, ctx, info) &#123;</span><br><span class=\"line\">    …</span><br><span class=\"line\">其中的参数的意义如下：</span><br><span class=\"line\"></span><br><span class=\"line\">parent: 当前上一个Resolver的返回值</span><br><span class=\"line\">args: 传入某个Query中的函数（比如上面例子中article(id: Int)中的id）</span><br><span class=\"line\">ctx: 在Resolver解析链中不断传递的中间变量（类似中间件架构中的context）</span><br><span class=\"line\">info: 当前Query的AST对象</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>query（查询）：当获取数据时，应当选取Query类型</p>\n<p>mutation（更改）：当尝试修改数据时，应当使用mutation类型</p>\n<p>subscription（订阅）：当希望数据更改时，可以进行消息推送，使用subscription类型</p>\n</li>\n</ol>\n"},{"title":"http","date":"2019-05-14T07:17:39.000Z","_content":"\n####XST 的全称是 Cross-Site Tracing\n\n    客户端发 TRACE 请求至服务器，如果服务器按照标准实现了 TRACE 响应，则在 response body 里会返回此次请求的完整头信息。通过这种方式，客户端可以获取某些敏感的头字段，例如 httpOnly 的 Cookie。\n\n    TRACE方法让客户端测试到服务器的网络通路，回路的意思如发送一个请返回一个响应，这就是一个请求响应回路\n\n####Set-Cookie\n    用于设置Cookie。\n    \n    Set-Cookie: name=value; secure; HttpOnly\n    secure 只在进行HTTP通信时发送Cookie。\n    HttpOnly 指定不能从JavaScript脚本代码访问Cookie值。\n    \n ####X-Download-Options: noopen\n    noopen 用于指定IE 8以上版本的用户不打开文件而直接保存文件。在下载对话框中不显示“打开”选项。\n \n ####keepalive \n \n    若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;   \n    http 1.0中默认是关闭的，需要在http头加入\"Connection: Keep-Alive\"，才能启用Keep-Alive；http 1.1中默认启用Keep-Alive，如果加入\"Connection: close \"，才关闭。目前大部分浏览器都是用http1.1协议，也就是说默认都会发起Keep-Alive的连接请求了，所以是否能完成一个完整的Keep-Alive连接就看服务器设置情况。\n    \n ####headers\n \n Accept-Charset： 浏览器申明自己接收的字符集 \n Accept-Encoding： 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate） \n \n  Age：当代理服务器用自己缓存的实体去响应请求时，用该头部表明该实体从产生到现在经过多长时间了。   \n  \n   http header 中使用location 进行302跳转 \n   \n   URL.createObjectURL() 静态方法会创建一个 DOMString，其中包含一个表示参数中给出的对象的URL。这个 URL 的生命周期和创建它的窗口中的 document 绑定。这个新的URL 对象表示指定的 File 对象或 Blob 对象。\n\n####http \n```text\nhttp 1.1 添加cache-contol \n\n长连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个长连接，而HTP1.1默认支持长连接\n节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）\nhost域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端口）：HTTP1.0没有host域\n\n\nhttp 2.0\n采用二进制格式传输;\n多路复用，其实就是将请求数据分成帧乱序发送到 TCP 中。TCP 只能有一个 steam，所以还是会阻塞;\n报头压缩;\n服务器推送主动向 B 端发送静态资源，避免往返延迟。\n1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好\n2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量\n3.多路复用：一个连接可以并发处理多个请求\n4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源\n\nhttp 3.0\n采用 QUIC 协议,自定义连接机制;自定义重传机制;无阻塞的多路复用\n\n2.按缓存分：强缓存和协商缓存：\n2.1强缓存：利用 cache-control 和 expires 设置，直接返回一个过期时间，所以在缓存期间不请求，If-modify-since；\n2.2协商缓存：响应头返回 etag 或 last-modified 的哈希值，第二次请求头 If-none-match 或 IF-modify-since 携带上次哈希值，一致则返回 304。\nF5 刷新会忽略强缓存不会忽略协商缓存，ctrl+f5 都失效\n```       \n\n1. Https https://zhuanlan.zhihu.com/p/27395037    https://blog.51cto.com/11883699/2160032\n1. Ca 使用证书颁发机构的证书中的公钥去解密被颁发者的指纹算法和指纹，并计算比对指纹，正确才能验证身份\n\n1. 缓存的分类：\n```text\n   强缓存：在缓存数据未失效的情况下，不需要再和服务器发生交互.cache-control :no-cache 走协商缓存\n   协商缓存：需要与服务端校验是否使用缓存。etag If-None-Match HTTP 请求头内提供 ETag\n```\n\n1. 30X 区分\n```text\n301，Moved Permanently。永久重定向，该操作比较危险，需要谨慎操作：如果设置了301，但是一段时间后又想取消，但是浏览器中已经有了缓存，还是会重定向。\n302，Fount。临时重定向，但是会在重定向的时候改变 method: 把 POST 改成 GET，于是有了 307\n307，Temporary Redirect。临时重定向，在重定向时不会改变 method\n```\n1. https \n```text\n这些ＣＡ本身也有证书来证明自己的身份，并且ＣＡ的信用是像树一样分级的，高层的ＣＡ给底层的ＣＡ做信用背书，而操作系统／浏览器中会内置一些顶层的ＣＡ的证书，相当于你自动信任了他们。　\n\n公钥+个人信息+其它信息—》hash 算法 —》信息摘要-》用ca的私钥加密—》数字签名   签名+信息=数字证书 \nCa 的公钥解密—》hash hash 算法 —》信息摘要-》对比是否一致\n\n```\n\n1. content-type\n```text\nmultipart/form-data\n\n请求消息头中, Content-Type: multipart/form-data; boundary=----WebKitFormBoundarykALcKBgBaI9xA79y\nboundary为分隔符.\n\napplication/x-www-form-urlencoded\n```\n\n1. Nat network adreess translation 网络地址转换.\n  当访问外网时自动分配一个端口，这个端口和内网的机器建立了映射关系。\n1. Defer\n\n   这个属性的用途是表明脚本在执行时不会影响页面的构造。也就是说，脚本会被延迟到整个页面都解析完毕后再运行。因此，在script元素中设置defer属性，相当于告诉浏览器立即下载，但延迟执行。\n   但与defer不同的是，标记为async的脚本并不保证按照它们的先后顺序执行。\n1.    在 http 1.1 中，在响应头中设置 keep-alive 可以在一个 TCP 连接上发送多个 http 请求\n      \n      避免了重开 TCP 连接的开销\n      避免了刷新时重新建立 SSL 连接的开销\n      避免了QPS过大时，服务器的连接数过大\n      \n1. 缓存协商\n \n ```text\n我们知道协商缓存有两种方式\n\nLast-Modified/if-Modified-Since  ** Last-Modified 是由一个 unix timestamp 表示，则意味着它只能作用于秒级的改变**\nETag/If-None-Match\n```     \n1. window.opener 表示打开当前窗体页面的的父窗体的是谁。例如，在 A 页面中，通过一个带有 target=\"_blank\" 的 a 标签打开了一个新的页面 B，那么在 B 页面里，window.opener 的值为 A 页面的 window 对象。   rel=noopener 规定禁止新页面传递源页面的地址，通过设置了此属性的链接打开的页面，其 window.opener 的值为 null。\n1. Gzip 不要使用再图片以及其它二进制文件上","source":"_posts/http.md","raw":"---\ntitle: http\ndate: 2019-05-14 15:17:39\ntags: http\n---\n\n####XST 的全称是 Cross-Site Tracing\n\n    客户端发 TRACE 请求至服务器，如果服务器按照标准实现了 TRACE 响应，则在 response body 里会返回此次请求的完整头信息。通过这种方式，客户端可以获取某些敏感的头字段，例如 httpOnly 的 Cookie。\n\n    TRACE方法让客户端测试到服务器的网络通路，回路的意思如发送一个请返回一个响应，这就是一个请求响应回路\n\n####Set-Cookie\n    用于设置Cookie。\n    \n    Set-Cookie: name=value; secure; HttpOnly\n    secure 只在进行HTTP通信时发送Cookie。\n    HttpOnly 指定不能从JavaScript脚本代码访问Cookie值。\n    \n ####X-Download-Options: noopen\n    noopen 用于指定IE 8以上版本的用户不打开文件而直接保存文件。在下载对话框中不显示“打开”选项。\n \n ####keepalive \n \n    若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;   \n    http 1.0中默认是关闭的，需要在http头加入\"Connection: Keep-Alive\"，才能启用Keep-Alive；http 1.1中默认启用Keep-Alive，如果加入\"Connection: close \"，才关闭。目前大部分浏览器都是用http1.1协议，也就是说默认都会发起Keep-Alive的连接请求了，所以是否能完成一个完整的Keep-Alive连接就看服务器设置情况。\n    \n ####headers\n \n Accept-Charset： 浏览器申明自己接收的字符集 \n Accept-Encoding： 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate） \n \n  Age：当代理服务器用自己缓存的实体去响应请求时，用该头部表明该实体从产生到现在经过多长时间了。   \n  \n   http header 中使用location 进行302跳转 \n   \n   URL.createObjectURL() 静态方法会创建一个 DOMString，其中包含一个表示参数中给出的对象的URL。这个 URL 的生命周期和创建它的窗口中的 document 绑定。这个新的URL 对象表示指定的 File 对象或 Blob 对象。\n\n####http \n```text\nhttp 1.1 添加cache-contol \n\n长连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个长连接，而HTP1.1默认支持长连接\n节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）\nhost域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端口）：HTTP1.0没有host域\n\n\nhttp 2.0\n采用二进制格式传输;\n多路复用，其实就是将请求数据分成帧乱序发送到 TCP 中。TCP 只能有一个 steam，所以还是会阻塞;\n报头压缩;\n服务器推送主动向 B 端发送静态资源，避免往返延迟。\n1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好\n2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量\n3.多路复用：一个连接可以并发处理多个请求\n4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源\n\nhttp 3.0\n采用 QUIC 协议,自定义连接机制;自定义重传机制;无阻塞的多路复用\n\n2.按缓存分：强缓存和协商缓存：\n2.1强缓存：利用 cache-control 和 expires 设置，直接返回一个过期时间，所以在缓存期间不请求，If-modify-since；\n2.2协商缓存：响应头返回 etag 或 last-modified 的哈希值，第二次请求头 If-none-match 或 IF-modify-since 携带上次哈希值，一致则返回 304。\nF5 刷新会忽略强缓存不会忽略协商缓存，ctrl+f5 都失效\n```       \n\n1. Https https://zhuanlan.zhihu.com/p/27395037    https://blog.51cto.com/11883699/2160032\n1. Ca 使用证书颁发机构的证书中的公钥去解密被颁发者的指纹算法和指纹，并计算比对指纹，正确才能验证身份\n\n1. 缓存的分类：\n```text\n   强缓存：在缓存数据未失效的情况下，不需要再和服务器发生交互.cache-control :no-cache 走协商缓存\n   协商缓存：需要与服务端校验是否使用缓存。etag If-None-Match HTTP 请求头内提供 ETag\n```\n\n1. 30X 区分\n```text\n301，Moved Permanently。永久重定向，该操作比较危险，需要谨慎操作：如果设置了301，但是一段时间后又想取消，但是浏览器中已经有了缓存，还是会重定向。\n302，Fount。临时重定向，但是会在重定向的时候改变 method: 把 POST 改成 GET，于是有了 307\n307，Temporary Redirect。临时重定向，在重定向时不会改变 method\n```\n1. https \n```text\n这些ＣＡ本身也有证书来证明自己的身份，并且ＣＡ的信用是像树一样分级的，高层的ＣＡ给底层的ＣＡ做信用背书，而操作系统／浏览器中会内置一些顶层的ＣＡ的证书，相当于你自动信任了他们。　\n\n公钥+个人信息+其它信息—》hash 算法 —》信息摘要-》用ca的私钥加密—》数字签名   签名+信息=数字证书 \nCa 的公钥解密—》hash hash 算法 —》信息摘要-》对比是否一致\n\n```\n\n1. content-type\n```text\nmultipart/form-data\n\n请求消息头中, Content-Type: multipart/form-data; boundary=----WebKitFormBoundarykALcKBgBaI9xA79y\nboundary为分隔符.\n\napplication/x-www-form-urlencoded\n```\n\n1. Nat network adreess translation 网络地址转换.\n  当访问外网时自动分配一个端口，这个端口和内网的机器建立了映射关系。\n1. Defer\n\n   这个属性的用途是表明脚本在执行时不会影响页面的构造。也就是说，脚本会被延迟到整个页面都解析完毕后再运行。因此，在script元素中设置defer属性，相当于告诉浏览器立即下载，但延迟执行。\n   但与defer不同的是，标记为async的脚本并不保证按照它们的先后顺序执行。\n1.    在 http 1.1 中，在响应头中设置 keep-alive 可以在一个 TCP 连接上发送多个 http 请求\n      \n      避免了重开 TCP 连接的开销\n      避免了刷新时重新建立 SSL 连接的开销\n      避免了QPS过大时，服务器的连接数过大\n      \n1. 缓存协商\n \n ```text\n我们知道协商缓存有两种方式\n\nLast-Modified/if-Modified-Since  ** Last-Modified 是由一个 unix timestamp 表示，则意味着它只能作用于秒级的改变**\nETag/If-None-Match\n```     \n1. window.opener 表示打开当前窗体页面的的父窗体的是谁。例如，在 A 页面中，通过一个带有 target=\"_blank\" 的 a 标签打开了一个新的页面 B，那么在 B 页面里，window.opener 的值为 A 页面的 window 对象。   rel=noopener 规定禁止新页面传递源页面的地址，通过设置了此属性的链接打开的页面，其 window.opener 的值为 null。\n1. Gzip 不要使用再图片以及其它二进制文件上","slug":"http","published":1,"updated":"2020-01-02T08:18:30.590Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5bwexcu000k998snaniholu","content":"<p>####XST 的全称是 Cross-Site Tracing</p>\n<pre><code>客户端发 TRACE 请求至服务器，如果服务器按照标准实现了 TRACE 响应，则在 response body 里会返回此次请求的完整头信息。通过这种方式，客户端可以获取某些敏感的头字段，例如 httpOnly 的 Cookie。\n\nTRACE方法让客户端测试到服务器的网络通路，回路的意思如发送一个请返回一个响应，这就是一个请求响应回路\n</code></pre><p>####Set-Cookie<br>    用于设置Cookie。</p>\n<pre><code>Set-Cookie: name=value; secure; HttpOnly\nsecure 只在进行HTTP通信时发送Cookie。\nHttpOnly 指定不能从JavaScript脚本代码访问Cookie值。\n</code></pre><p> ####X-Download-Options: noopen<br>    noopen 用于指定IE 8以上版本的用户不打开文件而直接保存文件。在下载对话框中不显示“打开”选项。</p>\n<p> ####keepalive </p>\n<pre><code>若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;   \nhttp 1.0中默认是关闭的，需要在http头加入&quot;Connection: Keep-Alive&quot;，才能启用Keep-Alive；http 1.1中默认启用Keep-Alive，如果加入&quot;Connection: close &quot;，才关闭。目前大部分浏览器都是用http1.1协议，也就是说默认都会发起Keep-Alive的连接请求了，所以是否能完成一个完整的Keep-Alive连接就看服务器设置情况。\n</code></pre><p> ####headers</p>\n<p> Accept-Charset： 浏览器申明自己接收的字符集<br> Accept-Encoding： 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate） </p>\n<p>  Age：当代理服务器用自己缓存的实体去响应请求时，用该头部表明该实体从产生到现在经过多长时间了。   </p>\n<p>   http header 中使用location 进行302跳转 </p>\n<p>   URL.createObjectURL() 静态方法会创建一个 DOMString，其中包含一个表示参数中给出的对象的URL。这个 URL 的生命周期和创建它的窗口中的 document 绑定。这个新的URL 对象表示指定的 File 对象或 Blob 对象。</p>\n<p>####http<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http 1.1 添加cache-contol </span><br><span class=\"line\"></span><br><span class=\"line\">长连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个长连接，而HTP1.1默认支持长连接</span><br><span class=\"line\">节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）</span><br><span class=\"line\">host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端口）：HTTP1.0没有host域</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">http 2.0</span><br><span class=\"line\">采用二进制格式传输;</span><br><span class=\"line\">多路复用，其实就是将请求数据分成帧乱序发送到 TCP 中。TCP 只能有一个 steam，所以还是会阻塞;</span><br><span class=\"line\">报头压缩;</span><br><span class=\"line\">服务器推送主动向 B 端发送静态资源，避免往返延迟。</span><br><span class=\"line\">1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好</span><br><span class=\"line\">2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量</span><br><span class=\"line\">3.多路复用：一个连接可以并发处理多个请求</span><br><span class=\"line\">4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源</span><br><span class=\"line\"></span><br><span class=\"line\">http 3.0</span><br><span class=\"line\">采用 QUIC 协议,自定义连接机制;自定义重传机制;无阻塞的多路复用</span><br><span class=\"line\"></span><br><span class=\"line\">2.按缓存分：强缓存和协商缓存：</span><br><span class=\"line\">2.1强缓存：利用 cache-control 和 expires 设置，直接返回一个过期时间，所以在缓存期间不请求，If-modify-since；</span><br><span class=\"line\">2.2协商缓存：响应头返回 etag 或 last-modified 的哈希值，第二次请求头 If-none-match 或 IF-modify-since 携带上次哈希值，一致则返回 304。</span><br><span class=\"line\">F5 刷新会忽略强缓存不会忽略协商缓存，ctrl+f5 都失效</span><br><span class=\"line\">```       </span><br><span class=\"line\"></span><br><span class=\"line\">1. Https https://zhuanlan.zhihu.com/p/27395037    https://blog.51cto.com/11883699/2160032</span><br><span class=\"line\">1. Ca 使用证书颁发机构的证书中的公钥去解密被颁发者的指纹算法和指纹，并计算比对指纹，正确才能验证身份</span><br><span class=\"line\"></span><br><span class=\"line\">1. 缓存的分类：</span><br><span class=\"line\">```text</span><br><span class=\"line\">   强缓存：在缓存数据未失效的情况下，不需要再和服务器发生交互.cache-control :no-cache 走协商缓存</span><br><span class=\"line\">   协商缓存：需要与服务端校验是否使用缓存。etag If-None-Match HTTP 请求头内提供 ETag</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li><p>30X 区分</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">301，Moved Permanently。永久重定向，该操作比较危险，需要谨慎操作：如果设置了301，但是一段时间后又想取消，但是浏览器中已经有了缓存，还是会重定向。</span><br><span class=\"line\">302，Fount。临时重定向，但是会在重定向的时候改变 method: 把 POST 改成 GET，于是有了 307</span><br><span class=\"line\">307，Temporary Redirect。临时重定向，在重定向时不会改变 method</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>https </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这些ＣＡ本身也有证书来证明自己的身份，并且ＣＡ的信用是像树一样分级的，高层的ＣＡ给底层的ＣＡ做信用背书，而操作系统／浏览器中会内置一些顶层的ＣＡ的证书，相当于你自动信任了他们。　</span><br><span class=\"line\"></span><br><span class=\"line\">公钥+个人信息+其它信息—》hash 算法 —》信息摘要-》用ca的私钥加密—》数字签名   签名+信息=数字证书 </span><br><span class=\"line\">Ca 的公钥解密—》hash hash 算法 —》信息摘要-》对比是否一致</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>content-type</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">multipart/form-data</span><br><span class=\"line\"></span><br><span class=\"line\">请求消息头中, Content-Type: multipart/form-data; boundary=----WebKitFormBoundarykALcKBgBaI9xA79y</span><br><span class=\"line\">boundary为分隔符.</span><br><span class=\"line\"></span><br><span class=\"line\">application/x-www-form-urlencoded</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Nat network adreess translation 网络地址转换.<br>当访问外网时自动分配一个端口，这个端口和内网的机器建立了映射关系。</p>\n</li>\n<li><p>Defer</p>\n<p>这个属性的用途是表明脚本在执行时不会影响页面的构造。也就是说，脚本会被延迟到整个页面都解析完毕后再运行。因此，在script元素中设置defer属性，相当于告诉浏览器立即下载，但延迟执行。<br>但与defer不同的是，标记为async的脚本并不保证按照它们的先后顺序执行。</p>\n</li>\n<li><p>在 http 1.1 中，在响应头中设置 keep-alive 可以在一个 TCP 连接上发送多个 http 请求</p>\n<p>避免了重开 TCP 连接的开销<br>避免了刷新时重新建立 SSL 连接的开销<br>避免了QPS过大时，服务器的连接数过大</p>\n</li>\n<li><p>缓存协商</p>\n<p><code>`</code>text<br>我们知道协商缓存有两种方式</p>\n</li>\n</ol>\n<p>Last-Modified/if-Modified-Since  <strong> Last-Modified 是由一个 unix timestamp 表示，则意味着它只能作用于秒级的改变</strong><br>ETag/If-None-Match<br><code>`</code>     </p>\n<ol>\n<li>window.opener 表示打开当前窗体页面的的父窗体的是谁。例如，在 A 页面中，通过一个带有 target=”_blank” 的 a 标签打开了一个新的页面 B，那么在 B 页面里，window.opener 的值为 A 页面的 window 对象。   rel=noopener 规定禁止新页面传递源页面的地址，通过设置了此属性的链接打开的页面，其 window.opener 的值为 null。</li>\n<li>Gzip 不要使用再图片以及其它二进制文件上</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>####XST 的全称是 Cross-Site Tracing</p>\n<pre><code>客户端发 TRACE 请求至服务器，如果服务器按照标准实现了 TRACE 响应，则在 response body 里会返回此次请求的完整头信息。通过这种方式，客户端可以获取某些敏感的头字段，例如 httpOnly 的 Cookie。\n\nTRACE方法让客户端测试到服务器的网络通路，回路的意思如发送一个请返回一个响应，这就是一个请求响应回路\n</code></pre><p>####Set-Cookie<br>    用于设置Cookie。</p>\n<pre><code>Set-Cookie: name=value; secure; HttpOnly\nsecure 只在进行HTTP通信时发送Cookie。\nHttpOnly 指定不能从JavaScript脚本代码访问Cookie值。\n</code></pre><p> ####X-Download-Options: noopen<br>    noopen 用于指定IE 8以上版本的用户不打开文件而直接保存文件。在下载对话框中不显示“打开”选项。</p>\n<p> ####keepalive </p>\n<pre><code>若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;   \nhttp 1.0中默认是关闭的，需要在http头加入&quot;Connection: Keep-Alive&quot;，才能启用Keep-Alive；http 1.1中默认启用Keep-Alive，如果加入&quot;Connection: close &quot;，才关闭。目前大部分浏览器都是用http1.1协议，也就是说默认都会发起Keep-Alive的连接请求了，所以是否能完成一个完整的Keep-Alive连接就看服务器设置情况。\n</code></pre><p> ####headers</p>\n<p> Accept-Charset： 浏览器申明自己接收的字符集<br> Accept-Encoding： 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate） </p>\n<p>  Age：当代理服务器用自己缓存的实体去响应请求时，用该头部表明该实体从产生到现在经过多长时间了。   </p>\n<p>   http header 中使用location 进行302跳转 </p>\n<p>   URL.createObjectURL() 静态方法会创建一个 DOMString，其中包含一个表示参数中给出的对象的URL。这个 URL 的生命周期和创建它的窗口中的 document 绑定。这个新的URL 对象表示指定的 File 对象或 Blob 对象。</p>\n<p>####http<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http 1.1 添加cache-contol </span><br><span class=\"line\"></span><br><span class=\"line\">长连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个长连接，而HTP1.1默认支持长连接</span><br><span class=\"line\">节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）</span><br><span class=\"line\">host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端口）：HTTP1.0没有host域</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">http 2.0</span><br><span class=\"line\">采用二进制格式传输;</span><br><span class=\"line\">多路复用，其实就是将请求数据分成帧乱序发送到 TCP 中。TCP 只能有一个 steam，所以还是会阻塞;</span><br><span class=\"line\">报头压缩;</span><br><span class=\"line\">服务器推送主动向 B 端发送静态资源，避免往返延迟。</span><br><span class=\"line\">1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好</span><br><span class=\"line\">2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量</span><br><span class=\"line\">3.多路复用：一个连接可以并发处理多个请求</span><br><span class=\"line\">4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源</span><br><span class=\"line\"></span><br><span class=\"line\">http 3.0</span><br><span class=\"line\">采用 QUIC 协议,自定义连接机制;自定义重传机制;无阻塞的多路复用</span><br><span class=\"line\"></span><br><span class=\"line\">2.按缓存分：强缓存和协商缓存：</span><br><span class=\"line\">2.1强缓存：利用 cache-control 和 expires 设置，直接返回一个过期时间，所以在缓存期间不请求，If-modify-since；</span><br><span class=\"line\">2.2协商缓存：响应头返回 etag 或 last-modified 的哈希值，第二次请求头 If-none-match 或 IF-modify-since 携带上次哈希值，一致则返回 304。</span><br><span class=\"line\">F5 刷新会忽略强缓存不会忽略协商缓存，ctrl+f5 都失效</span><br><span class=\"line\">```       </span><br><span class=\"line\"></span><br><span class=\"line\">1. Https https://zhuanlan.zhihu.com/p/27395037    https://blog.51cto.com/11883699/2160032</span><br><span class=\"line\">1. Ca 使用证书颁发机构的证书中的公钥去解密被颁发者的指纹算法和指纹，并计算比对指纹，正确才能验证身份</span><br><span class=\"line\"></span><br><span class=\"line\">1. 缓存的分类：</span><br><span class=\"line\">```text</span><br><span class=\"line\">   强缓存：在缓存数据未失效的情况下，不需要再和服务器发生交互.cache-control :no-cache 走协商缓存</span><br><span class=\"line\">   协商缓存：需要与服务端校验是否使用缓存。etag If-None-Match HTTP 请求头内提供 ETag</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li><p>30X 区分</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">301，Moved Permanently。永久重定向，该操作比较危险，需要谨慎操作：如果设置了301，但是一段时间后又想取消，但是浏览器中已经有了缓存，还是会重定向。</span><br><span class=\"line\">302，Fount。临时重定向，但是会在重定向的时候改变 method: 把 POST 改成 GET，于是有了 307</span><br><span class=\"line\">307，Temporary Redirect。临时重定向，在重定向时不会改变 method</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>https </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这些ＣＡ本身也有证书来证明自己的身份，并且ＣＡ的信用是像树一样分级的，高层的ＣＡ给底层的ＣＡ做信用背书，而操作系统／浏览器中会内置一些顶层的ＣＡ的证书，相当于你自动信任了他们。　</span><br><span class=\"line\"></span><br><span class=\"line\">公钥+个人信息+其它信息—》hash 算法 —》信息摘要-》用ca的私钥加密—》数字签名   签名+信息=数字证书 </span><br><span class=\"line\">Ca 的公钥解密—》hash hash 算法 —》信息摘要-》对比是否一致</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>content-type</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">multipart/form-data</span><br><span class=\"line\"></span><br><span class=\"line\">请求消息头中, Content-Type: multipart/form-data; boundary=----WebKitFormBoundarykALcKBgBaI9xA79y</span><br><span class=\"line\">boundary为分隔符.</span><br><span class=\"line\"></span><br><span class=\"line\">application/x-www-form-urlencoded</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Nat network adreess translation 网络地址转换.<br>当访问外网时自动分配一个端口，这个端口和内网的机器建立了映射关系。</p>\n</li>\n<li><p>Defer</p>\n<p>这个属性的用途是表明脚本在执行时不会影响页面的构造。也就是说，脚本会被延迟到整个页面都解析完毕后再运行。因此，在script元素中设置defer属性，相当于告诉浏览器立即下载，但延迟执行。<br>但与defer不同的是，标记为async的脚本并不保证按照它们的先后顺序执行。</p>\n</li>\n<li><p>在 http 1.1 中，在响应头中设置 keep-alive 可以在一个 TCP 连接上发送多个 http 请求</p>\n<p>避免了重开 TCP 连接的开销<br>避免了刷新时重新建立 SSL 连接的开销<br>避免了QPS过大时，服务器的连接数过大</p>\n</li>\n<li><p>缓存协商</p>\n<p><code>`</code>text<br>我们知道协商缓存有两种方式</p>\n</li>\n</ol>\n<p>Last-Modified/if-Modified-Since  <strong> Last-Modified 是由一个 unix timestamp 表示，则意味着它只能作用于秒级的改变</strong><br>ETag/If-None-Match<br><code>`</code>     </p>\n<ol>\n<li>window.opener 表示打开当前窗体页面的的父窗体的是谁。例如，在 A 页面中，通过一个带有 target=”_blank” 的 a 标签打开了一个新的页面 B，那么在 B 页面里，window.opener 的值为 A 页面的 window 对象。   rel=noopener 规定禁止新页面传递源页面的地址，通过设置了此属性的链接打开的页面，其 window.opener 的值为 null。</li>\n<li>Gzip 不要使用再图片以及其它二进制文件上</li>\n</ol>\n"},{"title":"interview","date":"2017-01-23T10:25:52.000Z","_content":"\n\n1. 企业级的特点：\n```text\n是高效 + 成熟方案的整合\n关注生产的整个链路，而不是某个环节\n有更强的约束和限制\n更严苛的要求。性能、可扩展性(以应对不同的需求)、健壮性、稳定性、可用性、安全性\n标准化\n经过生产环境验证, 有较多用例保证\n\n```\n\n\n1. \n 而在底层，Node.js借助libuv来作为抽象封装层， 从而屏蔽不同操作系统的差异，Node可以借助livuv来来实现多线程。\n \n ![image](http://www.admin10000.com/UploadFiles/Document/201509/30/20150930072020634231.PNG)\n \n 事件循环是单线程的，从下图可以看出\n \n ![image](http://www.admin10000.com/UploadFiles/Document/201509/30/20150930072028113909.PNG)\n \n 所有的同步任务在主线程上执行，形成一个任务栈。所有的异步任务的回调在另一队列中，只有执行完\n \n tTimeout()只是将事件插入了\"任务队列\"，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行。\n \n Node.js也是单线程的Event Loop，但是它的运行机制不同于浏览器环境。\n \n ![image](http://image.beekka.com/blog/2014/bg2014100803.png)\n \n\n```\nprocess.nextTick(function A() {\n  console.log(1);\n  process.nextTick(function B(){console.log(2);});\n});\n\nsetTimeout(function timeout() {\n  console.log('TIMEOUT FIRED');\n}, 0)\n// 1\n// 2\n// TIMEOUT FIRED\n```\n\n上面代码中，由于process.nextTick方法指定的回调函数，总是在当前\"执行栈\"的尾部触发，所以不仅函数A比setTimeout指定的回调函数timeout先执行，而且函数B也比timeout先执行。这说明，如果有多个process.nextTick语句（不管它们是否嵌套），将全部在当前\"执行栈\"执行。   setImmediate总是将事件注册到下一轮Event Loop\n\n\n　测试金字塔指的是： 当我们在编写测试用例时，底层的单元测试应该远比上层的端到端测试要多。\n　\n\n数组的shift和unshift  push 和 pop \n\nnode 优势：非阻塞IO、高并发、丰富的生态环境\n\n node有哪些全局对象?\n参考答案: process, console, Buffer和exports\n![image](https://camo.githubusercontent.com/233315761d49d4c75fe7969e36bda22ecf5bbc0f/687474703a2f2f6a6f616f7073696c76612e6769746875622e696f2f74616c6b732f456e642d746f2d456e642d4a6176615363726970742d776974682d7468652d4d45414e2d537461636b2f696d672f6e6f64656a732d617263682d7070742e706e67)\n\nprocess有哪些常用方法?\n参考答案: process.stdin, process.stdout, process.stderr, process.on, process.env, process.argv, process.arch, process.platform, process.exit\n\n通过domain获取eventemmiter 的异常：\n\n```\nvar domain = require('domain');\n    var myDomain = domain.create();\n    myDomain.on('error', function(err){\n        console.log('domain接收到的错误事件:', err);\n    }); // 接收事件并打印\n    myDomain.run(function(){\n        var emitter1 = new MyEmitter();\n        emitter1.emit('error', '错误事件来自emitter1');\n        emitter2 = new MyEmitter();\n        emitter2.emit('error', '错误事件来自emitter2');\n    });\n```\n\nsupper 代表父类构造函数和原形\n\n\n原生构造函数：\nBoolean()\nNumber()\nString()\nArray()\nDate()\nFunction()\nRegExp()\nError()\nObject()\n\nEs6 可以继承这些原生的构造函数\n \n```\nclass MyArray extends Array {\n  constructor(...args) {\n    super(...args);\n  }\n}\n\nvar arr = new MyArray();\narr[0] = 12;\narr.length // 1\n\narr.length = 0;\narr[0] // undefined\n```\n\n```\nclass ExtendableError extends Error {\n  constructor(message) {\n    super();\n    this.message = message;\n    this.stack = (new Error()).stack;\n    this.name = this.constructor.name;\n  }\n}\n\nclass MyError extends ExtendableError {\n  constructor(m) {\n    super(m);\n  }\n}\n\nvar myerror = new MyError('ll');\nmyerror.message // \"ll\"\nmyerror instanceof Error // true\nmyerror.name // \"MyError\"\nmyerror.stack\n```\n\n定义get set ,可在方法体内部拦截\n\n```\nclass MyClass {\n  constructor() {\n    // ...\n  }\n  get prop() {\n    return 'getter';\n  }\n  set prop(value) {\n    console.log('setter: '+value);\n  }\n  * [Symbol.iterator]() {\n    for (let arg of this.args) {\n      yield arg;\n    }\n  }\n}\n```\n\nStream有什么好处?\n参考答案: 非阻塞式数据处理提升效率，片断处理节省内存，管道处理方便可扩展等.\n\n\nfs.watch和fs.watchFile有什么区别，怎么应用?\n参考答案: 二者主要用来监听文件变动．fs.watch利用操作系统原生机制来监听，可能不适用网络文件系统; fs.watchFile则是定期检查文件状态变更，适用于网络文件系统，但是相比fs.watch有些慢，因为不是实时机制．\n\n实现一个简单的HTTP 服务器。\nrequire('http').createServer(function(req,res){}).listen(300);\n\nspawn应用来运行返回大量数据的子进程，如图像处理，文件读取等。而exec则应用来运行只返回少量返回值的子进程，如只返回一个状态码。\n\n有哪些常用方法可以防止程序崩溃?\n\n参考答案: 1) try-catch-finally 2) EventEmitter/Stream error事件处理 3) domain统一控制 4) jshint静态检查 5) jasmine/mocha进行单元测试\n\n\n要监控nodejs的内存使用的话，需要安装memwathch 模块\n\nnodejs C++ 扩展的实现：\nhttps://my.oschina.net/yushulx/blog/423704\n\nprocess.argv 数组的第一个元素永远都会是 node，并且第二个参数总是指向你的程序的路径，所以，你应该从第三个元素\n\n\n```\nregex test   if (/^\\/api\\/parsetime/.test(req.url))\n```\n\n\n回调函数的规则：err 为第一个参数\n\n文件的总行：\n```\nvar lines = contents.toString().split('\\n').length - 1\n```\n\n\nfs.unlink 删除文件\n\n\n```\n//创建一个tcp 服务器\nvar net = require('net')\n\nvar server = net.createServer(function (socket) {\n\n  // socket 处理逻辑\n\n})\n\nserver.listen(8000)\n```\n\n\n使用 socket.write(data) 可以写数据到 socket 中，用 socket.end() 可以关闭一个 socket。另外， .end() 方法也可以接收一个数据对象作为参数，因此，你可简单地使用 socket.end(data) 来完成写数据和关闭两个操作。\n\nconcat-stream：会连接多个stream,参数中不指定encoding 的话，会自行推断。\n\n```\nvar arrays = concat({ encoding: 'array' }, function(out) {\n    t.deepEqual(out, [1,2,3,4,5,6])\n  })\n  arrays.write([1,2,3])\n  arrays.write([4,5,6])\n  arrays.end()\n```\n\n```\nfs.createReadStream(file).pipe(process.stdout);\n```\n使用through2 对流数据进行转换：\n\n通过split 将流中的数据分行：\n\nYou can use the `split` module to split input by newlines. For example:\n```\n    var split = require('split');\n    process.stdin\n        .pipe(split())\n        .pipe(through2(function (line, _, next) {\n            console.dir(line.toString());\n            next();\n        }))\n    ;\n```","source":"_posts/interview.md","raw":"---\ntitle: interview\ndate: 2017-01-23 18:25:52\ntags: interview\n---\n\n\n1. 企业级的特点：\n```text\n是高效 + 成熟方案的整合\n关注生产的整个链路，而不是某个环节\n有更强的约束和限制\n更严苛的要求。性能、可扩展性(以应对不同的需求)、健壮性、稳定性、可用性、安全性\n标准化\n经过生产环境验证, 有较多用例保证\n\n```\n\n\n1. \n 而在底层，Node.js借助libuv来作为抽象封装层， 从而屏蔽不同操作系统的差异，Node可以借助livuv来来实现多线程。\n \n ![image](http://www.admin10000.com/UploadFiles/Document/201509/30/20150930072020634231.PNG)\n \n 事件循环是单线程的，从下图可以看出\n \n ![image](http://www.admin10000.com/UploadFiles/Document/201509/30/20150930072028113909.PNG)\n \n 所有的同步任务在主线程上执行，形成一个任务栈。所有的异步任务的回调在另一队列中，只有执行完\n \n tTimeout()只是将事件插入了\"任务队列\"，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行。\n \n Node.js也是单线程的Event Loop，但是它的运行机制不同于浏览器环境。\n \n ![image](http://image.beekka.com/blog/2014/bg2014100803.png)\n \n\n```\nprocess.nextTick(function A() {\n  console.log(1);\n  process.nextTick(function B(){console.log(2);});\n});\n\nsetTimeout(function timeout() {\n  console.log('TIMEOUT FIRED');\n}, 0)\n// 1\n// 2\n// TIMEOUT FIRED\n```\n\n上面代码中，由于process.nextTick方法指定的回调函数，总是在当前\"执行栈\"的尾部触发，所以不仅函数A比setTimeout指定的回调函数timeout先执行，而且函数B也比timeout先执行。这说明，如果有多个process.nextTick语句（不管它们是否嵌套），将全部在当前\"执行栈\"执行。   setImmediate总是将事件注册到下一轮Event Loop\n\n\n　测试金字塔指的是： 当我们在编写测试用例时，底层的单元测试应该远比上层的端到端测试要多。\n　\n\n数组的shift和unshift  push 和 pop \n\nnode 优势：非阻塞IO、高并发、丰富的生态环境\n\n node有哪些全局对象?\n参考答案: process, console, Buffer和exports\n![image](https://camo.githubusercontent.com/233315761d49d4c75fe7969e36bda22ecf5bbc0f/687474703a2f2f6a6f616f7073696c76612e6769746875622e696f2f74616c6b732f456e642d746f2d456e642d4a6176615363726970742d776974682d7468652d4d45414e2d537461636b2f696d672f6e6f64656a732d617263682d7070742e706e67)\n\nprocess有哪些常用方法?\n参考答案: process.stdin, process.stdout, process.stderr, process.on, process.env, process.argv, process.arch, process.platform, process.exit\n\n通过domain获取eventemmiter 的异常：\n\n```\nvar domain = require('domain');\n    var myDomain = domain.create();\n    myDomain.on('error', function(err){\n        console.log('domain接收到的错误事件:', err);\n    }); // 接收事件并打印\n    myDomain.run(function(){\n        var emitter1 = new MyEmitter();\n        emitter1.emit('error', '错误事件来自emitter1');\n        emitter2 = new MyEmitter();\n        emitter2.emit('error', '错误事件来自emitter2');\n    });\n```\n\nsupper 代表父类构造函数和原形\n\n\n原生构造函数：\nBoolean()\nNumber()\nString()\nArray()\nDate()\nFunction()\nRegExp()\nError()\nObject()\n\nEs6 可以继承这些原生的构造函数\n \n```\nclass MyArray extends Array {\n  constructor(...args) {\n    super(...args);\n  }\n}\n\nvar arr = new MyArray();\narr[0] = 12;\narr.length // 1\n\narr.length = 0;\narr[0] // undefined\n```\n\n```\nclass ExtendableError extends Error {\n  constructor(message) {\n    super();\n    this.message = message;\n    this.stack = (new Error()).stack;\n    this.name = this.constructor.name;\n  }\n}\n\nclass MyError extends ExtendableError {\n  constructor(m) {\n    super(m);\n  }\n}\n\nvar myerror = new MyError('ll');\nmyerror.message // \"ll\"\nmyerror instanceof Error // true\nmyerror.name // \"MyError\"\nmyerror.stack\n```\n\n定义get set ,可在方法体内部拦截\n\n```\nclass MyClass {\n  constructor() {\n    // ...\n  }\n  get prop() {\n    return 'getter';\n  }\n  set prop(value) {\n    console.log('setter: '+value);\n  }\n  * [Symbol.iterator]() {\n    for (let arg of this.args) {\n      yield arg;\n    }\n  }\n}\n```\n\nStream有什么好处?\n参考答案: 非阻塞式数据处理提升效率，片断处理节省内存，管道处理方便可扩展等.\n\n\nfs.watch和fs.watchFile有什么区别，怎么应用?\n参考答案: 二者主要用来监听文件变动．fs.watch利用操作系统原生机制来监听，可能不适用网络文件系统; fs.watchFile则是定期检查文件状态变更，适用于网络文件系统，但是相比fs.watch有些慢，因为不是实时机制．\n\n实现一个简单的HTTP 服务器。\nrequire('http').createServer(function(req,res){}).listen(300);\n\nspawn应用来运行返回大量数据的子进程，如图像处理，文件读取等。而exec则应用来运行只返回少量返回值的子进程，如只返回一个状态码。\n\n有哪些常用方法可以防止程序崩溃?\n\n参考答案: 1) try-catch-finally 2) EventEmitter/Stream error事件处理 3) domain统一控制 4) jshint静态检查 5) jasmine/mocha进行单元测试\n\n\n要监控nodejs的内存使用的话，需要安装memwathch 模块\n\nnodejs C++ 扩展的实现：\nhttps://my.oschina.net/yushulx/blog/423704\n\nprocess.argv 数组的第一个元素永远都会是 node，并且第二个参数总是指向你的程序的路径，所以，你应该从第三个元素\n\n\n```\nregex test   if (/^\\/api\\/parsetime/.test(req.url))\n```\n\n\n回调函数的规则：err 为第一个参数\n\n文件的总行：\n```\nvar lines = contents.toString().split('\\n').length - 1\n```\n\n\nfs.unlink 删除文件\n\n\n```\n//创建一个tcp 服务器\nvar net = require('net')\n\nvar server = net.createServer(function (socket) {\n\n  // socket 处理逻辑\n\n})\n\nserver.listen(8000)\n```\n\n\n使用 socket.write(data) 可以写数据到 socket 中，用 socket.end() 可以关闭一个 socket。另外， .end() 方法也可以接收一个数据对象作为参数，因此，你可简单地使用 socket.end(data) 来完成写数据和关闭两个操作。\n\nconcat-stream：会连接多个stream,参数中不指定encoding 的话，会自行推断。\n\n```\nvar arrays = concat({ encoding: 'array' }, function(out) {\n    t.deepEqual(out, [1,2,3,4,5,6])\n  })\n  arrays.write([1,2,3])\n  arrays.write([4,5,6])\n  arrays.end()\n```\n\n```\nfs.createReadStream(file).pipe(process.stdout);\n```\n使用through2 对流数据进行转换：\n\n通过split 将流中的数据分行：\n\nYou can use the `split` module to split input by newlines. For example:\n```\n    var split = require('split');\n    process.stdin\n        .pipe(split())\n        .pipe(through2(function (line, _, next) {\n            console.dir(line.toString());\n            next();\n        }))\n    ;\n```","slug":"interview","published":1,"updated":"2020-01-02T07:51:24.096Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5bwexcv000m998sbecgs4yw","content":"<ol>\n<li><p>企业级的特点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">是高效 + 成熟方案的整合</span><br><span class=\"line\">关注生产的整个链路，而不是某个环节</span><br><span class=\"line\">有更强的约束和限制</span><br><span class=\"line\">更严苛的要求。性能、可扩展性(以应对不同的需求)、健壮性、稳定性、可用性、安全性</span><br><span class=\"line\">标准化</span><br><span class=\"line\">经过生产环境验证, 有较多用例保证</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>而在底层，Node.js借助libuv来作为抽象封装层， 从而屏蔽不同操作系统的差异，Node可以借助livuv来来实现多线程。</p>\n<p><img src=\"http://www.admin10000.com/UploadFiles/Document/201509/30/20150930072020634231.PNG\" alt=\"image\"></p>\n<p>事件循环是单线程的，从下图可以看出</p>\n<p><img src=\"http://www.admin10000.com/UploadFiles/Document/201509/30/20150930072028113909.PNG\" alt=\"image\"></p>\n<p>所有的同步任务在主线程上执行，形成一个任务栈。所有的异步任务的回调在另一队列中，只有执行完</p>\n<p>tTimeout()只是将事件插入了”任务队列”，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行。</p>\n<p>Node.js也是单线程的Event Loop，但是它的运行机制不同于浏览器环境。</p>\n<p><img src=\"http://image.beekka.com/blog/2014/bg2014100803.png\" alt=\"image\"></p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">process.nextTick(function A() &#123;</span><br><span class=\"line\">  console.log(1);</span><br><span class=\"line\">  process.nextTick(function B()&#123;console.log(2);&#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(function timeout() &#123;</span><br><span class=\"line\">  console.log(&apos;TIMEOUT FIRED&apos;);</span><br><span class=\"line\">&#125;, 0)</span><br><span class=\"line\">// 1</span><br><span class=\"line\">// 2</span><br><span class=\"line\">// TIMEOUT FIRED</span><br></pre></td></tr></table></figure>\n<p>上面代码中，由于process.nextTick方法指定的回调函数，总是在当前”执行栈”的尾部触发，所以不仅函数A比setTimeout指定的回调函数timeout先执行，而且函数B也比timeout先执行。这说明，如果有多个process.nextTick语句（不管它们是否嵌套），将全部在当前”执行栈”执行。   setImmediate总是将事件注册到下一轮Event Loop</p>\n<p>　测试金字塔指的是： 当我们在编写测试用例时，底层的单元测试应该远比上层的端到端测试要多。\n　</p>\n<p>数组的shift和unshift  push 和 pop </p>\n<p>node 优势：非阻塞IO、高并发、丰富的生态环境</p>\n<p> node有哪些全局对象?<br>参考答案: process, console, Buffer和exports<br><img src=\"https://camo.githubusercontent.com/233315761d49d4c75fe7969e36bda22ecf5bbc0f/687474703a2f2f6a6f616f7073696c76612e6769746875622e696f2f74616c6b732f456e642d746f2d456e642d4a6176615363726970742d776974682d7468652d4d45414e2d537461636b2f696d672f6e6f64656a732d617263682d7070742e706e67\" alt=\"image\"></p>\n<p>process有哪些常用方法?<br>参考答案: process.stdin, process.stdout, process.stderr, process.on, process.env, process.argv, process.arch, process.platform, process.exit</p>\n<p>通过domain获取eventemmiter 的异常：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var domain = require(&apos;domain&apos;);</span><br><span class=\"line\">    var myDomain = domain.create();</span><br><span class=\"line\">    myDomain.on(&apos;error&apos;, function(err)&#123;</span><br><span class=\"line\">        console.log(&apos;domain接收到的错误事件:&apos;, err);</span><br><span class=\"line\">    &#125;); // 接收事件并打印</span><br><span class=\"line\">    myDomain.run(function()&#123;</span><br><span class=\"line\">        var emitter1 = new MyEmitter();</span><br><span class=\"line\">        emitter1.emit(&apos;error&apos;, &apos;错误事件来自emitter1&apos;);</span><br><span class=\"line\">        emitter2 = new MyEmitter();</span><br><span class=\"line\">        emitter2.emit(&apos;error&apos;, &apos;错误事件来自emitter2&apos;);</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>supper 代表父类构造函数和原形</p>\n<p>原生构造函数：<br>Boolean()<br>Number()<br>String()<br>Array()<br>Date()<br>Function()<br>RegExp()<br>Error()<br>Object()</p>\n<p>Es6 可以继承这些原生的构造函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyArray extends Array &#123;</span><br><span class=\"line\">  constructor(...args) &#123;</span><br><span class=\"line\">    super(...args);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var arr = new MyArray();</span><br><span class=\"line\">arr[0] = 12;</span><br><span class=\"line\">arr.length // 1</span><br><span class=\"line\"></span><br><span class=\"line\">arr.length = 0;</span><br><span class=\"line\">arr[0] // undefined</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class ExtendableError extends Error &#123;</span><br><span class=\"line\">  constructor(message) &#123;</span><br><span class=\"line\">    super();</span><br><span class=\"line\">    this.message = message;</span><br><span class=\"line\">    this.stack = (new Error()).stack;</span><br><span class=\"line\">    this.name = this.constructor.name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class MyError extends ExtendableError &#123;</span><br><span class=\"line\">  constructor(m) &#123;</span><br><span class=\"line\">    super(m);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var myerror = new MyError(&apos;ll&apos;);</span><br><span class=\"line\">myerror.message // &quot;ll&quot;</span><br><span class=\"line\">myerror instanceof Error // true</span><br><span class=\"line\">myerror.name // &quot;MyError&quot;</span><br><span class=\"line\">myerror.stack</span><br></pre></td></tr></table></figure>\n<p>定义get set ,可在方法体内部拦截</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyClass &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  get prop() &#123;</span><br><span class=\"line\">    return &apos;getter&apos;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  set prop(value) &#123;</span><br><span class=\"line\">    console.log(&apos;setter: &apos;+value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  * [Symbol.iterator]() &#123;</span><br><span class=\"line\">    for (let arg of this.args) &#123;</span><br><span class=\"line\">      yield arg;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Stream有什么好处?<br>参考答案: 非阻塞式数据处理提升效率，片断处理节省内存，管道处理方便可扩展等.</p>\n<p>fs.watch和fs.watchFile有什么区别，怎么应用?<br>参考答案: 二者主要用来监听文件变动．fs.watch利用操作系统原生机制来监听，可能不适用网络文件系统; fs.watchFile则是定期检查文件状态变更，适用于网络文件系统，但是相比fs.watch有些慢，因为不是实时机制．</p>\n<p>实现一个简单的HTTP 服务器。<br>require(‘http’).createServer(function(req,res){}).listen(300);</p>\n<p>spawn应用来运行返回大量数据的子进程，如图像处理，文件读取等。而exec则应用来运行只返回少量返回值的子进程，如只返回一个状态码。</p>\n<p>有哪些常用方法可以防止程序崩溃?</p>\n<p>参考答案: 1) try-catch-finally 2) EventEmitter/Stream error事件处理 3) domain统一控制 4) jshint静态检查 5) jasmine/mocha进行单元测试</p>\n<p>要监控nodejs的内存使用的话，需要安装memwathch 模块</p>\n<p>nodejs C++ 扩展的实现：<br><a href=\"https://my.oschina.net/yushulx/blog/423704\" target=\"_blank\" rel=\"noopener\">https://my.oschina.net/yushulx/blog/423704</a></p>\n<p>process.argv 数组的第一个元素永远都会是 node，并且第二个参数总是指向你的程序的路径，所以，你应该从第三个元素</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">regex test   if (/^\\/api\\/parsetime/.test(req.url))</span><br></pre></td></tr></table></figure>\n<p>回调函数的规则：err 为第一个参数</p>\n<p>文件的总行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var lines = contents.toString().split(&apos;\\n&apos;).length - 1</span><br></pre></td></tr></table></figure></p>\n<p>fs.unlink 删除文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//创建一个tcp 服务器</span><br><span class=\"line\">var net = require(&apos;net&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">var server = net.createServer(function (socket) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  // socket 处理逻辑</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(8000)</span><br></pre></td></tr></table></figure>\n<p>使用 socket.write(data) 可以写数据到 socket 中，用 socket.end() 可以关闭一个 socket。另外， .end() 方法也可以接收一个数据对象作为参数，因此，你可简单地使用 socket.end(data) 来完成写数据和关闭两个操作。</p>\n<p>concat-stream：会连接多个stream,参数中不指定encoding 的话，会自行推断。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arrays = concat(&#123; encoding: &apos;array&apos; &#125;, function(out) &#123;</span><br><span class=\"line\">    t.deepEqual(out, [1,2,3,4,5,6])</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  arrays.write([1,2,3])</span><br><span class=\"line\">  arrays.write([4,5,6])</span><br><span class=\"line\">  arrays.end()</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fs.createReadStream(file).pipe(process.stdout);</span><br></pre></td></tr></table></figure>\n<p>使用through2 对流数据进行转换：</p>\n<p>通过split 将流中的数据分行：</p>\n<p>You can use the <code>split</code> module to split input by newlines. For example:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var split = require(&apos;split&apos;);</span><br><span class=\"line\">process.stdin</span><br><span class=\"line\">    .pipe(split())</span><br><span class=\"line\">    .pipe(through2(function (line, _, next) &#123;</span><br><span class=\"line\">        console.dir(line.toString());</span><br><span class=\"line\">        next();</span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><p>企业级的特点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">是高效 + 成熟方案的整合</span><br><span class=\"line\">关注生产的整个链路，而不是某个环节</span><br><span class=\"line\">有更强的约束和限制</span><br><span class=\"line\">更严苛的要求。性能、可扩展性(以应对不同的需求)、健壮性、稳定性、可用性、安全性</span><br><span class=\"line\">标准化</span><br><span class=\"line\">经过生产环境验证, 有较多用例保证</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>而在底层，Node.js借助libuv来作为抽象封装层， 从而屏蔽不同操作系统的差异，Node可以借助livuv来来实现多线程。</p>\n<p><img src=\"http://www.admin10000.com/UploadFiles/Document/201509/30/20150930072020634231.PNG\" alt=\"image\"></p>\n<p>事件循环是单线程的，从下图可以看出</p>\n<p><img src=\"http://www.admin10000.com/UploadFiles/Document/201509/30/20150930072028113909.PNG\" alt=\"image\"></p>\n<p>所有的同步任务在主线程上执行，形成一个任务栈。所有的异步任务的回调在另一队列中，只有执行完</p>\n<p>tTimeout()只是将事件插入了”任务队列”，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行。</p>\n<p>Node.js也是单线程的Event Loop，但是它的运行机制不同于浏览器环境。</p>\n<p><img src=\"http://image.beekka.com/blog/2014/bg2014100803.png\" alt=\"image\"></p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">process.nextTick(function A() &#123;</span><br><span class=\"line\">  console.log(1);</span><br><span class=\"line\">  process.nextTick(function B()&#123;console.log(2);&#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(function timeout() &#123;</span><br><span class=\"line\">  console.log(&apos;TIMEOUT FIRED&apos;);</span><br><span class=\"line\">&#125;, 0)</span><br><span class=\"line\">// 1</span><br><span class=\"line\">// 2</span><br><span class=\"line\">// TIMEOUT FIRED</span><br></pre></td></tr></table></figure>\n<p>上面代码中，由于process.nextTick方法指定的回调函数，总是在当前”执行栈”的尾部触发，所以不仅函数A比setTimeout指定的回调函数timeout先执行，而且函数B也比timeout先执行。这说明，如果有多个process.nextTick语句（不管它们是否嵌套），将全部在当前”执行栈”执行。   setImmediate总是将事件注册到下一轮Event Loop</p>\n<p>　测试金字塔指的是： 当我们在编写测试用例时，底层的单元测试应该远比上层的端到端测试要多。\n　</p>\n<p>数组的shift和unshift  push 和 pop </p>\n<p>node 优势：非阻塞IO、高并发、丰富的生态环境</p>\n<p> node有哪些全局对象?<br>参考答案: process, console, Buffer和exports<br><img src=\"https://camo.githubusercontent.com/233315761d49d4c75fe7969e36bda22ecf5bbc0f/687474703a2f2f6a6f616f7073696c76612e6769746875622e696f2f74616c6b732f456e642d746f2d456e642d4a6176615363726970742d776974682d7468652d4d45414e2d537461636b2f696d672f6e6f64656a732d617263682d7070742e706e67\" alt=\"image\"></p>\n<p>process有哪些常用方法?<br>参考答案: process.stdin, process.stdout, process.stderr, process.on, process.env, process.argv, process.arch, process.platform, process.exit</p>\n<p>通过domain获取eventemmiter 的异常：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var domain = require(&apos;domain&apos;);</span><br><span class=\"line\">    var myDomain = domain.create();</span><br><span class=\"line\">    myDomain.on(&apos;error&apos;, function(err)&#123;</span><br><span class=\"line\">        console.log(&apos;domain接收到的错误事件:&apos;, err);</span><br><span class=\"line\">    &#125;); // 接收事件并打印</span><br><span class=\"line\">    myDomain.run(function()&#123;</span><br><span class=\"line\">        var emitter1 = new MyEmitter();</span><br><span class=\"line\">        emitter1.emit(&apos;error&apos;, &apos;错误事件来自emitter1&apos;);</span><br><span class=\"line\">        emitter2 = new MyEmitter();</span><br><span class=\"line\">        emitter2.emit(&apos;error&apos;, &apos;错误事件来自emitter2&apos;);</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>supper 代表父类构造函数和原形</p>\n<p>原生构造函数：<br>Boolean()<br>Number()<br>String()<br>Array()<br>Date()<br>Function()<br>RegExp()<br>Error()<br>Object()</p>\n<p>Es6 可以继承这些原生的构造函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyArray extends Array &#123;</span><br><span class=\"line\">  constructor(...args) &#123;</span><br><span class=\"line\">    super(...args);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var arr = new MyArray();</span><br><span class=\"line\">arr[0] = 12;</span><br><span class=\"line\">arr.length // 1</span><br><span class=\"line\"></span><br><span class=\"line\">arr.length = 0;</span><br><span class=\"line\">arr[0] // undefined</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class ExtendableError extends Error &#123;</span><br><span class=\"line\">  constructor(message) &#123;</span><br><span class=\"line\">    super();</span><br><span class=\"line\">    this.message = message;</span><br><span class=\"line\">    this.stack = (new Error()).stack;</span><br><span class=\"line\">    this.name = this.constructor.name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class MyError extends ExtendableError &#123;</span><br><span class=\"line\">  constructor(m) &#123;</span><br><span class=\"line\">    super(m);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var myerror = new MyError(&apos;ll&apos;);</span><br><span class=\"line\">myerror.message // &quot;ll&quot;</span><br><span class=\"line\">myerror instanceof Error // true</span><br><span class=\"line\">myerror.name // &quot;MyError&quot;</span><br><span class=\"line\">myerror.stack</span><br></pre></td></tr></table></figure>\n<p>定义get set ,可在方法体内部拦截</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyClass &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  get prop() &#123;</span><br><span class=\"line\">    return &apos;getter&apos;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  set prop(value) &#123;</span><br><span class=\"line\">    console.log(&apos;setter: &apos;+value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  * [Symbol.iterator]() &#123;</span><br><span class=\"line\">    for (let arg of this.args) &#123;</span><br><span class=\"line\">      yield arg;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Stream有什么好处?<br>参考答案: 非阻塞式数据处理提升效率，片断处理节省内存，管道处理方便可扩展等.</p>\n<p>fs.watch和fs.watchFile有什么区别，怎么应用?<br>参考答案: 二者主要用来监听文件变动．fs.watch利用操作系统原生机制来监听，可能不适用网络文件系统; fs.watchFile则是定期检查文件状态变更，适用于网络文件系统，但是相比fs.watch有些慢，因为不是实时机制．</p>\n<p>实现一个简单的HTTP 服务器。<br>require(‘http’).createServer(function(req,res){}).listen(300);</p>\n<p>spawn应用来运行返回大量数据的子进程，如图像处理，文件读取等。而exec则应用来运行只返回少量返回值的子进程，如只返回一个状态码。</p>\n<p>有哪些常用方法可以防止程序崩溃?</p>\n<p>参考答案: 1) try-catch-finally 2) EventEmitter/Stream error事件处理 3) domain统一控制 4) jshint静态检查 5) jasmine/mocha进行单元测试</p>\n<p>要监控nodejs的内存使用的话，需要安装memwathch 模块</p>\n<p>nodejs C++ 扩展的实现：<br><a href=\"https://my.oschina.net/yushulx/blog/423704\" target=\"_blank\" rel=\"noopener\">https://my.oschina.net/yushulx/blog/423704</a></p>\n<p>process.argv 数组的第一个元素永远都会是 node，并且第二个参数总是指向你的程序的路径，所以，你应该从第三个元素</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">regex test   if (/^\\/api\\/parsetime/.test(req.url))</span><br></pre></td></tr></table></figure>\n<p>回调函数的规则：err 为第一个参数</p>\n<p>文件的总行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var lines = contents.toString().split(&apos;\\n&apos;).length - 1</span><br></pre></td></tr></table></figure></p>\n<p>fs.unlink 删除文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//创建一个tcp 服务器</span><br><span class=\"line\">var net = require(&apos;net&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">var server = net.createServer(function (socket) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  // socket 处理逻辑</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(8000)</span><br></pre></td></tr></table></figure>\n<p>使用 socket.write(data) 可以写数据到 socket 中，用 socket.end() 可以关闭一个 socket。另外， .end() 方法也可以接收一个数据对象作为参数，因此，你可简单地使用 socket.end(data) 来完成写数据和关闭两个操作。</p>\n<p>concat-stream：会连接多个stream,参数中不指定encoding 的话，会自行推断。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arrays = concat(&#123; encoding: &apos;array&apos; &#125;, function(out) &#123;</span><br><span class=\"line\">    t.deepEqual(out, [1,2,3,4,5,6])</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  arrays.write([1,2,3])</span><br><span class=\"line\">  arrays.write([4,5,6])</span><br><span class=\"line\">  arrays.end()</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fs.createReadStream(file).pipe(process.stdout);</span><br></pre></td></tr></table></figure>\n<p>使用through2 对流数据进行转换：</p>\n<p>通过split 将流中的数据分行：</p>\n<p>You can use the <code>split</code> module to split input by newlines. For example:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var split = require(&apos;split&apos;);</span><br><span class=\"line\">process.stdin</span><br><span class=\"line\">    .pipe(split())</span><br><span class=\"line\">    .pipe(through2(function (line, _, next) &#123;</span><br><span class=\"line\">        console.dir(line.toString());</span><br><span class=\"line\">        next();</span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"linux","date":"2019-07-02T03:39:34.000Z","_content":"\n### command\n1. Linux touch 命令用于修改文件或者目录的时间属性,包括存取时间和更改时间。若文件不存在,系统会建立一个新的文件。\n\n1. which 指令会在环境变量\\$PATH 设置的目录里查找符合条件的文件。\n   \n1. \n\n","source":"_posts/linux.md","raw":"---\ntitle: linux\ndate: 2019-07-02 11:39:34\ntags: ops\n---\n\n### command\n1. Linux touch 命令用于修改文件或者目录的时间属性,包括存取时间和更改时间。若文件不存在,系统会建立一个新的文件。\n\n1. which 指令会在环境变量\\$PATH 设置的目录里查找符合条件的文件。\n   \n1. \n\n","slug":"linux","published":1,"updated":"2020-01-02T08:16:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5bwexcw000n998sb83wp3kg","content":"<h3 id=\"command\"><a href=\"#command\" class=\"headerlink\" title=\"command\"></a>command</h3><ol>\n<li><p>Linux touch 命令用于修改文件或者目录的时间属性,包括存取时间和更改时间。若文件不存在,系统会建立一个新的文件。</p>\n</li>\n<li><p>which 指令会在环境变量\\$PATH 设置的目录里查找符合条件的文件。</p>\n</li>\n<li></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"command\"><a href=\"#command\" class=\"headerlink\" title=\"command\"></a>command</h3><ol>\n<li><p>Linux touch 命令用于修改文件或者目录的时间属性,包括存取时间和更改时间。若文件不存在,系统会建立一个新的文件。</p>\n</li>\n<li><p>which 指令会在环境变量\\$PATH 设置的目录里查找符合条件的文件。</p>\n</li>\n<li></li>\n</ol>\n"},{"title":"loadtest","date":"2017-01-17T01:41:01.000Z","_content":"### loadtest 压力测试\n可用powershell 或linux bash \n\n命令行如果加post body 会报错\n\n常用参数：\n\n-T 表示持续时间\n\n-c 并行数量\n\n-n 总的请求\n\n-m  get,put,post\n\n--rps 每秒发送请求数\n\n-P Request body 数据\n\n-p body 数据存在的文件路径\n\n-H header 添加\n\n-C 设置cookie\n```\nparam(\n    [int] $iterations = 6000,\n    [int] $rps = 500,\n    [string][ValidateSet(\"plaintext\")] $variation = \"plaintext\")\n\nif ($variation -eq \"plaintext\")\n{\n    $url = \"http://wh.etao.cn/auth/test\"\n}\n\nWrite-Host -ForegroundColor Green Beginning workload\nWrite-Host \"`& loadtest -k -n $iterations -c 100 --rps $rps $url\"\nWrite-Host\n\n& loadtest -k -n $iterations -c 100 --rps $rps $url\n```\n\n```\nloadtest -c 5 -t 2 -m post -T 'application/json'  -P '{\"message\":\"hello\"}'  -H \"Accept: application/json; q=0.9, application/xml; q=0.6\" http://cttest.etao.cn:8011/api/auth/test\n```\n","source":"_posts/loadtest.md","raw":"---\ntitle: loadtest\ndate: 2017-01-17 09:41:01\ntags: loadtest\n---\n### loadtest 压力测试\n可用powershell 或linux bash \n\n命令行如果加post body 会报错\n\n常用参数：\n\n-T 表示持续时间\n\n-c 并行数量\n\n-n 总的请求\n\n-m  get,put,post\n\n--rps 每秒发送请求数\n\n-P Request body 数据\n\n-p body 数据存在的文件路径\n\n-H header 添加\n\n-C 设置cookie\n```\nparam(\n    [int] $iterations = 6000,\n    [int] $rps = 500,\n    [string][ValidateSet(\"plaintext\")] $variation = \"plaintext\")\n\nif ($variation -eq \"plaintext\")\n{\n    $url = \"http://wh.etao.cn/auth/test\"\n}\n\nWrite-Host -ForegroundColor Green Beginning workload\nWrite-Host \"`& loadtest -k -n $iterations -c 100 --rps $rps $url\"\nWrite-Host\n\n& loadtest -k -n $iterations -c 100 --rps $rps $url\n```\n\n```\nloadtest -c 5 -t 2 -m post -T 'application/json'  -P '{\"message\":\"hello\"}'  -H \"Accept: application/json; q=0.9, application/xml; q=0.6\" http://cttest.etao.cn:8011/api/auth/test\n```\n","slug":"loadtest","published":1,"updated":"2019-07-26T08:35:17.306Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5bwexcy000q998saek7d62m","content":"<h3 id=\"loadtest-压力测试\"><a href=\"#loadtest-压力测试\" class=\"headerlink\" title=\"loadtest 压力测试\"></a>loadtest 压力测试</h3><p>可用powershell 或linux bash </p>\n<p>命令行如果加post body 会报错</p>\n<p>常用参数：</p>\n<p>-T 表示持续时间</p>\n<p>-c 并行数量</p>\n<p>-n 总的请求</p>\n<p>-m  get,put,post</p>\n<p>–rps 每秒发送请求数</p>\n<p>-P Request body 数据</p>\n<p>-p body 数据存在的文件路径</p>\n<p>-H header 添加</p>\n<p>-C 设置cookie<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">param(</span><br><span class=\"line\">    [int] $iterations = 6000,</span><br><span class=\"line\">    [int] $rps = 500,</span><br><span class=\"line\">    [string][ValidateSet(&quot;plaintext&quot;)] $variation = &quot;plaintext&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">if ($variation -eq &quot;plaintext&quot;)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    $url = &quot;http://wh.etao.cn/auth/test&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Write-Host -ForegroundColor Green Beginning workload</span><br><span class=\"line\">Write-Host &quot;`&amp; loadtest -k -n $iterations -c 100 --rps $rps $url&quot;</span><br><span class=\"line\">Write-Host</span><br><span class=\"line\"></span><br><span class=\"line\">&amp; loadtest -k -n $iterations -c 100 --rps $rps $url</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loadtest -c 5 -t 2 -m post -T &apos;application/json&apos;  -P &apos;&#123;&quot;message&quot;:&quot;hello&quot;&#125;&apos;  -H &quot;Accept: application/json; q=0.9, application/xml; q=0.6&quot; http://cttest.etao.cn:8011/api/auth/test</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"loadtest-压力测试\"><a href=\"#loadtest-压力测试\" class=\"headerlink\" title=\"loadtest 压力测试\"></a>loadtest 压力测试</h3><p>可用powershell 或linux bash </p>\n<p>命令行如果加post body 会报错</p>\n<p>常用参数：</p>\n<p>-T 表示持续时间</p>\n<p>-c 并行数量</p>\n<p>-n 总的请求</p>\n<p>-m  get,put,post</p>\n<p>–rps 每秒发送请求数</p>\n<p>-P Request body 数据</p>\n<p>-p body 数据存在的文件路径</p>\n<p>-H header 添加</p>\n<p>-C 设置cookie<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">param(</span><br><span class=\"line\">    [int] $iterations = 6000,</span><br><span class=\"line\">    [int] $rps = 500,</span><br><span class=\"line\">    [string][ValidateSet(&quot;plaintext&quot;)] $variation = &quot;plaintext&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">if ($variation -eq &quot;plaintext&quot;)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    $url = &quot;http://wh.etao.cn/auth/test&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Write-Host -ForegroundColor Green Beginning workload</span><br><span class=\"line\">Write-Host &quot;`&amp; loadtest -k -n $iterations -c 100 --rps $rps $url&quot;</span><br><span class=\"line\">Write-Host</span><br><span class=\"line\"></span><br><span class=\"line\">&amp; loadtest -k -n $iterations -c 100 --rps $rps $url</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loadtest -c 5 -t 2 -m post -T &apos;application/json&apos;  -P &apos;&#123;&quot;message&quot;:&quot;hello&quot;&#125;&apos;  -H &quot;Accept: application/json; q=0.9, application/xml; q=0.6&quot; http://cttest.etao.cn:8011/api/auth/test</span><br></pre></td></tr></table></figure>\n"},{"title":"package","date":"2019-02-14T09:19:12.000Z","_content":"\n1. Opn: A better node-open. Opens stuff like websites, files, executables. Cross-platform.\n2. Ora:进度条和文字。\n3. joi：数据验\n4. satisfies ：版本工具\n5. minimist：简单的参数处理\n6. read-pkg:规范化解析pkg\n7. inquirer:询问时可以给出选项\n8. Resovel:解析包的安装路径\n9. slash:Convert Windows backslash paths to slash paths: foo\\\\bar ➔ foo/bar\n1. klaw-sync:回遍历出所有文件，并返回文件路径和文件夹\n1. mime-types content-type 工具：1. 可以根据文件后缀获取 2. 根据content-type获取charset 3. 根据content-type 获取默认的文件名\n1. CodeMirror是一个运行在浏览器中的在线代码编辑器，支持100多种语言，高度可定制。\n1. @typescript-eslint/eslint-plugin.  eslint 检测typescript \n1. nanoid  A tiny, secure, URL-friendly, unique string ID generator for JavaScript.\n1. mm 对mudule 中的方法mock\n1. numerify  用来格式化数字 \n   \n1. utils-lite  前端提供debounce、thorttling、clone、cloneDeep 等方法\n1. is-type-of   node check 数据类型\n1. on-finished  Execute a callback when a HTTP request closes, finishes, or errors\n1. await-event  封装了promise \n```javascript\nvar PassThrough = require('stream').PassThrough\n \nvar stream = new PassThrough()\n// you attach it directly on an event emitter\nstream.await = require('await-event')\n \nco(function* () {\n  var chunk = yield stream.await('data')\n  var chunk = yield stream.await('data')\n  var chunk = yield stream.await('data')\n}).catch(noop)\n \nstream.write('some chunk’) \n```\n1. get-ready  NodeJS mixin to add one-time ready event\n1. ShellJS 是Unix shell命令在Node.js API上的可移植实现\n1. graceful-process   graceful exit process even parent exit on SIGKILL.\n1. semver.gte(process.version, '7.0.0’)  版本的比对 \n1. pkgfiles  自动再package中添加 npm publish 文件\n1. depd  标注方法deprecating \n1. http-errors   http错误  \n1. Global-tunnel  http请求的全局代理  \n1. humanize-ms  转义为ms  \n```\ntransform humanize time to ms  ms('1s') // 1000\nms(1000) // 1000\n```\n1. Exceljs 一个功能强大的excel 处理包\n1. ready-callback 所有注册的事件完成后，才执行ready中方法\n1. Get-ready  NodeJS mixin to add one-time ready event，ready 后执行相关方法\n1. xml2js  将xml 转换为json \n1. debug  调试状态输出  debug=*  debug=work:*   \n1. delegates  node模块中代理proto中属性的方法、setter和getter\n1. chokidar filewatch \n1. Puppeteer  headless browser\n1. cross-env Run scripts that set and use environment variables across platforms\n1. simplemde  markdown editor \n1. serialize-javascript  Serialize JavaScript to a superset of JSON that includes regular expressions and functions.\n1.route-cache  express router cache\n```javascript\nvar routeCache = require('route-cache');\n \n// cache route for 20 seconds\napp.get('/index', routeCache.cacheSeconds(20), function(req, res){\n  // do your dirty work here...\n  console.log('you will only see this every 20 seconds.');\n  res.send('this response will be cached');\n});\n```\n1. Ws server 端的websoket \n1. fastclick  解决浏览器点击的延迟\n1. Qs  A querystring parsing and stringifying library with some added security.\n1. lru-cache  A cache object that deletes the least-recently-used items.\n1. memory-fs  A simple in-memory filesystem. Holds data in a javascript object\n1. faker.js  generate massive amounts of fake data in the browser and node.js\n1. parseurl 等同node url parse，加了cache\n1. vue-lazy-component   Vue.js 2.x 组件级懒加载方案-Vue.js 2.x component level lazy loading solution\n1. async-validator  数据验证\n1. fast-safe-stringify    Safe and fast serialization alternative to JSON.stringify.\n1. node-notifier   Send cross platform native notifications using Node.js.\n1. dateformat   node 时间处理函数\n1. agentkeepalive  defaut is keepalive\n1. copy-to   copy an object's properties to another one, include propertiy, getter and setter.\n1. platform   A platform detection library that works on nearly all JavaScript platforms.\n\n1. svg-captcha 验证码  \n1. vue-virtual-scroller  加载大量数据\n1. FileSaver.js  保存大于 ram的文档\n1. vue-draggable-resizable  Vue2 Component for draggable and resizable elements.\n1. ScrollTrigger  根据滚动位置出发事件\n1. Vue Virtual Scroller   RecycleScroller 可以渲染列表中的可见项目。如果你不知道项目的大小，最好使用 DynamicScroller\n1. Vuetensils  没有样式的component,可定制自己样式\n1. v-calendar  日历插件\n1. vue-grid-layout 可以拖拽的布局控件\n1. Vue-content-loader  占位符控件\n1. Sinon   node 端监控方法执行、mock、spy\n1. figlet  控制台标题文字\n1. Cockatiel  是一个弹性和瞬态故障处理库，如重试，断路器，超时，隔板隔离和回退之类的策略。\n1. Signale  一个 Node 的日志格式库，自带16个级别，可以定制颜色和 Emoji。\n1. Wiki.js  构建wiki 文档管理 ","source":"_posts/package.md","raw":"---\ntitle: package\ndate: 2019-02-14 17:19:12\ntags: useful package\n---\n\n1. Opn: A better node-open. Opens stuff like websites, files, executables. Cross-platform.\n2. Ora:进度条和文字。\n3. joi：数据验\n4. satisfies ：版本工具\n5. minimist：简单的参数处理\n6. read-pkg:规范化解析pkg\n7. inquirer:询问时可以给出选项\n8. Resovel:解析包的安装路径\n9. slash:Convert Windows backslash paths to slash paths: foo\\\\bar ➔ foo/bar\n1. klaw-sync:回遍历出所有文件，并返回文件路径和文件夹\n1. mime-types content-type 工具：1. 可以根据文件后缀获取 2. 根据content-type获取charset 3. 根据content-type 获取默认的文件名\n1. CodeMirror是一个运行在浏览器中的在线代码编辑器，支持100多种语言，高度可定制。\n1. @typescript-eslint/eslint-plugin.  eslint 检测typescript \n1. nanoid  A tiny, secure, URL-friendly, unique string ID generator for JavaScript.\n1. mm 对mudule 中的方法mock\n1. numerify  用来格式化数字 \n   \n1. utils-lite  前端提供debounce、thorttling、clone、cloneDeep 等方法\n1. is-type-of   node check 数据类型\n1. on-finished  Execute a callback when a HTTP request closes, finishes, or errors\n1. await-event  封装了promise \n```javascript\nvar PassThrough = require('stream').PassThrough\n \nvar stream = new PassThrough()\n// you attach it directly on an event emitter\nstream.await = require('await-event')\n \nco(function* () {\n  var chunk = yield stream.await('data')\n  var chunk = yield stream.await('data')\n  var chunk = yield stream.await('data')\n}).catch(noop)\n \nstream.write('some chunk’) \n```\n1. get-ready  NodeJS mixin to add one-time ready event\n1. ShellJS 是Unix shell命令在Node.js API上的可移植实现\n1. graceful-process   graceful exit process even parent exit on SIGKILL.\n1. semver.gte(process.version, '7.0.0’)  版本的比对 \n1. pkgfiles  自动再package中添加 npm publish 文件\n1. depd  标注方法deprecating \n1. http-errors   http错误  \n1. Global-tunnel  http请求的全局代理  \n1. humanize-ms  转义为ms  \n```\ntransform humanize time to ms  ms('1s') // 1000\nms(1000) // 1000\n```\n1. Exceljs 一个功能强大的excel 处理包\n1. ready-callback 所有注册的事件完成后，才执行ready中方法\n1. Get-ready  NodeJS mixin to add one-time ready event，ready 后执行相关方法\n1. xml2js  将xml 转换为json \n1. debug  调试状态输出  debug=*  debug=work:*   \n1. delegates  node模块中代理proto中属性的方法、setter和getter\n1. chokidar filewatch \n1. Puppeteer  headless browser\n1. cross-env Run scripts that set and use environment variables across platforms\n1. simplemde  markdown editor \n1. serialize-javascript  Serialize JavaScript to a superset of JSON that includes regular expressions and functions.\n1.route-cache  express router cache\n```javascript\nvar routeCache = require('route-cache');\n \n// cache route for 20 seconds\napp.get('/index', routeCache.cacheSeconds(20), function(req, res){\n  // do your dirty work here...\n  console.log('you will only see this every 20 seconds.');\n  res.send('this response will be cached');\n});\n```\n1. Ws server 端的websoket \n1. fastclick  解决浏览器点击的延迟\n1. Qs  A querystring parsing and stringifying library with some added security.\n1. lru-cache  A cache object that deletes the least-recently-used items.\n1. memory-fs  A simple in-memory filesystem. Holds data in a javascript object\n1. faker.js  generate massive amounts of fake data in the browser and node.js\n1. parseurl 等同node url parse，加了cache\n1. vue-lazy-component   Vue.js 2.x 组件级懒加载方案-Vue.js 2.x component level lazy loading solution\n1. async-validator  数据验证\n1. fast-safe-stringify    Safe and fast serialization alternative to JSON.stringify.\n1. node-notifier   Send cross platform native notifications using Node.js.\n1. dateformat   node 时间处理函数\n1. agentkeepalive  defaut is keepalive\n1. copy-to   copy an object's properties to another one, include propertiy, getter and setter.\n1. platform   A platform detection library that works on nearly all JavaScript platforms.\n\n1. svg-captcha 验证码  \n1. vue-virtual-scroller  加载大量数据\n1. FileSaver.js  保存大于 ram的文档\n1. vue-draggable-resizable  Vue2 Component for draggable and resizable elements.\n1. ScrollTrigger  根据滚动位置出发事件\n1. Vue Virtual Scroller   RecycleScroller 可以渲染列表中的可见项目。如果你不知道项目的大小，最好使用 DynamicScroller\n1. Vuetensils  没有样式的component,可定制自己样式\n1. v-calendar  日历插件\n1. vue-grid-layout 可以拖拽的布局控件\n1. Vue-content-loader  占位符控件\n1. Sinon   node 端监控方法执行、mock、spy\n1. figlet  控制台标题文字\n1. Cockatiel  是一个弹性和瞬态故障处理库，如重试，断路器，超时，隔板隔离和回退之类的策略。\n1. Signale  一个 Node 的日志格式库，自带16个级别，可以定制颜色和 Emoji。\n1. Wiki.js  构建wiki 文档管理 ","slug":"package","published":1,"updated":"2020-01-02T08:10:48.330Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5bwexcz000r998ss9681io5","content":"<ol>\n<li>Opn: A better node-open. Opens stuff like websites, files, executables. Cross-platform.</li>\n<li>Ora:进度条和文字。</li>\n<li>joi：数据验</li>\n<li>satisfies ：版本工具</li>\n<li>minimist：简单的参数处理</li>\n<li>read-pkg:规范化解析pkg</li>\n<li>inquirer:询问时可以给出选项</li>\n<li>Resovel:解析包的安装路径</li>\n<li>slash:Convert Windows backslash paths to slash paths: foo\\bar ➔ foo/bar</li>\n<li>klaw-sync:回遍历出所有文件，并返回文件路径和文件夹</li>\n<li>mime-types content-type 工具：1. 可以根据文件后缀获取 2. 根据content-type获取charset 3. 根据content-type 获取默认的文件名</li>\n<li>CodeMirror是一个运行在浏览器中的在线代码编辑器，支持100多种语言，高度可定制。</li>\n<li>@typescript-eslint/eslint-plugin.  eslint 检测typescript </li>\n<li>nanoid  A tiny, secure, URL-friendly, unique string ID generator for JavaScript.</li>\n<li>mm 对mudule 中的方法mock</li>\n<li><p>numerify  用来格式化数字 </p>\n</li>\n<li><p>utils-lite  前端提供debounce、thorttling、clone、cloneDeep 等方法</p>\n</li>\n<li>is-type-of   node check 数据类型</li>\n<li>on-finished  Execute a callback when a HTTP request closes, finishes, or errors</li>\n<li><p>await-event  封装了promise </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> PassThrough = <span class=\"built_in\">require</span>(<span class=\"string\">'stream'</span>).PassThrough</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">var</span> stream = <span class=\"keyword\">new</span> PassThrough()</span><br><span class=\"line\"><span class=\"comment\">// you attach it directly on an event emitter</span></span><br><span class=\"line\">stream.await = <span class=\"built_in\">require</span>(<span class=\"string\">'await-event'</span>)</span><br><span class=\"line\"> </span><br><span class=\"line\">co(<span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> chunk = <span class=\"keyword\">yield</span> stream.await(<span class=\"string\">'data'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> chunk = <span class=\"keyword\">yield</span> stream.await(<span class=\"string\">'data'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> chunk = <span class=\"keyword\">yield</span> stream.await(<span class=\"string\">'data'</span>)</span><br><span class=\"line\">&#125;).catch(noop)</span><br><span class=\"line\"> </span><br><span class=\"line\">stream.write(<span class=\"string\">'some chunk’)</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>get-ready  NodeJS mixin to add one-time ready event</p>\n</li>\n<li>ShellJS 是Unix shell命令在Node.js API上的可移植实现</li>\n<li>graceful-process   graceful exit process even parent exit on SIGKILL.</li>\n<li>semver.gte(process.version, ‘7.0.0’)  版本的比对 </li>\n<li>pkgfiles  自动再package中添加 npm publish 文件</li>\n<li>depd  标注方法deprecating </li>\n<li>http-errors   http错误  </li>\n<li>Global-tunnel  http请求的全局代理  </li>\n<li><p>humanize-ms  转义为ms  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">transform humanize time to ms  ms(&apos;1s&apos;) // 1000</span><br><span class=\"line\">ms(1000) // 1000</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Exceljs 一个功能强大的excel 处理包</p>\n</li>\n<li>ready-callback 所有注册的事件完成后，才执行ready中方法</li>\n<li>Get-ready  NodeJS mixin to add one-time ready event，ready 后执行相关方法</li>\n<li>xml2js  将xml 转换为json </li>\n<li>debug  调试状态输出  debug=<em>  debug=work:</em>   </li>\n<li>delegates  node模块中代理proto中属性的方法、setter和getter</li>\n<li>chokidar filewatch </li>\n<li>Puppeteer  headless browser</li>\n<li>cross-env Run scripts that set and use environment variables across platforms</li>\n<li>simplemde  markdown editor </li>\n<li><p>serialize-javascript  Serialize JavaScript to a superset of JSON that includes regular expressions and functions.<br>1.route-cache  express router cache</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> routeCache = <span class=\"built_in\">require</span>(<span class=\"string\">'route-cache'</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// cache route for 20 seconds</span></span><br><span class=\"line\">app.get(<span class=\"string\">'/index'</span>, routeCache.cacheSeconds(<span class=\"number\">20</span>), <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// do your dirty work here...</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'you will only see this every 20 seconds.'</span>);</span><br><span class=\"line\">  res.send(<span class=\"string\">'this response will be cached'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Ws server 端的websoket </p>\n</li>\n<li>fastclick  解决浏览器点击的延迟</li>\n<li>Qs  A querystring parsing and stringifying library with some added security.</li>\n<li>lru-cache  A cache object that deletes the least-recently-used items.</li>\n<li>memory-fs  A simple in-memory filesystem. Holds data in a javascript object</li>\n<li>faker.js  generate massive amounts of fake data in the browser and node.js</li>\n<li>parseurl 等同node url parse，加了cache</li>\n<li>vue-lazy-component   Vue.js 2.x 组件级懒加载方案-Vue.js 2.x component level lazy loading solution</li>\n<li>async-validator  数据验证</li>\n<li>fast-safe-stringify    Safe and fast serialization alternative to JSON.stringify.</li>\n<li>node-notifier   Send cross platform native notifications using Node.js.</li>\n<li>dateformat   node 时间处理函数</li>\n<li>agentkeepalive  defaut is keepalive</li>\n<li>copy-to   copy an object’s properties to another one, include propertiy, getter and setter.</li>\n<li><p>platform   A platform detection library that works on nearly all JavaScript platforms.</p>\n</li>\n<li><p>svg-captcha 验证码  </p>\n</li>\n<li>vue-virtual-scroller  加载大量数据</li>\n<li>FileSaver.js  保存大于 ram的文档</li>\n<li>vue-draggable-resizable  Vue2 Component for draggable and resizable elements.</li>\n<li>ScrollTrigger  根据滚动位置出发事件</li>\n<li>Vue Virtual Scroller   RecycleScroller 可以渲染列表中的可见项目。如果你不知道项目的大小，最好使用 DynamicScroller</li>\n<li>Vuetensils  没有样式的component,可定制自己样式</li>\n<li>v-calendar  日历插件</li>\n<li>vue-grid-layout 可以拖拽的布局控件</li>\n<li>Vue-content-loader  占位符控件</li>\n<li>Sinon   node 端监控方法执行、mock、spy</li>\n<li>figlet  控制台标题文字</li>\n<li>Cockatiel  是一个弹性和瞬态故障处理库，如重试，断路器，超时，隔板隔离和回退之类的策略。</li>\n<li>Signale  一个 Node 的日志格式库，自带16个级别，可以定制颜色和 Emoji。</li>\n<li>Wiki.js  构建wiki 文档管理 </li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>Opn: A better node-open. Opens stuff like websites, files, executables. Cross-platform.</li>\n<li>Ora:进度条和文字。</li>\n<li>joi：数据验</li>\n<li>satisfies ：版本工具</li>\n<li>minimist：简单的参数处理</li>\n<li>read-pkg:规范化解析pkg</li>\n<li>inquirer:询问时可以给出选项</li>\n<li>Resovel:解析包的安装路径</li>\n<li>slash:Convert Windows backslash paths to slash paths: foo\\bar ➔ foo/bar</li>\n<li>klaw-sync:回遍历出所有文件，并返回文件路径和文件夹</li>\n<li>mime-types content-type 工具：1. 可以根据文件后缀获取 2. 根据content-type获取charset 3. 根据content-type 获取默认的文件名</li>\n<li>CodeMirror是一个运行在浏览器中的在线代码编辑器，支持100多种语言，高度可定制。</li>\n<li>@typescript-eslint/eslint-plugin.  eslint 检测typescript </li>\n<li>nanoid  A tiny, secure, URL-friendly, unique string ID generator for JavaScript.</li>\n<li>mm 对mudule 中的方法mock</li>\n<li><p>numerify  用来格式化数字 </p>\n</li>\n<li><p>utils-lite  前端提供debounce、thorttling、clone、cloneDeep 等方法</p>\n</li>\n<li>is-type-of   node check 数据类型</li>\n<li>on-finished  Execute a callback when a HTTP request closes, finishes, or errors</li>\n<li><p>await-event  封装了promise </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> PassThrough = <span class=\"built_in\">require</span>(<span class=\"string\">'stream'</span>).PassThrough</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">var</span> stream = <span class=\"keyword\">new</span> PassThrough()</span><br><span class=\"line\"><span class=\"comment\">// you attach it directly on an event emitter</span></span><br><span class=\"line\">stream.await = <span class=\"built_in\">require</span>(<span class=\"string\">'await-event'</span>)</span><br><span class=\"line\"> </span><br><span class=\"line\">co(<span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> chunk = <span class=\"keyword\">yield</span> stream.await(<span class=\"string\">'data'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> chunk = <span class=\"keyword\">yield</span> stream.await(<span class=\"string\">'data'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> chunk = <span class=\"keyword\">yield</span> stream.await(<span class=\"string\">'data'</span>)</span><br><span class=\"line\">&#125;).catch(noop)</span><br><span class=\"line\"> </span><br><span class=\"line\">stream.write(<span class=\"string\">'some chunk’)</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>get-ready  NodeJS mixin to add one-time ready event</p>\n</li>\n<li>ShellJS 是Unix shell命令在Node.js API上的可移植实现</li>\n<li>graceful-process   graceful exit process even parent exit on SIGKILL.</li>\n<li>semver.gte(process.version, ‘7.0.0’)  版本的比对 </li>\n<li>pkgfiles  自动再package中添加 npm publish 文件</li>\n<li>depd  标注方法deprecating </li>\n<li>http-errors   http错误  </li>\n<li>Global-tunnel  http请求的全局代理  </li>\n<li><p>humanize-ms  转义为ms  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">transform humanize time to ms  ms(&apos;1s&apos;) // 1000</span><br><span class=\"line\">ms(1000) // 1000</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Exceljs 一个功能强大的excel 处理包</p>\n</li>\n<li>ready-callback 所有注册的事件完成后，才执行ready中方法</li>\n<li>Get-ready  NodeJS mixin to add one-time ready event，ready 后执行相关方法</li>\n<li>xml2js  将xml 转换为json </li>\n<li>debug  调试状态输出  debug=<em>  debug=work:</em>   </li>\n<li>delegates  node模块中代理proto中属性的方法、setter和getter</li>\n<li>chokidar filewatch </li>\n<li>Puppeteer  headless browser</li>\n<li>cross-env Run scripts that set and use environment variables across platforms</li>\n<li>simplemde  markdown editor </li>\n<li><p>serialize-javascript  Serialize JavaScript to a superset of JSON that includes regular expressions and functions.<br>1.route-cache  express router cache</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> routeCache = <span class=\"built_in\">require</span>(<span class=\"string\">'route-cache'</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// cache route for 20 seconds</span></span><br><span class=\"line\">app.get(<span class=\"string\">'/index'</span>, routeCache.cacheSeconds(<span class=\"number\">20</span>), <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// do your dirty work here...</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'you will only see this every 20 seconds.'</span>);</span><br><span class=\"line\">  res.send(<span class=\"string\">'this response will be cached'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Ws server 端的websoket </p>\n</li>\n<li>fastclick  解决浏览器点击的延迟</li>\n<li>Qs  A querystring parsing and stringifying library with some added security.</li>\n<li>lru-cache  A cache object that deletes the least-recently-used items.</li>\n<li>memory-fs  A simple in-memory filesystem. Holds data in a javascript object</li>\n<li>faker.js  generate massive amounts of fake data in the browser and node.js</li>\n<li>parseurl 等同node url parse，加了cache</li>\n<li>vue-lazy-component   Vue.js 2.x 组件级懒加载方案-Vue.js 2.x component level lazy loading solution</li>\n<li>async-validator  数据验证</li>\n<li>fast-safe-stringify    Safe and fast serialization alternative to JSON.stringify.</li>\n<li>node-notifier   Send cross platform native notifications using Node.js.</li>\n<li>dateformat   node 时间处理函数</li>\n<li>agentkeepalive  defaut is keepalive</li>\n<li>copy-to   copy an object’s properties to another one, include propertiy, getter and setter.</li>\n<li><p>platform   A platform detection library that works on nearly all JavaScript platforms.</p>\n</li>\n<li><p>svg-captcha 验证码  </p>\n</li>\n<li>vue-virtual-scroller  加载大量数据</li>\n<li>FileSaver.js  保存大于 ram的文档</li>\n<li>vue-draggable-resizable  Vue2 Component for draggable and resizable elements.</li>\n<li>ScrollTrigger  根据滚动位置出发事件</li>\n<li>Vue Virtual Scroller   RecycleScroller 可以渲染列表中的可见项目。如果你不知道项目的大小，最好使用 DynamicScroller</li>\n<li>Vuetensils  没有样式的component,可定制自己样式</li>\n<li>v-calendar  日历插件</li>\n<li>vue-grid-layout 可以拖拽的布局控件</li>\n<li>Vue-content-loader  占位符控件</li>\n<li>Sinon   node 端监控方法执行、mock、spy</li>\n<li>figlet  控制台标题文字</li>\n<li>Cockatiel  是一个弹性和瞬态故障处理库，如重试，断路器，超时，隔板隔离和回退之类的策略。</li>\n<li>Signale  一个 Node 的日志格式库，自带16个级别，可以定制颜色和 Emoji。</li>\n<li>Wiki.js  构建wiki 文档管理 </li>\n</ol>\n"},{"title":"pattern","date":"2016-12-26T06:05:38.000Z","_content":"##  装饰模式\n\n```\n'use strict';\nclass Sale {\n  constructor(price) {\n    [this.decoratorsList, this.price] = [[], price];\n  }\n\n  decorate(decorator) {\n    if (!Sale[decorator]) throw new Error(`decorator not exist: ${decorator}`);\n    this.decoratorsList.push(Sale[decorator]);\n  }\n\n  getPrice() {\n    for (let decorator of this.decoratorsList) {\n      this.price = decorator(this.price);\n    }\n    return this.price.toFixed(2);\n  }\n\n  static quebec(price) {\n    return price + price * 7.5 / 100;\n  }\n\n  static fedtax(price) {\n    return price + price * 5 / 100;\n  }\n}\nmodule.exports=Sale;\n```\n\n## 工厂模式\n\n\n```\n \n'use strict';\nclass CarMaker {\n  constructor() {\n    this.doors = 0;\n  }\n\n  drive() {\n    console.log(`jaja, i have ${this.doors} doors`);\n  }\n\n  static factory(type) {\n    return new CarMaker[type]();\n  }\n}\n\nCarMaker.Compact = class Compact extends CarMaker {\n  constructor() {\n    super();\n    this.doors = 4;\n  }\n};\n\nmodule.exports=CarMaker;\n\n```\n\n## 策略模式 --自行脑补\n## 单例模式\n\n\n```\n'use strict';\nlet __instance = function () {\n  let instance;\n  return (newInstance) => {\n    if (newInstance) instance = newInstance;\n    return instance;\n  }\n}();\n\nclass Universe {\n  constructor() {\n    if (__instance()) return __instance();\n    __instance(this);\n  }\n}\nmodule.exports=Universe;\n\n```\n\n##订阅者模式\n\n\n```\n/**\n * Created by ryan on 2016/8/29.\n */\n'use strict';\nclass Event {\n  constructor() {\n    this.subscribers = new Map([['any', []]]);\n  }\n\n  on(fn, type = 'any') {\n    let subs = this.subscribers;\n    if (!subs.get(type)) return subs.set(type, [fn]);\n    subs.set(type, (subs.get(type).push(fn)));\n  }\n\n  emit(content, type = 'any') {\n    for (let fn of this.subscribers.get(type)) {\n      fn(content);\n    }\n  }\n}\n\nlet event = new Event();\n\nevent.on((content) => console.log(`get published content: ${content}`), 'myEvent');\nevent.emit('jaja', 'myEvent'); //get published content: jaja\n\n```\n","source":"_posts/pattern.md","raw":"---\ntitle: pattern\ndate: 2016-12-26 14:05:38\ntags: pattern\n---\n##  装饰模式\n\n```\n'use strict';\nclass Sale {\n  constructor(price) {\n    [this.decoratorsList, this.price] = [[], price];\n  }\n\n  decorate(decorator) {\n    if (!Sale[decorator]) throw new Error(`decorator not exist: ${decorator}`);\n    this.decoratorsList.push(Sale[decorator]);\n  }\n\n  getPrice() {\n    for (let decorator of this.decoratorsList) {\n      this.price = decorator(this.price);\n    }\n    return this.price.toFixed(2);\n  }\n\n  static quebec(price) {\n    return price + price * 7.5 / 100;\n  }\n\n  static fedtax(price) {\n    return price + price * 5 / 100;\n  }\n}\nmodule.exports=Sale;\n```\n\n## 工厂模式\n\n\n```\n \n'use strict';\nclass CarMaker {\n  constructor() {\n    this.doors = 0;\n  }\n\n  drive() {\n    console.log(`jaja, i have ${this.doors} doors`);\n  }\n\n  static factory(type) {\n    return new CarMaker[type]();\n  }\n}\n\nCarMaker.Compact = class Compact extends CarMaker {\n  constructor() {\n    super();\n    this.doors = 4;\n  }\n};\n\nmodule.exports=CarMaker;\n\n```\n\n## 策略模式 --自行脑补\n## 单例模式\n\n\n```\n'use strict';\nlet __instance = function () {\n  let instance;\n  return (newInstance) => {\n    if (newInstance) instance = newInstance;\n    return instance;\n  }\n}();\n\nclass Universe {\n  constructor() {\n    if (__instance()) return __instance();\n    __instance(this);\n  }\n}\nmodule.exports=Universe;\n\n```\n\n##订阅者模式\n\n\n```\n/**\n * Created by ryan on 2016/8/29.\n */\n'use strict';\nclass Event {\n  constructor() {\n    this.subscribers = new Map([['any', []]]);\n  }\n\n  on(fn, type = 'any') {\n    let subs = this.subscribers;\n    if (!subs.get(type)) return subs.set(type, [fn]);\n    subs.set(type, (subs.get(type).push(fn)));\n  }\n\n  emit(content, type = 'any') {\n    for (let fn of this.subscribers.get(type)) {\n      fn(content);\n    }\n  }\n}\n\nlet event = new Event();\n\nevent.on((content) => console.log(`get published content: ${content}`), 'myEvent');\nevent.emit('jaja', 'myEvent'); //get published content: jaja\n\n```\n","slug":"pattern","published":1,"updated":"2019-07-26T08:35:17.308Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5bwexd1000t998sn93bqyrw","content":"<h2 id=\"装饰模式\"><a href=\"#装饰模式\" class=\"headerlink\" title=\"装饰模式\"></a>装饰模式</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;use strict&apos;;</span><br><span class=\"line\">class Sale &#123;</span><br><span class=\"line\">  constructor(price) &#123;</span><br><span class=\"line\">    [this.decoratorsList, this.price] = [[], price];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  decorate(decorator) &#123;</span><br><span class=\"line\">    if (!Sale[decorator]) throw new Error(`decorator not exist: $&#123;decorator&#125;`);</span><br><span class=\"line\">    this.decoratorsList.push(Sale[decorator]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  getPrice() &#123;</span><br><span class=\"line\">    for (let decorator of this.decoratorsList) &#123;</span><br><span class=\"line\">      this.price = decorator(this.price);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return this.price.toFixed(2);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  static quebec(price) &#123;</span><br><span class=\"line\">    return price + price * 7.5 / 100;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  static fedtax(price) &#123;</span><br><span class=\"line\">    return price + price * 5 / 100;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">module.exports=Sale;</span><br></pre></td></tr></table></figure>\n<h2 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> </span><br><span class=\"line\">&apos;use strict&apos;;</span><br><span class=\"line\">class CarMaker &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    this.doors = 0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  drive() &#123;</span><br><span class=\"line\">    console.log(`jaja, i have $&#123;this.doors&#125; doors`);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  static factory(type) &#123;</span><br><span class=\"line\">    return new CarMaker[type]();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">CarMaker.Compact = class Compact extends CarMaker &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    super();</span><br><span class=\"line\">    this.doors = 4;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports=CarMaker;</span><br></pre></td></tr></table></figure>\n<h2 id=\"策略模式-–自行脑补\"><a href=\"#策略模式-–自行脑补\" class=\"headerlink\" title=\"策略模式 –自行脑补\"></a>策略模式 –自行脑补</h2><h2 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;use strict&apos;;</span><br><span class=\"line\">let __instance = function () &#123;</span><br><span class=\"line\">  let instance;</span><br><span class=\"line\">  return (newInstance) =&gt; &#123;</span><br><span class=\"line\">    if (newInstance) instance = newInstance;</span><br><span class=\"line\">    return instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;();</span><br><span class=\"line\"></span><br><span class=\"line\">class Universe &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    if (__instance()) return __instance();</span><br><span class=\"line\">    __instance(this);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">module.exports=Universe;</span><br></pre></td></tr></table></figure>\n<p>##订阅者模式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Created by ryan on 2016/8/29.</span><br><span class=\"line\"> */</span><br><span class=\"line\">&apos;use strict&apos;;</span><br><span class=\"line\">class Event &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    this.subscribers = new Map([[&apos;any&apos;, []]]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  on(fn, type = &apos;any&apos;) &#123;</span><br><span class=\"line\">    let subs = this.subscribers;</span><br><span class=\"line\">    if (!subs.get(type)) return subs.set(type, [fn]);</span><br><span class=\"line\">    subs.set(type, (subs.get(type).push(fn)));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  emit(content, type = &apos;any&apos;) &#123;</span><br><span class=\"line\">    for (let fn of this.subscribers.get(type)) &#123;</span><br><span class=\"line\">      fn(content);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let event = new Event();</span><br><span class=\"line\"></span><br><span class=\"line\">event.on((content) =&gt; console.log(`get published content: $&#123;content&#125;`), &apos;myEvent&apos;);</span><br><span class=\"line\">event.emit(&apos;jaja&apos;, &apos;myEvent&apos;); //get published content: jaja</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"装饰模式\"><a href=\"#装饰模式\" class=\"headerlink\" title=\"装饰模式\"></a>装饰模式</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;use strict&apos;;</span><br><span class=\"line\">class Sale &#123;</span><br><span class=\"line\">  constructor(price) &#123;</span><br><span class=\"line\">    [this.decoratorsList, this.price] = [[], price];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  decorate(decorator) &#123;</span><br><span class=\"line\">    if (!Sale[decorator]) throw new Error(`decorator not exist: $&#123;decorator&#125;`);</span><br><span class=\"line\">    this.decoratorsList.push(Sale[decorator]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  getPrice() &#123;</span><br><span class=\"line\">    for (let decorator of this.decoratorsList) &#123;</span><br><span class=\"line\">      this.price = decorator(this.price);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return this.price.toFixed(2);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  static quebec(price) &#123;</span><br><span class=\"line\">    return price + price * 7.5 / 100;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  static fedtax(price) &#123;</span><br><span class=\"line\">    return price + price * 5 / 100;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">module.exports=Sale;</span><br></pre></td></tr></table></figure>\n<h2 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> </span><br><span class=\"line\">&apos;use strict&apos;;</span><br><span class=\"line\">class CarMaker &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    this.doors = 0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  drive() &#123;</span><br><span class=\"line\">    console.log(`jaja, i have $&#123;this.doors&#125; doors`);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  static factory(type) &#123;</span><br><span class=\"line\">    return new CarMaker[type]();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">CarMaker.Compact = class Compact extends CarMaker &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    super();</span><br><span class=\"line\">    this.doors = 4;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports=CarMaker;</span><br></pre></td></tr></table></figure>\n<h2 id=\"策略模式-–自行脑补\"><a href=\"#策略模式-–自行脑补\" class=\"headerlink\" title=\"策略模式 –自行脑补\"></a>策略模式 –自行脑补</h2><h2 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;use strict&apos;;</span><br><span class=\"line\">let __instance = function () &#123;</span><br><span class=\"line\">  let instance;</span><br><span class=\"line\">  return (newInstance) =&gt; &#123;</span><br><span class=\"line\">    if (newInstance) instance = newInstance;</span><br><span class=\"line\">    return instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;();</span><br><span class=\"line\"></span><br><span class=\"line\">class Universe &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    if (__instance()) return __instance();</span><br><span class=\"line\">    __instance(this);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">module.exports=Universe;</span><br></pre></td></tr></table></figure>\n<p>##订阅者模式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Created by ryan on 2016/8/29.</span><br><span class=\"line\"> */</span><br><span class=\"line\">&apos;use strict&apos;;</span><br><span class=\"line\">class Event &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    this.subscribers = new Map([[&apos;any&apos;, []]]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  on(fn, type = &apos;any&apos;) &#123;</span><br><span class=\"line\">    let subs = this.subscribers;</span><br><span class=\"line\">    if (!subs.get(type)) return subs.set(type, [fn]);</span><br><span class=\"line\">    subs.set(type, (subs.get(type).push(fn)));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  emit(content, type = &apos;any&apos;) &#123;</span><br><span class=\"line\">    for (let fn of this.subscribers.get(type)) &#123;</span><br><span class=\"line\">      fn(content);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let event = new Event();</span><br><span class=\"line\"></span><br><span class=\"line\">event.on((content) =&gt; console.log(`get published content: $&#123;content&#125;`), &apos;myEvent&apos;);</span><br><span class=\"line\">event.emit(&apos;jaja&apos;, &apos;myEvent&apos;); //get published content: jaja</span><br></pre></td></tr></table></figure>\n"},{"title":"pm2","date":"2016-12-29T09:53:39.000Z","_content":"### pm2 start 启动文件的设置\n\n1. 通过 pm2 ecosystem 生成文件\n2. 在配置文件中配置，主要参数如下：\n　　\n```\nmin_uptime：最小运行时间，这里设置的是60s即如果应用程序在60s内退出，pm2会认为程序异常退出，此时触发重启max_restarts设置数量\n\nexec_mode：应用程序启动模式，这里设置的是cluster_mode（集群），默认是fork\nerror_file：自定义应用程序的错误日志文件\nout_file：自定义应用程序日志文件\npid_file：自定义应用程序的pid文件\nwatch：是否启用监控模式，默认是false。如果设置成true，当应用程序变动时，pm2会自动重载。这里也可以设置你要监控的文件\n\nexec_interpreter：应用程序的脚本类型，这里使用的shell，默认是nodejs\ndefaults to “node”. can be “python”, “ruby”, “bash” or whatever interpreter you wish to use. “none” will execute your app as a binary executable\n\n当使用babel的时候： exec_interpreter:\"babel-node\"\n \nmax_memory_restart  超出这个内存后会重新启动\n\n```\n\n3. 可以设置watch 的目录\n   \n```\n{\n  \"name\"        : \"fis-receiver\",  // 应用名称\n  \"script\"      : \"./bin/www\",  // 实际启动脚本\n  \"cwd\"         : \"./\",  // 当前工作路径\n  \"watch\": [  // 监控变化的目录，一旦变化，自动重启\n    \"bin\",\n    \"routers\"\n  ],\n  \"ignore_watch\" : [  // 从监控目录中排除\n    \"node_modules\", \n    \"logs\",\n    \"public\"\n  ],\n  \"watch_options\": {\n    \"followSymlinks\": false\n  },\n  \"error_file\" : \"./logs/app-err.log\",  // 错误日志路径\n  \"out_file\"   : \"./logs/app-out.log\",  // 普通日志路径\n  \"env\": {\n      \"NODE_ENV\": \"production\"  // 环境参数，当前指定为生产环境\n  }\n}\n```\n\n","source":"_posts/pm2.md","raw":"---\ntitle: pm2\ndate: 2016-12-29 17:53:39\ntags: pm2 \n---\n### pm2 start 启动文件的设置\n\n1. 通过 pm2 ecosystem 生成文件\n2. 在配置文件中配置，主要参数如下：\n　　\n```\nmin_uptime：最小运行时间，这里设置的是60s即如果应用程序在60s内退出，pm2会认为程序异常退出，此时触发重启max_restarts设置数量\n\nexec_mode：应用程序启动模式，这里设置的是cluster_mode（集群），默认是fork\nerror_file：自定义应用程序的错误日志文件\nout_file：自定义应用程序日志文件\npid_file：自定义应用程序的pid文件\nwatch：是否启用监控模式，默认是false。如果设置成true，当应用程序变动时，pm2会自动重载。这里也可以设置你要监控的文件\n\nexec_interpreter：应用程序的脚本类型，这里使用的shell，默认是nodejs\ndefaults to “node”. can be “python”, “ruby”, “bash” or whatever interpreter you wish to use. “none” will execute your app as a binary executable\n\n当使用babel的时候： exec_interpreter:\"babel-node\"\n \nmax_memory_restart  超出这个内存后会重新启动\n\n```\n\n3. 可以设置watch 的目录\n   \n```\n{\n  \"name\"        : \"fis-receiver\",  // 应用名称\n  \"script\"      : \"./bin/www\",  // 实际启动脚本\n  \"cwd\"         : \"./\",  // 当前工作路径\n  \"watch\": [  // 监控变化的目录，一旦变化，自动重启\n    \"bin\",\n    \"routers\"\n  ],\n  \"ignore_watch\" : [  // 从监控目录中排除\n    \"node_modules\", \n    \"logs\",\n    \"public\"\n  ],\n  \"watch_options\": {\n    \"followSymlinks\": false\n  },\n  \"error_file\" : \"./logs/app-err.log\",  // 错误日志路径\n  \"out_file\"   : \"./logs/app-out.log\",  // 普通日志路径\n  \"env\": {\n      \"NODE_ENV\": \"production\"  // 环境参数，当前指定为生产环境\n  }\n}\n```\n\n","slug":"pm2","published":1,"updated":"2019-07-26T08:35:17.309Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5bwexd3000v998si23ur1qt","content":"<h3 id=\"pm2-start-启动文件的设置\"><a href=\"#pm2-start-启动文件的设置\" class=\"headerlink\" title=\"pm2 start 启动文件的设置\"></a>pm2 start 启动文件的设置</h3><ol>\n<li>通过 pm2 ecosystem 生成文件</li>\n<li><p>在配置文件中配置，主要参数如下：\n　　</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">min_uptime：最小运行时间，这里设置的是60s即如果应用程序在60s内退出，pm2会认为程序异常退出，此时触发重启max_restarts设置数量</span><br><span class=\"line\"></span><br><span class=\"line\">exec_mode：应用程序启动模式，这里设置的是cluster_mode（集群），默认是fork</span><br><span class=\"line\">error_file：自定义应用程序的错误日志文件</span><br><span class=\"line\">out_file：自定义应用程序日志文件</span><br><span class=\"line\">pid_file：自定义应用程序的pid文件</span><br><span class=\"line\">watch：是否启用监控模式，默认是false。如果设置成true，当应用程序变动时，pm2会自动重载。这里也可以设置你要监控的文件</span><br><span class=\"line\"></span><br><span class=\"line\">exec_interpreter：应用程序的脚本类型，这里使用的shell，默认是nodejs</span><br><span class=\"line\">defaults to “node”. can be “python”, “ruby”, “bash” or whatever interpreter you wish to use. “none” will execute your app as a binary executable</span><br><span class=\"line\"></span><br><span class=\"line\">当使用babel的时候： exec_interpreter:&quot;babel-node&quot;</span><br><span class=\"line\"> </span><br><span class=\"line\">max_memory_restart  超出这个内存后会重新启动</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>可以设置watch 的目录</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;name&quot;        : &quot;fis-receiver&quot;,  // 应用名称</span><br><span class=\"line\">  &quot;script&quot;      : &quot;./bin/www&quot;,  // 实际启动脚本</span><br><span class=\"line\">  &quot;cwd&quot;         : &quot;./&quot;,  // 当前工作路径</span><br><span class=\"line\">  &quot;watch&quot;: [  // 监控变化的目录，一旦变化，自动重启</span><br><span class=\"line\">    &quot;bin&quot;,</span><br><span class=\"line\">    &quot;routers&quot;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  &quot;ignore_watch&quot; : [  // 从监控目录中排除</span><br><span class=\"line\">    &quot;node_modules&quot;, </span><br><span class=\"line\">    &quot;logs&quot;,</span><br><span class=\"line\">    &quot;public&quot;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  &quot;watch_options&quot;: &#123;</span><br><span class=\"line\">    &quot;followSymlinks&quot;: false</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;error_file&quot; : &quot;./logs/app-err.log&quot;,  // 错误日志路径</span><br><span class=\"line\">  &quot;out_file&quot;   : &quot;./logs/app-out.log&quot;,  // 普通日志路径</span><br><span class=\"line\">  &quot;env&quot;: &#123;</span><br><span class=\"line\">      &quot;NODE_ENV&quot;: &quot;production&quot;  // 环境参数，当前指定为生产环境</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"pm2-start-启动文件的设置\"><a href=\"#pm2-start-启动文件的设置\" class=\"headerlink\" title=\"pm2 start 启动文件的设置\"></a>pm2 start 启动文件的设置</h3><ol>\n<li>通过 pm2 ecosystem 生成文件</li>\n<li><p>在配置文件中配置，主要参数如下：\n　　</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">min_uptime：最小运行时间，这里设置的是60s即如果应用程序在60s内退出，pm2会认为程序异常退出，此时触发重启max_restarts设置数量</span><br><span class=\"line\"></span><br><span class=\"line\">exec_mode：应用程序启动模式，这里设置的是cluster_mode（集群），默认是fork</span><br><span class=\"line\">error_file：自定义应用程序的错误日志文件</span><br><span class=\"line\">out_file：自定义应用程序日志文件</span><br><span class=\"line\">pid_file：自定义应用程序的pid文件</span><br><span class=\"line\">watch：是否启用监控模式，默认是false。如果设置成true，当应用程序变动时，pm2会自动重载。这里也可以设置你要监控的文件</span><br><span class=\"line\"></span><br><span class=\"line\">exec_interpreter：应用程序的脚本类型，这里使用的shell，默认是nodejs</span><br><span class=\"line\">defaults to “node”. can be “python”, “ruby”, “bash” or whatever interpreter you wish to use. “none” will execute your app as a binary executable</span><br><span class=\"line\"></span><br><span class=\"line\">当使用babel的时候： exec_interpreter:&quot;babel-node&quot;</span><br><span class=\"line\"> </span><br><span class=\"line\">max_memory_restart  超出这个内存后会重新启动</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>可以设置watch 的目录</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;name&quot;        : &quot;fis-receiver&quot;,  // 应用名称</span><br><span class=\"line\">  &quot;script&quot;      : &quot;./bin/www&quot;,  // 实际启动脚本</span><br><span class=\"line\">  &quot;cwd&quot;         : &quot;./&quot;,  // 当前工作路径</span><br><span class=\"line\">  &quot;watch&quot;: [  // 监控变化的目录，一旦变化，自动重启</span><br><span class=\"line\">    &quot;bin&quot;,</span><br><span class=\"line\">    &quot;routers&quot;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  &quot;ignore_watch&quot; : [  // 从监控目录中排除</span><br><span class=\"line\">    &quot;node_modules&quot;, </span><br><span class=\"line\">    &quot;logs&quot;,</span><br><span class=\"line\">    &quot;public&quot;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  &quot;watch_options&quot;: &#123;</span><br><span class=\"line\">    &quot;followSymlinks&quot;: false</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;error_file&quot; : &quot;./logs/app-err.log&quot;,  // 错误日志路径</span><br><span class=\"line\">  &quot;out_file&quot;   : &quot;./logs/app-out.log&quot;,  // 普通日志路径</span><br><span class=\"line\">  &quot;env&quot;: &#123;</span><br><span class=\"line\">      &quot;NODE_ENV&quot;: &quot;production&quot;  // 环境参数，当前指定为生产环境</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"postgre","date":"2017-02-21T03:18:37.000Z","_content":"\n```\ndb.many(query, values); // expects one or more rows\ndb.one(query, values); // expects a single row\ndb.none(query, values); // expects no rows\ndb.any(query, values); // expects anything, same as `manyOrNone`\ndb.oneOrNone(query, values); // expects 1 or 0 rows\ndb.manyOrNone(query, values); // expects anything, same as `any`\n```\n\nThe library supports named parameters in query formatting, with the syntax of $*propName*, where * is any of the following open-close pairs: {}, (), <>, [], //\n\n\n```\ndb.query('SELECT * FROM users WHERE name=${name} AND active=$/active/', {\n    name: 'John',\n    active: true\n});\n```\n\nthis 的用法：\n```\nvar doc = {\n    id: 123,\n    body: \"some text\"\n};\n\ndb.none(\"INSERT INTO documents(id, doc) VALUES(${id}, ${this})\", doc)\n    .then(function () {\n        // success;\n    })\n    .catch(function (error) {\n        // error;\n    });\n```\n\nwhich will execute:\n\nINSERT INTO documents(id, doc) VALUES(123, '{\"id\":123,\"body\":\"some text\"}')\n\n\n执行函数\n\nAnd when you are not expecting any return results, call db.proc instead. Both methods return a Promise object, but db.proc doesn't take a qrm parameter, always assuming it is one|none.\n```\ndb.func('findAudit', [123, new Date()])\n    .then(function (data) {\n        console.log(data); // printing the data returned \n    })\n    .catch(function (error) {\n        console.log(error); // printing the error \n    });\ndb.proc();\n```\n\n公用一个连接：\n\n```\ndb.task(function (t) {\n    // `t` and `this` here are the same;\n    // execute a chain of queries;\n})\n    .then(function (data) {\n        // success;\n    })\n    .catch(function (error) {\n        // failed;    \n    });\n```\n\n事物：其中可以嵌套事物\n\n```\ndb.tx(function (t) {\n    // t = this;\n    return t.batch([\n        t.one(\"insert into users(name) values($1) returning id\", \"John\"),\n        t.one(\"insert into events(code) values($1) returning id\", 123)\n    ]);\n})\n    .spread(function (user, event) {\n        // print new user id + new event id;\n        console.log(\"DATA:\", user.id, event.id);\n    })\n    .catch(function (error) {\n        console.log(\"ERROR:\", error); // print the error;\n    })\n    .finally(function () {\n    \n\n        pgp.end(); // for immediate app exit, closing the connection pool.   关闭连接池，是的一般不需要\n        \n        If, however you normally exit your application by killing the NodeJS process, then you don't need to use it.\n\n        \n    });\n```\n\n设置隔离级别：\n\n```\nvar TransactionMode = pgp.txMode.TransactionMode;\nvar isolationLevel = pgp.txMode.isolationLevel;\n\n// Create a reusable transaction mode (serializable + read-only + deferrable):\nvar tmSRD = new TransactionMode({\n    tiLevel: isolationLevel.serializable,\n    readOnly: true,\n    deferrable: true\n});\n\nfunction myTransaction() {\n    return this.query('SELECT * FROM table');\n}\n\nmyTransaction.txMode = tmSRD; // assign transaction mode;\n\ndb.tx(myTransaction)\n    .then(function(){\n        // success;\n    });\n```\n重置promise：\n\n```\nvar promise = require('bluebird');\nvar options = {\n    promiseLib: promise\n};\nvar pgp = require('pg-promise')(options);\n```\n\n","source":"_posts/postgre.md","raw":"---\ntitle: postgre\ndate: 2017-02-21 11:18:37\ntags: postgre\n---\n\n```\ndb.many(query, values); // expects one or more rows\ndb.one(query, values); // expects a single row\ndb.none(query, values); // expects no rows\ndb.any(query, values); // expects anything, same as `manyOrNone`\ndb.oneOrNone(query, values); // expects 1 or 0 rows\ndb.manyOrNone(query, values); // expects anything, same as `any`\n```\n\nThe library supports named parameters in query formatting, with the syntax of $*propName*, where * is any of the following open-close pairs: {}, (), <>, [], //\n\n\n```\ndb.query('SELECT * FROM users WHERE name=${name} AND active=$/active/', {\n    name: 'John',\n    active: true\n});\n```\n\nthis 的用法：\n```\nvar doc = {\n    id: 123,\n    body: \"some text\"\n};\n\ndb.none(\"INSERT INTO documents(id, doc) VALUES(${id}, ${this})\", doc)\n    .then(function () {\n        // success;\n    })\n    .catch(function (error) {\n        // error;\n    });\n```\n\nwhich will execute:\n\nINSERT INTO documents(id, doc) VALUES(123, '{\"id\":123,\"body\":\"some text\"}')\n\n\n执行函数\n\nAnd when you are not expecting any return results, call db.proc instead. Both methods return a Promise object, but db.proc doesn't take a qrm parameter, always assuming it is one|none.\n```\ndb.func('findAudit', [123, new Date()])\n    .then(function (data) {\n        console.log(data); // printing the data returned \n    })\n    .catch(function (error) {\n        console.log(error); // printing the error \n    });\ndb.proc();\n```\n\n公用一个连接：\n\n```\ndb.task(function (t) {\n    // `t` and `this` here are the same;\n    // execute a chain of queries;\n})\n    .then(function (data) {\n        // success;\n    })\n    .catch(function (error) {\n        // failed;    \n    });\n```\n\n事物：其中可以嵌套事物\n\n```\ndb.tx(function (t) {\n    // t = this;\n    return t.batch([\n        t.one(\"insert into users(name) values($1) returning id\", \"John\"),\n        t.one(\"insert into events(code) values($1) returning id\", 123)\n    ]);\n})\n    .spread(function (user, event) {\n        // print new user id + new event id;\n        console.log(\"DATA:\", user.id, event.id);\n    })\n    .catch(function (error) {\n        console.log(\"ERROR:\", error); // print the error;\n    })\n    .finally(function () {\n    \n\n        pgp.end(); // for immediate app exit, closing the connection pool.   关闭连接池，是的一般不需要\n        \n        If, however you normally exit your application by killing the NodeJS process, then you don't need to use it.\n\n        \n    });\n```\n\n设置隔离级别：\n\n```\nvar TransactionMode = pgp.txMode.TransactionMode;\nvar isolationLevel = pgp.txMode.isolationLevel;\n\n// Create a reusable transaction mode (serializable + read-only + deferrable):\nvar tmSRD = new TransactionMode({\n    tiLevel: isolationLevel.serializable,\n    readOnly: true,\n    deferrable: true\n});\n\nfunction myTransaction() {\n    return this.query('SELECT * FROM table');\n}\n\nmyTransaction.txMode = tmSRD; // assign transaction mode;\n\ndb.tx(myTransaction)\n    .then(function(){\n        // success;\n    });\n```\n重置promise：\n\n```\nvar promise = require('bluebird');\nvar options = {\n    promiseLib: promise\n};\nvar pgp = require('pg-promise')(options);\n```\n\n","slug":"postgre","published":1,"updated":"2019-07-26T08:35:17.310Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5bwexd4000x998sigw5ejsj","content":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.many(query, values); // expects one or more rows</span><br><span class=\"line\">db.one(query, values); // expects a single row</span><br><span class=\"line\">db.none(query, values); // expects no rows</span><br><span class=\"line\">db.any(query, values); // expects anything, same as `manyOrNone`</span><br><span class=\"line\">db.oneOrNone(query, values); // expects 1 or 0 rows</span><br><span class=\"line\">db.manyOrNone(query, values); // expects anything, same as `any`</span><br></pre></td></tr></table></figure>\n<p>The library supports named parameters in query formatting, with the syntax of $<em>propName</em>, where * is any of the following open-close pairs: {}, (), &lt;&gt;, [], //</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.query(&apos;SELECT * FROM users WHERE name=$&#123;name&#125; AND active=$/active/&apos;, &#123;</span><br><span class=\"line\">    name: &apos;John&apos;,</span><br><span class=\"line\">    active: true</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>this 的用法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var doc = &#123;</span><br><span class=\"line\">    id: 123,</span><br><span class=\"line\">    body: &quot;some text&quot;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">db.none(&quot;INSERT INTO documents(id, doc) VALUES($&#123;id&#125;, $&#123;this&#125;)&quot;, doc)</span><br><span class=\"line\">    .then(function () &#123;</span><br><span class=\"line\">        // success;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .catch(function (error) &#123;</span><br><span class=\"line\">        // error;</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>which will execute:</p>\n<p>INSERT INTO documents(id, doc) VALUES(123, ‘{“id”:123,”body”:”some text”}’)</p>\n<p>执行函数</p>\n<p>And when you are not expecting any return results, call db.proc instead. Both methods return a Promise object, but db.proc doesn’t take a qrm parameter, always assuming it is one|none.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.func(&apos;findAudit&apos;, [123, new Date()])</span><br><span class=\"line\">    .then(function (data) &#123;</span><br><span class=\"line\">        console.log(data); // printing the data returned </span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .catch(function (error) &#123;</span><br><span class=\"line\">        console.log(error); // printing the error </span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">db.proc();</span><br></pre></td></tr></table></figure></p>\n<p>公用一个连接：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.task(function (t) &#123;</span><br><span class=\"line\">    // `t` and `this` here are the same;</span><br><span class=\"line\">    // execute a chain of queries;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">    .then(function (data) &#123;</span><br><span class=\"line\">        // success;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .catch(function (error) &#123;</span><br><span class=\"line\">        // failed;    </span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>事物：其中可以嵌套事物</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.tx(function (t) &#123;</span><br><span class=\"line\">    // t = this;</span><br><span class=\"line\">    return t.batch([</span><br><span class=\"line\">        t.one(&quot;insert into users(name) values($1) returning id&quot;, &quot;John&quot;),</span><br><span class=\"line\">        t.one(&quot;insert into events(code) values($1) returning id&quot;, 123)</span><br><span class=\"line\">    ]);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">    .spread(function (user, event) &#123;</span><br><span class=\"line\">        // print new user id + new event id;</span><br><span class=\"line\">        console.log(&quot;DATA:&quot;, user.id, event.id);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .catch(function (error) &#123;</span><br><span class=\"line\">        console.log(&quot;ERROR:&quot;, error); // print the error;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .finally(function () &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">        pgp.end(); // for immediate app exit, closing the connection pool.   关闭连接池，是的一般不需要</span><br><span class=\"line\">        </span><br><span class=\"line\">        If, however you normally exit your application by killing the NodeJS process, then you don&apos;t need to use it.</span><br><span class=\"line\"></span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>设置隔离级别：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var TransactionMode = pgp.txMode.TransactionMode;</span><br><span class=\"line\">var isolationLevel = pgp.txMode.isolationLevel;</span><br><span class=\"line\"></span><br><span class=\"line\">// Create a reusable transaction mode (serializable + read-only + deferrable):</span><br><span class=\"line\">var tmSRD = new TransactionMode(&#123;</span><br><span class=\"line\">    tiLevel: isolationLevel.serializable,</span><br><span class=\"line\">    readOnly: true,</span><br><span class=\"line\">    deferrable: true</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">function myTransaction() &#123;</span><br><span class=\"line\">    return this.query(&apos;SELECT * FROM table&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">myTransaction.txMode = tmSRD; // assign transaction mode;</span><br><span class=\"line\"></span><br><span class=\"line\">db.tx(myTransaction)</span><br><span class=\"line\">    .then(function()&#123;</span><br><span class=\"line\">        // success;</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>重置promise：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var promise = require(&apos;bluebird&apos;);</span><br><span class=\"line\">var options = &#123;</span><br><span class=\"line\">    promiseLib: promise</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var pgp = require(&apos;pg-promise&apos;)(options);</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.many(query, values); // expects one or more rows</span><br><span class=\"line\">db.one(query, values); // expects a single row</span><br><span class=\"line\">db.none(query, values); // expects no rows</span><br><span class=\"line\">db.any(query, values); // expects anything, same as `manyOrNone`</span><br><span class=\"line\">db.oneOrNone(query, values); // expects 1 or 0 rows</span><br><span class=\"line\">db.manyOrNone(query, values); // expects anything, same as `any`</span><br></pre></td></tr></table></figure>\n<p>The library supports named parameters in query formatting, with the syntax of $<em>propName</em>, where * is any of the following open-close pairs: {}, (), &lt;&gt;, [], //</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.query(&apos;SELECT * FROM users WHERE name=$&#123;name&#125; AND active=$/active/&apos;, &#123;</span><br><span class=\"line\">    name: &apos;John&apos;,</span><br><span class=\"line\">    active: true</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>this 的用法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var doc = &#123;</span><br><span class=\"line\">    id: 123,</span><br><span class=\"line\">    body: &quot;some text&quot;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">db.none(&quot;INSERT INTO documents(id, doc) VALUES($&#123;id&#125;, $&#123;this&#125;)&quot;, doc)</span><br><span class=\"line\">    .then(function () &#123;</span><br><span class=\"line\">        // success;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .catch(function (error) &#123;</span><br><span class=\"line\">        // error;</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>which will execute:</p>\n<p>INSERT INTO documents(id, doc) VALUES(123, ‘{“id”:123,”body”:”some text”}’)</p>\n<p>执行函数</p>\n<p>And when you are not expecting any return results, call db.proc instead. Both methods return a Promise object, but db.proc doesn’t take a qrm parameter, always assuming it is one|none.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.func(&apos;findAudit&apos;, [123, new Date()])</span><br><span class=\"line\">    .then(function (data) &#123;</span><br><span class=\"line\">        console.log(data); // printing the data returned </span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .catch(function (error) &#123;</span><br><span class=\"line\">        console.log(error); // printing the error </span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">db.proc();</span><br></pre></td></tr></table></figure></p>\n<p>公用一个连接：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.task(function (t) &#123;</span><br><span class=\"line\">    // `t` and `this` here are the same;</span><br><span class=\"line\">    // execute a chain of queries;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">    .then(function (data) &#123;</span><br><span class=\"line\">        // success;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .catch(function (error) &#123;</span><br><span class=\"line\">        // failed;    </span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>事物：其中可以嵌套事物</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.tx(function (t) &#123;</span><br><span class=\"line\">    // t = this;</span><br><span class=\"line\">    return t.batch([</span><br><span class=\"line\">        t.one(&quot;insert into users(name) values($1) returning id&quot;, &quot;John&quot;),</span><br><span class=\"line\">        t.one(&quot;insert into events(code) values($1) returning id&quot;, 123)</span><br><span class=\"line\">    ]);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">    .spread(function (user, event) &#123;</span><br><span class=\"line\">        // print new user id + new event id;</span><br><span class=\"line\">        console.log(&quot;DATA:&quot;, user.id, event.id);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .catch(function (error) &#123;</span><br><span class=\"line\">        console.log(&quot;ERROR:&quot;, error); // print the error;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .finally(function () &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">        pgp.end(); // for immediate app exit, closing the connection pool.   关闭连接池，是的一般不需要</span><br><span class=\"line\">        </span><br><span class=\"line\">        If, however you normally exit your application by killing the NodeJS process, then you don&apos;t need to use it.</span><br><span class=\"line\"></span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>设置隔离级别：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var TransactionMode = pgp.txMode.TransactionMode;</span><br><span class=\"line\">var isolationLevel = pgp.txMode.isolationLevel;</span><br><span class=\"line\"></span><br><span class=\"line\">// Create a reusable transaction mode (serializable + read-only + deferrable):</span><br><span class=\"line\">var tmSRD = new TransactionMode(&#123;</span><br><span class=\"line\">    tiLevel: isolationLevel.serializable,</span><br><span class=\"line\">    readOnly: true,</span><br><span class=\"line\">    deferrable: true</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">function myTransaction() &#123;</span><br><span class=\"line\">    return this.query(&apos;SELECT * FROM table&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">myTransaction.txMode = tmSRD; // assign transaction mode;</span><br><span class=\"line\"></span><br><span class=\"line\">db.tx(myTransaction)</span><br><span class=\"line\">    .then(function()&#123;</span><br><span class=\"line\">        // success;</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>重置promise：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var promise = require(&apos;bluebird&apos;);</span><br><span class=\"line\">var options = &#123;</span><br><span class=\"line\">    promiseLib: promise</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var pgp = require(&apos;pg-promise&apos;)(options);</span><br></pre></td></tr></table></figure>\n"},{"title":"regex","date":"2019-06-24T05:56:32.000Z","_content":"\n### s修饰符使得 . 能够匹配任何字符\n \n/foo.bar/s.test('foo\\nbar')\n\n### ? 非贪婪模式\n\n? 非贪婪模式，只匹配最少的数据。 对 \"123abc\" 应用 /\\d+/ 将会返回 \"123\"，如果使用 /\\d+?/,那么就只会匹配到 \"1”。\n\n### 先行断言\n\nx(?=y)  匹配'x'仅仅当'x'后面跟着'y'.这种叫做先行断言。例如，/Jack(?=Sprat)/会匹配到'Jack'仅仅当它后面跟着'Sprat'。/Jack(?=Sprat|Frost)/匹配‘Jack’仅仅当它后面跟着'Sprat'或者是‘Frost’。但是‘Sprat’和‘Frost’都不是匹配结果的一部分。\n\n### 后行断言 \n\n(?<=y)x  匹配'x'仅仅当'x'前面是'y'.这种叫做后行断言。\n\n### 正向否定查找\n\nx(?!y)   匹配'x'仅仅当'x'后面不跟着'y',这个叫做正向否定查找。/\\d+(?!\\.)/匹配一个数字仅仅当这个数字后面没有跟小数点的时候。正则表达式/\\d+(?!\\.)/.exec(\"3.141\")匹配‘141’而不是‘3.141’\n\n### 边界 \n\\b 匹配一个词的边界。  \n\\B 匹配一个非单词边界\n\n### w\n\\w 匹配一个单字字符（字母、数字或者下划线）。\n等价于[A-Za-z0-9_]。\n\n例如, /\\w/ 匹配 \"apple,\" 中的 'a'，\"$5.28,\"中的 '5' 和 \"3D.\" 中的 '3’。\n\n\\W 匹配一个非单字字符。\n\n等价于[^A-Za-z0-9_]。\n\n例如, /\\W/ 或者 /[^A-Za-z0-9_]/ 匹配 \"50%.\" 中的 '%’。\n\n### 子字符串匹配\n```\nvar re = /(\\w+)\\s(\\w+)/;\nvar str = \"John Smith\";\nvar newstr = str.replace(re, \"$2, $1\");\nconsole.log(newstr);\n```\n\n#### 非捕获组\n\n?: 用非捕获组 提升匹配效率。\n\ny修饰符的一个应用，是从字符串提取 token（词元），y修饰符确保了匹配之间不会有漏掉的字符。可以修改regex的 lastIndex 。\n\n### 具名匹配\n\n```\nconst RE_DATE = /(\\d{4})-(\\d{2})-(\\d{2})/;\n\n\n\nconst matchObj = RE_DATE.exec('1999-12-31');\n\nconst year = matchObj[1]; // 1999\n\nconst month = matchObj[2]; // 12\n\nconst day = matchObj[3]; // 31\n\nReplace 函数形式：\n\n'2015-01-02'.replace(re, (\n\n   matched, // 整个匹配结果 2015-01-02\n\n   capture1, // 第一个组匹配 2015\n\n   capture2, // 第二个组匹配 01\n\n   capture3, // 第三个组匹配 02\n\n   position, // 匹配开始的位置 0\n\n   S, // 原字符串 2015-01-02\n\n   groups // 具名组构成的一个对象 {year, month, day}\n\n ) => {\n\n let {day, month, year} = groups;\n\n return `${day}/${month}/${year}`;\n\n});\n```\n\n```javascript\n// 可以直接赋值\nlet {groups: {one, two}} = /^(?<one>.*):(?<two>.*)$/u.exec('foo:bar');\none  // foo\ntwo  // bar\n\n// 直接replace\nlet re = /(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/u;\n\n'2015-01-02'.replace(re, '$<day>/$<month>/$<year>')\n```\n\n### 使用引用(具名)\n\n使用引用：const RE_TWICE = /^(?<word>[a-z]+)!\\k<word>$/;\n\nRE_TWICE.test('abc!abc') // true\nRE_TWICE.test('abc!ab') // false\n\n### 捕获组的使用\nRegex 中捕获组的使用：\n对于普通捕获组和命名捕获组的引用，语法如下：\n普通捕获组反向引用：\\k<number>，通常简写为\\number\n\n命名捕获组反向引用：\\k<name>或者\\k'name'\n\n### 匹配字符和非字符\n\\b matches the empty string at the beginning or end of a word. \n\n\\B matches the empty string not at the beginning or end of a word. \n\n","source":"_posts/regex.md","raw":"---\ntitle: regex\ndate: 2019-06-24 13:56:32\ntags: regex\n---\n\n### s修饰符使得 . 能够匹配任何字符\n \n/foo.bar/s.test('foo\\nbar')\n\n### ? 非贪婪模式\n\n? 非贪婪模式，只匹配最少的数据。 对 \"123abc\" 应用 /\\d+/ 将会返回 \"123\"，如果使用 /\\d+?/,那么就只会匹配到 \"1”。\n\n### 先行断言\n\nx(?=y)  匹配'x'仅仅当'x'后面跟着'y'.这种叫做先行断言。例如，/Jack(?=Sprat)/会匹配到'Jack'仅仅当它后面跟着'Sprat'。/Jack(?=Sprat|Frost)/匹配‘Jack’仅仅当它后面跟着'Sprat'或者是‘Frost’。但是‘Sprat’和‘Frost’都不是匹配结果的一部分。\n\n### 后行断言 \n\n(?<=y)x  匹配'x'仅仅当'x'前面是'y'.这种叫做后行断言。\n\n### 正向否定查找\n\nx(?!y)   匹配'x'仅仅当'x'后面不跟着'y',这个叫做正向否定查找。/\\d+(?!\\.)/匹配一个数字仅仅当这个数字后面没有跟小数点的时候。正则表达式/\\d+(?!\\.)/.exec(\"3.141\")匹配‘141’而不是‘3.141’\n\n### 边界 \n\\b 匹配一个词的边界。  \n\\B 匹配一个非单词边界\n\n### w\n\\w 匹配一个单字字符（字母、数字或者下划线）。\n等价于[A-Za-z0-9_]。\n\n例如, /\\w/ 匹配 \"apple,\" 中的 'a'，\"$5.28,\"中的 '5' 和 \"3D.\" 中的 '3’。\n\n\\W 匹配一个非单字字符。\n\n等价于[^A-Za-z0-9_]。\n\n例如, /\\W/ 或者 /[^A-Za-z0-9_]/ 匹配 \"50%.\" 中的 '%’。\n\n### 子字符串匹配\n```\nvar re = /(\\w+)\\s(\\w+)/;\nvar str = \"John Smith\";\nvar newstr = str.replace(re, \"$2, $1\");\nconsole.log(newstr);\n```\n\n#### 非捕获组\n\n?: 用非捕获组 提升匹配效率。\n\ny修饰符的一个应用，是从字符串提取 token（词元），y修饰符确保了匹配之间不会有漏掉的字符。可以修改regex的 lastIndex 。\n\n### 具名匹配\n\n```\nconst RE_DATE = /(\\d{4})-(\\d{2})-(\\d{2})/;\n\n\n\nconst matchObj = RE_DATE.exec('1999-12-31');\n\nconst year = matchObj[1]; // 1999\n\nconst month = matchObj[2]; // 12\n\nconst day = matchObj[3]; // 31\n\nReplace 函数形式：\n\n'2015-01-02'.replace(re, (\n\n   matched, // 整个匹配结果 2015-01-02\n\n   capture1, // 第一个组匹配 2015\n\n   capture2, // 第二个组匹配 01\n\n   capture3, // 第三个组匹配 02\n\n   position, // 匹配开始的位置 0\n\n   S, // 原字符串 2015-01-02\n\n   groups // 具名组构成的一个对象 {year, month, day}\n\n ) => {\n\n let {day, month, year} = groups;\n\n return `${day}/${month}/${year}`;\n\n});\n```\n\n```javascript\n// 可以直接赋值\nlet {groups: {one, two}} = /^(?<one>.*):(?<two>.*)$/u.exec('foo:bar');\none  // foo\ntwo  // bar\n\n// 直接replace\nlet re = /(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/u;\n\n'2015-01-02'.replace(re, '$<day>/$<month>/$<year>')\n```\n\n### 使用引用(具名)\n\n使用引用：const RE_TWICE = /^(?<word>[a-z]+)!\\k<word>$/;\n\nRE_TWICE.test('abc!abc') // true\nRE_TWICE.test('abc!ab') // false\n\n### 捕获组的使用\nRegex 中捕获组的使用：\n对于普通捕获组和命名捕获组的引用，语法如下：\n普通捕获组反向引用：\\k<number>，通常简写为\\number\n\n命名捕获组反向引用：\\k<name>或者\\k'name'\n\n### 匹配字符和非字符\n\\b matches the empty string at the beginning or end of a word. \n\n\\B matches the empty string not at the beginning or end of a word. \n\n","slug":"regex","published":1,"updated":"2019-11-26T03:08:47.063Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5bwexd4000z998sjkonsi5k","content":"<h3 id=\"s修饰符使得-能够匹配任何字符\"><a href=\"#s修饰符使得-能够匹配任何字符\" class=\"headerlink\" title=\"s修饰符使得 . 能够匹配任何字符\"></a>s修饰符使得 . 能够匹配任何字符</h3><p>/foo.bar/s.test(‘foo\\nbar’)</p>\n<h3 id=\"非贪婪模式\"><a href=\"#非贪婪模式\" class=\"headerlink\" title=\"? 非贪婪模式\"></a>? 非贪婪模式</h3><p>? 非贪婪模式，只匹配最少的数据。 对 “123abc” 应用 /\\d+/ 将会返回 “123”，如果使用 /\\d+?/,那么就只会匹配到 “1”。</p>\n<h3 id=\"先行断言\"><a href=\"#先行断言\" class=\"headerlink\" title=\"先行断言\"></a>先行断言</h3><p>x(?=y)  匹配’x’仅仅当’x’后面跟着’y’.这种叫做先行断言。例如，/Jack(?=Sprat)/会匹配到’Jack’仅仅当它后面跟着’Sprat’。/Jack(?=Sprat|Frost)/匹配‘Jack’仅仅当它后面跟着’Sprat’或者是‘Frost’。但是‘Sprat’和‘Frost’都不是匹配结果的一部分。</p>\n<h3 id=\"后行断言\"><a href=\"#后行断言\" class=\"headerlink\" title=\"后行断言\"></a>后行断言</h3><p>(?&lt;=y)x  匹配’x’仅仅当’x’前面是’y’.这种叫做后行断言。</p>\n<h3 id=\"正向否定查找\"><a href=\"#正向否定查找\" class=\"headerlink\" title=\"正向否定查找\"></a>正向否定查找</h3><p>x(?!y)   匹配’x’仅仅当’x’后面不跟着’y’,这个叫做正向否定查找。/\\d+(?!.)/匹配一个数字仅仅当这个数字后面没有跟小数点的时候。正则表达式/\\d+(?!.)/.exec(“3.141”)匹配‘141’而不是‘3.141’</p>\n<h3 id=\"边界\"><a href=\"#边界\" class=\"headerlink\" title=\"边界\"></a>边界</h3><p>\\b 匹配一个词的边界。<br>\\B 匹配一个非单词边界</p>\n<h3 id=\"w\"><a href=\"#w\" class=\"headerlink\" title=\"w\"></a>w</h3><p>\\w 匹配一个单字字符（字母、数字或者下划线）。<br>等价于[A-Za-z0-9_]。</p>\n<p>例如, /\\w/ 匹配 “apple,” 中的 ‘a’，”$5.28,”中的 ‘5’ 和 “3D.” 中的 ‘3’。</p>\n<p>\\W 匹配一个非单字字符。</p>\n<p>等价于[^A-Za-z0-9_]。</p>\n<p>例如, /\\W/ 或者 /[^A-Za-z0-9_]/ 匹配 “50%.” 中的 ‘%’。</p>\n<h3 id=\"子字符串匹配\"><a href=\"#子字符串匹配\" class=\"headerlink\" title=\"子字符串匹配\"></a>子字符串匹配</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var re = /(\\w+)\\s(\\w+)/;</span><br><span class=\"line\">var str = &quot;John Smith&quot;;</span><br><span class=\"line\">var newstr = str.replace(re, &quot;$2, $1&quot;);</span><br><span class=\"line\">console.log(newstr);</span><br></pre></td></tr></table></figure>\n<h4 id=\"非捕获组\"><a href=\"#非捕获组\" class=\"headerlink\" title=\"非捕获组\"></a>非捕获组</h4><p>?: 用非捕获组 提升匹配效率。</p>\n<p>y修饰符的一个应用，是从字符串提取 token（词元），y修饰符确保了匹配之间不会有漏掉的字符。可以修改regex的 lastIndex 。</p>\n<h3 id=\"具名匹配\"><a href=\"#具名匹配\" class=\"headerlink\" title=\"具名匹配\"></a>具名匹配</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const RE_DATE = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">const matchObj = RE_DATE.exec(&apos;1999-12-31&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">const year = matchObj[1]; // 1999</span><br><span class=\"line\"></span><br><span class=\"line\">const month = matchObj[2]; // 12</span><br><span class=\"line\"></span><br><span class=\"line\">const day = matchObj[3]; // 31</span><br><span class=\"line\"></span><br><span class=\"line\">Replace 函数形式：</span><br><span class=\"line\"></span><br><span class=\"line\">&apos;2015-01-02&apos;.replace(re, (</span><br><span class=\"line\"></span><br><span class=\"line\">   matched, // 整个匹配结果 2015-01-02</span><br><span class=\"line\"></span><br><span class=\"line\">   capture1, // 第一个组匹配 2015</span><br><span class=\"line\"></span><br><span class=\"line\">   capture2, // 第二个组匹配 01</span><br><span class=\"line\"></span><br><span class=\"line\">   capture3, // 第三个组匹配 02</span><br><span class=\"line\"></span><br><span class=\"line\">   position, // 匹配开始的位置 0</span><br><span class=\"line\"></span><br><span class=\"line\">   S, // 原字符串 2015-01-02</span><br><span class=\"line\"></span><br><span class=\"line\">   groups // 具名组构成的一个对象 &#123;year, month, day&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> ) =&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> let &#123;day, month, year&#125; = groups;</span><br><span class=\"line\"></span><br><span class=\"line\"> return `$&#123;day&#125;/$&#123;month&#125;/$&#123;year&#125;`;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 可以直接赋值</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123;<span class=\"attr\">groups</span>: &#123;one, two&#125;&#125; = <span class=\"regexp\">/^(?&lt;one&gt;.*):(?&lt;two&gt;.*)$/u</span>.exec(<span class=\"string\">'foo:bar'</span>);</span><br><span class=\"line\">one  <span class=\"comment\">// foo</span></span><br><span class=\"line\">two  <span class=\"comment\">// bar</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 直接replace</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> re = <span class=\"regexp\">/(?&lt;year&gt;\\d&#123;4&#125;)-(?&lt;month&gt;\\d&#123;2&#125;)-(?&lt;day&gt;\\d&#123;2&#125;)/u</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">'2015-01-02'</span>.replace(re, <span class=\"string\">'$&lt;day&gt;/$&lt;month&gt;/$&lt;year&gt;'</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用引用-具名\"><a href=\"#使用引用-具名\" class=\"headerlink\" title=\"使用引用(具名)\"></a>使用引用(具名)</h3><p>使用引用：const RE_TWICE = /^(?<word>[a-z]+)!\\k<word>$/;</word></word></p>\n<p>RE_TWICE.test(‘abc!abc’) // true<br>RE_TWICE.test(‘abc!ab’) // false</p>\n<h3 id=\"捕获组的使用\"><a href=\"#捕获组的使用\" class=\"headerlink\" title=\"捕获组的使用\"></a>捕获组的使用</h3><p>Regex 中捕获组的使用：<br>对于普通捕获组和命名捕获组的引用，语法如下：<br>普通捕获组反向引用：\\k<number>，通常简写为\\number</number></p>\n<p>命名捕获组反向引用：\\k<name>或者\\k’name’</name></p>\n<h3 id=\"匹配字符和非字符\"><a href=\"#匹配字符和非字符\" class=\"headerlink\" title=\"匹配字符和非字符\"></a>匹配字符和非字符</h3><p>\\b matches the empty string at the beginning or end of a word. </p>\n<p>\\B matches the empty string not at the beginning or end of a word. </p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"s修饰符使得-能够匹配任何字符\"><a href=\"#s修饰符使得-能够匹配任何字符\" class=\"headerlink\" title=\"s修饰符使得 . 能够匹配任何字符\"></a>s修饰符使得 . 能够匹配任何字符</h3><p>/foo.bar/s.test(‘foo\\nbar’)</p>\n<h3 id=\"非贪婪模式\"><a href=\"#非贪婪模式\" class=\"headerlink\" title=\"? 非贪婪模式\"></a>? 非贪婪模式</h3><p>? 非贪婪模式，只匹配最少的数据。 对 “123abc” 应用 /\\d+/ 将会返回 “123”，如果使用 /\\d+?/,那么就只会匹配到 “1”。</p>\n<h3 id=\"先行断言\"><a href=\"#先行断言\" class=\"headerlink\" title=\"先行断言\"></a>先行断言</h3><p>x(?=y)  匹配’x’仅仅当’x’后面跟着’y’.这种叫做先行断言。例如，/Jack(?=Sprat)/会匹配到’Jack’仅仅当它后面跟着’Sprat’。/Jack(?=Sprat|Frost)/匹配‘Jack’仅仅当它后面跟着’Sprat’或者是‘Frost’。但是‘Sprat’和‘Frost’都不是匹配结果的一部分。</p>\n<h3 id=\"后行断言\"><a href=\"#后行断言\" class=\"headerlink\" title=\"后行断言\"></a>后行断言</h3><p>(?&lt;=y)x  匹配’x’仅仅当’x’前面是’y’.这种叫做后行断言。</p>\n<h3 id=\"正向否定查找\"><a href=\"#正向否定查找\" class=\"headerlink\" title=\"正向否定查找\"></a>正向否定查找</h3><p>x(?!y)   匹配’x’仅仅当’x’后面不跟着’y’,这个叫做正向否定查找。/\\d+(?!.)/匹配一个数字仅仅当这个数字后面没有跟小数点的时候。正则表达式/\\d+(?!.)/.exec(“3.141”)匹配‘141’而不是‘3.141’</p>\n<h3 id=\"边界\"><a href=\"#边界\" class=\"headerlink\" title=\"边界\"></a>边界</h3><p>\\b 匹配一个词的边界。<br>\\B 匹配一个非单词边界</p>\n<h3 id=\"w\"><a href=\"#w\" class=\"headerlink\" title=\"w\"></a>w</h3><p>\\w 匹配一个单字字符（字母、数字或者下划线）。<br>等价于[A-Za-z0-9_]。</p>\n<p>例如, /\\w/ 匹配 “apple,” 中的 ‘a’，”$5.28,”中的 ‘5’ 和 “3D.” 中的 ‘3’。</p>\n<p>\\W 匹配一个非单字字符。</p>\n<p>等价于[^A-Za-z0-9_]。</p>\n<p>例如, /\\W/ 或者 /[^A-Za-z0-9_]/ 匹配 “50%.” 中的 ‘%’。</p>\n<h3 id=\"子字符串匹配\"><a href=\"#子字符串匹配\" class=\"headerlink\" title=\"子字符串匹配\"></a>子字符串匹配</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var re = /(\\w+)\\s(\\w+)/;</span><br><span class=\"line\">var str = &quot;John Smith&quot;;</span><br><span class=\"line\">var newstr = str.replace(re, &quot;$2, $1&quot;);</span><br><span class=\"line\">console.log(newstr);</span><br></pre></td></tr></table></figure>\n<h4 id=\"非捕获组\"><a href=\"#非捕获组\" class=\"headerlink\" title=\"非捕获组\"></a>非捕获组</h4><p>?: 用非捕获组 提升匹配效率。</p>\n<p>y修饰符的一个应用，是从字符串提取 token（词元），y修饰符确保了匹配之间不会有漏掉的字符。可以修改regex的 lastIndex 。</p>\n<h3 id=\"具名匹配\"><a href=\"#具名匹配\" class=\"headerlink\" title=\"具名匹配\"></a>具名匹配</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const RE_DATE = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">const matchObj = RE_DATE.exec(&apos;1999-12-31&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">const year = matchObj[1]; // 1999</span><br><span class=\"line\"></span><br><span class=\"line\">const month = matchObj[2]; // 12</span><br><span class=\"line\"></span><br><span class=\"line\">const day = matchObj[3]; // 31</span><br><span class=\"line\"></span><br><span class=\"line\">Replace 函数形式：</span><br><span class=\"line\"></span><br><span class=\"line\">&apos;2015-01-02&apos;.replace(re, (</span><br><span class=\"line\"></span><br><span class=\"line\">   matched, // 整个匹配结果 2015-01-02</span><br><span class=\"line\"></span><br><span class=\"line\">   capture1, // 第一个组匹配 2015</span><br><span class=\"line\"></span><br><span class=\"line\">   capture2, // 第二个组匹配 01</span><br><span class=\"line\"></span><br><span class=\"line\">   capture3, // 第三个组匹配 02</span><br><span class=\"line\"></span><br><span class=\"line\">   position, // 匹配开始的位置 0</span><br><span class=\"line\"></span><br><span class=\"line\">   S, // 原字符串 2015-01-02</span><br><span class=\"line\"></span><br><span class=\"line\">   groups // 具名组构成的一个对象 &#123;year, month, day&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> ) =&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> let &#123;day, month, year&#125; = groups;</span><br><span class=\"line\"></span><br><span class=\"line\"> return `$&#123;day&#125;/$&#123;month&#125;/$&#123;year&#125;`;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 可以直接赋值</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123;<span class=\"attr\">groups</span>: &#123;one, two&#125;&#125; = <span class=\"regexp\">/^(?&lt;one&gt;.*):(?&lt;two&gt;.*)$/u</span>.exec(<span class=\"string\">'foo:bar'</span>);</span><br><span class=\"line\">one  <span class=\"comment\">// foo</span></span><br><span class=\"line\">two  <span class=\"comment\">// bar</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 直接replace</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> re = <span class=\"regexp\">/(?&lt;year&gt;\\d&#123;4&#125;)-(?&lt;month&gt;\\d&#123;2&#125;)-(?&lt;day&gt;\\d&#123;2&#125;)/u</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">'2015-01-02'</span>.replace(re, <span class=\"string\">'$&lt;day&gt;/$&lt;month&gt;/$&lt;year&gt;'</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用引用-具名\"><a href=\"#使用引用-具名\" class=\"headerlink\" title=\"使用引用(具名)\"></a>使用引用(具名)</h3><p>使用引用：const RE_TWICE = /^(?<word>[a-z]+)!\\k<word>$/;</word></word></p>\n<p>RE_TWICE.test(‘abc!abc’) // true<br>RE_TWICE.test(‘abc!ab’) // false</p>\n<h3 id=\"捕获组的使用\"><a href=\"#捕获组的使用\" class=\"headerlink\" title=\"捕获组的使用\"></a>捕获组的使用</h3><p>Regex 中捕获组的使用：<br>对于普通捕获组和命名捕获组的引用，语法如下：<br>普通捕获组反向引用：\\k<number>，通常简写为\\number</number></p>\n<p>命名捕获组反向引用：\\k<name>或者\\k’name’</name></p>\n<h3 id=\"匹配字符和非字符\"><a href=\"#匹配字符和非字符\" class=\"headerlink\" title=\"匹配字符和非字符\"></a>匹配字符和非字符</h3><p>\\b matches the empty string at the beginning or end of a word. </p>\n<p>\\B matches the empty string not at the beginning or end of a word. </p>\n"},{"title":"security","date":"2019-12-09T10:11:18.000Z","_content":"\n\n### xss\n\nXSS 的原理是恶意攻击者往 Web 页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中 Web 里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。\n\n1. 反射型 XSS \n\n一般是通过给别人发送带有恶意脚本代码参数的 URL，当 URL 地址被打开时，特有的恶意代码参数被 HTML 解析、执行。\n不过一些浏览器如Chrome其内置了一些XSS过滤器，可以防止大部分反射型XSS攻击。\n\n反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等\n\n非持久型 XSS 漏洞攻击有以下几点特征：\n\n即时性，不经过服务器存储，直接通过 HTTP 的 GET 和 POST 请求就能完成一次攻击，拿到用户隐私数据。\n攻击者需要诱骗点击,必须要通过用户点击链接才能发起\n反馈率低，所以较难发现和响应修复\n盗取用户敏感保密信息\n\n2. 存储型 XSS\n\n持久型 XSS 漏洞，一般存在于 Form 表单提交等交互功能，如文章留言，提交文本信息等，黑客利用的 XSS 漏洞，将内容经正常功能提交进入数据库持久保存，当前端页面获得后端从数据库中读出的注入代码时，恰好将其渲染执行。\n\n这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。\n\n持久型 XSS 有以下几个特点：\n\n持久性，植入在数据库中\n盗取用户敏感私密信息\n危害面广\n\n3.DOM xss\n\n它不需要服务器解析响应的直接参与，触发XSS靠的是浏览器端的DOM解析，可以认为完全是客户端的事情。  解决方案通过csp: sript-src 的nonce值处理。\n\n4.jsonp 服务端做处理\n\n防御措施：1. httponly 2. csp 3.转义字符---现在的后端模板引擎都实现了转义 \n\n增加攻击难度，降低攻击后果\n\n\nhttps://xss-game.appspot.com/level1\n\n如果用 Vue/React 技术栈，并且不使用 v-html/dangerouslySetInnerHTML 功能，就在前端 render 阶段避免 innerHTML、outerHTML 的 XSS 隐患。\n\n### csrf\n\nCSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。\n\n\nCSRF的特点\n攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。\n攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。\n整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。\n跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。\n\n针对已上特点：同源检测 \n\n1. 同源检测 \n\n在HTTP协议中，每一个异步请求都会携带两个Header，用于标记来源域名：\n\n+ Origin Header\n+ Referer Header\n  这两个Header在浏览器发起请求时，大多数情况会自动带上，并且不能由前端自定义内容。 服务器可以通过解析这两个Header中的域名，确定请求的来源域\n\n但是Origin在以下两种情况下并不存在：\n + IE11同源策略： IE 11 不会在跨站CORS请求上添加Origin标头，Referer头将仍然是唯一的标识。最根本原因是因为IE 11对同源的定义和其他浏览器有不同，有两个主要的区别，可以参考MDN Same-origin_policy#IE_Exceptions\n\n+ 302重定向： 在302重定向之后Origin不包含在重定向的请求中，因为Origin可能会被认为是其他来源的敏感信息。对于302重定向的情况来说都是定向到新的服务器上的URL，因此浏览器不想将Origin泄漏到新的服务器上。\n\n#### 使用Referer Header确定来源域名\n\n根据HTTP协议，在HTTP头中有一个字段叫Referer，记录了该HTTP请求的来源地址。 对于Ajax请求，图片和script等资源请求，Referer为发起请求的页面地址。对于页面跳转，Referer为打开页面历史记录的前一个页面地址。因此我们使用Referer中链接的Origin部分可以得知请求的来源域名。\n\n通过refer 检测，可以定义不同的refer policy \n攻击者可以在自己的请求中隐藏Referer。 \nCSRF大多数情况下来自第三方域名，但并不能排除本域发起。如果攻击者有权限在本域发布评论（含链接、图片等，统称UGC），那么它可以直接在本域发起攻击，这种情况下同源策略无法达到防护的作用。\n\n综上所述：同源验证是一个相对简单的防范方法，能够防范绝大多数的CSRF攻击。但这并不是万无一失的，对于安全性要求较高，或者有较多用户输入内容的网站，我们就要对关键的接口做额外的防护措施。\n\n#### CSRF Token\nCSRF攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了用户自己的请求。那么我们可以要求所有的用户请求都携带一个CSRF攻击者无法获取到的Token。服务器通过校验请求是否携带正确的Token，来把正常的请求和攻击的请求区分开，也可以防范CSRF的攻击。\n\nToken是一个比较有效的CSRF防护方法，只要页面没有XSS漏洞泄露Token，那么接口的CSRF攻击就无法成功。\n\n验证码和密码其实也可以起到CSRF Token的作用哦，而且更安全。\n\n#### 双重Cookie验证\n\n利用CSRF攻击不能获取到用户Cookie的特点，我们可以要求Ajax和表单请求携带一个Cookie中的值。\n\n此方法相对于CSRF Token就简单了许多。可以直接通过前后端拦截的的方法自动化实现。后端校验也更加方便，只需进行请求中字段的对比，而不需要再进行查询和存储Token。\n\n当然，此方法并没有大规模应用，其在大型网站上的安全性还是没有CSRF Token高，原因我们举例进行说明。\n\n1. 用双重Cookie防御CSRF的优点：\n\n无需使用Session，适用面更广，易于实施。\nToken储存于客户端中，不会给服务器带来压力。\n相对于Token，实施成本更低，可以在前后端统一拦截校验，而不需要一个个接口和页面添加。\n\n2. 缺点：\n\n无法使用httponly，这样造成了cookie的安全风险。\n难以做到子域名的隔离。\n为了确保Cookie传输安全，采用这种防御方式的最好确保用整站HTTPS的方式，如果还没切HTTPS的使用这种方式也会有风险。\n\nSamesite Cookie属性\n\n####Samesite Cookie属性\n\n防止CSRF攻击的办法已经有上面的预防措施。为了从源头上解决这个问题，Google起草了一份草案来改进HTTP协议，那就是为Set-Cookie响应头新增Samesite属性，它用来标明这个 Cookie是个“同站 Cookie”，同站Cookie只能作为第一方Cookie，不能作为第三方Cookie，Samesite 有两个属性值，分别是 Strict 和 Lax，下面分别讲解：\n\nSamesite=Strict\n这种称为严格模式，表明这个 Cookie 在任何情况下都不可能作为第三方 Cookie，绝无例外。比如说 b.com 设置了如下 Cookie：\n\nSamesite=Lax 打开链接或者页面跳转时可带Cookie\n\n1. 另外一个问题是Samesite的兼容性不是很好，现阶段除了从新版Chrome和Firefox支持以外，Safari以及iOS Safari都还不支持，现阶段看来暂时还不能普及。\n2. SamesiteCookie目前有一个致命的缺陷：不支持子域。例如，种在topic.a.com下的Cookie，并不能使用a.com下种植的SamesiteCookie。这就导致了当我们网站有多个子域名时，不能使用SamesiteCookie在主域名存储用户登录信息。每个子域名都需要用户重新登录一次。\n\n\n1. 点击劫持\n1. url 跳转漏洞(url 钓鱼)\n1. 图片钓鱼\n1. iframe 钓鱼\n1. os 命令注入\n\n\nstrict-transport-security HTTP Strict Transport Security（通常简称为HSTS）是一个安全功能，它告诉浏览器只能通过HTTPS访问当前资源，而不是HTTP\n\n1. post 请求，用户访问该网页后激发 2. 链接类 用户点击后激发\n\n利用的form 表单、URL 跳转\n\n\nwaf:\n1. Web攻击防护：帮助您防护SQL注入、XSS跨站攻击等常见的Web攻击。\n1. CC攻击防护：帮助您防护针对页面请求的CC攻击。\n1. 恶意IP惩罚：帮助您自动封禁在短时间内进行多次Web攻击的客户端IP。\n1. 地理IP封禁：帮助您一键封禁来自指定国内省份或海外地区的IP的访问请求。\n\n\n1. XST 的全称是 Cross-Site Tracing，客户端发 TRACE 请求至服务器，如果服务器按照标准实现了 TRACE 响应，则在 response body 里会返回此次请求的完整头信息。通过这种方式，客户端可以获取某些敏感的头字段，例如 httpOnly 的 Cookie。","source":"_posts/security-1.md","raw":"---\ntitle: security\ndate: 2019-12-09 18:11:18\ntags: web 安全\n---\n\n\n### xss\n\nXSS 的原理是恶意攻击者往 Web 页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中 Web 里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。\n\n1. 反射型 XSS \n\n一般是通过给别人发送带有恶意脚本代码参数的 URL，当 URL 地址被打开时，特有的恶意代码参数被 HTML 解析、执行。\n不过一些浏览器如Chrome其内置了一些XSS过滤器，可以防止大部分反射型XSS攻击。\n\n反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等\n\n非持久型 XSS 漏洞攻击有以下几点特征：\n\n即时性，不经过服务器存储，直接通过 HTTP 的 GET 和 POST 请求就能完成一次攻击，拿到用户隐私数据。\n攻击者需要诱骗点击,必须要通过用户点击链接才能发起\n反馈率低，所以较难发现和响应修复\n盗取用户敏感保密信息\n\n2. 存储型 XSS\n\n持久型 XSS 漏洞，一般存在于 Form 表单提交等交互功能，如文章留言，提交文本信息等，黑客利用的 XSS 漏洞，将内容经正常功能提交进入数据库持久保存，当前端页面获得后端从数据库中读出的注入代码时，恰好将其渲染执行。\n\n这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。\n\n持久型 XSS 有以下几个特点：\n\n持久性，植入在数据库中\n盗取用户敏感私密信息\n危害面广\n\n3.DOM xss\n\n它不需要服务器解析响应的直接参与，触发XSS靠的是浏览器端的DOM解析，可以认为完全是客户端的事情。  解决方案通过csp: sript-src 的nonce值处理。\n\n4.jsonp 服务端做处理\n\n防御措施：1. httponly 2. csp 3.转义字符---现在的后端模板引擎都实现了转义 \n\n增加攻击难度，降低攻击后果\n\n\nhttps://xss-game.appspot.com/level1\n\n如果用 Vue/React 技术栈，并且不使用 v-html/dangerouslySetInnerHTML 功能，就在前端 render 阶段避免 innerHTML、outerHTML 的 XSS 隐患。\n\n### csrf\n\nCSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。\n\n\nCSRF的特点\n攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。\n攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。\n整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。\n跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。\n\n针对已上特点：同源检测 \n\n1. 同源检测 \n\n在HTTP协议中，每一个异步请求都会携带两个Header，用于标记来源域名：\n\n+ Origin Header\n+ Referer Header\n  这两个Header在浏览器发起请求时，大多数情况会自动带上，并且不能由前端自定义内容。 服务器可以通过解析这两个Header中的域名，确定请求的来源域\n\n但是Origin在以下两种情况下并不存在：\n + IE11同源策略： IE 11 不会在跨站CORS请求上添加Origin标头，Referer头将仍然是唯一的标识。最根本原因是因为IE 11对同源的定义和其他浏览器有不同，有两个主要的区别，可以参考MDN Same-origin_policy#IE_Exceptions\n\n+ 302重定向： 在302重定向之后Origin不包含在重定向的请求中，因为Origin可能会被认为是其他来源的敏感信息。对于302重定向的情况来说都是定向到新的服务器上的URL，因此浏览器不想将Origin泄漏到新的服务器上。\n\n#### 使用Referer Header确定来源域名\n\n根据HTTP协议，在HTTP头中有一个字段叫Referer，记录了该HTTP请求的来源地址。 对于Ajax请求，图片和script等资源请求，Referer为发起请求的页面地址。对于页面跳转，Referer为打开页面历史记录的前一个页面地址。因此我们使用Referer中链接的Origin部分可以得知请求的来源域名。\n\n通过refer 检测，可以定义不同的refer policy \n攻击者可以在自己的请求中隐藏Referer。 \nCSRF大多数情况下来自第三方域名，但并不能排除本域发起。如果攻击者有权限在本域发布评论（含链接、图片等，统称UGC），那么它可以直接在本域发起攻击，这种情况下同源策略无法达到防护的作用。\n\n综上所述：同源验证是一个相对简单的防范方法，能够防范绝大多数的CSRF攻击。但这并不是万无一失的，对于安全性要求较高，或者有较多用户输入内容的网站，我们就要对关键的接口做额外的防护措施。\n\n#### CSRF Token\nCSRF攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了用户自己的请求。那么我们可以要求所有的用户请求都携带一个CSRF攻击者无法获取到的Token。服务器通过校验请求是否携带正确的Token，来把正常的请求和攻击的请求区分开，也可以防范CSRF的攻击。\n\nToken是一个比较有效的CSRF防护方法，只要页面没有XSS漏洞泄露Token，那么接口的CSRF攻击就无法成功。\n\n验证码和密码其实也可以起到CSRF Token的作用哦，而且更安全。\n\n#### 双重Cookie验证\n\n利用CSRF攻击不能获取到用户Cookie的特点，我们可以要求Ajax和表单请求携带一个Cookie中的值。\n\n此方法相对于CSRF Token就简单了许多。可以直接通过前后端拦截的的方法自动化实现。后端校验也更加方便，只需进行请求中字段的对比，而不需要再进行查询和存储Token。\n\n当然，此方法并没有大规模应用，其在大型网站上的安全性还是没有CSRF Token高，原因我们举例进行说明。\n\n1. 用双重Cookie防御CSRF的优点：\n\n无需使用Session，适用面更广，易于实施。\nToken储存于客户端中，不会给服务器带来压力。\n相对于Token，实施成本更低，可以在前后端统一拦截校验，而不需要一个个接口和页面添加。\n\n2. 缺点：\n\n无法使用httponly，这样造成了cookie的安全风险。\n难以做到子域名的隔离。\n为了确保Cookie传输安全，采用这种防御方式的最好确保用整站HTTPS的方式，如果还没切HTTPS的使用这种方式也会有风险。\n\nSamesite Cookie属性\n\n####Samesite Cookie属性\n\n防止CSRF攻击的办法已经有上面的预防措施。为了从源头上解决这个问题，Google起草了一份草案来改进HTTP协议，那就是为Set-Cookie响应头新增Samesite属性，它用来标明这个 Cookie是个“同站 Cookie”，同站Cookie只能作为第一方Cookie，不能作为第三方Cookie，Samesite 有两个属性值，分别是 Strict 和 Lax，下面分别讲解：\n\nSamesite=Strict\n这种称为严格模式，表明这个 Cookie 在任何情况下都不可能作为第三方 Cookie，绝无例外。比如说 b.com 设置了如下 Cookie：\n\nSamesite=Lax 打开链接或者页面跳转时可带Cookie\n\n1. 另外一个问题是Samesite的兼容性不是很好，现阶段除了从新版Chrome和Firefox支持以外，Safari以及iOS Safari都还不支持，现阶段看来暂时还不能普及。\n2. SamesiteCookie目前有一个致命的缺陷：不支持子域。例如，种在topic.a.com下的Cookie，并不能使用a.com下种植的SamesiteCookie。这就导致了当我们网站有多个子域名时，不能使用SamesiteCookie在主域名存储用户登录信息。每个子域名都需要用户重新登录一次。\n\n\n1. 点击劫持\n1. url 跳转漏洞(url 钓鱼)\n1. 图片钓鱼\n1. iframe 钓鱼\n1. os 命令注入\n\n\nstrict-transport-security HTTP Strict Transport Security（通常简称为HSTS）是一个安全功能，它告诉浏览器只能通过HTTPS访问当前资源，而不是HTTP\n\n1. post 请求，用户访问该网页后激发 2. 链接类 用户点击后激发\n\n利用的form 表单、URL 跳转\n\n\nwaf:\n1. Web攻击防护：帮助您防护SQL注入、XSS跨站攻击等常见的Web攻击。\n1. CC攻击防护：帮助您防护针对页面请求的CC攻击。\n1. 恶意IP惩罚：帮助您自动封禁在短时间内进行多次Web攻击的客户端IP。\n1. 地理IP封禁：帮助您一键封禁来自指定国内省份或海外地区的IP的访问请求。\n\n\n1. XST 的全称是 Cross-Site Tracing，客户端发 TRACE 请求至服务器，如果服务器按照标准实现了 TRACE 响应，则在 response body 里会返回此次请求的完整头信息。通过这种方式，客户端可以获取某些敏感的头字段，例如 httpOnly 的 Cookie。","slug":"security-1","published":1,"updated":"2020-01-02T07:49:41.657Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5bwexd60011998smoqci7o0","content":"<h3 id=\"xss\"><a href=\"#xss\" class=\"headerlink\" title=\"xss\"></a>xss</h3><p>XSS 的原理是恶意攻击者往 Web 页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中 Web 里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。</p>\n<ol>\n<li>反射型 XSS </li>\n</ol>\n<p>一般是通过给别人发送带有恶意脚本代码参数的 URL，当 URL 地址被打开时，特有的恶意代码参数被 HTML 解析、执行。<br>不过一些浏览器如Chrome其内置了一些XSS过滤器，可以防止大部分反射型XSS攻击。</p>\n<p>反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等</p>\n<p>非持久型 XSS 漏洞攻击有以下几点特征：</p>\n<p>即时性，不经过服务器存储，直接通过 HTTP 的 GET 和 POST 请求就能完成一次攻击，拿到用户隐私数据。<br>攻击者需要诱骗点击,必须要通过用户点击链接才能发起<br>反馈率低，所以较难发现和响应修复<br>盗取用户敏感保密信息</p>\n<ol start=\"2\">\n<li>存储型 XSS</li>\n</ol>\n<p>持久型 XSS 漏洞，一般存在于 Form 表单提交等交互功能，如文章留言，提交文本信息等，黑客利用的 XSS 漏洞，将内容经正常功能提交进入数据库持久保存，当前端页面获得后端从数据库中读出的注入代码时，恰好将其渲染执行。</p>\n<p>这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。</p>\n<p>持久型 XSS 有以下几个特点：</p>\n<p>持久性，植入在数据库中<br>盗取用户敏感私密信息<br>危害面广</p>\n<p>3.DOM xss</p>\n<p>它不需要服务器解析响应的直接参与，触发XSS靠的是浏览器端的DOM解析，可以认为完全是客户端的事情。  解决方案通过csp: sript-src 的nonce值处理。</p>\n<p>4.jsonp 服务端做处理</p>\n<p>防御措施：1. httponly 2. csp 3.转义字符—现在的后端模板引擎都实现了转义 </p>\n<p>增加攻击难度，降低攻击后果</p>\n<p><a href=\"https://xss-game.appspot.com/level1\" target=\"_blank\" rel=\"noopener\">https://xss-game.appspot.com/level1</a></p>\n<p>如果用 Vue/React 技术栈，并且不使用 v-html/dangerouslySetInnerHTML 功能，就在前端 render 阶段避免 innerHTML、outerHTML 的 XSS 隐患。</p>\n<h3 id=\"csrf\"><a href=\"#csrf\" class=\"headerlink\" title=\"csrf\"></a>csrf</h3><p>CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</p>\n<p>CSRF的特点<br>攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。<br>攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。<br>整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。<br>跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。</p>\n<p>针对已上特点：同源检测 </p>\n<ol>\n<li>同源检测 </li>\n</ol>\n<p>在HTTP协议中，每一个异步请求都会携带两个Header，用于标记来源域名：</p>\n<ul>\n<li>Origin Header</li>\n<li>Referer Header<br>这两个Header在浏览器发起请求时，大多数情况会自动带上，并且不能由前端自定义内容。 服务器可以通过解析这两个Header中的域名，确定请求的来源域</li>\n</ul>\n<p>但是Origin在以下两种情况下并不存在：</p>\n<ul>\n<li>IE11同源策略： IE 11 不会在跨站CORS请求上添加Origin标头，Referer头将仍然是唯一的标识。最根本原因是因为IE 11对同源的定义和其他浏览器有不同，有两个主要的区别，可以参考MDN Same-origin_policy#IE_Exceptions</li>\n</ul>\n<ul>\n<li>302重定向： 在302重定向之后Origin不包含在重定向的请求中，因为Origin可能会被认为是其他来源的敏感信息。对于302重定向的情况来说都是定向到新的服务器上的URL，因此浏览器不想将Origin泄漏到新的服务器上。</li>\n</ul>\n<h4 id=\"使用Referer-Header确定来源域名\"><a href=\"#使用Referer-Header确定来源域名\" class=\"headerlink\" title=\"使用Referer Header确定来源域名\"></a>使用Referer Header确定来源域名</h4><p>根据HTTP协议，在HTTP头中有一个字段叫Referer，记录了该HTTP请求的来源地址。 对于Ajax请求，图片和script等资源请求，Referer为发起请求的页面地址。对于页面跳转，Referer为打开页面历史记录的前一个页面地址。因此我们使用Referer中链接的Origin部分可以得知请求的来源域名。</p>\n<p>通过refer 检测，可以定义不同的refer policy<br>攻击者可以在自己的请求中隐藏Referer。<br>CSRF大多数情况下来自第三方域名，但并不能排除本域发起。如果攻击者有权限在本域发布评论（含链接、图片等，统称UGC），那么它可以直接在本域发起攻击，这种情况下同源策略无法达到防护的作用。</p>\n<p>综上所述：同源验证是一个相对简单的防范方法，能够防范绝大多数的CSRF攻击。但这并不是万无一失的，对于安全性要求较高，或者有较多用户输入内容的网站，我们就要对关键的接口做额外的防护措施。</p>\n<h4 id=\"CSRF-Token\"><a href=\"#CSRF-Token\" class=\"headerlink\" title=\"CSRF Token\"></a>CSRF Token</h4><p>CSRF攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了用户自己的请求。那么我们可以要求所有的用户请求都携带一个CSRF攻击者无法获取到的Token。服务器通过校验请求是否携带正确的Token，来把正常的请求和攻击的请求区分开，也可以防范CSRF的攻击。</p>\n<p>Token是一个比较有效的CSRF防护方法，只要页面没有XSS漏洞泄露Token，那么接口的CSRF攻击就无法成功。</p>\n<p>验证码和密码其实也可以起到CSRF Token的作用哦，而且更安全。</p>\n<h4 id=\"双重Cookie验证\"><a href=\"#双重Cookie验证\" class=\"headerlink\" title=\"双重Cookie验证\"></a>双重Cookie验证</h4><p>利用CSRF攻击不能获取到用户Cookie的特点，我们可以要求Ajax和表单请求携带一个Cookie中的值。</p>\n<p>此方法相对于CSRF Token就简单了许多。可以直接通过前后端拦截的的方法自动化实现。后端校验也更加方便，只需进行请求中字段的对比，而不需要再进行查询和存储Token。</p>\n<p>当然，此方法并没有大规模应用，其在大型网站上的安全性还是没有CSRF Token高，原因我们举例进行说明。</p>\n<ol>\n<li>用双重Cookie防御CSRF的优点：</li>\n</ol>\n<p>无需使用Session，适用面更广，易于实施。<br>Token储存于客户端中，不会给服务器带来压力。<br>相对于Token，实施成本更低，可以在前后端统一拦截校验，而不需要一个个接口和页面添加。</p>\n<ol start=\"2\">\n<li>缺点：</li>\n</ol>\n<p>无法使用httponly，这样造成了cookie的安全风险。<br>难以做到子域名的隔离。<br>为了确保Cookie传输安全，采用这种防御方式的最好确保用整站HTTPS的方式，如果还没切HTTPS的使用这种方式也会有风险。</p>\n<p>Samesite Cookie属性</p>\n<p>####Samesite Cookie属性</p>\n<p>防止CSRF攻击的办法已经有上面的预防措施。为了从源头上解决这个问题，Google起草了一份草案来改进HTTP协议，那就是为Set-Cookie响应头新增Samesite属性，它用来标明这个 Cookie是个“同站 Cookie”，同站Cookie只能作为第一方Cookie，不能作为第三方Cookie，Samesite 有两个属性值，分别是 Strict 和 Lax，下面分别讲解：</p>\n<p>Samesite=Strict<br>这种称为严格模式，表明这个 Cookie 在任何情况下都不可能作为第三方 Cookie，绝无例外。比如说 b.com 设置了如下 Cookie：</p>\n<p>Samesite=Lax 打开链接或者页面跳转时可带Cookie</p>\n<ol>\n<li>另外一个问题是Samesite的兼容性不是很好，现阶段除了从新版Chrome和Firefox支持以外，Safari以及iOS Safari都还不支持，现阶段看来暂时还不能普及。</li>\n<li>SamesiteCookie目前有一个致命的缺陷：不支持子域。例如，种在topic.a.com下的Cookie，并不能使用a.com下种植的SamesiteCookie。这就导致了当我们网站有多个子域名时，不能使用SamesiteCookie在主域名存储用户登录信息。每个子域名都需要用户重新登录一次。</li>\n</ol>\n<ol>\n<li>点击劫持</li>\n<li>url 跳转漏洞(url 钓鱼)</li>\n<li>图片钓鱼</li>\n<li>iframe 钓鱼</li>\n<li>os 命令注入</li>\n</ol>\n<p>strict-transport-security HTTP Strict Transport Security（通常简称为HSTS）是一个安全功能，它告诉浏览器只能通过HTTPS访问当前资源，而不是HTTP</p>\n<ol>\n<li>post 请求，用户访问该网页后激发 2. 链接类 用户点击后激发</li>\n</ol>\n<p>利用的form 表单、URL 跳转</p>\n<p>waf:</p>\n<ol>\n<li>Web攻击防护：帮助您防护SQL注入、XSS跨站攻击等常见的Web攻击。</li>\n<li>CC攻击防护：帮助您防护针对页面请求的CC攻击。</li>\n<li>恶意IP惩罚：帮助您自动封禁在短时间内进行多次Web攻击的客户端IP。</li>\n<li>地理IP封禁：帮助您一键封禁来自指定国内省份或海外地区的IP的访问请求。</li>\n</ol>\n<ol>\n<li>XST 的全称是 Cross-Site Tracing，客户端发 TRACE 请求至服务器，如果服务器按照标准实现了 TRACE 响应，则在 response body 里会返回此次请求的完整头信息。通过这种方式，客户端可以获取某些敏感的头字段，例如 httpOnly 的 Cookie。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"xss\"><a href=\"#xss\" class=\"headerlink\" title=\"xss\"></a>xss</h3><p>XSS 的原理是恶意攻击者往 Web 页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中 Web 里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。</p>\n<ol>\n<li>反射型 XSS </li>\n</ol>\n<p>一般是通过给别人发送带有恶意脚本代码参数的 URL，当 URL 地址被打开时，特有的恶意代码参数被 HTML 解析、执行。<br>不过一些浏览器如Chrome其内置了一些XSS过滤器，可以防止大部分反射型XSS攻击。</p>\n<p>反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等</p>\n<p>非持久型 XSS 漏洞攻击有以下几点特征：</p>\n<p>即时性，不经过服务器存储，直接通过 HTTP 的 GET 和 POST 请求就能完成一次攻击，拿到用户隐私数据。<br>攻击者需要诱骗点击,必须要通过用户点击链接才能发起<br>反馈率低，所以较难发现和响应修复<br>盗取用户敏感保密信息</p>\n<ol start=\"2\">\n<li>存储型 XSS</li>\n</ol>\n<p>持久型 XSS 漏洞，一般存在于 Form 表单提交等交互功能，如文章留言，提交文本信息等，黑客利用的 XSS 漏洞，将内容经正常功能提交进入数据库持久保存，当前端页面获得后端从数据库中读出的注入代码时，恰好将其渲染执行。</p>\n<p>这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。</p>\n<p>持久型 XSS 有以下几个特点：</p>\n<p>持久性，植入在数据库中<br>盗取用户敏感私密信息<br>危害面广</p>\n<p>3.DOM xss</p>\n<p>它不需要服务器解析响应的直接参与，触发XSS靠的是浏览器端的DOM解析，可以认为完全是客户端的事情。  解决方案通过csp: sript-src 的nonce值处理。</p>\n<p>4.jsonp 服务端做处理</p>\n<p>防御措施：1. httponly 2. csp 3.转义字符—现在的后端模板引擎都实现了转义 </p>\n<p>增加攻击难度，降低攻击后果</p>\n<p><a href=\"https://xss-game.appspot.com/level1\" target=\"_blank\" rel=\"noopener\">https://xss-game.appspot.com/level1</a></p>\n<p>如果用 Vue/React 技术栈，并且不使用 v-html/dangerouslySetInnerHTML 功能，就在前端 render 阶段避免 innerHTML、outerHTML 的 XSS 隐患。</p>\n<h3 id=\"csrf\"><a href=\"#csrf\" class=\"headerlink\" title=\"csrf\"></a>csrf</h3><p>CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</p>\n<p>CSRF的特点<br>攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。<br>攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。<br>整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。<br>跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。</p>\n<p>针对已上特点：同源检测 </p>\n<ol>\n<li>同源检测 </li>\n</ol>\n<p>在HTTP协议中，每一个异步请求都会携带两个Header，用于标记来源域名：</p>\n<ul>\n<li>Origin Header</li>\n<li>Referer Header<br>这两个Header在浏览器发起请求时，大多数情况会自动带上，并且不能由前端自定义内容。 服务器可以通过解析这两个Header中的域名，确定请求的来源域</li>\n</ul>\n<p>但是Origin在以下两种情况下并不存在：</p>\n<ul>\n<li>IE11同源策略： IE 11 不会在跨站CORS请求上添加Origin标头，Referer头将仍然是唯一的标识。最根本原因是因为IE 11对同源的定义和其他浏览器有不同，有两个主要的区别，可以参考MDN Same-origin_policy#IE_Exceptions</li>\n</ul>\n<ul>\n<li>302重定向： 在302重定向之后Origin不包含在重定向的请求中，因为Origin可能会被认为是其他来源的敏感信息。对于302重定向的情况来说都是定向到新的服务器上的URL，因此浏览器不想将Origin泄漏到新的服务器上。</li>\n</ul>\n<h4 id=\"使用Referer-Header确定来源域名\"><a href=\"#使用Referer-Header确定来源域名\" class=\"headerlink\" title=\"使用Referer Header确定来源域名\"></a>使用Referer Header确定来源域名</h4><p>根据HTTP协议，在HTTP头中有一个字段叫Referer，记录了该HTTP请求的来源地址。 对于Ajax请求，图片和script等资源请求，Referer为发起请求的页面地址。对于页面跳转，Referer为打开页面历史记录的前一个页面地址。因此我们使用Referer中链接的Origin部分可以得知请求的来源域名。</p>\n<p>通过refer 检测，可以定义不同的refer policy<br>攻击者可以在自己的请求中隐藏Referer。<br>CSRF大多数情况下来自第三方域名，但并不能排除本域发起。如果攻击者有权限在本域发布评论（含链接、图片等，统称UGC），那么它可以直接在本域发起攻击，这种情况下同源策略无法达到防护的作用。</p>\n<p>综上所述：同源验证是一个相对简单的防范方法，能够防范绝大多数的CSRF攻击。但这并不是万无一失的，对于安全性要求较高，或者有较多用户输入内容的网站，我们就要对关键的接口做额外的防护措施。</p>\n<h4 id=\"CSRF-Token\"><a href=\"#CSRF-Token\" class=\"headerlink\" title=\"CSRF Token\"></a>CSRF Token</h4><p>CSRF攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了用户自己的请求。那么我们可以要求所有的用户请求都携带一个CSRF攻击者无法获取到的Token。服务器通过校验请求是否携带正确的Token，来把正常的请求和攻击的请求区分开，也可以防范CSRF的攻击。</p>\n<p>Token是一个比较有效的CSRF防护方法，只要页面没有XSS漏洞泄露Token，那么接口的CSRF攻击就无法成功。</p>\n<p>验证码和密码其实也可以起到CSRF Token的作用哦，而且更安全。</p>\n<h4 id=\"双重Cookie验证\"><a href=\"#双重Cookie验证\" class=\"headerlink\" title=\"双重Cookie验证\"></a>双重Cookie验证</h4><p>利用CSRF攻击不能获取到用户Cookie的特点，我们可以要求Ajax和表单请求携带一个Cookie中的值。</p>\n<p>此方法相对于CSRF Token就简单了许多。可以直接通过前后端拦截的的方法自动化实现。后端校验也更加方便，只需进行请求中字段的对比，而不需要再进行查询和存储Token。</p>\n<p>当然，此方法并没有大规模应用，其在大型网站上的安全性还是没有CSRF Token高，原因我们举例进行说明。</p>\n<ol>\n<li>用双重Cookie防御CSRF的优点：</li>\n</ol>\n<p>无需使用Session，适用面更广，易于实施。<br>Token储存于客户端中，不会给服务器带来压力。<br>相对于Token，实施成本更低，可以在前后端统一拦截校验，而不需要一个个接口和页面添加。</p>\n<ol start=\"2\">\n<li>缺点：</li>\n</ol>\n<p>无法使用httponly，这样造成了cookie的安全风险。<br>难以做到子域名的隔离。<br>为了确保Cookie传输安全，采用这种防御方式的最好确保用整站HTTPS的方式，如果还没切HTTPS的使用这种方式也会有风险。</p>\n<p>Samesite Cookie属性</p>\n<p>####Samesite Cookie属性</p>\n<p>防止CSRF攻击的办法已经有上面的预防措施。为了从源头上解决这个问题，Google起草了一份草案来改进HTTP协议，那就是为Set-Cookie响应头新增Samesite属性，它用来标明这个 Cookie是个“同站 Cookie”，同站Cookie只能作为第一方Cookie，不能作为第三方Cookie，Samesite 有两个属性值，分别是 Strict 和 Lax，下面分别讲解：</p>\n<p>Samesite=Strict<br>这种称为严格模式，表明这个 Cookie 在任何情况下都不可能作为第三方 Cookie，绝无例外。比如说 b.com 设置了如下 Cookie：</p>\n<p>Samesite=Lax 打开链接或者页面跳转时可带Cookie</p>\n<ol>\n<li>另外一个问题是Samesite的兼容性不是很好，现阶段除了从新版Chrome和Firefox支持以外，Safari以及iOS Safari都还不支持，现阶段看来暂时还不能普及。</li>\n<li>SamesiteCookie目前有一个致命的缺陷：不支持子域。例如，种在topic.a.com下的Cookie，并不能使用a.com下种植的SamesiteCookie。这就导致了当我们网站有多个子域名时，不能使用SamesiteCookie在主域名存储用户登录信息。每个子域名都需要用户重新登录一次。</li>\n</ol>\n<ol>\n<li>点击劫持</li>\n<li>url 跳转漏洞(url 钓鱼)</li>\n<li>图片钓鱼</li>\n<li>iframe 钓鱼</li>\n<li>os 命令注入</li>\n</ol>\n<p>strict-transport-security HTTP Strict Transport Security（通常简称为HSTS）是一个安全功能，它告诉浏览器只能通过HTTPS访问当前资源，而不是HTTP</p>\n<ol>\n<li>post 请求，用户访问该网页后激发 2. 链接类 用户点击后激发</li>\n</ol>\n<p>利用的form 表单、URL 跳转</p>\n<p>waf:</p>\n<ol>\n<li>Web攻击防护：帮助您防护SQL注入、XSS跨站攻击等常见的Web攻击。</li>\n<li>CC攻击防护：帮助您防护针对页面请求的CC攻击。</li>\n<li>恶意IP惩罚：帮助您自动封禁在短时间内进行多次Web攻击的客户端IP。</li>\n<li>地理IP封禁：帮助您一键封禁来自指定国内省份或海外地区的IP的访问请求。</li>\n</ol>\n<ol>\n<li>XST 的全称是 Cross-Site Tracing，客户端发 TRACE 请求至服务器，如果服务器按照标准实现了 TRACE 响应，则在 response body 里会返回此次请求的完整头信息。通过这种方式，客户端可以获取某些敏感的头字段，例如 httpOnly 的 Cookie。</li>\n</ol>\n"},{"title":"security","date":"2019-04-25T08:49:58.000Z","_content":"```text\n参考： https://juejin.im/post/5bad9140e51d450e935c6d64#heading-9\n\nxss 攻击类型分为：反射、存储和dom \n\n在纯前端渲染中，我们会明确的告诉浏览器：下面要设置的内容是文本（.innerText），还是属性（.setAttribute），还是样式（.style）等等。浏览器不会被轻易的被欺骗，执行预期外的代码了.\n\n在很多内部、管理系统中，采用纯前端渲染是非常合适的。但对于性能要求高，或有 SEO 需求的页面，我们仍然要面对拼接 HTML 的问题。需要html 转义。\n\n利用模板引擎\n开启模板引擎自带的 HTML 转义功能。例如：\n在 ejs 中，尽量使用 <%= data %> 而不是 <%- data %>；\n在 doT.js 中，尽量使用 {{! data } 而不是 {{= data }；\n在 FreeMarker 中，确保引擎版本高于 2.3.24，并且选择正确的 freemarker.core.OutputFormat。\n避免内联事件\n尽量不要使用 onLoad=\"onload('{{data}}')\"、onClick=\"go('{{action}}')\" 这种拼接内联事件的写法。在 JavaScript 中通过 .addEventlistener() 事件绑定会更安全。\n避免拼接 HTML\n前端采用拼接 HTML 的方法比较危险，如果框架允许，使用 createElement、setAttribute 之类的方法实现。或者采用比较成熟的渲染框架，如 Vue/React 等。\n时刻保持警惕\n在插入位置为 DOM 属性、链接等位置时，要打起精神，严加防范。\n增加攻击难度，降低攻击后果\n通过 CSP、输入长度配置、接口安全措施等方法，增加攻击的难度，降低攻击的后果。\n主动检测和发现\n可使用 XSS 攻击字符串和自动扫描工具寻找潜在的 XSS 漏洞。\n\n```\n\n\n\n","source":"_posts/security.md","raw":"---\ntitle: security\ndate: 2019-04-25 16:49:58\ntags: 安全\n---\n```text\n参考： https://juejin.im/post/5bad9140e51d450e935c6d64#heading-9\n\nxss 攻击类型分为：反射、存储和dom \n\n在纯前端渲染中，我们会明确的告诉浏览器：下面要设置的内容是文本（.innerText），还是属性（.setAttribute），还是样式（.style）等等。浏览器不会被轻易的被欺骗，执行预期外的代码了.\n\n在很多内部、管理系统中，采用纯前端渲染是非常合适的。但对于性能要求高，或有 SEO 需求的页面，我们仍然要面对拼接 HTML 的问题。需要html 转义。\n\n利用模板引擎\n开启模板引擎自带的 HTML 转义功能。例如：\n在 ejs 中，尽量使用 <%= data %> 而不是 <%- data %>；\n在 doT.js 中，尽量使用 {{! data } 而不是 {{= data }；\n在 FreeMarker 中，确保引擎版本高于 2.3.24，并且选择正确的 freemarker.core.OutputFormat。\n避免内联事件\n尽量不要使用 onLoad=\"onload('{{data}}')\"、onClick=\"go('{{action}}')\" 这种拼接内联事件的写法。在 JavaScript 中通过 .addEventlistener() 事件绑定会更安全。\n避免拼接 HTML\n前端采用拼接 HTML 的方法比较危险，如果框架允许，使用 createElement、setAttribute 之类的方法实现。或者采用比较成熟的渲染框架，如 Vue/React 等。\n时刻保持警惕\n在插入位置为 DOM 属性、链接等位置时，要打起精神，严加防范。\n增加攻击难度，降低攻击后果\n通过 CSP、输入长度配置、接口安全措施等方法，增加攻击的难度，降低攻击的后果。\n主动检测和发现\n可使用 XSS 攻击字符串和自动扫描工具寻找潜在的 XSS 漏洞。\n\n```\n\n\n\n","slug":"security","published":1,"updated":"2019-07-26T08:35:17.312Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5bwexd60013998sr1wambin","content":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">参考： https://juejin.im/post/5bad9140e51d450e935c6d64#heading-9</span><br><span class=\"line\"></span><br><span class=\"line\">xss 攻击类型分为：反射、存储和dom </span><br><span class=\"line\"></span><br><span class=\"line\">在纯前端渲染中，我们会明确的告诉浏览器：下面要设置的内容是文本（.innerText），还是属性（.setAttribute），还是样式（.style）等等。浏览器不会被轻易的被欺骗，执行预期外的代码了.</span><br><span class=\"line\"></span><br><span class=\"line\">在很多内部、管理系统中，采用纯前端渲染是非常合适的。但对于性能要求高，或有 SEO 需求的页面，我们仍然要面对拼接 HTML 的问题。需要html 转义。</span><br><span class=\"line\"></span><br><span class=\"line\">利用模板引擎</span><br><span class=\"line\">开启模板引擎自带的 HTML 转义功能。例如：</span><br><span class=\"line\">在 ejs 中，尽量使用 &lt;%= data %&gt; 而不是 &lt;%- data %&gt;；</span><br><span class=\"line\">在 doT.js 中，尽量使用 &#123;&#123;! data &#125; 而不是 &#123;&#123;= data &#125;；</span><br><span class=\"line\">在 FreeMarker 中，确保引擎版本高于 2.3.24，并且选择正确的 freemarker.core.OutputFormat。</span><br><span class=\"line\">避免内联事件</span><br><span class=\"line\">尽量不要使用 onLoad=&quot;onload(&apos;&#123;&#123;data&#125;&#125;&apos;)&quot;、onClick=&quot;go(&apos;&#123;&#123;action&#125;&#125;&apos;)&quot; 这种拼接内联事件的写法。在 JavaScript 中通过 .addEventlistener() 事件绑定会更安全。</span><br><span class=\"line\">避免拼接 HTML</span><br><span class=\"line\">前端采用拼接 HTML 的方法比较危险，如果框架允许，使用 createElement、setAttribute 之类的方法实现。或者采用比较成熟的渲染框架，如 Vue/React 等。</span><br><span class=\"line\">时刻保持警惕</span><br><span class=\"line\">在插入位置为 DOM 属性、链接等位置时，要打起精神，严加防范。</span><br><span class=\"line\">增加攻击难度，降低攻击后果</span><br><span class=\"line\">通过 CSP、输入长度配置、接口安全措施等方法，增加攻击的难度，降低攻击的后果。</span><br><span class=\"line\">主动检测和发现</span><br><span class=\"line\">可使用 XSS 攻击字符串和自动扫描工具寻找潜在的 XSS 漏洞。</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">参考： https://juejin.im/post/5bad9140e51d450e935c6d64#heading-9</span><br><span class=\"line\"></span><br><span class=\"line\">xss 攻击类型分为：反射、存储和dom </span><br><span class=\"line\"></span><br><span class=\"line\">在纯前端渲染中，我们会明确的告诉浏览器：下面要设置的内容是文本（.innerText），还是属性（.setAttribute），还是样式（.style）等等。浏览器不会被轻易的被欺骗，执行预期外的代码了.</span><br><span class=\"line\"></span><br><span class=\"line\">在很多内部、管理系统中，采用纯前端渲染是非常合适的。但对于性能要求高，或有 SEO 需求的页面，我们仍然要面对拼接 HTML 的问题。需要html 转义。</span><br><span class=\"line\"></span><br><span class=\"line\">利用模板引擎</span><br><span class=\"line\">开启模板引擎自带的 HTML 转义功能。例如：</span><br><span class=\"line\">在 ejs 中，尽量使用 &lt;%= data %&gt; 而不是 &lt;%- data %&gt;；</span><br><span class=\"line\">在 doT.js 中，尽量使用 &#123;&#123;! data &#125; 而不是 &#123;&#123;= data &#125;；</span><br><span class=\"line\">在 FreeMarker 中，确保引擎版本高于 2.3.24，并且选择正确的 freemarker.core.OutputFormat。</span><br><span class=\"line\">避免内联事件</span><br><span class=\"line\">尽量不要使用 onLoad=&quot;onload(&apos;&#123;&#123;data&#125;&#125;&apos;)&quot;、onClick=&quot;go(&apos;&#123;&#123;action&#125;&#125;&apos;)&quot; 这种拼接内联事件的写法。在 JavaScript 中通过 .addEventlistener() 事件绑定会更安全。</span><br><span class=\"line\">避免拼接 HTML</span><br><span class=\"line\">前端采用拼接 HTML 的方法比较危险，如果框架允许，使用 createElement、setAttribute 之类的方法实现。或者采用比较成熟的渲染框架，如 Vue/React 等。</span><br><span class=\"line\">时刻保持警惕</span><br><span class=\"line\">在插入位置为 DOM 属性、链接等位置时，要打起精神，严加防范。</span><br><span class=\"line\">增加攻击难度，降低攻击后果</span><br><span class=\"line\">通过 CSP、输入长度配置、接口安全措施等方法，增加攻击的难度，降低攻击的后果。</span><br><span class=\"line\">主动检测和发现</span><br><span class=\"line\">可使用 XSS 攻击字符串和自动扫描工具寻找潜在的 XSS 漏洞。</span><br></pre></td></tr></table></figure>\n"},{"title":"stringencode","date":"2019-12-10T09:10:23.000Z","_content":"\nASCII、UTF-8\\16\nunicode GB2312 \n\n字符是语言中的概念，但是计算机只认识 0 和 1 这两个数字。因此要想让计算机存储、处理字符串，就必须把字符串用二进制表示出来。在 ASCII 码中，每个英文字母都有自己对应的数字。我们通常把 ASCII 码称为字符集，也就是字符的集合。了解 ASCII 码的同学应该都知道小写字母 a 可以用 97 来表示，97 也被称为字符 a 在 ASCII 字符集中的码位。\n\n可见把字符转换成码位的过程类似于加密(encrypt)，我们称之为编码(encode)，反则则类似于解密，我们称之为解码(decode)\n\n字符转换成码位的过程是编码，这个过程有无数种实现方式。比如 a -> 97、b -> 98 这种就是 ASCII 编码，因为 255 = 2 ^ 8，所以所有 ASCII 编码下的码位恰好都可以由一个字节表示。\n\n除了中国人之外，各个地区的人也都根据自己的语言拓展了相应的编码方式。这样unicode就出现了。\n\n缺点：过于庞大、\n\n中文的utf-8 大于GBk的两个字节\n\n因此，我们有了对 Unicode 字符再次编码的编码方式，常见的有 utf-8，utf-16 等。UTF 表示 Unicode Transfer Format，因此是针对 Unicode 字符集的一系列编码方式。utf-8 是一种变长编码，也就是说不同的 Unicode 字符在 utf-8 编码下的码位长度可能不同，如下表所示:\n\n |Unicode 编码(16进制) | utf-8 码位(二进制)|\n |----|----|\n |000000-00007F       |0xxxxxxx|\n |000080-0007FF|110xxxxx 10xxxxxx|\n |000800-00FFFF|1110xxxx 10xxxxxx 10xxxxxx|\n |010000-1FFFFF|11110xxx10xxxxxx10xxxxxx10xxxxxx|\n\n\n1. escape\n1. encodeURIComponent encodeURI\n\nencodeURI()不会对本身属于URI的特殊字符进行编码，例如冒号、正斜杠、问号和井字号；而encodeURIComponent()则会对它发现的任何非标准字符进行编码。\n使用encodeURI()编码后的结果是除了空格之外的其他字符都原封不动，只有空格被替换成了%20。而encodeURIComponent()方法则会使用对应的编码替换所有非字母数字字符。\n\nescape 在处理 0xff 之外字符的时候，是直接使用字符的 unicode 在前面加上一个 「%u」,举例说明。\n而encodeURI则是先进行 UTF-8，再在 UTF-8 的每个字节码前加上一个 「%」；\nencodeURI 是W3C 的标准，而 Escape 是非标准。","source":"_posts/stringencode.md","raw":"---\ntitle: stringencode\ndate: 2019-12-10 17:10:23\ntags: encode decode\n---\n\nASCII、UTF-8\\16\nunicode GB2312 \n\n字符是语言中的概念，但是计算机只认识 0 和 1 这两个数字。因此要想让计算机存储、处理字符串，就必须把字符串用二进制表示出来。在 ASCII 码中，每个英文字母都有自己对应的数字。我们通常把 ASCII 码称为字符集，也就是字符的集合。了解 ASCII 码的同学应该都知道小写字母 a 可以用 97 来表示，97 也被称为字符 a 在 ASCII 字符集中的码位。\n\n可见把字符转换成码位的过程类似于加密(encrypt)，我们称之为编码(encode)，反则则类似于解密，我们称之为解码(decode)\n\n字符转换成码位的过程是编码，这个过程有无数种实现方式。比如 a -> 97、b -> 98 这种就是 ASCII 编码，因为 255 = 2 ^ 8，所以所有 ASCII 编码下的码位恰好都可以由一个字节表示。\n\n除了中国人之外，各个地区的人也都根据自己的语言拓展了相应的编码方式。这样unicode就出现了。\n\n缺点：过于庞大、\n\n中文的utf-8 大于GBk的两个字节\n\n因此，我们有了对 Unicode 字符再次编码的编码方式，常见的有 utf-8，utf-16 等。UTF 表示 Unicode Transfer Format，因此是针对 Unicode 字符集的一系列编码方式。utf-8 是一种变长编码，也就是说不同的 Unicode 字符在 utf-8 编码下的码位长度可能不同，如下表所示:\n\n |Unicode 编码(16进制) | utf-8 码位(二进制)|\n |----|----|\n |000000-00007F       |0xxxxxxx|\n |000080-0007FF|110xxxxx 10xxxxxx|\n |000800-00FFFF|1110xxxx 10xxxxxx 10xxxxxx|\n |010000-1FFFFF|11110xxx10xxxxxx10xxxxxx10xxxxxx|\n\n\n1. escape\n1. encodeURIComponent encodeURI\n\nencodeURI()不会对本身属于URI的特殊字符进行编码，例如冒号、正斜杠、问号和井字号；而encodeURIComponent()则会对它发现的任何非标准字符进行编码。\n使用encodeURI()编码后的结果是除了空格之外的其他字符都原封不动，只有空格被替换成了%20。而encodeURIComponent()方法则会使用对应的编码替换所有非字母数字字符。\n\nescape 在处理 0xff 之外字符的时候，是直接使用字符的 unicode 在前面加上一个 「%u」,举例说明。\n而encodeURI则是先进行 UTF-8，再在 UTF-8 的每个字节码前加上一个 「%」；\nencodeURI 是W3C 的标准，而 Escape 是非标准。","slug":"stringencode","published":1,"updated":"2019-12-10T09:14:10.304Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5bwexd70015998s4trt742i","content":"<p>ASCII、UTF-8\\16<br>unicode GB2312 </p>\n<p>字符是语言中的概念，但是计算机只认识 0 和 1 这两个数字。因此要想让计算机存储、处理字符串，就必须把字符串用二进制表示出来。在 ASCII 码中，每个英文字母都有自己对应的数字。我们通常把 ASCII 码称为字符集，也就是字符的集合。了解 ASCII 码的同学应该都知道小写字母 a 可以用 97 来表示，97 也被称为字符 a 在 ASCII 字符集中的码位。</p>\n<p>可见把字符转换成码位的过程类似于加密(encrypt)，我们称之为编码(encode)，反则则类似于解密，我们称之为解码(decode)</p>\n<p>字符转换成码位的过程是编码，这个过程有无数种实现方式。比如 a -&gt; 97、b -&gt; 98 这种就是 ASCII 编码，因为 255 = 2 ^ 8，所以所有 ASCII 编码下的码位恰好都可以由一个字节表示。</p>\n<p>除了中国人之外，各个地区的人也都根据自己的语言拓展了相应的编码方式。这样unicode就出现了。</p>\n<p>缺点：过于庞大、</p>\n<p>中文的utf-8 大于GBk的两个字节</p>\n<p>因此，我们有了对 Unicode 字符再次编码的编码方式，常见的有 utf-8，utf-16 等。UTF 表示 Unicode Transfer Format，因此是针对 Unicode 字符集的一系列编码方式。utf-8 是一种变长编码，也就是说不同的 Unicode 字符在 utf-8 编码下的码位长度可能不同，如下表所示:</p>\n<table>\n<thead>\n<tr>\n<th>Unicode 编码(16进制)</th>\n<th>utf-8 码位(二进制)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>000000-00007F</td>\n<td>0xxxxxxx</td>\n</tr>\n<tr>\n<td>000080-0007FF</td>\n<td>110xxxxx 10xxxxxx</td>\n</tr>\n<tr>\n<td>000800-00FFFF</td>\n<td>1110xxxx 10xxxxxx 10xxxxxx</td>\n</tr>\n<tr>\n<td>010000-1FFFFF</td>\n<td>11110xxx10xxxxxx10xxxxxx10xxxxxx</td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li>escape</li>\n<li>encodeURIComponent encodeURI</li>\n</ol>\n<p>encodeURI()不会对本身属于URI的特殊字符进行编码，例如冒号、正斜杠、问号和井字号；而encodeURIComponent()则会对它发现的任何非标准字符进行编码。<br>使用encodeURI()编码后的结果是除了空格之外的其他字符都原封不动，只有空格被替换成了%20。而encodeURIComponent()方法则会使用对应的编码替换所有非字母数字字符。</p>\n<p>escape 在处理 0xff 之外字符的时候，是直接使用字符的 unicode 在前面加上一个 「%u」,举例说明。<br>而encodeURI则是先进行 UTF-8，再在 UTF-8 的每个字节码前加上一个 「%」；<br>encodeURI 是W3C 的标准，而 Escape 是非标准。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>ASCII、UTF-8\\16<br>unicode GB2312 </p>\n<p>字符是语言中的概念，但是计算机只认识 0 和 1 这两个数字。因此要想让计算机存储、处理字符串，就必须把字符串用二进制表示出来。在 ASCII 码中，每个英文字母都有自己对应的数字。我们通常把 ASCII 码称为字符集，也就是字符的集合。了解 ASCII 码的同学应该都知道小写字母 a 可以用 97 来表示，97 也被称为字符 a 在 ASCII 字符集中的码位。</p>\n<p>可见把字符转换成码位的过程类似于加密(encrypt)，我们称之为编码(encode)，反则则类似于解密，我们称之为解码(decode)</p>\n<p>字符转换成码位的过程是编码，这个过程有无数种实现方式。比如 a -&gt; 97、b -&gt; 98 这种就是 ASCII 编码，因为 255 = 2 ^ 8，所以所有 ASCII 编码下的码位恰好都可以由一个字节表示。</p>\n<p>除了中国人之外，各个地区的人也都根据自己的语言拓展了相应的编码方式。这样unicode就出现了。</p>\n<p>缺点：过于庞大、</p>\n<p>中文的utf-8 大于GBk的两个字节</p>\n<p>因此，我们有了对 Unicode 字符再次编码的编码方式，常见的有 utf-8，utf-16 等。UTF 表示 Unicode Transfer Format，因此是针对 Unicode 字符集的一系列编码方式。utf-8 是一种变长编码，也就是说不同的 Unicode 字符在 utf-8 编码下的码位长度可能不同，如下表所示:</p>\n<table>\n<thead>\n<tr>\n<th>Unicode 编码(16进制)</th>\n<th>utf-8 码位(二进制)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>000000-00007F</td>\n<td>0xxxxxxx</td>\n</tr>\n<tr>\n<td>000080-0007FF</td>\n<td>110xxxxx 10xxxxxx</td>\n</tr>\n<tr>\n<td>000800-00FFFF</td>\n<td>1110xxxx 10xxxxxx 10xxxxxx</td>\n</tr>\n<tr>\n<td>010000-1FFFFF</td>\n<td>11110xxx10xxxxxx10xxxxxx10xxxxxx</td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li>escape</li>\n<li>encodeURIComponent encodeURI</li>\n</ol>\n<p>encodeURI()不会对本身属于URI的特殊字符进行编码，例如冒号、正斜杠、问号和井字号；而encodeURIComponent()则会对它发现的任何非标准字符进行编码。<br>使用encodeURI()编码后的结果是除了空格之外的其他字符都原封不动，只有空格被替换成了%20。而encodeURIComponent()方法则会使用对应的编码替换所有非字母数字字符。</p>\n<p>escape 在处理 0xff 之外字符的时候，是直接使用字符的 unicode 在前面加上一个 「%u」,举例说明。<br>而encodeURI则是先进行 UTF-8，再在 UTF-8 的每个字节码前加上一个 「%」；<br>encodeURI 是W3C 的标准，而 Escape 是非标准。</p>\n"},{"title":"vue","date":"2017-01-19T07:19:03.000Z","_content":"### js\n\n1. Vue 通过在内存中实现文档结构的虚拟表示来解决此问题，其中虚拟节点（VNode）表示 DOM 树中的节点。当需要操纵时，可以在虚拟 DOM的 内存中执行计算和操作，而不是在真实 DOM 上进行操纵。这自然会更快，并且允许虚拟 DOM 算法计算出最优化的方式来更新实际 DOM 结构。\n1. \nVue 不会对 provide 中的变量进行响应式处理。所以，要想 inject 接受的变量是响应式的，provide 提供的变量本身就需要是响应式的。单项数据流\n\ninheritAttrs: false, // 可以关闭自动挂载到组件根元素上的没有在props声明的属性\n1. 子组件不需要任何处理，只需要在父组件引用的时候通过@hook来监听即可，代码重写如下：<Child @hook:mounted=\"doSomething”/>\n1. 数据动态变化：\n   export const store = Vue.observable({ count: 0 });\n1. vue life cycle\n```\nparse阶段：使用正在表达式将template进行字符串解析，得到指令、class、style等数据，生成抽象语法树 AST。\noptimize阶段：寻找 AST 中的静态节点进行标记，为后面 VNode 的 patch 过程中对比做优化。被标记为 static 的节点在后面的 diff 算法中会被直接忽略，不做详细的比较。\n\ngenerate阶段：根据 AST 结构拼接生成 render 函数的字符串。\n```\n![life cycle](https://user-gold-cdn.xitu.io/2019/12/26/16f40a08cac6d3cb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n1. 每个逻辑关注点的代码现在都在复合函数中并置在一起。 这大大减少了在处理大型组件时需要不断“跳转”的情况。 组合函数也可以在编辑器中折叠，使组件更容易扫描:\n\n1. js 链接 defer 和 async\n1. keep-alive 的实现正是用到了 LRU 策略,将最近访问的组件 push 到 this.keys 最后面,this.keys[0]也就是最久没被访问的组件,当缓存实例超过 max 设置值,删除 this.keys[0]\n```text\ndefer 和 async 都是并行加载的，主要区别在于下载后何时执行。\n每一个 async 属性的脚本都在它下载结束之后立刻执行，所以就有可能出现脚本执行顺序被打乱的情况\n每一个 defer 属性的脚本会在 HTML 解析完成后, DOMContentLoaded 之前，按照 DOM 中的顺序执行（ie>=10）\ndefer 和 async 都只适用于外部脚本文件，对与内联的 script 标签是不起作用\n\n```\n1. preload 用 “as” 或者用 “type” 属性来表示他们请求资源的优先级（比如说 preload 使用 as=\"style\" 属性将获得最高的优先级）。没有 “as” 属性的将被看作异步请求，“Early”意味着在所有未被预加载的图片请求之前被请求（“late”意味着之后）\n1. WebRTC，名称源自网页即时通信（英语：Web Real-Time Communication）的缩写，是一个支持网页浏览器进行实时语音对话或视频对话的API。\n1. Vue-intro  新功能引导  \n1. Vm.$attrs  Vm.$attrs \n1. <home :title.sync=\n   \"title\" /> //编译时会被扩展为 <home :title=\"title\" @update:title=\"val => title = val\"/> // 子组件 // 所以子组件可以通过$emit 触发 update 方法改变 mounted(){ this.$emit(\"update:title\", '这是新的title') }\n1. Vue.config.errorHandler   \n1. v-pre  场景:vue 是响应式系统,但是有些静态的标签不需要多次编译,这样可以节省性能\n1. v-loader transformAssetUrls  \n在模板编译过程中，编译器可以将某些特性转换为 require 调用，例如 src 中的 URL。因此这些目标资源可以被 webpack 处理。例如 <img src=\"./foo.png\"> 会找到你文件系统中的 ./foo.png 并将其作为一个依赖包含在你的包里\n1. view router加key  场景:由于 Vue 会复用相同组件, 即 /page/1 => /page/2 或者 /page?id=1 => /page?id=2 这类链接跳转时, 将不在执行created, mounted之类的钩子\n1. 生命周期\n```text\nbeforeCreate阶段：vue实例的挂载元素el和数据对象data都是undefined，还没有初始化。\ncreated阶段：vue实例的数据对象data有了，可以访问里面的数据和方法，未挂载到DOM，el还没有\nbeforeMount阶段：vue实例的el和data都初始化了，但是挂载之前为虚拟的dom节点\nmounted阶段：vue实例挂载到真实DOM上，就可以通过DOM获取DOM节点\nbeforeUpdate阶段：响应式数据更新时调用，发生在虚拟DOM打补丁之前，适合在更新之前访问现有的DOM，比如手动移除已添加的事件监听器\nupdated阶段：虚拟DOM重新渲染和打补丁之后调用，组成新的DOM已经更新，避免在这个钩子函数中操作数据，防止死循环\nbeforeDestroy阶段：实例销毁前调用，实例还可以用，this能获取到实例，常用于销毁定时器，解绑事件\ndestroyed阶段：实例销毁后调用，调用后所有事件监听器会被移除，所有的子实例都会被销毁  \n```         \n1. __proto__ 属性，这是历史遗留的非标准的语法，但在现代浏览器中广泛实现。获得原型的更可靠方法是使用 Object.getPrototypeOf(new Object())；例如：\n ```javascript\nconst car = {}\nconst list = []\n \nconsole.log(Object.getPrototypeOf(car));\nconsole.log(Object.getPrototypeOf(list));\n```\n1. Object.prototype.toString.call(variable) 用这个方法来判断变量类型目前是最可靠的了，它总能返回正确的值。\n   \n   该方法返回 \"[object type]\", 其中type是对象类型。\n1.  document.getElementsByClassName('test');\n1.    \n\n### 内部机制 \n\nvue-loader \n\ncompiler 目录包含 Vue.js 所有编译相关的代码。它包括把模板解析成 ast 语法树，ast 语法树优化，代码生成等功能。\n\n\n微任务的例子：micortask\n\nprocess.nextTick\npromise\nObject.observe\n\n宏任务的例子：\n\nsetTimeout\nsetInterval\nsetImmediate\nI/O\n\n需要注意的是node 和 浏览器的 event loop 是有区别的(需要注意的是node v12.0 之后和浏览器处理事一致的)：\n\n```text\n浏览器的事件循环：\n\n执行全局Script同步代码，这些同步代码有一些是同步语句，有一些是异步语句（比如setTimeout等）；\n全局Script代码执行完毕后，调用栈Stack会清空；\n从微队列microtask queue中取出位于队首的回调任务，放入调用栈Stack中执行，执行完后microtask queue长度减1；\n继续取出位于队首的任务，放入调用栈Stack中执行，以此类推，直到直到把microtask queue中的所有任务都执行完毕。注意，如果在执行microtask的过程中，又产生了microtask，那么会加入到队列的末尾，也会在这个周期被调用执行；\nmicrotask queue中的所有任务都执行完毕，此时microtask queue为空队列，调用栈Stack也为空；\n取出宏队列macrotask queue中位于队首的任务，放入Stack中执行；\n执行完毕后，调用栈Stack为空；\n重复第3-7个步骤；\n重复第3-7个步骤；\n……\n\nNodeJS中微队列主要有2个：\nNext Tick Queue：是放置process.nextTick(callback)的回调任务的\nOther Micro Queue：放置其他microtask，比如Promise等\n\n具体参见： https://segmentfault.com/a/1190000016278115\n\n```\n\n\n``` \ntimers 阶段：这个阶段执行timer（setTimeout、setInterval）的回调\nI/O callbacks 阶段：执行一些系统调用错误，比如网络通信的错误回调\nidle, prepare 阶段：仅node内部使用\npoll 阶段：获取新的I/O事件, 适当的条件下node将阻塞在这里\ncheck 阶段：执行 setImmediate() 的回调\nclose callbacks 阶段：执行 socket 的 close 事件回调\n\ntimers 是事件循环的第一个阶段，Node 会去检查有无已过期的timer，如果有则把它的回调压入timer的任务队列中等待执行，事实上，Node 并不能保证timer在预设时间到了就会立即执行，因为Node对timer的过期检查不一定靠谱，它会受机器上其它运行程序影响，或者那个时间点主线程不空闲。比如下面的代码，setTimeout() 和 setImmediate() 的执行顺序是不确定的。\n\npoll 阶段\npoll 阶段主要有2个功能：\n\n处理 poll 队列的事件\n当有已超时的 timer，执行它的回调函数\neven loop将同步执行poll队列里的回调，直到队列为空或执行的回调达到系统上限（上限具体多少未详），接下来even loop会去检查有无预设的setImmediate()，分两种情况：\n\n若有预设的setImmediate(), event loop将结束poll阶段进入check阶段，并执行check阶段的任务队列\n若没有预设的setImmediate()，event loop将阻塞在该阶段等待\n注意一个细节，没有setImmediate()会导致event loop阻塞在poll阶段，这样之前设置的timer岂不是执行不了了？所以咧，在poll阶段event loop会有一个检查机制，检查timer队列是否为空，如果timer队列非空，event loop就开始下一轮事件循环，即重新进入到timer阶段。\n\ncheck 阶段\nsetImmediate()的回调会被加入check队列中，从event loop的阶段图可以知道，check阶段的执行顺序在poll阶段之后。\n\n\n回顾上一篇，浏览器环境下，microtask的任务队列是每个macrotask执行完之后执行。而在Node.js中，microtask会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行microtask队列的任务。详见：http://lynnelv.github.io/js-event-loop-nodejs\n\nprocess.nextTick() 会在各个事件阶段之间执行，一旦执行，要直到nextTick队列被清空，才会进入到下一个事件阶段，所以如果递归调用 process.nextTick()，会导致出现I/O starving（饥饿）的问题\n\n官方文档：https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/\n\n```\n\n\n\n###vitual dom\n\n Vue.js 实现响应式的核心是利用了 ES5 的 Object.defineProperty，这也是为什么 Vue.js 不能兼容 IE8 及以下浏览器的原因，我们先来对它有个直观的认识。值改变时会触发set方法。\n \n 核心就是利用 Object.defineProperty 给数据添加了 getter 和 setter，目的就是为了在我们访问数据以及写数据的时候能自动执行一些逻辑：getter 做的事情是依赖收集，setter 做的事情是派发更新\n \n 它会先执行 vm._render() 方法，因为之前分析过这个方法会生成 渲染 VNode，并且在这个过程中会对 vm 上的数据访问，这个时候就触发了数据对象的 getter。\n \n 它并不会每次数据改变都触发 watcher 的回调，而是把这些 watcher 先添加到一个队列里，然后在 nextTick 后执行 flushSchedulerQueue。\n\n \n\nVD 最大的特点是将页面的状态抽象为 JS 对象的形式，配合不同的渲染工具，使跨平台渲染成为可能。如 React 就借助 VD 实现了服务端渲染、浏览器渲染和移动端渲染等功能。\njs计算-》生成渲染树-》渲染页面\n\n通过VD的比较，我们可以将多个操作合并成一个批量的操作，从而减少dom重排的次数，进而缩短了生成渲染树和绘制所花的时间。\n\n在mounted 方法中会将template 编译成为render 方法。这是一个编译过程，render中会调用createElement 创建vnode。\n\n![流程图片](https://ustbhuangyi.github.io/vue-analysis/assets/new-vue.png)\n\n\n回到 mountComponent 函数的过程，我们已经知道 createElement 是如何创建了一个 VNode，接下来就是要把这个 VNode 渲染成一个真实的 DOM 并渲染出来，这个过程是通过 vm._update 完成的\n\nVue 的 _update 是实例的一个私有方法，它被调用的时机有 2 个，一个是首次渲染，一个是数据更新的时候；由于我们这一章节只分析首次渲染部分，数据更新部分会在之后分析响应式原理的时候涉及。_update 方法的作用是把 VNode 渲染成真实的 DOM\n\n\n在我们之前对 setter 的分析过程知道，当响应式数据发送变化后，触发了 watcher.update()，只是把这个 watcher 推送到一个队列中，在 nextTick 后才会真正执行 watcher 的回调函数。而一旦我们设置了 sync，就可以在当前 Tick 中同步执行 watcher 的回调函数。\n\ndeep watcher 和 sync watcher  \n\n\n\n###  router 元数据 \n meta: { requiresAuth: true }  \n \n#####  v-once 指令，你也能执行一次性地插值\n\n#### v-slot 新的用法\nv-slot 的别名是#。因此，可以用#header=\"data\" 来代替 v-slot:header=\"data\"。还可以使用 #header来代替 v-slot:header(前提:不是作用域插槽时)。对于默认插槽，在使用别名时需要指定默认名称。换句话说，需要这样写 #default=\"data\" 而不是#=\"data\"。\n\n\n##### Mustache 不能在 HTML 属性中使用，应使用 v-bind 指令：\n\n```\n<div v-bind:id=\"dynamicId\"></div>\n```\n\n##### 修饰符（Modifiers）是以半角句号 . 指明的特殊后缀，用于指出一个指定应该以特殊方式绑定。例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()\n\n```\n<!-- 阻止单击事件冒泡 -->\n<a v-on:click.stop=\"doThis\"></a>\n<!-- 提交事件不再重载页面 -->\n<form v-on:submit.prevent=\"onSubmit\"></form>\n<!-- 修饰符可以串联  -->\n<a v-on:click.stop.prevent=\"doThat\"></a>\n<!-- 只有修饰符 -->\n<form v-on:submit.prevent></form>\n<!-- 添加事件侦听器时使用事件捕获模式 -->\n<div v-on:click.capture=\"doThis\">...</div>\n<!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 -->\n<div v-on:click.self=\"doThat\">...</div>\n<a v-on:click.once=\"doThis\"></a>\n```\n\n##### 过滤器函数总接受表达式的值作为第一个参数。\n\n```\nnew Vue({\n  // ...\n  filters: {\n    capitalize: function (value) {\n      if (!value) return ''\n      value = value.toString()\n      return value.charAt(0).toUpperCase() + value.slice(1)\n    }\n  }\n})\n过滤器可以串联：\n{{ message | filterA | filterB }}\n```\n\n##### v-bind 缩写\n\n\n```\n<!-- 完整语法 -->\n<a v-bind:href=\"url\"></a>\n<!-- 缩写 -->\n<a :href=\"url\"></a>\nv-on 缩写\n\n<!-- 完整语法 -->\n<a v-on:click=\"doSomething\"></a>\n<!-- 缩写 -->\n<a @click=\"doSomething\"></a>\n```\n \n \n##### 按键修饰符\n记住所有的 keyCode 比较困难，所以 Vue 为最常用的按键提供了别名：\n\n```\n<!-- 同上 -->\n<input v-on:keyup.enter=\"submit\">\n<!-- 缩写语法 -->\n<input @keyup.enter=\"submit\">\n全部的按键别名：\n.enter\n.tab\n.delete (捕获 “删除” 和 “退格” 键)\n.esc\n.space\n.up\n.down\n.left\n.right\n```\n##### 绑定属性值\n\n```\n<input\n  type=\"checkbox\"\n  v-model=\"toggle\"\n  v-bind:true-value=\"a\"\n  v-bind:false-value=\"b\"\n>\n```\n##### 修饰符\n\n```\n在默认情况下， v-model 在 input 事件中同步输入框的值与数据 (除了 上述 IME 部分)，但你可以添加一个修饰符 lazy ，从而转变为在 change 事件中同步：\n<!-- 在 \"change\" 而不是 \"input\" 事件中更新 -->\n<input v-model.lazy=\"msg\" >\n.number\n\n如果想自动将用户的输入值转为 Number 类型（如果原值的转换结果为 NaN 则返回原值），可以添加一个修饰符 number 给 v-model 来处理输入值：\n<input v-model.number=\"age\" type=\"number\">\n这通常很有用，因为在 type=\"number\" 时 HTML 中输入的值也总是会返回字符串类型。\n.trim\n\n如果要自动过滤用户输入的首尾空格，可以添加 trim 修饰符到 v-model 上过滤输入：\n<input v-model.trim=\"msg\">\n```\n","source":"_posts/vue.md","raw":"---\ntitle: vue\ndate: 2017-01-19 15:19:03\ntags: vue eventloop js \n---\n### js\n\n1. Vue 通过在内存中实现文档结构的虚拟表示来解决此问题，其中虚拟节点（VNode）表示 DOM 树中的节点。当需要操纵时，可以在虚拟 DOM的 内存中执行计算和操作，而不是在真实 DOM 上进行操纵。这自然会更快，并且允许虚拟 DOM 算法计算出最优化的方式来更新实际 DOM 结构。\n1. \nVue 不会对 provide 中的变量进行响应式处理。所以，要想 inject 接受的变量是响应式的，provide 提供的变量本身就需要是响应式的。单项数据流\n\ninheritAttrs: false, // 可以关闭自动挂载到组件根元素上的没有在props声明的属性\n1. 子组件不需要任何处理，只需要在父组件引用的时候通过@hook来监听即可，代码重写如下：<Child @hook:mounted=\"doSomething”/>\n1. 数据动态变化：\n   export const store = Vue.observable({ count: 0 });\n1. vue life cycle\n```\nparse阶段：使用正在表达式将template进行字符串解析，得到指令、class、style等数据，生成抽象语法树 AST。\noptimize阶段：寻找 AST 中的静态节点进行标记，为后面 VNode 的 patch 过程中对比做优化。被标记为 static 的节点在后面的 diff 算法中会被直接忽略，不做详细的比较。\n\ngenerate阶段：根据 AST 结构拼接生成 render 函数的字符串。\n```\n![life cycle](https://user-gold-cdn.xitu.io/2019/12/26/16f40a08cac6d3cb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n1. 每个逻辑关注点的代码现在都在复合函数中并置在一起。 这大大减少了在处理大型组件时需要不断“跳转”的情况。 组合函数也可以在编辑器中折叠，使组件更容易扫描:\n\n1. js 链接 defer 和 async\n1. keep-alive 的实现正是用到了 LRU 策略,将最近访问的组件 push 到 this.keys 最后面,this.keys[0]也就是最久没被访问的组件,当缓存实例超过 max 设置值,删除 this.keys[0]\n```text\ndefer 和 async 都是并行加载的，主要区别在于下载后何时执行。\n每一个 async 属性的脚本都在它下载结束之后立刻执行，所以就有可能出现脚本执行顺序被打乱的情况\n每一个 defer 属性的脚本会在 HTML 解析完成后, DOMContentLoaded 之前，按照 DOM 中的顺序执行（ie>=10）\ndefer 和 async 都只适用于外部脚本文件，对与内联的 script 标签是不起作用\n\n```\n1. preload 用 “as” 或者用 “type” 属性来表示他们请求资源的优先级（比如说 preload 使用 as=\"style\" 属性将获得最高的优先级）。没有 “as” 属性的将被看作异步请求，“Early”意味着在所有未被预加载的图片请求之前被请求（“late”意味着之后）\n1. WebRTC，名称源自网页即时通信（英语：Web Real-Time Communication）的缩写，是一个支持网页浏览器进行实时语音对话或视频对话的API。\n1. Vue-intro  新功能引导  \n1. Vm.$attrs  Vm.$attrs \n1. <home :title.sync=\n   \"title\" /> //编译时会被扩展为 <home :title=\"title\" @update:title=\"val => title = val\"/> // 子组件 // 所以子组件可以通过$emit 触发 update 方法改变 mounted(){ this.$emit(\"update:title\", '这是新的title') }\n1. Vue.config.errorHandler   \n1. v-pre  场景:vue 是响应式系统,但是有些静态的标签不需要多次编译,这样可以节省性能\n1. v-loader transformAssetUrls  \n在模板编译过程中，编译器可以将某些特性转换为 require 调用，例如 src 中的 URL。因此这些目标资源可以被 webpack 处理。例如 <img src=\"./foo.png\"> 会找到你文件系统中的 ./foo.png 并将其作为一个依赖包含在你的包里\n1. view router加key  场景:由于 Vue 会复用相同组件, 即 /page/1 => /page/2 或者 /page?id=1 => /page?id=2 这类链接跳转时, 将不在执行created, mounted之类的钩子\n1. 生命周期\n```text\nbeforeCreate阶段：vue实例的挂载元素el和数据对象data都是undefined，还没有初始化。\ncreated阶段：vue实例的数据对象data有了，可以访问里面的数据和方法，未挂载到DOM，el还没有\nbeforeMount阶段：vue实例的el和data都初始化了，但是挂载之前为虚拟的dom节点\nmounted阶段：vue实例挂载到真实DOM上，就可以通过DOM获取DOM节点\nbeforeUpdate阶段：响应式数据更新时调用，发生在虚拟DOM打补丁之前，适合在更新之前访问现有的DOM，比如手动移除已添加的事件监听器\nupdated阶段：虚拟DOM重新渲染和打补丁之后调用，组成新的DOM已经更新，避免在这个钩子函数中操作数据，防止死循环\nbeforeDestroy阶段：实例销毁前调用，实例还可以用，this能获取到实例，常用于销毁定时器，解绑事件\ndestroyed阶段：实例销毁后调用，调用后所有事件监听器会被移除，所有的子实例都会被销毁  \n```         \n1. __proto__ 属性，这是历史遗留的非标准的语法，但在现代浏览器中广泛实现。获得原型的更可靠方法是使用 Object.getPrototypeOf(new Object())；例如：\n ```javascript\nconst car = {}\nconst list = []\n \nconsole.log(Object.getPrototypeOf(car));\nconsole.log(Object.getPrototypeOf(list));\n```\n1. Object.prototype.toString.call(variable) 用这个方法来判断变量类型目前是最可靠的了，它总能返回正确的值。\n   \n   该方法返回 \"[object type]\", 其中type是对象类型。\n1.  document.getElementsByClassName('test');\n1.    \n\n### 内部机制 \n\nvue-loader \n\ncompiler 目录包含 Vue.js 所有编译相关的代码。它包括把模板解析成 ast 语法树，ast 语法树优化，代码生成等功能。\n\n\n微任务的例子：micortask\n\nprocess.nextTick\npromise\nObject.observe\n\n宏任务的例子：\n\nsetTimeout\nsetInterval\nsetImmediate\nI/O\n\n需要注意的是node 和 浏览器的 event loop 是有区别的(需要注意的是node v12.0 之后和浏览器处理事一致的)：\n\n```text\n浏览器的事件循环：\n\n执行全局Script同步代码，这些同步代码有一些是同步语句，有一些是异步语句（比如setTimeout等）；\n全局Script代码执行完毕后，调用栈Stack会清空；\n从微队列microtask queue中取出位于队首的回调任务，放入调用栈Stack中执行，执行完后microtask queue长度减1；\n继续取出位于队首的任务，放入调用栈Stack中执行，以此类推，直到直到把microtask queue中的所有任务都执行完毕。注意，如果在执行microtask的过程中，又产生了microtask，那么会加入到队列的末尾，也会在这个周期被调用执行；\nmicrotask queue中的所有任务都执行完毕，此时microtask queue为空队列，调用栈Stack也为空；\n取出宏队列macrotask queue中位于队首的任务，放入Stack中执行；\n执行完毕后，调用栈Stack为空；\n重复第3-7个步骤；\n重复第3-7个步骤；\n……\n\nNodeJS中微队列主要有2个：\nNext Tick Queue：是放置process.nextTick(callback)的回调任务的\nOther Micro Queue：放置其他microtask，比如Promise等\n\n具体参见： https://segmentfault.com/a/1190000016278115\n\n```\n\n\n``` \ntimers 阶段：这个阶段执行timer（setTimeout、setInterval）的回调\nI/O callbacks 阶段：执行一些系统调用错误，比如网络通信的错误回调\nidle, prepare 阶段：仅node内部使用\npoll 阶段：获取新的I/O事件, 适当的条件下node将阻塞在这里\ncheck 阶段：执行 setImmediate() 的回调\nclose callbacks 阶段：执行 socket 的 close 事件回调\n\ntimers 是事件循环的第一个阶段，Node 会去检查有无已过期的timer，如果有则把它的回调压入timer的任务队列中等待执行，事实上，Node 并不能保证timer在预设时间到了就会立即执行，因为Node对timer的过期检查不一定靠谱，它会受机器上其它运行程序影响，或者那个时间点主线程不空闲。比如下面的代码，setTimeout() 和 setImmediate() 的执行顺序是不确定的。\n\npoll 阶段\npoll 阶段主要有2个功能：\n\n处理 poll 队列的事件\n当有已超时的 timer，执行它的回调函数\neven loop将同步执行poll队列里的回调，直到队列为空或执行的回调达到系统上限（上限具体多少未详），接下来even loop会去检查有无预设的setImmediate()，分两种情况：\n\n若有预设的setImmediate(), event loop将结束poll阶段进入check阶段，并执行check阶段的任务队列\n若没有预设的setImmediate()，event loop将阻塞在该阶段等待\n注意一个细节，没有setImmediate()会导致event loop阻塞在poll阶段，这样之前设置的timer岂不是执行不了了？所以咧，在poll阶段event loop会有一个检查机制，检查timer队列是否为空，如果timer队列非空，event loop就开始下一轮事件循环，即重新进入到timer阶段。\n\ncheck 阶段\nsetImmediate()的回调会被加入check队列中，从event loop的阶段图可以知道，check阶段的执行顺序在poll阶段之后。\n\n\n回顾上一篇，浏览器环境下，microtask的任务队列是每个macrotask执行完之后执行。而在Node.js中，microtask会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行microtask队列的任务。详见：http://lynnelv.github.io/js-event-loop-nodejs\n\nprocess.nextTick() 会在各个事件阶段之间执行，一旦执行，要直到nextTick队列被清空，才会进入到下一个事件阶段，所以如果递归调用 process.nextTick()，会导致出现I/O starving（饥饿）的问题\n\n官方文档：https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/\n\n```\n\n\n\n###vitual dom\n\n Vue.js 实现响应式的核心是利用了 ES5 的 Object.defineProperty，这也是为什么 Vue.js 不能兼容 IE8 及以下浏览器的原因，我们先来对它有个直观的认识。值改变时会触发set方法。\n \n 核心就是利用 Object.defineProperty 给数据添加了 getter 和 setter，目的就是为了在我们访问数据以及写数据的时候能自动执行一些逻辑：getter 做的事情是依赖收集，setter 做的事情是派发更新\n \n 它会先执行 vm._render() 方法，因为之前分析过这个方法会生成 渲染 VNode，并且在这个过程中会对 vm 上的数据访问，这个时候就触发了数据对象的 getter。\n \n 它并不会每次数据改变都触发 watcher 的回调，而是把这些 watcher 先添加到一个队列里，然后在 nextTick 后执行 flushSchedulerQueue。\n\n \n\nVD 最大的特点是将页面的状态抽象为 JS 对象的形式，配合不同的渲染工具，使跨平台渲染成为可能。如 React 就借助 VD 实现了服务端渲染、浏览器渲染和移动端渲染等功能。\njs计算-》生成渲染树-》渲染页面\n\n通过VD的比较，我们可以将多个操作合并成一个批量的操作，从而减少dom重排的次数，进而缩短了生成渲染树和绘制所花的时间。\n\n在mounted 方法中会将template 编译成为render 方法。这是一个编译过程，render中会调用createElement 创建vnode。\n\n![流程图片](https://ustbhuangyi.github.io/vue-analysis/assets/new-vue.png)\n\n\n回到 mountComponent 函数的过程，我们已经知道 createElement 是如何创建了一个 VNode，接下来就是要把这个 VNode 渲染成一个真实的 DOM 并渲染出来，这个过程是通过 vm._update 完成的\n\nVue 的 _update 是实例的一个私有方法，它被调用的时机有 2 个，一个是首次渲染，一个是数据更新的时候；由于我们这一章节只分析首次渲染部分，数据更新部分会在之后分析响应式原理的时候涉及。_update 方法的作用是把 VNode 渲染成真实的 DOM\n\n\n在我们之前对 setter 的分析过程知道，当响应式数据发送变化后，触发了 watcher.update()，只是把这个 watcher 推送到一个队列中，在 nextTick 后才会真正执行 watcher 的回调函数。而一旦我们设置了 sync，就可以在当前 Tick 中同步执行 watcher 的回调函数。\n\ndeep watcher 和 sync watcher  \n\n\n\n###  router 元数据 \n meta: { requiresAuth: true }  \n \n#####  v-once 指令，你也能执行一次性地插值\n\n#### v-slot 新的用法\nv-slot 的别名是#。因此，可以用#header=\"data\" 来代替 v-slot:header=\"data\"。还可以使用 #header来代替 v-slot:header(前提:不是作用域插槽时)。对于默认插槽，在使用别名时需要指定默认名称。换句话说，需要这样写 #default=\"data\" 而不是#=\"data\"。\n\n\n##### Mustache 不能在 HTML 属性中使用，应使用 v-bind 指令：\n\n```\n<div v-bind:id=\"dynamicId\"></div>\n```\n\n##### 修饰符（Modifiers）是以半角句号 . 指明的特殊后缀，用于指出一个指定应该以特殊方式绑定。例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()\n\n```\n<!-- 阻止单击事件冒泡 -->\n<a v-on:click.stop=\"doThis\"></a>\n<!-- 提交事件不再重载页面 -->\n<form v-on:submit.prevent=\"onSubmit\"></form>\n<!-- 修饰符可以串联  -->\n<a v-on:click.stop.prevent=\"doThat\"></a>\n<!-- 只有修饰符 -->\n<form v-on:submit.prevent></form>\n<!-- 添加事件侦听器时使用事件捕获模式 -->\n<div v-on:click.capture=\"doThis\">...</div>\n<!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 -->\n<div v-on:click.self=\"doThat\">...</div>\n<a v-on:click.once=\"doThis\"></a>\n```\n\n##### 过滤器函数总接受表达式的值作为第一个参数。\n\n```\nnew Vue({\n  // ...\n  filters: {\n    capitalize: function (value) {\n      if (!value) return ''\n      value = value.toString()\n      return value.charAt(0).toUpperCase() + value.slice(1)\n    }\n  }\n})\n过滤器可以串联：\n{{ message | filterA | filterB }}\n```\n\n##### v-bind 缩写\n\n\n```\n<!-- 完整语法 -->\n<a v-bind:href=\"url\"></a>\n<!-- 缩写 -->\n<a :href=\"url\"></a>\nv-on 缩写\n\n<!-- 完整语法 -->\n<a v-on:click=\"doSomething\"></a>\n<!-- 缩写 -->\n<a @click=\"doSomething\"></a>\n```\n \n \n##### 按键修饰符\n记住所有的 keyCode 比较困难，所以 Vue 为最常用的按键提供了别名：\n\n```\n<!-- 同上 -->\n<input v-on:keyup.enter=\"submit\">\n<!-- 缩写语法 -->\n<input @keyup.enter=\"submit\">\n全部的按键别名：\n.enter\n.tab\n.delete (捕获 “删除” 和 “退格” 键)\n.esc\n.space\n.up\n.down\n.left\n.right\n```\n##### 绑定属性值\n\n```\n<input\n  type=\"checkbox\"\n  v-model=\"toggle\"\n  v-bind:true-value=\"a\"\n  v-bind:false-value=\"b\"\n>\n```\n##### 修饰符\n\n```\n在默认情况下， v-model 在 input 事件中同步输入框的值与数据 (除了 上述 IME 部分)，但你可以添加一个修饰符 lazy ，从而转变为在 change 事件中同步：\n<!-- 在 \"change\" 而不是 \"input\" 事件中更新 -->\n<input v-model.lazy=\"msg\" >\n.number\n\n如果想自动将用户的输入值转为 Number 类型（如果原值的转换结果为 NaN 则返回原值），可以添加一个修饰符 number 给 v-model 来处理输入值：\n<input v-model.number=\"age\" type=\"number\">\n这通常很有用，因为在 type=\"number\" 时 HTML 中输入的值也总是会返回字符串类型。\n.trim\n\n如果要自动过滤用户输入的首尾空格，可以添加 trim 修饰符到 v-model 上过滤输入：\n<input v-model.trim=\"msg\">\n```\n","slug":"vue","published":1,"updated":"2020-01-02T08:23:27.666Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5bwexd80017998sf3a70upp","content":"<h3 id=\"js\"><a href=\"#js\" class=\"headerlink\" title=\"js\"></a>js</h3><ol>\n<li>Vue 通过在内存中实现文档结构的虚拟表示来解决此问题，其中虚拟节点（VNode）表示 DOM 树中的节点。当需要操纵时，可以在虚拟 DOM的 内存中执行计算和操作，而不是在真实 DOM 上进行操纵。这自然会更快，并且允许虚拟 DOM 算法计算出最优化的方式来更新实际 DOM 结构。</li>\n<li>Vue 不会对 provide 中的变量进行响应式处理。所以，要想 inject 接受的变量是响应式的，provide 提供的变量本身就需要是响应式的。单项数据流</li>\n</ol>\n<p>inheritAttrs: false, // 可以关闭自动挂载到组件根元素上的没有在props声明的属性</p>\n<ol>\n<li>子组件不需要任何处理，只需要在父组件引用的时候通过@hook来监听即可，代码重写如下：&lt;Child @hook:mounted=”doSomething”/&gt;</li>\n<li>数据动态变化：<br>export const store = Vue.observable({ count: 0 });</li>\n<li>vue life cycle<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">parse阶段：使用正在表达式将template进行字符串解析，得到指令、class、style等数据，生成抽象语法树 AST。</span><br><span class=\"line\">optimize阶段：寻找 AST 中的静态节点进行标记，为后面 VNode 的 patch 过程中对比做优化。被标记为 static 的节点在后面的 diff 算法中会被直接忽略，不做详细的比较。</span><br><span class=\"line\"></span><br><span class=\"line\">generate阶段：根据 AST 结构拼接生成 render 函数的字符串。</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/12/26/16f40a08cac6d3cb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"life cycle\"></p>\n<ol>\n<li><p>每个逻辑关注点的代码现在都在复合函数中并置在一起。 这大大减少了在处理大型组件时需要不断“跳转”的情况。 组合函数也可以在编辑器中折叠，使组件更容易扫描:</p>\n</li>\n<li><p>js 链接 defer 和 async</p>\n</li>\n<li><p>keep-alive 的实现正是用到了 LRU 策略,将最近访问的组件 push 到 this.keys 最后面,this.keys[0]也就是最久没被访问的组件,当缓存实例超过 max 设置值,删除 this.keys[0]</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">defer 和 async 都是并行加载的，主要区别在于下载后何时执行。</span><br><span class=\"line\">每一个 async 属性的脚本都在它下载结束之后立刻执行，所以就有可能出现脚本执行顺序被打乱的情况</span><br><span class=\"line\">每一个 defer 属性的脚本会在 HTML 解析完成后, DOMContentLoaded 之前，按照 DOM 中的顺序执行（ie&gt;=10）</span><br><span class=\"line\">defer 和 async 都只适用于外部脚本文件，对与内联的 script 标签是不起作用</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>preload 用 “as” 或者用 “type” 属性来表示他们请求资源的优先级（比如说 preload 使用 as=”style” 属性将获得最高的优先级）。没有 “as” 属性的将被看作异步请求，“Early”意味着在所有未被预加载的图片请求之前被请求（“late”意味着之后）</p>\n</li>\n<li>WebRTC，名称源自网页即时通信（英语：Web Real-Time Communication）的缩写，是一个支持网页浏览器进行实时语音对话或视频对话的API。</li>\n<li>Vue-intro  新功能引导  </li>\n<li>Vm.$attrs  Vm.$attrs </li>\n<li><home :title.sync=\"title\"> //编译时会被扩展为 <home :title=\"title\" @update:title=\"val => title = val\"> // 子组件 // 所以子组件可以通过$emit 触发 update 方法改变 mounted(){ this.$emit(“update:title”, ‘这是新的title’) }</home></home></li>\n<li>Vue.config.errorHandler   </li>\n<li>v-pre  场景:vue 是响应式系统,但是有些静态的标签不需要多次编译,这样可以节省性能</li>\n<li>v-loader transformAssetUrls<br>在模板编译过程中，编译器可以将某些特性转换为 require 调用，例如 src 中的 URL。因此这些目标资源可以被 webpack 处理。例如 <img src=\"./foo.png\"> 会找到你文件系统中的 ./foo.png 并将其作为一个依赖包含在你的包里</li>\n<li>view router加key  场景:由于 Vue 会复用相同组件, 即 /page/1 =&gt; /page/2 或者 /page?id=1 =&gt; /page?id=2 这类链接跳转时, 将不在执行created, mounted之类的钩子</li>\n<li><p>生命周期</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">beforeCreate阶段：vue实例的挂载元素el和数据对象data都是undefined，还没有初始化。</span><br><span class=\"line\">created阶段：vue实例的数据对象data有了，可以访问里面的数据和方法，未挂载到DOM，el还没有</span><br><span class=\"line\">beforeMount阶段：vue实例的el和data都初始化了，但是挂载之前为虚拟的dom节点</span><br><span class=\"line\">mounted阶段：vue实例挂载到真实DOM上，就可以通过DOM获取DOM节点</span><br><span class=\"line\">beforeUpdate阶段：响应式数据更新时调用，发生在虚拟DOM打补丁之前，适合在更新之前访问现有的DOM，比如手动移除已添加的事件监听器</span><br><span class=\"line\">updated阶段：虚拟DOM重新渲染和打补丁之后调用，组成新的DOM已经更新，避免在这个钩子函数中操作数据，防止死循环</span><br><span class=\"line\">beforeDestroy阶段：实例销毁前调用，实例还可以用，this能获取到实例，常用于销毁定时器，解绑事件</span><br><span class=\"line\">destroyed阶段：实例销毁后调用，调用后所有事件监听器会被移除，所有的子实例都会被销毁  </span><br><span class=\"line\">```         </span><br><span class=\"line\">1. __proto__ 属性，这是历史遗留的非标准的语法，但在现代浏览器中广泛实现。获得原型的更可靠方法是使用 Object.getPrototypeOf(new Object())；例如：</span><br><span class=\"line\"> ```javascript</span><br><span class=\"line\">const car = &#123;&#125;</span><br><span class=\"line\">const list = []</span><br><span class=\"line\"> </span><br><span class=\"line\">console.log(Object.getPrototypeOf(car));</span><br><span class=\"line\">console.log(Object.getPrototypeOf(list));</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Object.prototype.toString.call(variable) 用这个方法来判断变量类型目前是最可靠的了，它总能返回正确的值。</p>\n<p>该方法返回 “[object type]”, 其中type是对象类型。</p>\n</li>\n<li>document.getElementsByClassName(‘test’);</li>\n<li></li>\n</ol>\n<h3 id=\"内部机制\"><a href=\"#内部机制\" class=\"headerlink\" title=\"内部机制\"></a>内部机制</h3><p>vue-loader </p>\n<p>compiler 目录包含 Vue.js 所有编译相关的代码。它包括把模板解析成 ast 语法树，ast 语法树优化，代码生成等功能。</p>\n<p>微任务的例子：micortask</p>\n<p>process.nextTick<br>promise<br>Object.observe</p>\n<p>宏任务的例子：</p>\n<p>setTimeout<br>setInterval<br>setImmediate<br>I/O</p>\n<p>需要注意的是node 和 浏览器的 event loop 是有区别的(需要注意的是node v12.0 之后和浏览器处理事一致的)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">浏览器的事件循环：</span><br><span class=\"line\"></span><br><span class=\"line\">执行全局Script同步代码，这些同步代码有一些是同步语句，有一些是异步语句（比如setTimeout等）；</span><br><span class=\"line\">全局Script代码执行完毕后，调用栈Stack会清空；</span><br><span class=\"line\">从微队列microtask queue中取出位于队首的回调任务，放入调用栈Stack中执行，执行完后microtask queue长度减1；</span><br><span class=\"line\">继续取出位于队首的任务，放入调用栈Stack中执行，以此类推，直到直到把microtask queue中的所有任务都执行完毕。注意，如果在执行microtask的过程中，又产生了microtask，那么会加入到队列的末尾，也会在这个周期被调用执行；</span><br><span class=\"line\">microtask queue中的所有任务都执行完毕，此时microtask queue为空队列，调用栈Stack也为空；</span><br><span class=\"line\">取出宏队列macrotask queue中位于队首的任务，放入Stack中执行；</span><br><span class=\"line\">执行完毕后，调用栈Stack为空；</span><br><span class=\"line\">重复第3-7个步骤；</span><br><span class=\"line\">重复第3-7个步骤；</span><br><span class=\"line\">……</span><br><span class=\"line\"></span><br><span class=\"line\">NodeJS中微队列主要有2个：</span><br><span class=\"line\">Next Tick Queue：是放置process.nextTick(callback)的回调任务的</span><br><span class=\"line\">Other Micro Queue：放置其他microtask，比如Promise等</span><br><span class=\"line\"></span><br><span class=\"line\">具体参见： https://segmentfault.com/a/1190000016278115</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">timers 阶段：这个阶段执行timer（setTimeout、setInterval）的回调</span><br><span class=\"line\">I/O callbacks 阶段：执行一些系统调用错误，比如网络通信的错误回调</span><br><span class=\"line\">idle, prepare 阶段：仅node内部使用</span><br><span class=\"line\">poll 阶段：获取新的I/O事件, 适当的条件下node将阻塞在这里</span><br><span class=\"line\">check 阶段：执行 setImmediate() 的回调</span><br><span class=\"line\">close callbacks 阶段：执行 socket 的 close 事件回调</span><br><span class=\"line\"></span><br><span class=\"line\">timers 是事件循环的第一个阶段，Node 会去检查有无已过期的timer，如果有则把它的回调压入timer的任务队列中等待执行，事实上，Node 并不能保证timer在预设时间到了就会立即执行，因为Node对timer的过期检查不一定靠谱，它会受机器上其它运行程序影响，或者那个时间点主线程不空闲。比如下面的代码，setTimeout() 和 setImmediate() 的执行顺序是不确定的。</span><br><span class=\"line\"></span><br><span class=\"line\">poll 阶段</span><br><span class=\"line\">poll 阶段主要有2个功能：</span><br><span class=\"line\"></span><br><span class=\"line\">处理 poll 队列的事件</span><br><span class=\"line\">当有已超时的 timer，执行它的回调函数</span><br><span class=\"line\">even loop将同步执行poll队列里的回调，直到队列为空或执行的回调达到系统上限（上限具体多少未详），接下来even loop会去检查有无预设的setImmediate()，分两种情况：</span><br><span class=\"line\"></span><br><span class=\"line\">若有预设的setImmediate(), event loop将结束poll阶段进入check阶段，并执行check阶段的任务队列</span><br><span class=\"line\">若没有预设的setImmediate()，event loop将阻塞在该阶段等待</span><br><span class=\"line\">注意一个细节，没有setImmediate()会导致event loop阻塞在poll阶段，这样之前设置的timer岂不是执行不了了？所以咧，在poll阶段event loop会有一个检查机制，检查timer队列是否为空，如果timer队列非空，event loop就开始下一轮事件循环，即重新进入到timer阶段。</span><br><span class=\"line\"></span><br><span class=\"line\">check 阶段</span><br><span class=\"line\">setImmediate()的回调会被加入check队列中，从event loop的阶段图可以知道，check阶段的执行顺序在poll阶段之后。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">回顾上一篇，浏览器环境下，microtask的任务队列是每个macrotask执行完之后执行。而在Node.js中，microtask会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行microtask队列的任务。详见：http://lynnelv.github.io/js-event-loop-nodejs</span><br><span class=\"line\"></span><br><span class=\"line\">process.nextTick() 会在各个事件阶段之间执行，一旦执行，要直到nextTick队列被清空，才会进入到下一个事件阶段，所以如果递归调用 process.nextTick()，会导致出现I/O starving（饥饿）的问题</span><br><span class=\"line\"></span><br><span class=\"line\">官方文档：https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/</span><br></pre></td></tr></table></figure>\n<p>###vitual dom</p>\n<p> Vue.js 实现响应式的核心是利用了 ES5 的 Object.defineProperty，这也是为什么 Vue.js 不能兼容 IE8 及以下浏览器的原因，我们先来对它有个直观的认识。值改变时会触发set方法。</p>\n<p> 核心就是利用 Object.defineProperty 给数据添加了 getter 和 setter，目的就是为了在我们访问数据以及写数据的时候能自动执行一些逻辑：getter 做的事情是依赖收集，setter 做的事情是派发更新</p>\n<p> 它会先执行 vm._render() 方法，因为之前分析过这个方法会生成 渲染 VNode，并且在这个过程中会对 vm 上的数据访问，这个时候就触发了数据对象的 getter。</p>\n<p> 它并不会每次数据改变都触发 watcher 的回调，而是把这些 watcher 先添加到一个队列里，然后在 nextTick 后执行 flushSchedulerQueue。</p>\n<p>VD 最大的特点是将页面的状态抽象为 JS 对象的形式，配合不同的渲染工具，使跨平台渲染成为可能。如 React 就借助 VD 实现了服务端渲染、浏览器渲染和移动端渲染等功能。<br>js计算-》生成渲染树-》渲染页面</p>\n<p>通过VD的比较，我们可以将多个操作合并成一个批量的操作，从而减少dom重排的次数，进而缩短了生成渲染树和绘制所花的时间。</p>\n<p>在mounted 方法中会将template 编译成为render 方法。这是一个编译过程，render中会调用createElement 创建vnode。</p>\n<p><img src=\"https://ustbhuangyi.github.io/vue-analysis/assets/new-vue.png\" alt=\"流程图片\"></p>\n<p>回到 mountComponent 函数的过程，我们已经知道 createElement 是如何创建了一个 VNode，接下来就是要把这个 VNode 渲染成一个真实的 DOM 并渲染出来，这个过程是通过 vm._update 完成的</p>\n<p>Vue 的 _update 是实例的一个私有方法，它被调用的时机有 2 个，一个是首次渲染，一个是数据更新的时候；由于我们这一章节只分析首次渲染部分，数据更新部分会在之后分析响应式原理的时候涉及。_update 方法的作用是把 VNode 渲染成真实的 DOM</p>\n<p>在我们之前对 setter 的分析过程知道，当响应式数据发送变化后，触发了 watcher.update()，只是把这个 watcher 推送到一个队列中，在 nextTick 后才会真正执行 watcher 的回调函数。而一旦我们设置了 sync，就可以在当前 Tick 中同步执行 watcher 的回调函数。</p>\n<p>deep watcher 和 sync watcher  </p>\n<h3 id=\"router-元数据\"><a href=\"#router-元数据\" class=\"headerlink\" title=\"router 元数据\"></a>router 元数据</h3><p> meta: { requiresAuth: true }  </p>\n<h5 id=\"v-once-指令，你也能执行一次性地插值\"><a href=\"#v-once-指令，你也能执行一次性地插值\" class=\"headerlink\" title=\"v-once 指令，你也能执行一次性地插值\"></a>v-once 指令，你也能执行一次性地插值</h5><h4 id=\"v-slot-新的用法\"><a href=\"#v-slot-新的用法\" class=\"headerlink\" title=\"v-slot 新的用法\"></a>v-slot 新的用法</h4><p>v-slot 的别名是#。因此，可以用#header=”data” 来代替 v-slot:header=”data”。还可以使用 #header来代替 v-slot:header(前提:不是作用域插槽时)。对于默认插槽，在使用别名时需要指定默认名称。换句话说，需要这样写 #default=”data” 而不是#=”data”。</p>\n<h5 id=\"Mustache-不能在-HTML-属性中使用，应使用-v-bind-指令：\"><a href=\"#Mustache-不能在-HTML-属性中使用，应使用-v-bind-指令：\" class=\"headerlink\" title=\"Mustache 不能在 HTML 属性中使用，应使用 v-bind 指令：\"></a>Mustache 不能在 HTML 属性中使用，应使用 v-bind 指令：</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<h5 id=\"修饰符（Modifiers）是以半角句号-指明的特殊后缀，用于指出一个指定应该以特殊方式绑定。例如，-prevent-修饰符告诉-v-on-指令对于触发的事件调用-event-preventDefault\"><a href=\"#修饰符（Modifiers）是以半角句号-指明的特殊后缀，用于指出一个指定应该以特殊方式绑定。例如，-prevent-修饰符告诉-v-on-指令对于触发的事件调用-event-preventDefault\" class=\"headerlink\" title=\"修饰符（Modifiers）是以半角句号 . 指明的特殊后缀，用于指出一个指定应该以特殊方式绑定。例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()\"></a>修饰符（Modifiers）是以半角句号 . 指明的特殊后缀，用于指出一个指定应该以特殊方式绑定。例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 阻止单击事件冒泡 --&gt;</span><br><span class=\"line\">&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">&lt;!-- 提交事件不再重载页面 --&gt;</span><br><span class=\"line\">&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;</span><br><span class=\"line\">&lt;!-- 修饰符可以串联  --&gt;</span><br><span class=\"line\">&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">&lt;!-- 只有修饰符 --&gt;</span><br><span class=\"line\">&lt;form v-on:submit.prevent&gt;&lt;/form&gt;</span><br><span class=\"line\">&lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt;</span><br><span class=\"line\">&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;</span><br><span class=\"line\">&lt;!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 --&gt;</span><br><span class=\"line\">&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;</span><br><span class=\"line\">&lt;a v-on:click.once=&quot;doThis&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n<h5 id=\"过滤器函数总接受表达式的值作为第一个参数。\"><a href=\"#过滤器函数总接受表达式的值作为第一个参数。\" class=\"headerlink\" title=\"过滤器函数总接受表达式的值作为第一个参数。\"></a>过滤器函数总接受表达式的值作为第一个参数。</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">  filters: &#123;</span><br><span class=\"line\">    capitalize: function (value) &#123;</span><br><span class=\"line\">      if (!value) return &apos;&apos;</span><br><span class=\"line\">      value = value.toString()</span><br><span class=\"line\">      return value.charAt(0).toUpperCase() + value.slice(1)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">过滤器可以串联：</span><br><span class=\"line\">&#123;&#123; message | filterA | filterB &#125;&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"v-bind-缩写\"><a href=\"#v-bind-缩写\" class=\"headerlink\" title=\"v-bind 缩写\"></a>v-bind 缩写</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 完整语法 --&gt;</span><br><span class=\"line\">&lt;a v-bind:href=&quot;url&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">&lt;!-- 缩写 --&gt;</span><br><span class=\"line\">&lt;a :href=&quot;url&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">v-on 缩写</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 完整语法 --&gt;</span><br><span class=\"line\">&lt;a v-on:click=&quot;doSomething&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">&lt;!-- 缩写 --&gt;</span><br><span class=\"line\">&lt;a @click=&quot;doSomething&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n<h5 id=\"按键修饰符\"><a href=\"#按键修饰符\" class=\"headerlink\" title=\"按键修饰符\"></a>按键修饰符</h5><p>记住所有的 keyCode 比较困难，所以 Vue 为最常用的按键提供了别名：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 同上 --&gt;</span><br><span class=\"line\">&lt;input v-on:keyup.enter=&quot;submit&quot;&gt;</span><br><span class=\"line\">&lt;!-- 缩写语法 --&gt;</span><br><span class=\"line\">&lt;input @keyup.enter=&quot;submit&quot;&gt;</span><br><span class=\"line\">全部的按键别名：</span><br><span class=\"line\">.enter</span><br><span class=\"line\">.tab</span><br><span class=\"line\">.delete (捕获 “删除” 和 “退格” 键)</span><br><span class=\"line\">.esc</span><br><span class=\"line\">.space</span><br><span class=\"line\">.up</span><br><span class=\"line\">.down</span><br><span class=\"line\">.left</span><br><span class=\"line\">.right</span><br></pre></td></tr></table></figure>\n<h5 id=\"绑定属性值\"><a href=\"#绑定属性值\" class=\"headerlink\" title=\"绑定属性值\"></a>绑定属性值</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input</span><br><span class=\"line\">  type=&quot;checkbox&quot;</span><br><span class=\"line\">  v-model=&quot;toggle&quot;</span><br><span class=\"line\">  v-bind:true-value=&quot;a&quot;</span><br><span class=\"line\">  v-bind:false-value=&quot;b&quot;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n<h5 id=\"修饰符\"><a href=\"#修饰符\" class=\"headerlink\" title=\"修饰符\"></a>修饰符</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在默认情况下， v-model 在 input 事件中同步输入框的值与数据 (除了 上述 IME 部分)，但你可以添加一个修饰符 lazy ，从而转变为在 change 事件中同步：</span><br><span class=\"line\">&lt;!-- 在 &quot;change&quot; 而不是 &quot;input&quot; 事件中更新 --&gt;</span><br><span class=\"line\">&lt;input v-model.lazy=&quot;msg&quot; &gt;</span><br><span class=\"line\">.number</span><br><span class=\"line\"></span><br><span class=\"line\">如果想自动将用户的输入值转为 Number 类型（如果原值的转换结果为 NaN 则返回原值），可以添加一个修饰符 number 给 v-model 来处理输入值：</span><br><span class=\"line\">&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt;</span><br><span class=\"line\">这通常很有用，因为在 type=&quot;number&quot; 时 HTML 中输入的值也总是会返回字符串类型。</span><br><span class=\"line\">.trim</span><br><span class=\"line\"></span><br><span class=\"line\">如果要自动过滤用户输入的首尾空格，可以添加 trim 修饰符到 v-model 上过滤输入：</span><br><span class=\"line\">&lt;input v-model.trim=&quot;msg&quot;&gt;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"js\"><a href=\"#js\" class=\"headerlink\" title=\"js\"></a>js</h3><ol>\n<li>Vue 通过在内存中实现文档结构的虚拟表示来解决此问题，其中虚拟节点（VNode）表示 DOM 树中的节点。当需要操纵时，可以在虚拟 DOM的 内存中执行计算和操作，而不是在真实 DOM 上进行操纵。这自然会更快，并且允许虚拟 DOM 算法计算出最优化的方式来更新实际 DOM 结构。</li>\n<li>Vue 不会对 provide 中的变量进行响应式处理。所以，要想 inject 接受的变量是响应式的，provide 提供的变量本身就需要是响应式的。单项数据流</li>\n</ol>\n<p>inheritAttrs: false, // 可以关闭自动挂载到组件根元素上的没有在props声明的属性</p>\n<ol>\n<li>子组件不需要任何处理，只需要在父组件引用的时候通过@hook来监听即可，代码重写如下：&lt;Child @hook:mounted=”doSomething”/&gt;</li>\n<li>数据动态变化：<br>export const store = Vue.observable({ count: 0 });</li>\n<li>vue life cycle<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">parse阶段：使用正在表达式将template进行字符串解析，得到指令、class、style等数据，生成抽象语法树 AST。</span><br><span class=\"line\">optimize阶段：寻找 AST 中的静态节点进行标记，为后面 VNode 的 patch 过程中对比做优化。被标记为 static 的节点在后面的 diff 算法中会被直接忽略，不做详细的比较。</span><br><span class=\"line\"></span><br><span class=\"line\">generate阶段：根据 AST 结构拼接生成 render 函数的字符串。</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/12/26/16f40a08cac6d3cb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"life cycle\"></p>\n<ol>\n<li><p>每个逻辑关注点的代码现在都在复合函数中并置在一起。 这大大减少了在处理大型组件时需要不断“跳转”的情况。 组合函数也可以在编辑器中折叠，使组件更容易扫描:</p>\n</li>\n<li><p>js 链接 defer 和 async</p>\n</li>\n<li><p>keep-alive 的实现正是用到了 LRU 策略,将最近访问的组件 push 到 this.keys 最后面,this.keys[0]也就是最久没被访问的组件,当缓存实例超过 max 设置值,删除 this.keys[0]</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">defer 和 async 都是并行加载的，主要区别在于下载后何时执行。</span><br><span class=\"line\">每一个 async 属性的脚本都在它下载结束之后立刻执行，所以就有可能出现脚本执行顺序被打乱的情况</span><br><span class=\"line\">每一个 defer 属性的脚本会在 HTML 解析完成后, DOMContentLoaded 之前，按照 DOM 中的顺序执行（ie&gt;=10）</span><br><span class=\"line\">defer 和 async 都只适用于外部脚本文件，对与内联的 script 标签是不起作用</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>preload 用 “as” 或者用 “type” 属性来表示他们请求资源的优先级（比如说 preload 使用 as=”style” 属性将获得最高的优先级）。没有 “as” 属性的将被看作异步请求，“Early”意味着在所有未被预加载的图片请求之前被请求（“late”意味着之后）</p>\n</li>\n<li>WebRTC，名称源自网页即时通信（英语：Web Real-Time Communication）的缩写，是一个支持网页浏览器进行实时语音对话或视频对话的API。</li>\n<li>Vue-intro  新功能引导  </li>\n<li>Vm.$attrs  Vm.$attrs </li>\n<li><home :title.sync=\"title\"> //编译时会被扩展为 <home :title=\"title\" @update:title=\"val => title = val\"> // 子组件 // 所以子组件可以通过$emit 触发 update 方法改变 mounted(){ this.$emit(“update:title”, ‘这是新的title’) }</home></home></li>\n<li>Vue.config.errorHandler   </li>\n<li>v-pre  场景:vue 是响应式系统,但是有些静态的标签不需要多次编译,这样可以节省性能</li>\n<li>v-loader transformAssetUrls<br>在模板编译过程中，编译器可以将某些特性转换为 require 调用，例如 src 中的 URL。因此这些目标资源可以被 webpack 处理。例如 <img src=\"./foo.png\"> 会找到你文件系统中的 ./foo.png 并将其作为一个依赖包含在你的包里</li>\n<li>view router加key  场景:由于 Vue 会复用相同组件, 即 /page/1 =&gt; /page/2 或者 /page?id=1 =&gt; /page?id=2 这类链接跳转时, 将不在执行created, mounted之类的钩子</li>\n<li><p>生命周期</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">beforeCreate阶段：vue实例的挂载元素el和数据对象data都是undefined，还没有初始化。</span><br><span class=\"line\">created阶段：vue实例的数据对象data有了，可以访问里面的数据和方法，未挂载到DOM，el还没有</span><br><span class=\"line\">beforeMount阶段：vue实例的el和data都初始化了，但是挂载之前为虚拟的dom节点</span><br><span class=\"line\">mounted阶段：vue实例挂载到真实DOM上，就可以通过DOM获取DOM节点</span><br><span class=\"line\">beforeUpdate阶段：响应式数据更新时调用，发生在虚拟DOM打补丁之前，适合在更新之前访问现有的DOM，比如手动移除已添加的事件监听器</span><br><span class=\"line\">updated阶段：虚拟DOM重新渲染和打补丁之后调用，组成新的DOM已经更新，避免在这个钩子函数中操作数据，防止死循环</span><br><span class=\"line\">beforeDestroy阶段：实例销毁前调用，实例还可以用，this能获取到实例，常用于销毁定时器，解绑事件</span><br><span class=\"line\">destroyed阶段：实例销毁后调用，调用后所有事件监听器会被移除，所有的子实例都会被销毁  </span><br><span class=\"line\">```         </span><br><span class=\"line\">1. __proto__ 属性，这是历史遗留的非标准的语法，但在现代浏览器中广泛实现。获得原型的更可靠方法是使用 Object.getPrototypeOf(new Object())；例如：</span><br><span class=\"line\"> ```javascript</span><br><span class=\"line\">const car = &#123;&#125;</span><br><span class=\"line\">const list = []</span><br><span class=\"line\"> </span><br><span class=\"line\">console.log(Object.getPrototypeOf(car));</span><br><span class=\"line\">console.log(Object.getPrototypeOf(list));</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Object.prototype.toString.call(variable) 用这个方法来判断变量类型目前是最可靠的了，它总能返回正确的值。</p>\n<p>该方法返回 “[object type]”, 其中type是对象类型。</p>\n</li>\n<li>document.getElementsByClassName(‘test’);</li>\n<li></li>\n</ol>\n<h3 id=\"内部机制\"><a href=\"#内部机制\" class=\"headerlink\" title=\"内部机制\"></a>内部机制</h3><p>vue-loader </p>\n<p>compiler 目录包含 Vue.js 所有编译相关的代码。它包括把模板解析成 ast 语法树，ast 语法树优化，代码生成等功能。</p>\n<p>微任务的例子：micortask</p>\n<p>process.nextTick<br>promise<br>Object.observe</p>\n<p>宏任务的例子：</p>\n<p>setTimeout<br>setInterval<br>setImmediate<br>I/O</p>\n<p>需要注意的是node 和 浏览器的 event loop 是有区别的(需要注意的是node v12.0 之后和浏览器处理事一致的)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">浏览器的事件循环：</span><br><span class=\"line\"></span><br><span class=\"line\">执行全局Script同步代码，这些同步代码有一些是同步语句，有一些是异步语句（比如setTimeout等）；</span><br><span class=\"line\">全局Script代码执行完毕后，调用栈Stack会清空；</span><br><span class=\"line\">从微队列microtask queue中取出位于队首的回调任务，放入调用栈Stack中执行，执行完后microtask queue长度减1；</span><br><span class=\"line\">继续取出位于队首的任务，放入调用栈Stack中执行，以此类推，直到直到把microtask queue中的所有任务都执行完毕。注意，如果在执行microtask的过程中，又产生了microtask，那么会加入到队列的末尾，也会在这个周期被调用执行；</span><br><span class=\"line\">microtask queue中的所有任务都执行完毕，此时microtask queue为空队列，调用栈Stack也为空；</span><br><span class=\"line\">取出宏队列macrotask queue中位于队首的任务，放入Stack中执行；</span><br><span class=\"line\">执行完毕后，调用栈Stack为空；</span><br><span class=\"line\">重复第3-7个步骤；</span><br><span class=\"line\">重复第3-7个步骤；</span><br><span class=\"line\">……</span><br><span class=\"line\"></span><br><span class=\"line\">NodeJS中微队列主要有2个：</span><br><span class=\"line\">Next Tick Queue：是放置process.nextTick(callback)的回调任务的</span><br><span class=\"line\">Other Micro Queue：放置其他microtask，比如Promise等</span><br><span class=\"line\"></span><br><span class=\"line\">具体参见： https://segmentfault.com/a/1190000016278115</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">timers 阶段：这个阶段执行timer（setTimeout、setInterval）的回调</span><br><span class=\"line\">I/O callbacks 阶段：执行一些系统调用错误，比如网络通信的错误回调</span><br><span class=\"line\">idle, prepare 阶段：仅node内部使用</span><br><span class=\"line\">poll 阶段：获取新的I/O事件, 适当的条件下node将阻塞在这里</span><br><span class=\"line\">check 阶段：执行 setImmediate() 的回调</span><br><span class=\"line\">close callbacks 阶段：执行 socket 的 close 事件回调</span><br><span class=\"line\"></span><br><span class=\"line\">timers 是事件循环的第一个阶段，Node 会去检查有无已过期的timer，如果有则把它的回调压入timer的任务队列中等待执行，事实上，Node 并不能保证timer在预设时间到了就会立即执行，因为Node对timer的过期检查不一定靠谱，它会受机器上其它运行程序影响，或者那个时间点主线程不空闲。比如下面的代码，setTimeout() 和 setImmediate() 的执行顺序是不确定的。</span><br><span class=\"line\"></span><br><span class=\"line\">poll 阶段</span><br><span class=\"line\">poll 阶段主要有2个功能：</span><br><span class=\"line\"></span><br><span class=\"line\">处理 poll 队列的事件</span><br><span class=\"line\">当有已超时的 timer，执行它的回调函数</span><br><span class=\"line\">even loop将同步执行poll队列里的回调，直到队列为空或执行的回调达到系统上限（上限具体多少未详），接下来even loop会去检查有无预设的setImmediate()，分两种情况：</span><br><span class=\"line\"></span><br><span class=\"line\">若有预设的setImmediate(), event loop将结束poll阶段进入check阶段，并执行check阶段的任务队列</span><br><span class=\"line\">若没有预设的setImmediate()，event loop将阻塞在该阶段等待</span><br><span class=\"line\">注意一个细节，没有setImmediate()会导致event loop阻塞在poll阶段，这样之前设置的timer岂不是执行不了了？所以咧，在poll阶段event loop会有一个检查机制，检查timer队列是否为空，如果timer队列非空，event loop就开始下一轮事件循环，即重新进入到timer阶段。</span><br><span class=\"line\"></span><br><span class=\"line\">check 阶段</span><br><span class=\"line\">setImmediate()的回调会被加入check队列中，从event loop的阶段图可以知道，check阶段的执行顺序在poll阶段之后。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">回顾上一篇，浏览器环境下，microtask的任务队列是每个macrotask执行完之后执行。而在Node.js中，microtask会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行microtask队列的任务。详见：http://lynnelv.github.io/js-event-loop-nodejs</span><br><span class=\"line\"></span><br><span class=\"line\">process.nextTick() 会在各个事件阶段之间执行，一旦执行，要直到nextTick队列被清空，才会进入到下一个事件阶段，所以如果递归调用 process.nextTick()，会导致出现I/O starving（饥饿）的问题</span><br><span class=\"line\"></span><br><span class=\"line\">官方文档：https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/</span><br></pre></td></tr></table></figure>\n<p>###vitual dom</p>\n<p> Vue.js 实现响应式的核心是利用了 ES5 的 Object.defineProperty，这也是为什么 Vue.js 不能兼容 IE8 及以下浏览器的原因，我们先来对它有个直观的认识。值改变时会触发set方法。</p>\n<p> 核心就是利用 Object.defineProperty 给数据添加了 getter 和 setter，目的就是为了在我们访问数据以及写数据的时候能自动执行一些逻辑：getter 做的事情是依赖收集，setter 做的事情是派发更新</p>\n<p> 它会先执行 vm._render() 方法，因为之前分析过这个方法会生成 渲染 VNode，并且在这个过程中会对 vm 上的数据访问，这个时候就触发了数据对象的 getter。</p>\n<p> 它并不会每次数据改变都触发 watcher 的回调，而是把这些 watcher 先添加到一个队列里，然后在 nextTick 后执行 flushSchedulerQueue。</p>\n<p>VD 最大的特点是将页面的状态抽象为 JS 对象的形式，配合不同的渲染工具，使跨平台渲染成为可能。如 React 就借助 VD 实现了服务端渲染、浏览器渲染和移动端渲染等功能。<br>js计算-》生成渲染树-》渲染页面</p>\n<p>通过VD的比较，我们可以将多个操作合并成一个批量的操作，从而减少dom重排的次数，进而缩短了生成渲染树和绘制所花的时间。</p>\n<p>在mounted 方法中会将template 编译成为render 方法。这是一个编译过程，render中会调用createElement 创建vnode。</p>\n<p><img src=\"https://ustbhuangyi.github.io/vue-analysis/assets/new-vue.png\" alt=\"流程图片\"></p>\n<p>回到 mountComponent 函数的过程，我们已经知道 createElement 是如何创建了一个 VNode，接下来就是要把这个 VNode 渲染成一个真实的 DOM 并渲染出来，这个过程是通过 vm._update 完成的</p>\n<p>Vue 的 _update 是实例的一个私有方法，它被调用的时机有 2 个，一个是首次渲染，一个是数据更新的时候；由于我们这一章节只分析首次渲染部分，数据更新部分会在之后分析响应式原理的时候涉及。_update 方法的作用是把 VNode 渲染成真实的 DOM</p>\n<p>在我们之前对 setter 的分析过程知道，当响应式数据发送变化后，触发了 watcher.update()，只是把这个 watcher 推送到一个队列中，在 nextTick 后才会真正执行 watcher 的回调函数。而一旦我们设置了 sync，就可以在当前 Tick 中同步执行 watcher 的回调函数。</p>\n<p>deep watcher 和 sync watcher  </p>\n<h3 id=\"router-元数据\"><a href=\"#router-元数据\" class=\"headerlink\" title=\"router 元数据\"></a>router 元数据</h3><p> meta: { requiresAuth: true }  </p>\n<h5 id=\"v-once-指令，你也能执行一次性地插值\"><a href=\"#v-once-指令，你也能执行一次性地插值\" class=\"headerlink\" title=\"v-once 指令，你也能执行一次性地插值\"></a>v-once 指令，你也能执行一次性地插值</h5><h4 id=\"v-slot-新的用法\"><a href=\"#v-slot-新的用法\" class=\"headerlink\" title=\"v-slot 新的用法\"></a>v-slot 新的用法</h4><p>v-slot 的别名是#。因此，可以用#header=”data” 来代替 v-slot:header=”data”。还可以使用 #header来代替 v-slot:header(前提:不是作用域插槽时)。对于默认插槽，在使用别名时需要指定默认名称。换句话说，需要这样写 #default=”data” 而不是#=”data”。</p>\n<h5 id=\"Mustache-不能在-HTML-属性中使用，应使用-v-bind-指令：\"><a href=\"#Mustache-不能在-HTML-属性中使用，应使用-v-bind-指令：\" class=\"headerlink\" title=\"Mustache 不能在 HTML 属性中使用，应使用 v-bind 指令：\"></a>Mustache 不能在 HTML 属性中使用，应使用 v-bind 指令：</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<h5 id=\"修饰符（Modifiers）是以半角句号-指明的特殊后缀，用于指出一个指定应该以特殊方式绑定。例如，-prevent-修饰符告诉-v-on-指令对于触发的事件调用-event-preventDefault\"><a href=\"#修饰符（Modifiers）是以半角句号-指明的特殊后缀，用于指出一个指定应该以特殊方式绑定。例如，-prevent-修饰符告诉-v-on-指令对于触发的事件调用-event-preventDefault\" class=\"headerlink\" title=\"修饰符（Modifiers）是以半角句号 . 指明的特殊后缀，用于指出一个指定应该以特殊方式绑定。例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()\"></a>修饰符（Modifiers）是以半角句号 . 指明的特殊后缀，用于指出一个指定应该以特殊方式绑定。例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 阻止单击事件冒泡 --&gt;</span><br><span class=\"line\">&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">&lt;!-- 提交事件不再重载页面 --&gt;</span><br><span class=\"line\">&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;</span><br><span class=\"line\">&lt;!-- 修饰符可以串联  --&gt;</span><br><span class=\"line\">&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">&lt;!-- 只有修饰符 --&gt;</span><br><span class=\"line\">&lt;form v-on:submit.prevent&gt;&lt;/form&gt;</span><br><span class=\"line\">&lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt;</span><br><span class=\"line\">&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;</span><br><span class=\"line\">&lt;!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 --&gt;</span><br><span class=\"line\">&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;</span><br><span class=\"line\">&lt;a v-on:click.once=&quot;doThis&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n<h5 id=\"过滤器函数总接受表达式的值作为第一个参数。\"><a href=\"#过滤器函数总接受表达式的值作为第一个参数。\" class=\"headerlink\" title=\"过滤器函数总接受表达式的值作为第一个参数。\"></a>过滤器函数总接受表达式的值作为第一个参数。</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">  filters: &#123;</span><br><span class=\"line\">    capitalize: function (value) &#123;</span><br><span class=\"line\">      if (!value) return &apos;&apos;</span><br><span class=\"line\">      value = value.toString()</span><br><span class=\"line\">      return value.charAt(0).toUpperCase() + value.slice(1)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">过滤器可以串联：</span><br><span class=\"line\">&#123;&#123; message | filterA | filterB &#125;&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"v-bind-缩写\"><a href=\"#v-bind-缩写\" class=\"headerlink\" title=\"v-bind 缩写\"></a>v-bind 缩写</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 完整语法 --&gt;</span><br><span class=\"line\">&lt;a v-bind:href=&quot;url&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">&lt;!-- 缩写 --&gt;</span><br><span class=\"line\">&lt;a :href=&quot;url&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">v-on 缩写</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 完整语法 --&gt;</span><br><span class=\"line\">&lt;a v-on:click=&quot;doSomething&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">&lt;!-- 缩写 --&gt;</span><br><span class=\"line\">&lt;a @click=&quot;doSomething&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n<h5 id=\"按键修饰符\"><a href=\"#按键修饰符\" class=\"headerlink\" title=\"按键修饰符\"></a>按键修饰符</h5><p>记住所有的 keyCode 比较困难，所以 Vue 为最常用的按键提供了别名：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 同上 --&gt;</span><br><span class=\"line\">&lt;input v-on:keyup.enter=&quot;submit&quot;&gt;</span><br><span class=\"line\">&lt;!-- 缩写语法 --&gt;</span><br><span class=\"line\">&lt;input @keyup.enter=&quot;submit&quot;&gt;</span><br><span class=\"line\">全部的按键别名：</span><br><span class=\"line\">.enter</span><br><span class=\"line\">.tab</span><br><span class=\"line\">.delete (捕获 “删除” 和 “退格” 键)</span><br><span class=\"line\">.esc</span><br><span class=\"line\">.space</span><br><span class=\"line\">.up</span><br><span class=\"line\">.down</span><br><span class=\"line\">.left</span><br><span class=\"line\">.right</span><br></pre></td></tr></table></figure>\n<h5 id=\"绑定属性值\"><a href=\"#绑定属性值\" class=\"headerlink\" title=\"绑定属性值\"></a>绑定属性值</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input</span><br><span class=\"line\">  type=&quot;checkbox&quot;</span><br><span class=\"line\">  v-model=&quot;toggle&quot;</span><br><span class=\"line\">  v-bind:true-value=&quot;a&quot;</span><br><span class=\"line\">  v-bind:false-value=&quot;b&quot;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n<h5 id=\"修饰符\"><a href=\"#修饰符\" class=\"headerlink\" title=\"修饰符\"></a>修饰符</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在默认情况下， v-model 在 input 事件中同步输入框的值与数据 (除了 上述 IME 部分)，但你可以添加一个修饰符 lazy ，从而转变为在 change 事件中同步：</span><br><span class=\"line\">&lt;!-- 在 &quot;change&quot; 而不是 &quot;input&quot; 事件中更新 --&gt;</span><br><span class=\"line\">&lt;input v-model.lazy=&quot;msg&quot; &gt;</span><br><span class=\"line\">.number</span><br><span class=\"line\"></span><br><span class=\"line\">如果想自动将用户的输入值转为 Number 类型（如果原值的转换结果为 NaN 则返回原值），可以添加一个修饰符 number 给 v-model 来处理输入值：</span><br><span class=\"line\">&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt;</span><br><span class=\"line\">这通常很有用，因为在 type=&quot;number&quot; 时 HTML 中输入的值也总是会返回字符串类型。</span><br><span class=\"line\">.trim</span><br><span class=\"line\"></span><br><span class=\"line\">如果要自动过滤用户输入的首尾空格，可以添加 trim 修饰符到 v-model 上过滤输入：</span><br><span class=\"line\">&lt;input v-model.trim=&quot;msg&quot;&gt;</span><br></pre></td></tr></table></figure>\n"},{"title":"typescript","date":"2019-02-25T02:16:27.000Z","_content":"\n### 只读属性\n```\ninterface Point {\n    readonly x: number;\n    readonly y: number;\n}\n```\n\n###  接口继承  \n    支持多重继承, 比较有意思的事接口可以继承类\n\n### 枚举类型\n ```\n enum Color {Red, Green, Blue}\n let c: Color = Color.Green;\n```\n\n### any \n```angular2html\nlet notSure: any = 4;\nnotSure = \"maybe a string instead\";\nnotSure = false; // okay, definitely a boolean\n\n```\n### 类型断言 \nas 和 <>\n\n### 剩余参数 \n```angular2html\nfunction invokeLater(args: any[], callback: (...args: any[]) => void) {\n    /* ... Invoke callback with 'args' ... */\n}\n\n// Unsound - invokeLater \"might\" provide any number of arguments\ninvokeLater([1, 2], (x, y) => console.log(x + ', ' + y));\n\n```\n\n### 交叉类型 特色\nPerson & Serializable & Loggable同时是 Person 和 Serializable 和 Loggable。 就是说这个类型的对象同时拥有了这三种类型的成员。\n\n### 联合类型 \n 如果一个值的类型是 A | B，我们能够 确定的是它包含了 A 和 B中共有的成员。 -- 用来做代码检查的\n ```\ninterface Bird {\n    fly();\n    layEggs();\n}\n\ninterface Fish {\n    swim();\n    layEggs();\n}\n\nfunction getSmallPet(): Fish | Bird {\n    // ...\n}\n\nlet pet = getSmallPet();\npet.layEggs(); // okay\npet.swim();    // error\n\n需要类型转换：(<Fish>pet).swim()\n\n```\n \n###  谓词为 parameterName is Type这种形式\n```\nfunction isFish(pet: Fish | Bird): pet is Fish {\n    return (<Fish>pet).swim !== undefined;\n}\n```\n### 参数指定默认值 \n```angular2html\nfunction keepWholeObject(wholeObject: { a: string, b?: number }) {\n    let { a, b = 1001 } = wholeObject;\n}\nTypeScript编译器不允许展开泛型函数上的类型参数 。 这个特性会在TypeScript的未来版本中考虑实现。 ...\n\n\nfunction buildName(firstName: string, lastName: string = 'Cat') {\n    return firstName + ' ' + lastName;\n}\n\n```\n### 数组泛型   \nArray<number>  \n\nlet list: any[] = ['Xcat Liu', 25, { website: 'http://xcatliu.com' }];\n\n用接口表示数组：\n\ninterface NumberArray {\n    [index: number]: number;\n}\n\n### 声明语句 \ndeclare var jQuery: (string) => any;\n\n我们约定声明文件以 .d.ts 为后缀。\n### 元组 \n```angular2html\nlet xcatliu: [string, number];\nxcatliu[0] = 'Xcat Liu';\nxcatliu[1] = 25;\n```\n### 命名空间  来源于C# \nnamespace Validation {}\n\nimport 别名\n```angular2html\namespace Shapes {\n    export namespace Polygons {\n        export class Triangle { }\n        export class Square { }\n    }\n}\n\nimport polygons = Shapes.Polygons;\nlet sq = new polygons.Square();\n```\n### index \n```angular2html\ntype Index = 'a' | 'b' | 'c'\ntype FromIndex = { [k in Index]?: number }\n\nconst good: FromIndex = {b:1, c:2}\n\n// Error:\n// Type '{ b: number; c: number; d: number; }' is not assignable to type 'FromIndex'.\n// Object literal may only specify known properties, and 'd' does not exist in type 'FromIndex'.\nconst bad: FromIndex = {b:1, c:2, d:3};\n```\n### this 参数\n```angular2html\ninterface Card {\n    suit: string;\n    card: number;\n}\ninterface Deck {\n    suits: string[];\n    cards: number[];\n    createCardPicker(this: Deck): () => Card;\n}\nlet deck: Deck = {\n    suits: [\"hearts\", \"spades\", \"clubs\", \"diamonds\"],\n    cards: Array(52),\n    // NOTE: The function now explicitly specifies that its callee must be of type Deck\n    createCardPicker: function(this: Deck) {\n        return () => {\n            let pickedCard = Math.floor(Math.random() * 52);\n            let pickedSuit = Math.floor(pickedCard / 13);\n\n            return {suit: this.suits[pickedSuit], card: pickedCard % 13};\n        }\n    }\n}\n```\n\n","source":"_posts/typescript.md","raw":"---\ntitle: typescript\ndate: 2019-02-25 10:16:27\ntags: ts\n---\n\n### 只读属性\n```\ninterface Point {\n    readonly x: number;\n    readonly y: number;\n}\n```\n\n###  接口继承  \n    支持多重继承, 比较有意思的事接口可以继承类\n\n### 枚举类型\n ```\n enum Color {Red, Green, Blue}\n let c: Color = Color.Green;\n```\n\n### any \n```angular2html\nlet notSure: any = 4;\nnotSure = \"maybe a string instead\";\nnotSure = false; // okay, definitely a boolean\n\n```\n### 类型断言 \nas 和 <>\n\n### 剩余参数 \n```angular2html\nfunction invokeLater(args: any[], callback: (...args: any[]) => void) {\n    /* ... Invoke callback with 'args' ... */\n}\n\n// Unsound - invokeLater \"might\" provide any number of arguments\ninvokeLater([1, 2], (x, y) => console.log(x + ', ' + y));\n\n```\n\n### 交叉类型 特色\nPerson & Serializable & Loggable同时是 Person 和 Serializable 和 Loggable。 就是说这个类型的对象同时拥有了这三种类型的成员。\n\n### 联合类型 \n 如果一个值的类型是 A | B，我们能够 确定的是它包含了 A 和 B中共有的成员。 -- 用来做代码检查的\n ```\ninterface Bird {\n    fly();\n    layEggs();\n}\n\ninterface Fish {\n    swim();\n    layEggs();\n}\n\nfunction getSmallPet(): Fish | Bird {\n    // ...\n}\n\nlet pet = getSmallPet();\npet.layEggs(); // okay\npet.swim();    // error\n\n需要类型转换：(<Fish>pet).swim()\n\n```\n \n###  谓词为 parameterName is Type这种形式\n```\nfunction isFish(pet: Fish | Bird): pet is Fish {\n    return (<Fish>pet).swim !== undefined;\n}\n```\n### 参数指定默认值 \n```angular2html\nfunction keepWholeObject(wholeObject: { a: string, b?: number }) {\n    let { a, b = 1001 } = wholeObject;\n}\nTypeScript编译器不允许展开泛型函数上的类型参数 。 这个特性会在TypeScript的未来版本中考虑实现。 ...\n\n\nfunction buildName(firstName: string, lastName: string = 'Cat') {\n    return firstName + ' ' + lastName;\n}\n\n```\n### 数组泛型   \nArray<number>  \n\nlet list: any[] = ['Xcat Liu', 25, { website: 'http://xcatliu.com' }];\n\n用接口表示数组：\n\ninterface NumberArray {\n    [index: number]: number;\n}\n\n### 声明语句 \ndeclare var jQuery: (string) => any;\n\n我们约定声明文件以 .d.ts 为后缀。\n### 元组 \n```angular2html\nlet xcatliu: [string, number];\nxcatliu[0] = 'Xcat Liu';\nxcatliu[1] = 25;\n```\n### 命名空间  来源于C# \nnamespace Validation {}\n\nimport 别名\n```angular2html\namespace Shapes {\n    export namespace Polygons {\n        export class Triangle { }\n        export class Square { }\n    }\n}\n\nimport polygons = Shapes.Polygons;\nlet sq = new polygons.Square();\n```\n### index \n```angular2html\ntype Index = 'a' | 'b' | 'c'\ntype FromIndex = { [k in Index]?: number }\n\nconst good: FromIndex = {b:1, c:2}\n\n// Error:\n// Type '{ b: number; c: number; d: number; }' is not assignable to type 'FromIndex'.\n// Object literal may only specify known properties, and 'd' does not exist in type 'FromIndex'.\nconst bad: FromIndex = {b:1, c:2, d:3};\n```\n### this 参数\n```angular2html\ninterface Card {\n    suit: string;\n    card: number;\n}\ninterface Deck {\n    suits: string[];\n    cards: number[];\n    createCardPicker(this: Deck): () => Card;\n}\nlet deck: Deck = {\n    suits: [\"hearts\", \"spades\", \"clubs\", \"diamonds\"],\n    cards: Array(52),\n    // NOTE: The function now explicitly specifies that its callee must be of type Deck\n    createCardPicker: function(this: Deck) {\n        return () => {\n            let pickedCard = Math.floor(Math.random() * 52);\n            let pickedSuit = Math.floor(pickedCard / 13);\n\n            return {suit: this.suits[pickedSuit], card: pickedCard % 13};\n        }\n    }\n}\n```\n\n","slug":"typescript","published":1,"updated":"2019-07-26T08:35:17.313Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5bwexd90018998slpekobfb","content":"<h3 id=\"只读属性\"><a href=\"#只读属性\" class=\"headerlink\" title=\"只读属性\"></a>只读属性</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface Point &#123;</span><br><span class=\"line\">    readonly x: number;</span><br><span class=\"line\">    readonly y: number;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"接口继承\"><a href=\"#接口继承\" class=\"headerlink\" title=\"接口继承\"></a>接口继承</h3><pre><code>支持多重继承, 比较有意思的事接口可以继承类\n</code></pre><h3 id=\"枚举类型\"><a href=\"#枚举类型\" class=\"headerlink\" title=\"枚举类型\"></a>枚举类型</h3> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum Color &#123;Red, Green, Blue&#125;</span><br><span class=\"line\">let c: Color = Color.Green;</span><br></pre></td></tr></table></figure>\n<h3 id=\"any\"><a href=\"#any\" class=\"headerlink\" title=\"any\"></a>any</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let notSure: any = 4;</span><br><span class=\"line\">notSure = &quot;maybe a string instead&quot;;</span><br><span class=\"line\">notSure = false; // okay, definitely a boolean</span><br></pre></td></tr></table></figure>\n<h3 id=\"类型断言\"><a href=\"#类型断言\" class=\"headerlink\" title=\"类型断言\"></a>类型断言</h3><p>as 和 &lt;&gt;</p>\n<h3 id=\"剩余参数\"><a href=\"#剩余参数\" class=\"headerlink\" title=\"剩余参数\"></a>剩余参数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function invokeLater(args: any[], callback: (...args: any[]) =&gt; void) &#123;</span><br><span class=\"line\">    /* ... Invoke callback with &apos;args&apos; ... */</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Unsound - invokeLater &quot;might&quot; provide any number of arguments</span><br><span class=\"line\">invokeLater([1, 2], (x, y) =&gt; console.log(x + &apos;, &apos; + y));</span><br></pre></td></tr></table></figure>\n<h3 id=\"交叉类型-特色\"><a href=\"#交叉类型-特色\" class=\"headerlink\" title=\"交叉类型 特色\"></a>交叉类型 特色</h3><p>Person &amp; Serializable &amp; Loggable同时是 Person 和 Serializable 和 Loggable。 就是说这个类型的对象同时拥有了这三种类型的成员。</p>\n<h3 id=\"联合类型\"><a href=\"#联合类型\" class=\"headerlink\" title=\"联合类型\"></a>联合类型</h3><p> 如果一个值的类型是 A | B，我们能够 确定的是它包含了 A 和 B中共有的成员。 – 用来做代码检查的<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface Bird &#123;</span><br><span class=\"line\">    fly();</span><br><span class=\"line\">    layEggs();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">interface Fish &#123;</span><br><span class=\"line\">    swim();</span><br><span class=\"line\">    layEggs();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function getSmallPet(): Fish | Bird &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let pet = getSmallPet();</span><br><span class=\"line\">pet.layEggs(); // okay</span><br><span class=\"line\">pet.swim();    // error</span><br><span class=\"line\"></span><br><span class=\"line\">需要类型转换：(&lt;Fish&gt;pet).swim()</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"谓词为-parameterName-is-Type这种形式\"><a href=\"#谓词为-parameterName-is-Type这种形式\" class=\"headerlink\" title=\"谓词为 parameterName is Type这种形式\"></a>谓词为 parameterName is Type这种形式</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function isFish(pet: Fish | Bird): pet is Fish &#123;</span><br><span class=\"line\">    return (&lt;Fish&gt;pet).swim !== undefined;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"参数指定默认值\"><a href=\"#参数指定默认值\" class=\"headerlink\" title=\"参数指定默认值\"></a>参数指定默认值</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function keepWholeObject(wholeObject: &#123; a: string, b?: number &#125;) &#123;</span><br><span class=\"line\">    let &#123; a, b = 1001 &#125; = wholeObject;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">TypeScript编译器不允许展开泛型函数上的类型参数 。 这个特性会在TypeScript的未来版本中考虑实现。 ...</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">function buildName(firstName: string, lastName: string = &apos;Cat&apos;) &#123;</span><br><span class=\"line\">    return firstName + &apos; &apos; + lastName;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"数组泛型\"><a href=\"#数组泛型\" class=\"headerlink\" title=\"数组泛型\"></a>数组泛型</h3><p>Array<number>  </number></p>\n<p>let list: any[] = [‘Xcat Liu’, 25, { website: ‘<a href=\"http://xcatliu.com&#39;\" target=\"_blank\" rel=\"noopener\">http://xcatliu.com&#39;</a> }];</p>\n<p>用接口表示数组：</p>\n<p>interface NumberArray {<br>    [index: number]: number;<br>}</p>\n<h3 id=\"声明语句\"><a href=\"#声明语句\" class=\"headerlink\" title=\"声明语句\"></a>声明语句</h3><p>declare var jQuery: (string) =&gt; any;</p>\n<p>我们约定声明文件以 .d.ts 为后缀。</p>\n<h3 id=\"元组\"><a href=\"#元组\" class=\"headerlink\" title=\"元组\"></a>元组</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let xcatliu: [string, number];</span><br><span class=\"line\">xcatliu[0] = &apos;Xcat Liu&apos;;</span><br><span class=\"line\">xcatliu[1] = 25;</span><br></pre></td></tr></table></figure>\n<h3 id=\"命名空间-来源于C\"><a href=\"#命名空间-来源于C\" class=\"headerlink\" title=\"命名空间  来源于C\"></a>命名空间  来源于C</h3><p>namespace Validation {}</p>\n<p>import 别名<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">amespace Shapes &#123;</span><br><span class=\"line\">    export namespace Polygons &#123;</span><br><span class=\"line\">        export class Triangle &#123; &#125;</span><br><span class=\"line\">        export class Square &#123; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">import polygons = Shapes.Polygons;</span><br><span class=\"line\">let sq = new polygons.Square();</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"index\"><a href=\"#index\" class=\"headerlink\" title=\"index\"></a>index</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Index = &apos;a&apos; | &apos;b&apos; | &apos;c&apos;</span><br><span class=\"line\">type FromIndex = &#123; [k in Index]?: number &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const good: FromIndex = &#123;b:1, c:2&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Error:</span><br><span class=\"line\">// Type &apos;&#123; b: number; c: number; d: number; &#125;&apos; is not assignable to type &apos;FromIndex&apos;.</span><br><span class=\"line\">// Object literal may only specify known properties, and &apos;d&apos; does not exist in type &apos;FromIndex&apos;.</span><br><span class=\"line\">const bad: FromIndex = &#123;b:1, c:2, d:3&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"this-参数\"><a href=\"#this-参数\" class=\"headerlink\" title=\"this 参数\"></a>this 参数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface Card &#123;</span><br><span class=\"line\">    suit: string;</span><br><span class=\"line\">    card: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">interface Deck &#123;</span><br><span class=\"line\">    suits: string[];</span><br><span class=\"line\">    cards: number[];</span><br><span class=\"line\">    createCardPicker(this: Deck): () =&gt; Card;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let deck: Deck = &#123;</span><br><span class=\"line\">    suits: [&quot;hearts&quot;, &quot;spades&quot;, &quot;clubs&quot;, &quot;diamonds&quot;],</span><br><span class=\"line\">    cards: Array(52),</span><br><span class=\"line\">    // NOTE: The function now explicitly specifies that its callee must be of type Deck</span><br><span class=\"line\">    createCardPicker: function(this: Deck) &#123;</span><br><span class=\"line\">        return () =&gt; &#123;</span><br><span class=\"line\">            let pickedCard = Math.floor(Math.random() * 52);</span><br><span class=\"line\">            let pickedSuit = Math.floor(pickedCard / 13);</span><br><span class=\"line\"></span><br><span class=\"line\">            return &#123;suit: this.suits[pickedSuit], card: pickedCard % 13&#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"只读属性\"><a href=\"#只读属性\" class=\"headerlink\" title=\"只读属性\"></a>只读属性</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface Point &#123;</span><br><span class=\"line\">    readonly x: number;</span><br><span class=\"line\">    readonly y: number;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"接口继承\"><a href=\"#接口继承\" class=\"headerlink\" title=\"接口继承\"></a>接口继承</h3><pre><code>支持多重继承, 比较有意思的事接口可以继承类\n</code></pre><h3 id=\"枚举类型\"><a href=\"#枚举类型\" class=\"headerlink\" title=\"枚举类型\"></a>枚举类型</h3> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum Color &#123;Red, Green, Blue&#125;</span><br><span class=\"line\">let c: Color = Color.Green;</span><br></pre></td></tr></table></figure>\n<h3 id=\"any\"><a href=\"#any\" class=\"headerlink\" title=\"any\"></a>any</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let notSure: any = 4;</span><br><span class=\"line\">notSure = &quot;maybe a string instead&quot;;</span><br><span class=\"line\">notSure = false; // okay, definitely a boolean</span><br></pre></td></tr></table></figure>\n<h3 id=\"类型断言\"><a href=\"#类型断言\" class=\"headerlink\" title=\"类型断言\"></a>类型断言</h3><p>as 和 &lt;&gt;</p>\n<h3 id=\"剩余参数\"><a href=\"#剩余参数\" class=\"headerlink\" title=\"剩余参数\"></a>剩余参数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function invokeLater(args: any[], callback: (...args: any[]) =&gt; void) &#123;</span><br><span class=\"line\">    /* ... Invoke callback with &apos;args&apos; ... */</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Unsound - invokeLater &quot;might&quot; provide any number of arguments</span><br><span class=\"line\">invokeLater([1, 2], (x, y) =&gt; console.log(x + &apos;, &apos; + y));</span><br></pre></td></tr></table></figure>\n<h3 id=\"交叉类型-特色\"><a href=\"#交叉类型-特色\" class=\"headerlink\" title=\"交叉类型 特色\"></a>交叉类型 特色</h3><p>Person &amp; Serializable &amp; Loggable同时是 Person 和 Serializable 和 Loggable。 就是说这个类型的对象同时拥有了这三种类型的成员。</p>\n<h3 id=\"联合类型\"><a href=\"#联合类型\" class=\"headerlink\" title=\"联合类型\"></a>联合类型</h3><p> 如果一个值的类型是 A | B，我们能够 确定的是它包含了 A 和 B中共有的成员。 – 用来做代码检查的<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface Bird &#123;</span><br><span class=\"line\">    fly();</span><br><span class=\"line\">    layEggs();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">interface Fish &#123;</span><br><span class=\"line\">    swim();</span><br><span class=\"line\">    layEggs();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function getSmallPet(): Fish | Bird &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let pet = getSmallPet();</span><br><span class=\"line\">pet.layEggs(); // okay</span><br><span class=\"line\">pet.swim();    // error</span><br><span class=\"line\"></span><br><span class=\"line\">需要类型转换：(&lt;Fish&gt;pet).swim()</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"谓词为-parameterName-is-Type这种形式\"><a href=\"#谓词为-parameterName-is-Type这种形式\" class=\"headerlink\" title=\"谓词为 parameterName is Type这种形式\"></a>谓词为 parameterName is Type这种形式</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function isFish(pet: Fish | Bird): pet is Fish &#123;</span><br><span class=\"line\">    return (&lt;Fish&gt;pet).swim !== undefined;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"参数指定默认值\"><a href=\"#参数指定默认值\" class=\"headerlink\" title=\"参数指定默认值\"></a>参数指定默认值</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function keepWholeObject(wholeObject: &#123; a: string, b?: number &#125;) &#123;</span><br><span class=\"line\">    let &#123; a, b = 1001 &#125; = wholeObject;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">TypeScript编译器不允许展开泛型函数上的类型参数 。 这个特性会在TypeScript的未来版本中考虑实现。 ...</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">function buildName(firstName: string, lastName: string = &apos;Cat&apos;) &#123;</span><br><span class=\"line\">    return firstName + &apos; &apos; + lastName;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"数组泛型\"><a href=\"#数组泛型\" class=\"headerlink\" title=\"数组泛型\"></a>数组泛型</h3><p>Array<number>  </number></p>\n<p>let list: any[] = [‘Xcat Liu’, 25, { website: ‘<a href=\"http://xcatliu.com&#39;\" target=\"_blank\" rel=\"noopener\">http://xcatliu.com&#39;</a> }];</p>\n<p>用接口表示数组：</p>\n<p>interface NumberArray {<br>    [index: number]: number;<br>}</p>\n<h3 id=\"声明语句\"><a href=\"#声明语句\" class=\"headerlink\" title=\"声明语句\"></a>声明语句</h3><p>declare var jQuery: (string) =&gt; any;</p>\n<p>我们约定声明文件以 .d.ts 为后缀。</p>\n<h3 id=\"元组\"><a href=\"#元组\" class=\"headerlink\" title=\"元组\"></a>元组</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let xcatliu: [string, number];</span><br><span class=\"line\">xcatliu[0] = &apos;Xcat Liu&apos;;</span><br><span class=\"line\">xcatliu[1] = 25;</span><br></pre></td></tr></table></figure>\n<h3 id=\"命名空间-来源于C\"><a href=\"#命名空间-来源于C\" class=\"headerlink\" title=\"命名空间  来源于C\"></a>命名空间  来源于C</h3><p>namespace Validation {}</p>\n<p>import 别名<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">amespace Shapes &#123;</span><br><span class=\"line\">    export namespace Polygons &#123;</span><br><span class=\"line\">        export class Triangle &#123; &#125;</span><br><span class=\"line\">        export class Square &#123; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">import polygons = Shapes.Polygons;</span><br><span class=\"line\">let sq = new polygons.Square();</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"index\"><a href=\"#index\" class=\"headerlink\" title=\"index\"></a>index</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Index = &apos;a&apos; | &apos;b&apos; | &apos;c&apos;</span><br><span class=\"line\">type FromIndex = &#123; [k in Index]?: number &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const good: FromIndex = &#123;b:1, c:2&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Error:</span><br><span class=\"line\">// Type &apos;&#123; b: number; c: number; d: number; &#125;&apos; is not assignable to type &apos;FromIndex&apos;.</span><br><span class=\"line\">// Object literal may only specify known properties, and &apos;d&apos; does not exist in type &apos;FromIndex&apos;.</span><br><span class=\"line\">const bad: FromIndex = &#123;b:1, c:2, d:3&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"this-参数\"><a href=\"#this-参数\" class=\"headerlink\" title=\"this 参数\"></a>this 参数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface Card &#123;</span><br><span class=\"line\">    suit: string;</span><br><span class=\"line\">    card: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">interface Deck &#123;</span><br><span class=\"line\">    suits: string[];</span><br><span class=\"line\">    cards: number[];</span><br><span class=\"line\">    createCardPicker(this: Deck): () =&gt; Card;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let deck: Deck = &#123;</span><br><span class=\"line\">    suits: [&quot;hearts&quot;, &quot;spades&quot;, &quot;clubs&quot;, &quot;diamonds&quot;],</span><br><span class=\"line\">    cards: Array(52),</span><br><span class=\"line\">    // NOTE: The function now explicitly specifies that its callee must be of type Deck</span><br><span class=\"line\">    createCardPicker: function(this: Deck) &#123;</span><br><span class=\"line\">        return () =&gt; &#123;</span><br><span class=\"line\">            let pickedCard = Math.floor(Math.random() * 52);</span><br><span class=\"line\">            let pickedSuit = Math.floor(pickedCard / 13);</span><br><span class=\"line\"></span><br><span class=\"line\">            return &#123;suit: this.suits[pickedSuit], card: pickedCard % 13&#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"webpack","date":"2017-01-17T06:58:02.000Z","_content":"### babel相关\n1. 虽然@babel/polyfill提供了我们想要的所有新方法新类，但是这里依然存在一些问题：\n   \n   体积太大：比如我只用了String的新特性，但是我把整个包都引进来了，，这不是徒增了很多无用的代码。\n   污染全局环境：如果你引用了 @babel/polyfill，那么像Promise这样的新类就是挂载在全局上的，这样就会污染了全局命名空间。可能在一个团建建立的项目问题不太大，但是如果你是一个工具的开发者，你把全局环境污染了，别人用你的工具，就有可能把别人给坑了\n   \n1.  @babel/plugin-transform-runtime会为代码创建一个沙盒环境，为core-js这里内建的实例提供假名，你可以无缝的使用这些新特性，而不需要使用require polyfill。\n    \n    一个解决方案就是引入transform runtime 来替代 @babel/polyfill。\n    幸运的是，我们有env这个preset，它又一个useBuiltIns选项，如果设置成\"usage\"，那么将会自动检测语法帮你require你代码中使用到的功能。  \n1. @babel/core\n   其中最核心的包就是@babel/core，它主要的作用就是编译.\n   \n   Babel-cli \n   光有core是无法在命令行使用这些功能的，@babel/cli支持你直接在命令行中编译代码。\n   这句话会编译你src目录下的所有js代码，并编译成你想要的那样（babel.config.js配置的），并输出到lib目录下。 \n1. @babel/preset-env\n如果useBuiltIns为true，项目中必须引入babel-polyfill。\n\n\n\n1.UglifyJS: vue-cli 默认使用的压缩代码方式，它使用的是单线程压缩代码，打包时间较慢\n  ParallelUglifyPlugin: 开启多个子进程，把对多个文件压缩的工作分别给多个子进程去完成\n1. Vue Loader 是一个 webpack 的 loader，它允许你以一种名为单文件组件 (SFCs)的格式撰写 Vue 组件.   \n1. autoprefixer 自动补充前缀\n\n1. Hot Module Replacement（以下简称 HMR）是 webpack 发展至今引入的最令人兴奋的特性之一 ，当你对代码进行修改并保存后，webpack 将对代码重新打包，并将新的模块发送到浏览器端，浏览器通过新的模块替换老的模块，这样在不刷新浏览器的前提下就能够对应用进行更新。\n1.  webpack-dev-server 修改了webpack 配置中的 entry 属性，在里面添加了 webpack-dev-client 的代码，这样在最后的 bundle.js 文件中就会有接收 websocket 消息的代码了。\n1. \n1. WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。\n\n1. Webpack splitchunk 将各个模块的交集部分抽离出来 \n\n1. Webpack ProvidePlugin 自动加载js，不必import。\n   new webpack.ProvidePlugin({\n     _map: ['lodash', 'map']\n   })\n\n1. Webpack在打包时可以为我们生成的source maps，这为我们提供了一种对应编译文件和源文件的方法，使得编译后的代码可读性更高，也更容易调试\n\n具体配置参考：http://www.jianshu.com/p/42e11515c10f\n\n感叹号的作用在于使同一文件能够使用不同类型的loader\n\n对css 分模块：\n\n```\n{\n        test: /\\.css$/,\n        loader: 'style!css?modules'//跟前面相比就在后面加上了?modules\n}\n```\n\nLoaders和Plugins常常被弄混，但是他们其实是完全不同的东西，可以这么来说，loaders是在打包构建过程中用来处理源文件的（JSX，Scss，Less..），一次处理一个，插件并不直接操作单个文件，它直接对整个构建过程其作用。\n\n####  常用命令\n\n\n```\n$ webpack --config webpack.min.js //另一份配置文件\n\n$ webpack --display-error-details //显示异常信息\n\n$ webpack --watch   //监听变动并自动打包\n \n$ webpack -p    //压缩混淆脚本，这个非常非常重要！\n \n$ webpack -d    //生成map映射文件，告知哪些模块被最终打包到哪里了\n```\n\n对公共库的封装：\n\n```\nentry: {\n  vendor: [\"jquery\", \"other-lib\"],\n  app: \"./entry\"\n}\nnew CommonsChunkPlugin({\n  name: \"vendor\",\n\n  // filename: \"vendor.js\"\n  // (Give the chunk a different name)\n\n  minChunks: Infinity,\n  // (with more entries, this ensures that no other module\n  //  goes into the vendor chunk)\n})\n```\n\n关于express webpack middleware 的配置\n\nhttp://www.cnblogs.com/linfangshuhellowored/p/5657285.html\n\n给文件自动添加hash后缀\n\n根据chunkhash的定义知道，chunkhash是根据具体模块文件的内容计算所得的hash值，所以某个文件的改动只会影响它本身的hash指纹，不会影响其他文件。配置webpack的output如下：\n```\noutput: {\n    filename: '[name].[chunkhash:8].js',\n    path: __dirname + '/built'\n}\noutput: {\n    filename: '[name].[hash:8].js',\n    path: __dirname + '/built'\n}\n```","source":"_posts/webpack.md","raw":"---\ntitle: webpack\ndate: 2017-01-17 14:58:02\ntags: webpack  \n---\n### babel相关\n1. 虽然@babel/polyfill提供了我们想要的所有新方法新类，但是这里依然存在一些问题：\n   \n   体积太大：比如我只用了String的新特性，但是我把整个包都引进来了，，这不是徒增了很多无用的代码。\n   污染全局环境：如果你引用了 @babel/polyfill，那么像Promise这样的新类就是挂载在全局上的，这样就会污染了全局命名空间。可能在一个团建建立的项目问题不太大，但是如果你是一个工具的开发者，你把全局环境污染了，别人用你的工具，就有可能把别人给坑了\n   \n1.  @babel/plugin-transform-runtime会为代码创建一个沙盒环境，为core-js这里内建的实例提供假名，你可以无缝的使用这些新特性，而不需要使用require polyfill。\n    \n    一个解决方案就是引入transform runtime 来替代 @babel/polyfill。\n    幸运的是，我们有env这个preset，它又一个useBuiltIns选项，如果设置成\"usage\"，那么将会自动检测语法帮你require你代码中使用到的功能。  \n1. @babel/core\n   其中最核心的包就是@babel/core，它主要的作用就是编译.\n   \n   Babel-cli \n   光有core是无法在命令行使用这些功能的，@babel/cli支持你直接在命令行中编译代码。\n   这句话会编译你src目录下的所有js代码，并编译成你想要的那样（babel.config.js配置的），并输出到lib目录下。 \n1. @babel/preset-env\n如果useBuiltIns为true，项目中必须引入babel-polyfill。\n\n\n\n1.UglifyJS: vue-cli 默认使用的压缩代码方式，它使用的是单线程压缩代码，打包时间较慢\n  ParallelUglifyPlugin: 开启多个子进程，把对多个文件压缩的工作分别给多个子进程去完成\n1. Vue Loader 是一个 webpack 的 loader，它允许你以一种名为单文件组件 (SFCs)的格式撰写 Vue 组件.   \n1. autoprefixer 自动补充前缀\n\n1. Hot Module Replacement（以下简称 HMR）是 webpack 发展至今引入的最令人兴奋的特性之一 ，当你对代码进行修改并保存后，webpack 将对代码重新打包，并将新的模块发送到浏览器端，浏览器通过新的模块替换老的模块，这样在不刷新浏览器的前提下就能够对应用进行更新。\n1.  webpack-dev-server 修改了webpack 配置中的 entry 属性，在里面添加了 webpack-dev-client 的代码，这样在最后的 bundle.js 文件中就会有接收 websocket 消息的代码了。\n1. \n1. WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。\n\n1. Webpack splitchunk 将各个模块的交集部分抽离出来 \n\n1. Webpack ProvidePlugin 自动加载js，不必import。\n   new webpack.ProvidePlugin({\n     _map: ['lodash', 'map']\n   })\n\n1. Webpack在打包时可以为我们生成的source maps，这为我们提供了一种对应编译文件和源文件的方法，使得编译后的代码可读性更高，也更容易调试\n\n具体配置参考：http://www.jianshu.com/p/42e11515c10f\n\n感叹号的作用在于使同一文件能够使用不同类型的loader\n\n对css 分模块：\n\n```\n{\n        test: /\\.css$/,\n        loader: 'style!css?modules'//跟前面相比就在后面加上了?modules\n}\n```\n\nLoaders和Plugins常常被弄混，但是他们其实是完全不同的东西，可以这么来说，loaders是在打包构建过程中用来处理源文件的（JSX，Scss，Less..），一次处理一个，插件并不直接操作单个文件，它直接对整个构建过程其作用。\n\n####  常用命令\n\n\n```\n$ webpack --config webpack.min.js //另一份配置文件\n\n$ webpack --display-error-details //显示异常信息\n\n$ webpack --watch   //监听变动并自动打包\n \n$ webpack -p    //压缩混淆脚本，这个非常非常重要！\n \n$ webpack -d    //生成map映射文件，告知哪些模块被最终打包到哪里了\n```\n\n对公共库的封装：\n\n```\nentry: {\n  vendor: [\"jquery\", \"other-lib\"],\n  app: \"./entry\"\n}\nnew CommonsChunkPlugin({\n  name: \"vendor\",\n\n  // filename: \"vendor.js\"\n  // (Give the chunk a different name)\n\n  minChunks: Infinity,\n  // (with more entries, this ensures that no other module\n  //  goes into the vendor chunk)\n})\n```\n\n关于express webpack middleware 的配置\n\nhttp://www.cnblogs.com/linfangshuhellowored/p/5657285.html\n\n给文件自动添加hash后缀\n\n根据chunkhash的定义知道，chunkhash是根据具体模块文件的内容计算所得的hash值，所以某个文件的改动只会影响它本身的hash指纹，不会影响其他文件。配置webpack的output如下：\n```\noutput: {\n    filename: '[name].[chunkhash:8].js',\n    path: __dirname + '/built'\n}\noutput: {\n    filename: '[name].[hash:8].js',\n    path: __dirname + '/built'\n}\n```","slug":"webpack","published":1,"updated":"2020-01-02T07:11:20.123Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5bwexdq0020998s3usguf5i","content":"<h3 id=\"babel相关\"><a href=\"#babel相关\" class=\"headerlink\" title=\"babel相关\"></a>babel相关</h3><ol>\n<li><p>虽然@babel/polyfill提供了我们想要的所有新方法新类，但是这里依然存在一些问题：</p>\n<p>体积太大：比如我只用了String的新特性，但是我把整个包都引进来了，，这不是徒增了很多无用的代码。<br>污染全局环境：如果你引用了 @babel/polyfill，那么像Promise这样的新类就是挂载在全局上的，这样就会污染了全局命名空间。可能在一个团建建立的项目问题不太大，但是如果你是一个工具的开发者，你把全局环境污染了，别人用你的工具，就有可能把别人给坑了</p>\n</li>\n<li><p>@babel/plugin-transform-runtime会为代码创建一个沙盒环境，为core-js这里内建的实例提供假名，你可以无缝的使用这些新特性，而不需要使用require polyfill。</p>\n<p>一个解决方案就是引入transform runtime 来替代 @babel/polyfill。<br>幸运的是，我们有env这个preset，它又一个useBuiltIns选项，如果设置成”usage”，那么将会自动检测语法帮你require你代码中使用到的功能。  </p>\n</li>\n<li><p>@babel/core<br>其中最核心的包就是@babel/core，它主要的作用就是编译.</p>\n<p>Babel-cli<br>光有core是无法在命令行使用这些功能的，@babel/cli支持你直接在命令行中编译代码。<br>这句话会编译你src目录下的所有js代码，并编译成你想要的那样（babel.config.js配置的），并输出到lib目录下。 </p>\n</li>\n<li>@babel/preset-env<br>如果useBuiltIns为true，项目中必须引入babel-polyfill。</li>\n</ol>\n<p>1.UglifyJS: vue-cli 默认使用的压缩代码方式，它使用的是单线程压缩代码，打包时间较慢<br>  ParallelUglifyPlugin: 开启多个子进程，把对多个文件压缩的工作分别给多个子进程去完成</p>\n<ol>\n<li>Vue Loader 是一个 webpack 的 loader，它允许你以一种名为单文件组件 (SFCs)的格式撰写 Vue 组件.   </li>\n<li><p>autoprefixer 自动补充前缀</p>\n</li>\n<li><p>Hot Module Replacement（以下简称 HMR）是 webpack 发展至今引入的最令人兴奋的特性之一 ，当你对代码进行修改并保存后，webpack 将对代码重新打包，并将新的模块发送到浏览器端，浏览器通过新的模块替换老的模块，这样在不刷新浏览器的前提下就能够对应用进行更新。</p>\n</li>\n<li>webpack-dev-server 修改了webpack 配置中的 entry 属性，在里面添加了 webpack-dev-client 的代码，这样在最后的 bundle.js 文件中就会有接收 websocket 消息的代码了。</li>\n<li></li>\n<li><p>WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。</p>\n</li>\n<li><p>Webpack splitchunk 将各个模块的交集部分抽离出来 </p>\n</li>\n<li><p>Webpack ProvidePlugin 自动加载js，不必import。<br>new webpack.ProvidePlugin({<br>  _map: [‘lodash’, ‘map’]<br>})</p>\n</li>\n<li><p>Webpack在打包时可以为我们生成的source maps，这为我们提供了一种对应编译文件和源文件的方法，使得编译后的代码可读性更高，也更容易调试</p>\n</li>\n</ol>\n<p>具体配置参考：<a href=\"http://www.jianshu.com/p/42e11515c10f\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/42e11515c10f</a></p>\n<p>感叹号的作用在于使同一文件能够使用不同类型的loader</p>\n<p>对css 分模块：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">        test: /\\.css$/,</span><br><span class=\"line\">        loader: &apos;style!css?modules&apos;//跟前面相比就在后面加上了?modules</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Loaders和Plugins常常被弄混，但是他们其实是完全不同的东西，可以这么来说，loaders是在打包构建过程中用来处理源文件的（JSX，Scss，Less..），一次处理一个，插件并不直接操作单个文件，它直接对整个构建过程其作用。</p>\n<h4 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ webpack --config webpack.min.js //另一份配置文件</span><br><span class=\"line\"></span><br><span class=\"line\">$ webpack --display-error-details //显示异常信息</span><br><span class=\"line\"></span><br><span class=\"line\">$ webpack --watch   //监听变动并自动打包</span><br><span class=\"line\"> </span><br><span class=\"line\">$ webpack -p    //压缩混淆脚本，这个非常非常重要！</span><br><span class=\"line\"> </span><br><span class=\"line\">$ webpack -d    //生成map映射文件，告知哪些模块被最终打包到哪里了</span><br></pre></td></tr></table></figure>\n<p>对公共库的封装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">entry: &#123;</span><br><span class=\"line\">  vendor: [&quot;jquery&quot;, &quot;other-lib&quot;],</span><br><span class=\"line\">  app: &quot;./entry&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">new CommonsChunkPlugin(&#123;</span><br><span class=\"line\">  name: &quot;vendor&quot;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // filename: &quot;vendor.js&quot;</span><br><span class=\"line\">  // (Give the chunk a different name)</span><br><span class=\"line\"></span><br><span class=\"line\">  minChunks: Infinity,</span><br><span class=\"line\">  // (with more entries, this ensures that no other module</span><br><span class=\"line\">  //  goes into the vendor chunk)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>关于express webpack middleware 的配置</p>\n<p><a href=\"http://www.cnblogs.com/linfangshuhellowored/p/5657285.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/linfangshuhellowored/p/5657285.html</a></p>\n<p>给文件自动添加hash后缀</p>\n<p>根据chunkhash的定义知道，chunkhash是根据具体模块文件的内容计算所得的hash值，所以某个文件的改动只会影响它本身的hash指纹，不会影响其他文件。配置webpack的output如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">output: &#123;</span><br><span class=\"line\">    filename: &apos;[name].[chunkhash:8].js&apos;,</span><br><span class=\"line\">    path: __dirname + &apos;/built&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">output: &#123;</span><br><span class=\"line\">    filename: &apos;[name].[hash:8].js&apos;,</span><br><span class=\"line\">    path: __dirname + &apos;/built&apos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"babel相关\"><a href=\"#babel相关\" class=\"headerlink\" title=\"babel相关\"></a>babel相关</h3><ol>\n<li><p>虽然@babel/polyfill提供了我们想要的所有新方法新类，但是这里依然存在一些问题：</p>\n<p>体积太大：比如我只用了String的新特性，但是我把整个包都引进来了，，这不是徒增了很多无用的代码。<br>污染全局环境：如果你引用了 @babel/polyfill，那么像Promise这样的新类就是挂载在全局上的，这样就会污染了全局命名空间。可能在一个团建建立的项目问题不太大，但是如果你是一个工具的开发者，你把全局环境污染了，别人用你的工具，就有可能把别人给坑了</p>\n</li>\n<li><p>@babel/plugin-transform-runtime会为代码创建一个沙盒环境，为core-js这里内建的实例提供假名，你可以无缝的使用这些新特性，而不需要使用require polyfill。</p>\n<p>一个解决方案就是引入transform runtime 来替代 @babel/polyfill。<br>幸运的是，我们有env这个preset，它又一个useBuiltIns选项，如果设置成”usage”，那么将会自动检测语法帮你require你代码中使用到的功能。  </p>\n</li>\n<li><p>@babel/core<br>其中最核心的包就是@babel/core，它主要的作用就是编译.</p>\n<p>Babel-cli<br>光有core是无法在命令行使用这些功能的，@babel/cli支持你直接在命令行中编译代码。<br>这句话会编译你src目录下的所有js代码，并编译成你想要的那样（babel.config.js配置的），并输出到lib目录下。 </p>\n</li>\n<li>@babel/preset-env<br>如果useBuiltIns为true，项目中必须引入babel-polyfill。</li>\n</ol>\n<p>1.UglifyJS: vue-cli 默认使用的压缩代码方式，它使用的是单线程压缩代码，打包时间较慢<br>  ParallelUglifyPlugin: 开启多个子进程，把对多个文件压缩的工作分别给多个子进程去完成</p>\n<ol>\n<li>Vue Loader 是一个 webpack 的 loader，它允许你以一种名为单文件组件 (SFCs)的格式撰写 Vue 组件.   </li>\n<li><p>autoprefixer 自动补充前缀</p>\n</li>\n<li><p>Hot Module Replacement（以下简称 HMR）是 webpack 发展至今引入的最令人兴奋的特性之一 ，当你对代码进行修改并保存后，webpack 将对代码重新打包，并将新的模块发送到浏览器端，浏览器通过新的模块替换老的模块，这样在不刷新浏览器的前提下就能够对应用进行更新。</p>\n</li>\n<li>webpack-dev-server 修改了webpack 配置中的 entry 属性，在里面添加了 webpack-dev-client 的代码，这样在最后的 bundle.js 文件中就会有接收 websocket 消息的代码了。</li>\n<li></li>\n<li><p>WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。</p>\n</li>\n<li><p>Webpack splitchunk 将各个模块的交集部分抽离出来 </p>\n</li>\n<li><p>Webpack ProvidePlugin 自动加载js，不必import。<br>new webpack.ProvidePlugin({<br>  _map: [‘lodash’, ‘map’]<br>})</p>\n</li>\n<li><p>Webpack在打包时可以为我们生成的source maps，这为我们提供了一种对应编译文件和源文件的方法，使得编译后的代码可读性更高，也更容易调试</p>\n</li>\n</ol>\n<p>具体配置参考：<a href=\"http://www.jianshu.com/p/42e11515c10f\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/42e11515c10f</a></p>\n<p>感叹号的作用在于使同一文件能够使用不同类型的loader</p>\n<p>对css 分模块：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">        test: /\\.css$/,</span><br><span class=\"line\">        loader: &apos;style!css?modules&apos;//跟前面相比就在后面加上了?modules</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Loaders和Plugins常常被弄混，但是他们其实是完全不同的东西，可以这么来说，loaders是在打包构建过程中用来处理源文件的（JSX，Scss，Less..），一次处理一个，插件并不直接操作单个文件，它直接对整个构建过程其作用。</p>\n<h4 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ webpack --config webpack.min.js //另一份配置文件</span><br><span class=\"line\"></span><br><span class=\"line\">$ webpack --display-error-details //显示异常信息</span><br><span class=\"line\"></span><br><span class=\"line\">$ webpack --watch   //监听变动并自动打包</span><br><span class=\"line\"> </span><br><span class=\"line\">$ webpack -p    //压缩混淆脚本，这个非常非常重要！</span><br><span class=\"line\"> </span><br><span class=\"line\">$ webpack -d    //生成map映射文件，告知哪些模块被最终打包到哪里了</span><br></pre></td></tr></table></figure>\n<p>对公共库的封装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">entry: &#123;</span><br><span class=\"line\">  vendor: [&quot;jquery&quot;, &quot;other-lib&quot;],</span><br><span class=\"line\">  app: &quot;./entry&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">new CommonsChunkPlugin(&#123;</span><br><span class=\"line\">  name: &quot;vendor&quot;,</span><br><span class=\"line\"></span><br><span class=\"line\">  // filename: &quot;vendor.js&quot;</span><br><span class=\"line\">  // (Give the chunk a different name)</span><br><span class=\"line\"></span><br><span class=\"line\">  minChunks: Infinity,</span><br><span class=\"line\">  // (with more entries, this ensures that no other module</span><br><span class=\"line\">  //  goes into the vendor chunk)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>关于express webpack middleware 的配置</p>\n<p><a href=\"http://www.cnblogs.com/linfangshuhellowored/p/5657285.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/linfangshuhellowored/p/5657285.html</a></p>\n<p>给文件自动添加hash后缀</p>\n<p>根据chunkhash的定义知道，chunkhash是根据具体模块文件的内容计算所得的hash值，所以某个文件的改动只会影响它本身的hash指纹，不会影响其他文件。配置webpack的output如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">output: &#123;</span><br><span class=\"line\">    filename: &apos;[name].[chunkhash:8].js&apos;,</span><br><span class=\"line\">    path: __dirname + &apos;/built&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">output: &#123;</span><br><span class=\"line\">    filename: &apos;[name].[hash:8].js&apos;,</span><br><span class=\"line\">    path: __dirname + &apos;/built&apos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ck5bwexcb0001998su8twhddl","tag_id":"ck5bwexcf0003998slshkwyj8","_id":"ck5bwexck0008998stpbuk6fg"},{"post_id":"ck5bwexce0002998s4use0sf2","tag_id":"ck5bwexck0007998sj8fuubp7","_id":"ck5bwexco000d998so8f075ko"},{"post_id":"ck5bwexch0004998sw7oa50y5","tag_id":"ck5bwexcm000b998ssthxmi61","_id":"ck5bwexcs000h998sqqp7nf49"},{"post_id":"ck5bwexci0005998sg7qxv23y","tag_id":"ck5bwexcr000f998s6q2mr0s1","_id":"ck5bwexcv000l998sma1e58j9"},{"post_id":"ck5bwexck0009998s2ca5h83a","tag_id":"ck5bwexcu000j998s8wqc6w5x","_id":"ck5bwexcy000p998sqvogvta7"},{"post_id":"ck5bwexcl000a998s6k9mm8ca","tag_id":"ck5bwexcx000o998s9jvguxuy","_id":"ck5bwexd2000u998sdf4c8ipe"},{"post_id":"ck5bwexcn000c998sfz5cw5rf","tag_id":"ck5bwexcu000j998s8wqc6w5x","_id":"ck5bwexd4000y998sx708lh1o"},{"post_id":"ck5bwexco000e998siarb0mr7","tag_id":"ck5bwexd3000w998sax98eanc","_id":"ck5bwexd60012998s43427731"},{"post_id":"ck5bwexcr000g998suijeun2o","tag_id":"ck5bwexd50010998sdo0rsx90","_id":"ck5bwexd80016998skxvrncri"},{"post_id":"ck5bwexcu000k998snaniholu","tag_id":"ck5bwexd70014998srxt2u95m","_id":"ck5bwexdd001a998s0k8j3kf2"},{"post_id":"ck5bwexcv000m998sbecgs4yw","tag_id":"ck5bwexdc0019998s13j0i2tr","_id":"ck5bwexdd001c998syqu21g0n"},{"post_id":"ck5bwexcw000n998sb83wp3kg","tag_id":"ck5bwexdd001b998sxeawjjnr","_id":"ck5bwexde001e998sjnd176q1"},{"post_id":"ck5bwexcy000q998saek7d62m","tag_id":"ck5bwexdd001d998ssbguipvq","_id":"ck5bwexde001g998s20j7gfoa"},{"post_id":"ck5bwexcz000r998ss9681io5","tag_id":"ck5bwexde001f998s886a7yph","_id":"ck5bwexde001i998s9u9m76j5"},{"post_id":"ck5bwexd1000t998sn93bqyrw","tag_id":"ck5bwexde001h998str31gn53","_id":"ck5bwexdf001k998sooys0d90"},{"post_id":"ck5bwexd3000v998si23ur1qt","tag_id":"ck5bwexde001j998s3uslziz1","_id":"ck5bwexdf001m998sssg3owdq"},{"post_id":"ck5bwexd4000x998sigw5ejsj","tag_id":"ck5bwexdf001l998smqjlof6c","_id":"ck5bwexdf001o998s19xthu3n"},{"post_id":"ck5bwexd4000z998sjkonsi5k","tag_id":"ck5bwexdf001n998spp6gnpuv","_id":"ck5bwexdg001q998s46zdjm79"},{"post_id":"ck5bwexd60011998smoqci7o0","tag_id":"ck5bwexdg001p998spbmpg8sr","_id":"ck5bwexdg001s998srs1hnxbf"},{"post_id":"ck5bwexd60013998sr1wambin","tag_id":"ck5bwexdg001r998s1qs7n1oy","_id":"ck5bwexdh001u998sh24b5ozb"},{"post_id":"ck5bwexd70015998s4trt742i","tag_id":"ck5bwexdh001t998svsikcjrr","_id":"ck5bwexdh001w998sbe86jemy"},{"post_id":"ck5bwexd80017998sf3a70upp","tag_id":"ck5bwexdh001v998sw3fcy1gw","_id":"ck5bwexdi001y998sbvnaxqq5"},{"post_id":"ck5bwexd90018998slpekobfb","tag_id":"ck5bwexdh001x998souecqshf","_id":"ck5bwexdi001z998sr5a5l2q4"},{"post_id":"ck5bwexdq0020998s3usguf5i","tag_id":"ck5bwexds0023998sviao3p1g","_id":"ck5bwexdt0024998smnjy4nmn"}],"Tag":[{"name":"https","_id":"ck5bwexcf0003998slshkwyj8"},{"name":"零碎","_id":"ck5bwexck0007998sj8fuubp7"},{"name":"css","_id":"ck5bwexcm000b998ssthxmi61"},{"name":"docker","_id":"ck5bwexcr000f998s6q2mr0s1"},{"name":"es","_id":"ck5bwexcu000j998s8wqc6w5x"},{"name":"eslint","_id":"ck5bwexcx000o998s9jvguxuy"},{"name":"git","_id":"ck5bwexd3000w998sax98eanc"},{"name":"hexo","_id":"ck5bwexd50010998sdo0rsx90"},{"name":"http","_id":"ck5bwexd70014998srxt2u95m"},{"name":"interview","_id":"ck5bwexdc0019998s13j0i2tr"},{"name":"ops","_id":"ck5bwexdd001b998sxeawjjnr"},{"name":"loadtest","_id":"ck5bwexdd001d998ssbguipvq"},{"name":"useful package","_id":"ck5bwexde001f998s886a7yph"},{"name":"pattern","_id":"ck5bwexde001h998str31gn53"},{"name":"pm2","_id":"ck5bwexde001j998s3uslziz1"},{"name":"postgre","_id":"ck5bwexdf001l998smqjlof6c"},{"name":"regex","_id":"ck5bwexdf001n998spp6gnpuv"},{"name":"web 安全","_id":"ck5bwexdg001p998spbmpg8sr"},{"name":"安全","_id":"ck5bwexdg001r998s1qs7n1oy"},{"name":"encode decode","_id":"ck5bwexdh001t998svsikcjrr"},{"name":"vue eventloop js","_id":"ck5bwexdh001v998sw3fcy1gw"},{"name":"ts","_id":"ck5bwexdh001x998souecqshf"},{"name":"webpack","_id":"ck5bwexds0023998sviao3p1g"}]}}