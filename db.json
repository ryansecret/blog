{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1},{"_id":"source/asset/eventloop.jpg","path":"asset/eventloop.jpg","modified":0,"renderable":0},{"_id":"node_modules/hexo-theme-next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/css/noscript.styl","path":"css/noscript.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/logo-algolia-nebula-blue-full.svg","path":"images/logo-algolia-nebula-blue-full.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/comments-buttons.js","path":"js/comments-buttons.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/comments.js","path":"js/comments.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/config.js","path":"js/config.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/pjax.js","path":"js/pjax.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/schedule.js","path":"js/schedule.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/fancybox.js","path":"js/third-party/fancybox.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/pace.js","path":"js/third-party/pace.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/quicklink.js","path":"js/third-party/quicklink.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/rating.js","path":"js/third-party/rating.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/baidu-analytics.js","path":"js/third-party/analytics/baidu-analytics.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/google-analytics.js","path":"js/third-party/analytics/google-analytics.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/growingio.js","path":"js/third-party/analytics/growingio.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/matomo.js","path":"js/third-party/analytics/matomo.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/chatra.js","path":"js/third-party/chat/chatra.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/gitter.js","path":"js/third-party/chat/gitter.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/tidio.js","path":"js/third-party/chat/tidio.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/changyan.js","path":"js/third-party/comments/changyan.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/disqus.js","path":"js/third-party/comments/disqus.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/disqusjs.js","path":"js/third-party/comments/disqusjs.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/gitalk.js","path":"js/third-party/comments/gitalk.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/isso.js","path":"js/third-party/comments/isso.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/livere.js","path":"js/third-party/comments/livere.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/utterances.js","path":"js/third-party/comments/utterances.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/math/katex.js","path":"js/third-party/math/katex.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/math/mathjax.js","path":"js/third-party/math/mathjax.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/search/algolia-search.js","path":"js/third-party/search/algolia-search.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/search/local-search.js","path":"js/third-party/search/local-search.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/statistics/firestore.js","path":"js/third-party/statistics/firestore.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/statistics/lean-analytics.js","path":"js/third-party/statistics/lean-analytics.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/tags/mermaid.js","path":"js/third-party/tags/mermaid.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-next/source/js/third-party/tags/pdf.js","path":"js/third-party/tags/pdf.js","modified":0,"renderable":1}],"Cache":[{"_id":"themes/landscape/.gitignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1593411744364},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1593411744364},{"_id":"themes/landscape/package.json","hash":"85358dc34311c6662e841584e206a4679183943f","modified":1593411744369},{"_id":"themes/landscape/_config.yml","hash":"fb8c98a0f6ff9f962637f329c22699721854cd73","modified":1593411744365},{"_id":"themes/landscape/README.md","hash":"c7e83cfe8f2c724fc9cac32bd71bb5faf9ceeddb","modified":1593411744364},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1593411744364},{"_id":"source/_posts/cookies.md","hash":"7e6980e6be6b86ee0e8f88d4a9e969740756f4dd","modified":1619781160388},{"_id":"source/_posts/Let's Encrypt SSL.md","hash":"5e638f906e622817ab93fe64d640477c06213e6d","modified":1593411744359},{"_id":"source/_posts/css.md","hash":"dbfb94c396ba51ea76ce1e917eeccf3678afc604","modified":1598408435523},{"_id":"source/_posts/docker.md","hash":"b073b3d18f350b12fafb88c094aa65f13d05d40e","modified":1593411744360},{"_id":"source/_posts/encoding.md","hash":"5e0c545a8f40974922640cd0a3900df059f797e9","modified":1593411744360},{"_id":"source/_posts/cloud.md","hash":"bffd5864e77721317cb64a6e92e12591ab652393","modified":1604979286003},{"_id":"source/_posts/es6.md","hash":"22a8a6fada6f91119f3f9528cabcc61cfa480a1a","modified":1597739838147},{"_id":"source/_posts/es8.md","hash":"3bf925cc89354e04c865a4568ec27fa40c46b9ef","modified":1593411744360},{"_id":"source/_posts/eslint.md","hash":"f63c0eef0f9062e5850f00bc3435aa02f0261bb8","modified":1593760365925},{"_id":"source/_posts/graphql.md","hash":"89cf554cba1910b0bf8ff13d3bd63816904409b8","modified":1593411744361},{"_id":"source/_posts/hexo.md","hash":"1010707ca170d6de3a91c19aed39e79558a0bc9a","modified":1593411744361},{"_id":"source/_posts/fresh.md","hash":"85c13de45df37ebca714079637d615946f59ed99","modified":1600865676982},{"_id":"source/_posts/gitInfo.md","hash":"2211ed79e405d66f08cd7208a1b746b888d8b142","modified":1640178532753},{"_id":"source/_posts/interview.md","hash":"9019e1d46a6e4a351bd9a98fb882e5f850312430","modified":1597717233076},{"_id":"source/_posts/http.md","hash":"28d5bc9990d48a4e8042208f1f1d5d42c753ebda","modified":1619781288275},{"_id":"source/_posts/k8s.md","hash":"f14f5dd69178413db1678ef34d98177f865d4bcb","modified":1641284724585},{"_id":"source/_posts/html.md","hash":"f38249e9ae065de0690e86487cdce0173d52bd76","modified":1597746528648},{"_id":"source/_posts/investment.md","hash":"3bad26a6b24cc50a3b70120f7d6b98bc06f09dd3","modified":1610071452452},{"_id":"source/_posts/js.md","hash":"3ff6944cf3bbd8efefbeb90a72bfaa162ebfcd87","modified":1598234621383},{"_id":"source/_posts/loadtest.md","hash":"430b59a7b6776d600d67a6f6a0051bb0b758338f","modified":1593411744361},{"_id":"source/_posts/linux.md","hash":"f4feba47126a7d1f86a8e14ead36c2b5e9c96dac","modified":1640178532754},{"_id":"source/_posts/node.md","hash":"5e2f02b0f28a1a39be5a148a65b8b93a16c5772b","modified":1597312133556},{"_id":"source/_posts/overview.md","hash":"a9d09cd0e66d08c70db7c423e118b88fb512a657","modified":1663036710312},{"_id":"source/_posts/package.md","hash":"c96ad80f3ce22f1342cb7b2ba91aa730e6de4c3e","modified":1648607197703},{"_id":"source/_posts/manage.md","hash":"f99befa2f1a1517c32cfdeeddd255652789ad2cc","modified":1619780272461},{"_id":"source/_posts/pattern.md","hash":"85ff08997e08d562362138ed63a097f5b4cf3de6","modified":1593411744362},{"_id":"source/_posts/pm2.md","hash":"c8fc02c5bff7e9dc766e78c52456ccb4f62b7426","modified":1593411744362},{"_id":"source/_posts/postgre.md","hash":"58288a0cd5d4992365d259d095a3b2a469667ff5","modified":1593411744362},{"_id":"source/_posts/security-1.md","hash":"1793db36167b31517ed2036a01f47c1cc236b1db","modified":1593411744362},{"_id":"source/_posts/stringencode.md","hash":"e7cc592266e91977e449f8c2bbad243d14ac1053","modified":1593411744363},{"_id":"source/_posts/regex.md","hash":"d010078bf537fa54171ec402dc2ba74cc0573f6b","modified":1640241460458},{"_id":"source/_posts/security.md","hash":"1e5e9232a3c8c5114dcc498a47d3347b1a4c3456","modified":1597888763888},{"_id":"source/_posts/typescript.md","hash":"7de3284a07085eb11fd734aaca0b65780f8f566f","modified":1593411744363},{"_id":"source/categories/index.md","hash":"d51db580efc1edca02813a5939b51abb9333c3c2","modified":1593411744364},{"_id":"source/tags/index.md","hash":"ba27695f1572dff9ace58e82b5a66c43840fe56c","modified":1593411744364},{"_id":"source/about/index.md","hash":"0330b10bfb69136ccca8e2b04cf01353c89d26cb","modified":1593411744363},{"_id":"source/_posts/vue.md","hash":"d1218f0fd180eb9b7e4200de014faf544ca5aa22","modified":1640178532757},{"_id":"source/_posts/stock.md","hash":"2d7b017337a85f5e3a948409ee900b2fec4eaf6c","modified":1625796413112},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1593411744370},{"_id":"source/_posts/webpack.md","hash":"f5b44b217688d97bd587174ef624540ca1e18709","modified":1597716854754},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1593411744369},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1593411744369},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1593411744369},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1593411744369},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1593411744369},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1593411744369},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1593411744365},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1593411744369},{"_id":"themes/landscape/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1593411744365},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1593411744365},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1593411744365},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1593411744365},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1593411744365},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1593411744366},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1593411744370},{"_id":"themes/landscape/source/css/_variables.styl","hash":"5e37a6571caf87149af83ac1cc0cdef99f117350","modified":1593411744372},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1593411744379},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1593411744379},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1593411744379},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1593411744379},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1593411744379},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1593411744379},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1593411744381},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1593411744382},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1593411744381},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1593411744380},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1593411744381},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"dc5d69f1bef3499d7d56c03727e178f3d56b40f7","modified":1593411744366},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1593411744366},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"931aaaffa0910a48199388ede576184ff15793ee","modified":1593411744366},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1593411744366},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1593411744366},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1593411744366},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"83a1ab12eb2a871bddf0620f611a97f13ebd731d","modified":1593411744367},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"c21ca56f419d01a9f49c27b6be9f4a98402b2aa3","modified":1593411744367},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1593411744367},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1593411744368},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1593411744368},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1593411744368},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1593411744368},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1593411744368},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1593411744368},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1593411744370},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1593411744370},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1593411744370},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1593411744370},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1593411744371},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1593411744371},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1593411744371},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1593411744371},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1593411744371},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1593411744371},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1593411744371},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1593411744372},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1593411744373},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1593411744377},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1593411744380},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1593411744380},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1593411744380},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1593411744380},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1593411744381},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1593411744380},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1593411744367},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1593411744367},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1593411744367},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1593411744367},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1593411744367},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1593411744368},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1593411744373},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1593411744377},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1593411744375},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1593411744378},{"_id":"source/asset/eventloop.jpg","hash":"397acedd56e075f1c7332b887ce2ee6a1897db68","modified":1593677432000},{"_id":"public/categories/index.html","hash":"1bdbb89c4b00499bed6960b2efd7326fe1f9f934","modified":1663036765433},{"_id":"public/tags/index.html","hash":"5f9d88b7c7540b1aed6a0deba20e897e54086366","modified":1663036765433},{"_id":"public/2021/12/13/overview/index.html","hash":"7516e32a56a4369642ce55e902d31dac40546651","modified":1663036765433},{"_id":"public/about/index.html","hash":"03bc25ffcbaa3157d69f45a97ec7c5346dab3e4c","modified":1663036765433},{"_id":"public/2021/11/18/k8s/index.html","hash":"c6df9cfc21581c2a601ae666b63fdbcf89edca7b","modified":1663036765433},{"_id":"public/2021/07/09/stock/index.html","hash":"c47b8fcd8947f82410dd2e63349cfcd3b19e243f","modified":1663036765433},{"_id":"public/2021/01/08/investment/index.html","hash":"3818475d7266b2d2f596f5e192a89a70a8ba3edd","modified":1663036765433},{"_id":"public/2021/04/30/manage/index.html","hash":"42d90862a4dd420988d10463ba267e898c5a1dfb","modified":1663036765433},{"_id":"public/2020/11/10/cloud/index.html","hash":"283542e0ba30218c3006cd667cd9d5552a4b9553","modified":1663036765433},{"_id":"public/2020/08/13/node/index.html","hash":"9cfd2580e697ee30b96efbf7a89519ddd65a5ccd","modified":1663036765433},{"_id":"public/2020/08/13/html/index.html","hash":"59ddce0be7d14818cea16ca8da70a938f868389b","modified":1663036765433},{"_id":"public/2020/08/13/js/index.html","hash":"1254f1c332e8302a3af37717f450caee4b68394b","modified":1663036765433},{"_id":"public/2020/06/04/fresh/index.html","hash":"c8661814a7b221c8e291b8941e1cfa62b172d153","modified":1663036765433},{"_id":"public/2019/12/10/stringencode/index.html","hash":"2d11b38306b768068fd8c7016ae7e7b8632e2f7a","modified":1663036765433},{"_id":"public/2019/12/09/security-1/index.html","hash":"a30c30339727520cdbdb8d8f7a1437b4391da0ed","modified":1663036765433},{"_id":"public/2019/11/08/encoding/index.html","hash":"b84cdedcee484e0824dfa13cc64064b49182528e","modified":1663036765433},{"_id":"public/2019/08/23/graphql/index.html","hash":"0612492a725412be7570f3b105e46dbc263e7651","modified":1663036765433},{"_id":"public/2019/07/02/linux/index.html","hash":"6d28fe2ce00760eaf06fa0abfcd00809966d4b70","modified":1663036765433},{"_id":"public/2019/07/02/es8/index.html","hash":"8bf5a4a5c14488fd551be1238b2a59753e8606d4","modified":1663036765433},{"_id":"public/2019/06/28/es6/index.html","hash":"7de4aa495d06a59e970578e56710e9e561b17ea6","modified":1663036765433},{"_id":"public/2019/06/24/cookies/index.html","hash":"e011bc1d7e1e4ac3bda7c4219b34d41386a612aa","modified":1663036765433},{"_id":"public/2019/06/24/regex/index.html","hash":"500e3046fe6f0d8367175545900f561135d39ad1","modified":1663036765433},{"_id":"public/2019/05/14/http/index.html","hash":"3271485f9936e0294260b6a47f6a922dcf18f731","modified":1663036765433},{"_id":"public/2019/05/07/css/index.html","hash":"ad6861e4d24ca31be4ca792f67bf9f4e61880b6a","modified":1663036765433},{"_id":"public/2019/04/25/security/index.html","hash":"33784238a8d7203d0090c3cf935caac4e8d93fcc","modified":1663036765433},{"_id":"public/2019/02/25/typescript/index.html","hash":"0c34bac96fddee5a6517ed50f6ef6f4b7a29fe49","modified":1663036765433},{"_id":"public/2019/02/14/package/index.html","hash":"9ba917b3e3ac15f05f972c952ca9906e500d8d04","modified":1663036765433},{"_id":"public/2019/02/20/gitInfo/index.html","hash":"2f7bdef94c851d772d04310645d079bc174ee85d","modified":1663036765433},{"_id":"public/2017/02/21/postgre/index.html","hash":"015772a20cce13492ae63b3e6280a83ff17bc66e","modified":1663036765433},{"_id":"public/2017/01/23/interview/index.html","hash":"3897d22705f906431887ccda61e1f640eecc92c2","modified":1663036765433},{"_id":"public/2017/01/19/vue/index.html","hash":"4ecbbcdb724ea349b10d71ff30c846cc1e7b2f00","modified":1663036765433},{"_id":"public/2017/01/17/webpack/index.html","hash":"160319d273b84c12024690c9d0f2fc188f24d3b1","modified":1663036765433},{"_id":"public/2017/01/17/loadtest/index.html","hash":"01d7f7d8952606b4aca42409a3966252d89b2ae9","modified":1663036765433},{"_id":"public/2016/12/29/pm2/index.html","hash":"aea6d2fe241aed87356dab49dea94e010b53020d","modified":1663036765433},{"_id":"public/2016/12/26/pattern/index.html","hash":"46341088b615930049bd4d589942eee6de2a80b6","modified":1663036765433},{"_id":"public/2016/12/25/eslint/index.html","hash":"39b87a79dd4ebe71c951bea0d3eebf400f505bc6","modified":1663036765433},{"_id":"public/2016/12/21/Let's Encrypt SSL/index.html","hash":"f7e41af7f0d517ac16f7605ee173c11f718a4aed","modified":1663036765433},{"_id":"public/2016/12/21/hexo/index.html","hash":"146ce4424b9882face8edcac7f767044a8e54002","modified":1663036765433},{"_id":"public/2016/12/14/docker/index.html","hash":"7ac5a4b645424cae57a3146c045f0365e411666b","modified":1663036765433},{"_id":"public/tags/零碎/index.html","hash":"b0377e54adc9f845844b943bbd821e36c4e74fb6","modified":1663036765433},{"_id":"public/tags/css/index.html","hash":"724c2efe7d909050bea497b41486f998e766c36a","modified":1663036765433},{"_id":"public/tags/https/index.html","hash":"d889c0a73ee7631ff1b9323cf9aa6221c2827fba","modified":1663036765433},{"_id":"public/tags/docker/index.html","hash":"a80836797f6492a2fccd34fe81ff714564785ae3","modified":1663036765433},{"_id":"public/tags/es/index.html","hash":"0bf7a0e08b2eba0c7cfba3ec092336d425937b1c","modified":1663036765433},{"_id":"public/tags/eslint/index.html","hash":"6ceeb510378dd6e551c75de15122e64a00822b01","modified":1663036765433},{"_id":"public/tags/hexo/index.html","hash":"57918bf36aa135938f2dbb571d18aee4247ba96d","modified":1663036765433},{"_id":"public/tags/git/index.html","hash":"b5a64e81393b4ec3be03aa8064fdfda419a27695","modified":1663036765433},{"_id":"public/tags/interview/index.html","hash":"c9eb51c19ac4d1e217228ac4e5727474597cda97","modified":1663036765433},{"_id":"public/tags/http/index.html","hash":"25598c5f2b0fcf7240af3f10391369672e03c567","modified":1663036765433},{"_id":"public/tags/k8s/index.html","hash":"cb6efed8e7ee89e27d7280d5ad50bac81d42b867","modified":1663036765433},{"_id":"public/tags/html/index.html","hash":"efd1aa4b088c0b0412fef5606adb2f71bdb52aa1","modified":1663036765433},{"_id":"public/tags/stock/index.html","hash":"aba6c22440846ade3c38d9a77d0f9ea0233dc340","modified":1663036765433},{"_id":"public/tags/loadtest/index.html","hash":"290e4b76258e6ae7211c9217e03ab9729091e229","modified":1663036765433},{"_id":"public/tags/ops/index.html","hash":"0e80e8a35a44546997e9a2ba5b596ad0e9c8d13c","modified":1663036765433},{"_id":"public/tags/node、egg/index.html","hash":"deea661d67ce95057ece908d42915c1244866322","modified":1663036765433},{"_id":"public/tags/overview/index.html","hash":"cb5d3b4d733e210faf5af43085e1d50df942f928","modified":1663036765433},{"_id":"public/tags/useful-package/index.html","hash":"bbdb13f8efbe15be91119be26fd659f2b1cbdf95","modified":1663036765433},{"_id":"public/tags/pattern/index.html","hash":"ed4a951988ea80a7cacb91161408da768f6fa23f","modified":1663036765433},{"_id":"public/tags/pm2/index.html","hash":"39445f407c72f25b6b3605d00a946843c6af0c39","modified":1663036765433},{"_id":"public/tags/postgre/index.html","hash":"4ec3ad91d2702dfc149537cab026af3f2b8b2bab","modified":1663036765433},{"_id":"public/tags/web-安全/index.html","hash":"c5b7ee7906aaba88314a1b1118c782fd140cf1f7","modified":1663036765433},{"_id":"public/tags/regex/index.html","hash":"14cc99616d1f8ffffdf57c8740c6de925840d91a","modified":1663036765433},{"_id":"public/tags/encode-decode/index.html","hash":"b6cf1d9664289f22d3c5982b4dd1fb38a39f8186","modified":1663036765433},{"_id":"public/tags/安全/index.html","hash":"5fc23b13cead35a74b64f3f9bb7675655c6599b6","modified":1663036765433},{"_id":"public/tags/ts/index.html","hash":"0f2adf7e7fba4440860c9fde19084d529d248adf","modified":1663036765433},{"_id":"public/tags/vue-eventloop-js/index.html","hash":"9ab237b34e86b8ccb7e9f11f1bf9ebf28cc355ce","modified":1663036765433},{"_id":"public/tags/webpack/index.html","hash":"ecb291cdd05870919b6385bf590da48970d11dce","modified":1663036765433},{"_id":"public/index.html","hash":"5b97ac48d7b7069376622cf977894b7d3499fa66","modified":1663036765433},{"_id":"public/page/2/index.html","hash":"f153a0e5f95f2f0ee190c468df70e93dc1a38b83","modified":1663036765433},{"_id":"public/page/3/index.html","hash":"8bcaeb862dafba5b3e754bdea64cc4f926bdcf50","modified":1663036765433},{"_id":"public/page/4/index.html","hash":"cf87559cc312f7d6915d860a42712b25e9812ab2","modified":1663036765433},{"_id":"public/archives/index.html","hash":"bd6563ac68b594162586f739a91e9c45ba3f1180","modified":1663036765433},{"_id":"public/archives/page/2/index.html","hash":"dd27b4f1ba85ce33dd03fc5c653ab194f4b13db5","modified":1663036765433},{"_id":"public/archives/page/3/index.html","hash":"b0f6e4476866281f0749007190ac8f6d8b06cda6","modified":1663036765433},{"_id":"public/archives/page/4/index.html","hash":"183cf7796f3ecf66ed8b7d4a208f100ecde62843","modified":1663036765433},{"_id":"public/archives/2016/index.html","hash":"7011a7968f20d79aeec663e7d695dc2364afe075","modified":1663036765433},{"_id":"public/archives/2016/12/index.html","hash":"91b5975bf7cd4bc4223b2c5ad2c7441325ceaba8","modified":1663036765433},{"_id":"public/archives/2017/index.html","hash":"7b270650662e22fbaa2a60ddd1fee6941a67c4ac","modified":1663036765433},{"_id":"public/archives/2017/01/index.html","hash":"faf364895c85cc276cbb0970b5bab20a03cc40a6","modified":1663036765433},{"_id":"public/archives/2017/02/index.html","hash":"fdee881347e2ef26a537e802a78c0d27e6513ca2","modified":1663036765433},{"_id":"public/archives/2019/index.html","hash":"fb76c88f04a1cefd557b09c33e7b99c7f6927020","modified":1663036765433},{"_id":"public/archives/2019/page/2/index.html","hash":"34208ef4570a9bf870b33e9cfa109766bfa73b71","modified":1663036765433},{"_id":"public/archives/2019/02/index.html","hash":"47f363df500875016ac087749cd7f0f1c0b7025f","modified":1663036765433},{"_id":"public/archives/2019/04/index.html","hash":"e33447fa836fdbc7aeec24cb8874f88266e45c0f","modified":1663036765433},{"_id":"public/archives/2019/05/index.html","hash":"2c1242ce3067350b97034df89de872f68e5cf69f","modified":1663036765433},{"_id":"public/archives/2019/06/index.html","hash":"c78896aadb92941858db68a66ed4af646b945c3b","modified":1663036765433},{"_id":"public/archives/2019/07/index.html","hash":"10eef080d83f81e6a17982603bbf0600b6bfeaa4","modified":1663036765433},{"_id":"public/archives/2019/08/index.html","hash":"008d33a53d1b9fa6a20b417b3a22a570d76a386e","modified":1663036765433},{"_id":"public/archives/2019/11/index.html","hash":"cb8811c9aceae5050b46ef0c8bfa2b8ea509cf8d","modified":1663036765433},{"_id":"public/archives/2019/12/index.html","hash":"9e09d58e5746e905c0308f1a8767d8f6940036e8","modified":1663036765433},{"_id":"public/archives/2020/index.html","hash":"284e0855b556653d853feb91697ecc3aaf7ab3da","modified":1663036765433},{"_id":"public/archives/2020/08/index.html","hash":"68ec9fe9971ead42618d3bb710d295c3a5c45bf8","modified":1663036765433},{"_id":"public/archives/2020/06/index.html","hash":"90557aeb0eadf33a2ae152fc9c8ba2bf557ec295","modified":1663036765433},{"_id":"public/archives/2020/11/index.html","hash":"863eca017618c11bdd232c79ff4236d6ecd19e24","modified":1663036765433},{"_id":"public/archives/2021/index.html","hash":"4d087631e70d060e0395fc46a02ef50f4fd2de75","modified":1663036765433},{"_id":"public/archives/2021/01/index.html","hash":"0f51927972ecd42bf1a4eba03aac43909e425385","modified":1663036765433},{"_id":"public/archives/2021/04/index.html","hash":"ab7f43d2b628e9838df0b544a1ac5367f67a5dcf","modified":1663036765433},{"_id":"public/archives/2021/07/index.html","hash":"44b13f5ddaacb3c1a96d2ad0e0b735ae2c57a6e6","modified":1663036765433},{"_id":"public/archives/2021/11/index.html","hash":"906ca7d0b23de0fcfbb47a584f360397d6d53ebd","modified":1663036765433},{"_id":"public/archives/2021/12/index.html","hash":"37ea16224c1ee05619ff770fc68bdc8aa95470dd","modified":1663036765433},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1646986819263},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1646986819263},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1646986819263},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1646986819263},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1646986819263},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1646986819263},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1646986819263},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1646986819263},{"_id":"public/css/style.css","hash":"fffb3966bf36057a325498aba9ce3a2ea7bd79e1","modified":1646986819263},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1646986819263},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1646986819263},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1646986819263},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1646986819263},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1646986819263},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1646986819263},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1646986819263},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1646986819263},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1646986819263},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1646986819263},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1646986819263},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1646986819263},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1646986819263},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1646986819263},{"_id":"public/asset/eventloop.jpg","hash":"397acedd56e075f1c7332b887ce2ee6a1897db68","modified":1646986819263},{"_id":"source/_posts/vite.md","hash":"1e3484e90173e375d715285cbe3ee6ad4dd1a7ce","modified":1654501971570},{"_id":"public/2022/06/06/vite/index.html","hash":"f0eb88e5f8bbc24a4b8dc7ceba7e990639cff574","modified":1663036765433},{"_id":"public/archives/2022/index.html","hash":"721f71668bf6129bd95aed888d9eacf139dcce36","modified":1663036765433},{"_id":"public/archives/2022/06/index.html","hash":"b8fd1456e16d76474d642005dd4d4ad71d63db25","modified":1663036765433},{"_id":"source/_posts/yanbao.md","hash":"393ee4bf7680d1ab745e20681a59fc0de8dd1387","modified":1657072388982},{"_id":"public/2022/07/06/yanbao/index.html","hash":"c954cfd4feecf5e82cbd08a1d51b1c179d7146b9","modified":1663036765433},{"_id":"public/archives/2022/07/index.html","hash":"684cb2d9863e5b162c54c05ef33b476f40a9b408","modified":1663036765433},{"_id":"node_modules/hexo-theme-next/_vendors.yml","hash":"618ea653d36f4444a0768513788a3f11beaddd16","modified":499162500000},{"_id":"node_modules/hexo-theme-next/package.json","hash":"a070d8a57c542af4ece821790d483bf7ee238d84","modified":1666407535995},{"_id":"node_modules/hexo-theme-next/LICENSE.md","hash":"68fc9a03d50fd4b5ea97092b05967d1819dea2c4","modified":499162500000},{"_id":"node_modules/hexo-theme-next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":499162500000},{"_id":"node_modules/hexo-theme-next/README.md","hash":"56638e4978154a2f2a3f03ba84047b77b4a499cc","modified":499162500000},{"_id":"node_modules/hexo-theme-next/docs/AUTHORS.md","hash":"a648823121563c34a177ae91f5a774b5e29f01a0","modified":499162500000},{"_id":"node_modules/hexo-theme-next/_config.yml","hash":"66d8d7c5d4fe4458b0f1ce7e22b039198aa7eb1b","modified":499162500000},{"_id":"node_modules/hexo-theme-next/docs/LICENSE.txt","hash":"f5b14f791b7cfa1d16da981d929152e088a5d1b8","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/README.md","hash":"b2567e32805dda79601157351a07e5ca9fe01315","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/ar.yml","hash":"bca66db21c015dbd32970d8708b898518a773e1e","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/bn.yml","hash":"fccbf2855392186e11daa8590121073594037b7b","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/de.yml","hash":"4be7b8b76c81bf1853eb36d2e874b17546a0e792","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/en.yml","hash":"814d81c27fed736055ee300e0a6505b26ff4313c","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/es.yml","hash":"b813da5aed9d73b809133db4dfb08f90ec56afd9","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/fa.yml","hash":"6456d40dd42f44101d9d6e7054e9884e9163f948","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/fr.yml","hash":"b15dc05afdc94de02e5d3fee4f8d3dc5594dd37e","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/it.yml","hash":"c1eeab4992c76bfd436bb205ce58b1cfeef55ee6","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/id.yml","hash":"14e794db4eca36b257994d81eb513e61d1edcbd6","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/ja.yml","hash":"d48c4157e0e02e847aac7b513580d3364c81948c","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/ko.yml","hash":"819c19eb9d142e5411f77cf3821d90f740ee114a","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/pt-BR.yml","hash":"a1f27b3a592fc58f17d247f5563ff4a90a3da5f2","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/nl.yml","hash":"ecb8e39c6225f3c068a5fdd569ee7dafd5c41a1f","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/pt.yml","hash":"63a3e1e728ba5e6e22150de7331bb8a654f34960","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/ru.yml","hash":"8c2b6361f2de17561c1a3eede2bf47b4e2ba6ce5","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/si.yml","hash":"615d18d044f44df476d6bfbf73f7b0edc2632168","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/tk.yml","hash":"519239e35c3bda7b62b00ff5d34644f45b16fe6a","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/tr.yml","hash":"0bebba73d6f06c7dad61f80c0d7ad5f6f1791a01","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/uk.yml","hash":"7dd24580c0865c5a7bc4d391855045366a598936","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/vi.yml","hash":"c669c34da544a563ceae3e196addc9df6a78e024","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/zh-CN.yml","hash":"5a3ab21210304efef736e96bad254f789f42c567","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/zh-HK.yml","hash":"f195bb0502ffe66e850077a1af1033455ea65f93","modified":499162500000},{"_id":"node_modules/hexo-theme-next/languages/zh-TW.yml","hash":"92256b90028de9a1e79c6bc0e5885b93e7fb4b17","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_layout.njk","hash":"20e4160cd0deb4fa272cc3aed0f43520b3cf4a9c","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/archive.njk","hash":"d759f4d2cf5ddc6875ea250113a00662c1caf6d1","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/category.njk","hash":"c68b7343d0f8145010f93351908cc36ef6212ec1","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/index.njk","hash":"dd63e488ae8cc144335a5958acedf6a16edd7a92","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/post.njk","hash":"6abeb85fb3e4c382ed4bb6049b12a807e6226e67","modified":499162500000},{"_id":"node_modules/hexo-theme-next/docs/ru/README.md","hash":"6c82bfd2ec8248c248da701f091b548a7a133580","modified":499162500000},{"_id":"node_modules/hexo-theme-next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"7a06d443f374bd1e84294067a0ac796afd9fbe60","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/page.njk","hash":"6c40aa438c658eb7f0cd0f6a759f18b43e7e8f93","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/tag.njk","hash":"9e16ba20c28a7f2c6bc75aa427f48122301a30aa","modified":499162500000},{"_id":"node_modules/hexo-theme-next/docs/zh-CN/CONTRIBUTING.md","hash":"a089f7a8368ab0b7d7b9b7ec0ac3767a453435df","modified":499162500000},{"_id":"node_modules/hexo-theme-next/docs/zh-CN/README.md","hash":"ccf27b9249524b9fec1c15497b4353c8d1748c6c","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_macro/post-collapse.njk","hash":"1a30d751871dabfa80940042ddb1f77d07d830b9","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_macro/sidebar.njk","hash":"eb786e8b35e354287cda345c524cd35ec955f692","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/comments.njk","hash":"d0c470b0f6690aa217e9ada848c5e2e73fb27c6f","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_macro/post.njk","hash":"434b3e76a040a816169e1929657e4176e7b8164c","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/languages.njk","hash":"e43f22198cccb5f6e306b1ce0d28d12a4fb891f8","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/pagination.njk","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_scripts/index.njk","hash":"6668878a0f9a1166c6a879755f54a08d942da870","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/index.njk","hash":"d41eeb262978e34de4679d8971a9e7ac5d90ecbc","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/fancybox.njk","hash":"844559f46e2ff1c8be234d5763703106e2072a7b","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/pace.njk","hash":"d7ad5714079f7f65446f880baf14722435ca9061","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/widgets.njk","hash":"852a750524decf1efa587cd52b09e387ed8315de","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/quicklink.njk","hash":"0efed71ed530447718c4ea5bbd5fc8695b0b0d5f","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/events/index.js","hash":"3ce10d4cce94e3d4c482c2e18bb6f0f0ca380d3d","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_scripts/vendors.njk","hash":"be80b9fe415a9a09d74c28e230995fd292dfc123","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/filters/default-injects.js","hash":"872f01cb10e422a648ea505436532e776e92926b","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/filters/locals.js","hash":"9eb5310664759931287dd28ea39165dfb67f12ed","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/filters/minify.js","hash":"f160e39943e39d7276da86adb47c3f08e5f22c7a","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/filters/post.js","hash":"30e03a1d4828259f82d46e64cbfe2955b6cff9a9","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/helpers/engine.js","hash":"d292b78485e8e8055712b0ed6de7cf559c5fbdcd","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/rating.njk","hash":"1bcdbc7fde26d6d9ef4e7fa43ffcff5a9506b20e","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/helpers/font.js","hash":"3394185a7f0393c16ce52c8028f90da3e9239c55","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/helpers/navigation.js","hash":"78107021101553c3d23e89290f7530b60cf4aa86","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/footer.njk","hash":"19713f472972caac33ae5fbcfe9105da61257de4","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/helpers/next-config.js","hash":"226fccbe9c93265e65a300e3cb4bf6f9065cfdd7","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/helpers/next-url.js","hash":"a11b71ba0c5012e2cdcab31c15439156b215563e","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/helpers/next-vendors.js","hash":"afdd6a188a74c188f0dd154fac70efd4080ca262","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/tags/button.js","hash":"c6ad2ed544fbb25ecb5d820c36e76302504271b7","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/tags/caniuse.js","hash":"935a311142a409c1896b3ae3f01fe7a9e2db1134","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/tags/center-quote.js","hash":"92c19d796bdb3320df9caea59bf52df7a95d9da9","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/tags/group-pictures.js","hash":"9ed799c329abf830f623689d7e136991256a24ca","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/tags/index.js","hash":"17f9451ce1f10f78437f52218757d38d4e1591b0","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/tags/link-grid.js","hash":"18a483c2d5afd701f6080ffdddf2d1321370336c","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/tags/mermaid.js","hash":"4fb01ca650fa8b256b8d48f50dc1b18350bd3d6d","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/tags/label.js","hash":"8a73348186113bae0a51ea2f891c1bb882fab05a","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/tags/note.js","hash":"7b94ddb46b7d4b0fe815f2fbe4bd375f07f55363","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/tags/pdf.js","hash":"344636b6fd7e27e8831c1e194039afc0d61931cd","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/tags/tabs.js","hash":"0eabe51da40b4b13e16419c8fe02452d9a4fef73","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/tags/video.js","hash":"2ee926448583be8f95af1f2884ae2c9c4830151d","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_colors.styl","hash":"3c6798c10cc220d83481cb3f3782e78558cee789","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_mixins.styl","hash":"32d31cb5a155681c19f5ad0bb56dcb08429f93ef","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/images/avatar.gif","hash":"2dbc3e2f2d624b2ca1afe6edc2ca17307f1950c8","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/noscript.styl","hash":"263eddabfae40e54c0591e7baa8403ade8cdd56d","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/main.styl","hash":"78ce791cc4ac95386cf6839ca72f5f7b51f86ee9","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/images/logo.svg","hash":"2cb74fd3ea2635e015eabc58a8d488aed6cf6417","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/bookmark.js","hash":"0f563ffbf05fad30e854e413ab17ff7164ab5a53","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/comments-buttons.js","hash":"1a7344440321713426a0b2ab17e276b5bdf85ade","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/config.js","hash":"4c4ebbe3b3f3841a26f9d5af6d0ba8bc6da01c54","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/motion.js","hash":"f7c825cbff11885fa0dffa64824fd00e505d6a8d","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/next-boot.js","hash":"da0f07f9eaaa83de70128b0feaea3fdadb90457a","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/pjax.js","hash":"919f5281c4a04d11cfd94573ecf57b3dbabd3cc8","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/head/head.njk","hash":"0ba2bf0266f1fcb8edbd961869f8521b29685c56","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/head/head-unique.njk","hash":"8da52a144060db1a0a088ccb2e6cc8376d1fce70","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/schedule.js","hash":"a1333258726caf84f368a8f8454639c7dc1626bb","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/brand.njk","hash":"aff4613756456be26415febc668860fdab8d33c5","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/utils.js","hash":"200088bfd042f5304b2a04befab0829148845e0e","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/index.njk","hash":"650de421a8ce4cf685428ffbe0087ff84cbd1356","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/menu-item.njk","hash":"41a8b0cc16f60fa085cb719d07216d86b6bc4bf8","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/menu.njk","hash":"ee6fc2f111572d3eeab0a2fecbb2d6b3e37ab26b","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/header/sub-menu.njk","hash":"06480d8ec5f0b87eafd47f082f07968d7282dd5c","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/breadcrumb.njk","hash":"89825e75cc45e9709fa6ba89883669eedaff6f46","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/categories.njk","hash":"17156d99941f28a225951ffdcfa9a115e20dc2d2","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/page-header.njk","hash":"7ed4f102a1825195cff8d7995bf9219f323a9034","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/schedule.njk","hash":"0f4bc8e257da60f77c0c1738607b2bde55810684","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/page/tags.njk","hash":"a18d1598e36cc72f2b0b24c3cc3c5990dfaa3254","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-copyright.njk","hash":"133942922e34abae9e4de7ea5591d77c0caa4b37","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-followme.njk","hash":"154df0bb323c332d8c25343f258ee865e5553423","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-footer.njk","hash":"bde2c7356d9362972bde41cc206d5816f8ed714d","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-meta.njk","hash":"9fa47e4fb342811da590ee4adc91cf81118c0a39","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-related.njk","hash":"57eca76cfbbe9a65bc2a77f1deebf003ed335673","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/post/post-reward.njk","hash":"002b51d0cae3f2e2e008bdc58be90c728282de5b","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/search/algolia-search.njk","hash":"efb2b6f19df02ba5ae623a1f274fff52aed21e6f","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/search/localsearch.njk","hash":"661f7acae43f0be694266323320f977d84119abe","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/search/index.njk","hash":"8f6f256ab3b351ffc80f1f3f1d9834e9a7cfac31","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_partials/sidebar/site-overview.njk","hash":"3d8591bb92df77ceb9d5b07bc76da1ca89e5bd76","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/baidu-analytics.njk","hash":"6215309aee028dcb734452beec448c5afb6c63fc","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/google-analytics.njk","hash":"d89066ff53879693f023e540d59c86137172c529","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/cloudflare.njk","hash":"a5b8297c2c383124dd6a56e256ecc0c0dcf489be","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/growingio.njk","hash":"8afaa772c390bd9d53a5cff9645ac3168334eb98","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/index.njk","hash":"314805f0186e9f6208c845f0757fdb7891c540f6","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/matomo.njk","hash":"4e89648a8ec8194c5823064cbca39c938a799006","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/analytics/microsoft-clarity.njk","hash":"9dc00fcb0a05899f048eace9f9160b78956655d5","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/chat/chatra.njk","hash":"d7263fca16d0278ccf1f6aa1c6df6902a6344a09","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/chat/gitter.njk","hash":"f8cc14b7aa949999a1faaeb7855e2f20b59a386d","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/chat/tidio.njk","hash":"02aab857c27fc103216029be991688b12a73a525","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/changyan.njk","hash":"d1c950f8fbdf85e7a3eae5463767a89e858e8220","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/disqus.njk","hash":"9375b19a89b7fa9474e558d085af5448d4c5c50c","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/disqusjs.njk","hash":"0749cb6902baecdfd01f779a2a2513f6d2f6a823","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/gitalk.njk","hash":"b63b7e2ede0d3e66e732fa1a06bda9b19e1e85d4","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/isso.njk","hash":"64cc3bdaf644fd32c0d0a247f29f5b6904da9af3","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/utterances.njk","hash":"5a94032bc3512a10ad4328fc19ec07b819a1d687","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/comments/livere.njk","hash":"3b13b09fba84ec6000886890a6710736a2b8fafe","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/math/index.njk","hash":"abf37fc55aa86702118e8fdf5bf2d389dd589aa0","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/math/katex.njk","hash":"1ebf658690468ea197bdd0416eb7cfa4bd0b083a","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/math/mathjax.njk","hash":"3677017fd4572b158311f5f5d870590ab25184e0","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/search/algolia-search.njk","hash":"24ed76e0c72a25ac152820c750a05826a706b6f4","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/search/localsearch.njk","hash":"e45ea3542cdc9ed7ec8447b5e6f35df4c5e82758","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/statistics/busuanzi-counter.njk","hash":"a4bc501da0f22f7e420f0ca47e83988ce90b1368","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/statistics/firestore.njk","hash":"d32ebe94560fa95824478ebbff531bffc47b194d","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/statistics/index.njk","hash":"568ddf7955d11d93fb5e842b403a7ac8b1b7fdb1","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/statistics/lean-analytics.njk","hash":"2446e748cdc102c78492216319ac02148db7daf6","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/tags/mermaid.njk","hash":"099e031f52fb8e47b3af5b2684737efc9e643ee7","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/config.js","hash":"c8b59b404f5d2a0b3b5cd1a6c9a10af5f30e43b5","modified":499162500000},{"_id":"node_modules/hexo-theme-next/layout/_third-party/tags/pdf.njk","hash":"2c81984cc4f5123103460442f6e046f5b6c97127","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/highlight.js","hash":"6aec7b2c38c50989a23bfaa0d560e75c7f553e12","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/injects.js","hash":"d987709267a1bc6e5014411e9983d7c49c102c16","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/navigation.js","hash":"dd3562686d95a50375e6fd32e717ccb0d99c1e3d","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/utils.js","hash":"ec996d0673f766167c86df0966e9da1ae036e103","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/events/lib/vendors.js","hash":"64e4024376b51fe81be7ad80235abdf0a83853bd","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/changyan.js","hash":"5798cfc8f63665031dd3e01debed051628cec319","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/common.js","hash":"19a402a225c31edffc50f202a14e0d582d3db23e","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/default-config.js","hash":"93ee5f9109dad885dc38c49bcee630c10f9dce6e","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/disqusjs.js","hash":"62faf6b0b0020066a0dec1f0123cf1fee3198e7e","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/disqus.js","hash":"7f71d6b271ba65ff333d5682e7575711d368c0d2","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/gitalk.js","hash":"7bb7dafdd7f6bca8464b54e17e552ce7f1714195","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/isso.js","hash":"ff8b5b5145220a17d0ecd9508ba9bd2d3b2da47d","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/livere.js","hash":"5a07d8bb52bc1d51a624ca8db54be144566c306b","modified":499162500000},{"_id":"node_modules/hexo-theme-next/scripts/filters/comment/utterances.js","hash":"d3bded697bc32dace689d2a6dfb6eb7514169d15","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_variables/Mist.styl","hash":"e1fbf169b9b6a194b518240cbd06ec3c48b83d61","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_variables/Gemini.styl","hash":"96e0a7c2a65ce68215e17e369085b2ea2f1334f2","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_variables/Muse.styl","hash":"e3be898f5ebcf435a26542653a9297ff2c71aeb0","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_variables/Pisces.styl","hash":"c65536a128b9bc9dbe2fbb1b235a3cded2891002","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/schemes/muse.js","hash":"9794bd4fc6a458322949d6a0ade89cd1026bc69f","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/fancybox.js","hash":"c098d14e65dd170537134358d4b8359ad0539c2c","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_variables/base.styl","hash":"163c7441d777bee87042d475e6ce0fde199add28","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/pace.js","hash":"0ef04218b93561ba4d0ff420d556c3d90a756d32","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/quicklink.js","hash":"eed02e6fced8e5a653077205d4d4d7834ca71472","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/back-to-top.styl","hash":"bab653bcf226311381e8411a0492202f1bf1fce9","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/rating.js","hash":"4e92c2d107ba47b47826829f9668030d5ea9bfb8","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/reading-progress.styl","hash":"90a86045a33c1bae49fc2f6fa1e1b53170c7f77b","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/mobile.styl","hash":"64775c729512b30b144ab5ae9dc4a4dfd4e13f35","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/index.styl","hash":"fe1868f47681e00a33a96199302be85377282f63","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/base.styl","hash":"d0a7c99095f490b0d2ed6b1be43d435960798cec","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/index.styl","hash":"8e34df131830d4fa3725e4590a672ba1cf1903e5","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/comments.styl","hash":"e4fecc889ba3317a64e9abba5842c79dff9b7827","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/buttons.styl","hash":"a042571d85ff7265f799004239a45f36b716b8a6","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/index.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/pagination.styl","hash":"b5c7782368889fa9fd93807d28ff2daf270e3703","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tables.styl","hash":"e840b23d33023e6d45e018f6e84b683dd56efd8d","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/toggles.styl","hash":"572a41499391677d84b16d8dbd6a996a3d5ce041","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Gemini/index.styl","hash":"fd49b521d67eaccc629f77b4e095cb7310327565","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/_header.styl","hash":"4817e77577896ab5c0da434549917ee703a3f4cf","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/_layout.styl","hash":"5604ac1e161099a4d3e5657d53507268866dc717","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/_menu.styl","hash":"fb550935d374e0bdf1097fce187337dc05cad3e1","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/_posts-expand.styl","hash":"be6cf377ae8f4a01ee76f9b3014e74161d4d5d17","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Mist/index.styl","hash":"ab16a3dcdc0393b9b582ef59dcc13db9320e917c","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_header.styl","hash":"06080fd963c904d96c00eff098a284e337953013","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_menu.styl","hash":"b7f48be3c43bfa393d62142544a5487a67871713","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_layout.styl","hash":"82a29572dd90451f75358a2ee2522b87304a0bb8","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_sidebar.styl","hash":"944364893bd7160d954c10ba931af641c91515a4","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_header.styl","hash":"b741ab96e73370711c63a6581159f2ea8b5bfa1b","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_layout.styl","hash":"6eee86c8f0175d6c09e434053516cd8556f78d44","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_menu.styl","hash":"72dc825c50357402c342d62ab60fc0c478ab6bc1","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_sidebar.styl","hash":"d9141e6e14a56b5952488101e9a8388c2170e270","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/index.styl","hash":"8000075b227749a7495eaf417cac6ccfbe441580","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"778ed2ad5643b93970c95626b325defeb586733f","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/baidu-analytics.js","hash":"f629acc46ff40c071ffd31b77d5c7616f0fdd778","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/google-analytics.js","hash":"59684383385059dc4f8a1ff85dbbeb703bcdbcb5","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/growingio.js","hash":"78dd3cf04082b7dbe6246e404b2aa8e726922402","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/analytics/matomo.js","hash":"c6a25b26a1443caa70b47fd3dfa282271574deb5","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/chatra.js","hash":"c32180522788c10e51df1803aa6842ef0432ddc9","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/gitter.js","hash":"cc38c94125f90dadde11b5ebac7d8bf99a1a08a2","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/chat/tidio.js","hash":"b0079f6a4601e06ca6fe46e83a2f5af553e9bc3c","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/changyan.js","hash":"260d1a77d6a3bb33a579d3e4cca1997003e799b5","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/disqus.js","hash":"e1cc671b0d524864fd445e3ab4ade9ee6d07e565","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/disqusjs.js","hash":"33a82207a15aad9d1c8fb2251f9e3eba50452932","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/gitalk.js","hash":"0ec038cf83e8ec067534f16a54041e47a3c1e59a","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/isso.js","hash":"753a873b6f566aff5ba77ca23f91b78eb880ca64","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/livere.js","hash":"2247d88c934c765c43013337860774aaa99f0b31","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/comments/utterances.js","hash":"f67f90eb03e284c82da2b8cf2f1e31801813c16d","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/math/katex.js","hash":"83c54ee536e487a1031783443fe0cb63b1b4767e","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/math/mathjax.js","hash":"5c749b9c1c3bb738122d0516211ecff6496d4907","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/search/algolia-search.js","hash":"fdb7b7cef1a147d897e7f7cd8903b58368ec2062","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/search/local-search.js","hash":"4536cb6d0a9bbaaa86fab3fa0101f6a3a3ec5a76","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/statistics/firestore.js","hash":"411a72df581f5b21317dc28633c7993207eb9e1c","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/statistics/lean-analytics.js","hash":"835cbf54c49ef1327f47df70ff2636ad36b6f57d","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/tags/mermaid.js","hash":"f27d817b0c2138dd3215b1f46af0753f60a008f3","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/js/third-party/tags/pdf.js","hash":"af78c22f0e61c8c8aa8794e585e0d632c6d4fcb8","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/categories.styl","hash":"b6e2eb1550a7845cb2adf86081a4ab6c7bde1e68","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/breadcrumb.styl","hash":"8afdc311c6b8db121758371f95cf1c5e77354f42","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/index.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/schedule.styl","hash":"6b816c2511242ee503fb5f34cd3e4dcdafc06b85","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/pages/tag-cloud.styl","hash":"1a81d1a71fcf0699629ce6e72dfd0a15f3a2dd0a","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/index.styl","hash":"d0805a763176b3c0003967401644f41dfe3bc9e8","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-body.styl","hash":"d757768a58743601d0d84158ba955eb15d4c3c01","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-collapse.styl","hash":"ec37a36e94ba791663607a5022f763915778578f","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-followme.styl","hash":"fc1a7bac6493f24aa50665574f37f3dd954f210c","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-footer.styl","hash":"1d284f3ea03ba9b4feb76b375e539a8e0bccf1c3","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-gallery.styl","hash":"aa366d37389760c8595529b850f461569577a1c5","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-header.styl","hash":"010c901e4ef49a606f8a350efbf09044e76d2ff3","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-nav.styl","hash":"9ac6f477177264c26a46e8333b8456720a0444dc","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-reward.styl","hash":"07cff69f2d57e6321595f64c16d8b763dc88df6a","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/post/post-widgets.styl","hash":"b6677dc2a2368084ab82bb4f145ac79e5966c150","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/gitalk.styl","hash":"070737d101e7cd58e997e8c7af09958268c43a21","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/disqusjs.styl","hash":"c2326ee3e8b724d99c24a818ddee32813ea5bf89","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/gitter.styl","hash":"35104dc6883a61c31e0e368dac8ac2f697be62fe","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/index.styl","hash":"979486a41a81f2a9fd8b0b87c4f87d6416c68c7d","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/math.styl","hash":"9d995eb4871a6c273d9d51558676a1fdabf69e72","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/related-posts.styl","hash":"41ed817e1eb64078074e245e771446ee041e5790","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/search.styl","hash":"e72799ce3f9b79753e365b2f8c8ef6c310668d4a","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/components/third-party/utterances.styl","hash":"56d90ae0559caa55b75f3c300ff2711f9ed65fc4","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/footer/index.styl","hash":"8b9407e5cfd0571ef8de7df19022b268f962fa2f","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/bookmark.styl","hash":"e74f4bb47a101b014ee2a1783c87f3b87323f9a0","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/github-banner.styl","hash":"38c64c2d04e46848382bfa246a0e9c508294767b","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/index.styl","hash":"ff642130354a0b3be0d708c43044ed4d710b5e83","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/menu.styl","hash":"392fd53a8dd4e3f33a853ebb24290a622300e0ff","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/site-meta.styl","hash":"759e582d34d08e3386c55d87a835a9523608619f","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/header/site-nav.styl","hash":"bf3ad8b4268f763a1e26377681644887694bc009","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/index.styl","hash":"cee43480eba028c37d51cb620c2d81486aa24e01","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"52fc98b1435129eb3edb9293ced9e507741f1350","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"5b38ac4a0f1ade0e681aff0e3366c481d9cf3dcd","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"9950c3188a28e1c63b5498b7bdcd14b12ace3e28","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"b926e368f702f8686aaa2eb98d3d2e533418958c","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"fbdb63c6a8887d19b7137325ba7d6806f728139c","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"ee94a1a27090ad24e3ed579093088d97ff96d77d","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"021a37cf178440cc341940a299d3bca359996c6b","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"3103b81fc76b59e1e2c161e2c484625c770ed66f","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/outline/sidebar/site-state.styl","hash":"26dd0adfcb1db6df29c6090c8d7e9b5a43583fb0","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"670fc109b56a010b166b86b616823a1aae97a738","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/highlight/index.styl","hash":"f2328caa94645836e06fb39a6a9c9a84ed68a8b5","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"d6418fd2bbfba7b73ddf11ec62db9637fdf5d8af","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"393ff96234e4196b569d4b11496774eb78e147de","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/index.styl","hash":"3f76c73a891bbc10679753e702feba9e8a5ffdd2","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/label.styl","hash":"debee14539272fbe3835a7d3853af2230baa3501","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/link-grid.styl","hash":"7f8a7345e6537a62cd9e9a94c8f7065b541d9b04","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/mermaid.styl","hash":"48d35dba575a7c9e8845b16652e76b7d4a4646de","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/note.styl","hash":"d27fbf7799695295dd5860a161a13ac4d90c5ba4","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b6654a1d7cf82577d8263faffee8af3ad4a5c0e8","modified":499162500000},{"_id":"node_modules/hexo-theme-next/source/css/_common/scaffolding/tags/tabs.styl","hash":"7a39bcce7274284e87388743db62afc847fe6897","modified":499162500000}],"Category":[],"Data":[],"Page":[{"title":"categories","date":"2017-01-19T08:52:48.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2017-01-19 16:52:48\ntype: \"categories\"\n---\n","updated":"2020-06-29T06:22:24.364Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ckzf5sdzu0012yy8k9vt66ykq","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2017-01-19T08:53:34.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2017-01-19 16:53:34\ntype: \"tags\"\n---\n","updated":"2020-06-29T06:22:24.364Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckzf5sdzv0014yy8k1yzy6ze3","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"about","date":"2017-01-19T08:44:34.000Z","_content":"adfsdfffffffff","source":"about/index.md","raw":"---\ntitle: about\ndate: 2017-01-19 16:44:34\n---\nadfsdfffffffff","updated":"2020-06-29T06:22:24.363Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckzf5sdzx0017yy8k8ej38z7t","content":"<p>adfsdfffffffff</p>\n","site":{"data":{}},"excerpt":"","more":"<p>adfsdfffffffff</p>\n"}],"Post":[{"title":"cookies","date":"2019-06-24T06:40:18.000Z","_content":"\n:smile:\n### 发版\n1. 发布阶段：更新chagelog ,打 git tag 。\n\n### react \n1.  useMemo是将父组件传递给子组件的值缓存起来,useMemo 是在DOM渲染之前执行的\n2.  usecallback是将父组件传给子组件的方法给缓存下来\n3.  dva   connect Model 的组件通过 props 可以访问到 dispatch，可以调用 Model 中的 Reducer 或者 Effects\n4.  向主进程发送消息   ipcRenderer.send(channel, ...args)\n5.  webContens.send  向渲染进程发送消息 \n### word\n1. analogy 类比 [əˈnælədʒi]\n1. pache [ə’pætʃɪ]\n2. deflate 放气，紧缩\n3. Sanitize 消毒，净化\n4. access [‘ækses]\n5. Azure [‘æʒə]\n6. avatar [‘ævətɑː]\n7. ASCII [‘æski]\n8. archive [‘ɑːkaɪv]\n9. debt  [det]\n10. typical [‘tɪpɪkl]  \n11. parameter [pə’ræmɪtə] \n12. integer  [‘ɪntɪdʒə]\n13. height [haɪt]\n14. shallow  肤浅的 \n15. tenant  租户，房客\n16. coerce [kəʊˈɜːs]  强制 \n17. indeterminate  [ˌɪndɪˈtɜːrmɪnət]\n18. sup 一口；饮酒  \n19. crumb 面包屑   \n20. prune  修剪；减少；\n21. Unify 整合、统一 \n22. contiguous  kənˈtɪɡjuəs\n \n23. 无论你使用的是解释型语言(JavaScript、Python、Ruby)还是编译型语言(c#、Java、Rust)，都有一个共同的部分:将源代码作为纯文本解析为 抽象语法树(abstract syntax tree, AST) 的数据结构。\n\n24. AST 不仅以结构化的方式显示源代码，而且在语义分析中扮演着重要角色。在语义分析中，编译器验证程序和语言元素的语法使用是否正确。之后，使用 AST 来生成实际的字节码或者机器码。\n\n25. 要应用更新，Virtual DOM核心功能将发挥作用，即 协调算法，它的工作是提供最优的解决方案来解决以前和当前虚拟DOM 状态之间的差异。\n\n## opentracing\n1. Opentracing 的carrier 有多种实现，tracer 的inject（客户端进程） 和 extract（服务端进程），这样 客户端和服务端 就可以拥有相同的trace context。\n1. Server 首先extract check 有没有注入的span，没有的话启动一个新的span\n\n## mac\n1. Mac 设置path  export PATH=$PATH:\n1.  查看端口占用：lsof -i:3001\n1. export http_proxy=\"http://localhost:8899\"\n1. Grep -A 5 显示后面5行信息\n1. Mac 配置：\n   Oh my zsh \n   brew install autojump  \n   \n   git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions\n\n   git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting\n\n   plugins=(\n     git zsh-autosuggestions autojump zsh-syntax-highlighting\n   )\n   \n   \n## npm\n1. npm config edit\n1. npm config set init.author.name \"ryansecreat\"\n1. npm config set init.email='chenjingnan@jd.com’\n1. npm config set init.license \"MIT\"\n1. npm start --prefix path/to/your/folder   //指定目录下运行\n1. npm repo   浏览器中打开repo\n1. npm publish --registry=http://registry.npmjs.org  --registry=https://registry.npm.taobao.org\n1. npm outdated  查看过时package\n1. npm publish --tag=beta.\n1. npm version patch -m \"Upgrade to %s for reasons”\n1. npm dist-tag add n-n-n-n@1.0.2-1 latest  将某个预发版本更新为最新   \n1. npm ping [--registry <registry>]\n1. Npm install  --unsafe-perm\n \n\n  \n### vim \nj: 下移一行；\n\nk: 上移一行；\n\nw: 前移一个单词，光标停在下一个单词开头；\n\ne: 前移一个单词，光标停在下一个单词末尾；\n\n0: 移动到行首。\n\n$: 移动到行尾。\n\nn|: 把光标移到递n列上\n\nzz: 将当前行移动到屏幕中央。\n\no: 在下面新建一行插入；\n\nO: 在上面新建一行插入；\n\na: 在光标后插入；\n\nA: 在当前行最后插入；\n\nu: 取消一(n)个改动。\n\nctrl + r: 重做最后的改动。","source":"_posts/cookies.md","raw":"---\ntitle: cookies\ndate: 2019-06-24 14:40:18\ntags: 零碎\n---\n\n:smile:\n### 发版\n1. 发布阶段：更新chagelog ,打 git tag 。\n\n### react \n1.  useMemo是将父组件传递给子组件的值缓存起来,useMemo 是在DOM渲染之前执行的\n2.  usecallback是将父组件传给子组件的方法给缓存下来\n3.  dva   connect Model 的组件通过 props 可以访问到 dispatch，可以调用 Model 中的 Reducer 或者 Effects\n4.  向主进程发送消息   ipcRenderer.send(channel, ...args)\n5.  webContens.send  向渲染进程发送消息 \n### word\n1. analogy 类比 [əˈnælədʒi]\n1. pache [ə’pætʃɪ]\n2. deflate 放气，紧缩\n3. Sanitize 消毒，净化\n4. access [‘ækses]\n5. Azure [‘æʒə]\n6. avatar [‘ævətɑː]\n7. ASCII [‘æski]\n8. archive [‘ɑːkaɪv]\n9. debt  [det]\n10. typical [‘tɪpɪkl]  \n11. parameter [pə’ræmɪtə] \n12. integer  [‘ɪntɪdʒə]\n13. height [haɪt]\n14. shallow  肤浅的 \n15. tenant  租户，房客\n16. coerce [kəʊˈɜːs]  强制 \n17. indeterminate  [ˌɪndɪˈtɜːrmɪnət]\n18. sup 一口；饮酒  \n19. crumb 面包屑   \n20. prune  修剪；减少；\n21. Unify 整合、统一 \n22. contiguous  kənˈtɪɡjuəs\n \n23. 无论你使用的是解释型语言(JavaScript、Python、Ruby)还是编译型语言(c#、Java、Rust)，都有一个共同的部分:将源代码作为纯文本解析为 抽象语法树(abstract syntax tree, AST) 的数据结构。\n\n24. AST 不仅以结构化的方式显示源代码，而且在语义分析中扮演着重要角色。在语义分析中，编译器验证程序和语言元素的语法使用是否正确。之后，使用 AST 来生成实际的字节码或者机器码。\n\n25. 要应用更新，Virtual DOM核心功能将发挥作用，即 协调算法，它的工作是提供最优的解决方案来解决以前和当前虚拟DOM 状态之间的差异。\n\n## opentracing\n1. Opentracing 的carrier 有多种实现，tracer 的inject（客户端进程） 和 extract（服务端进程），这样 客户端和服务端 就可以拥有相同的trace context。\n1. Server 首先extract check 有没有注入的span，没有的话启动一个新的span\n\n## mac\n1. Mac 设置path  export PATH=$PATH:\n1.  查看端口占用：lsof -i:3001\n1. export http_proxy=\"http://localhost:8899\"\n1. Grep -A 5 显示后面5行信息\n1. Mac 配置：\n   Oh my zsh \n   brew install autojump  \n   \n   git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions\n\n   git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting\n\n   plugins=(\n     git zsh-autosuggestions autojump zsh-syntax-highlighting\n   )\n   \n   \n## npm\n1. npm config edit\n1. npm config set init.author.name \"ryansecreat\"\n1. npm config set init.email='chenjingnan@jd.com’\n1. npm config set init.license \"MIT\"\n1. npm start --prefix path/to/your/folder   //指定目录下运行\n1. npm repo   浏览器中打开repo\n1. npm publish --registry=http://registry.npmjs.org  --registry=https://registry.npm.taobao.org\n1. npm outdated  查看过时package\n1. npm publish --tag=beta.\n1. npm version patch -m \"Upgrade to %s for reasons”\n1. npm dist-tag add n-n-n-n@1.0.2-1 latest  将某个预发版本更新为最新   \n1. npm ping [--registry <registry>]\n1. Npm install  --unsafe-perm\n \n\n  \n### vim \nj: 下移一行；\n\nk: 上移一行；\n\nw: 前移一个单词，光标停在下一个单词开头；\n\ne: 前移一个单词，光标停在下一个单词末尾；\n\n0: 移动到行首。\n\n$: 移动到行尾。\n\nn|: 把光标移到递n列上\n\nzz: 将当前行移动到屏幕中央。\n\no: 在下面新建一行插入；\n\nO: 在上面新建一行插入；\n\na: 在光标后插入；\n\nA: 在当前行最后插入；\n\nu: 取消一(n)个改动。\n\nctrl + r: 重做最后的改动。","slug":"cookies","published":1,"updated":"2021-04-30T11:12:40.388Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckzf5sdyt0000yy8kmd769rti","content":"<p>:smile:</p>\n<h3 id=\"发版\"><a href=\"#发版\" class=\"headerlink\" title=\"发版\"></a>发版</h3><ol>\n<li>发布阶段：更新chagelog ,打 git tag 。</li>\n</ol>\n<h3 id=\"react\"><a href=\"#react\" class=\"headerlink\" title=\"react\"></a>react</h3><ol>\n<li>useMemo是将父组件传递给子组件的值缓存起来,useMemo 是在DOM渲染之前执行的</li>\n<li>usecallback是将父组件传给子组件的方法给缓存下来</li>\n<li>dva   connect Model 的组件通过 props 可以访问到 dispatch，可以调用 Model 中的 Reducer 或者 Effects</li>\n<li>向主进程发送消息   ipcRenderer.send(channel, …args)</li>\n<li>webContens.send  向渲染进程发送消息 <h3 id=\"word\"><a href=\"#word\" class=\"headerlink\" title=\"word\"></a>word</h3></li>\n<li>analogy 类比 [əˈnælədʒi]</li>\n<li>pache [ə’pætʃɪ]</li>\n<li>deflate 放气，紧缩</li>\n<li>Sanitize 消毒，净化</li>\n<li>access [‘ækses]</li>\n<li>Azure [‘æʒə]</li>\n<li>avatar [‘ævətɑː]</li>\n<li>ASCII [‘æski]</li>\n<li>archive [‘ɑːkaɪv]</li>\n<li>debt  [det]</li>\n<li>typical [‘tɪpɪkl]  </li>\n<li>parameter [pə’ræmɪtə] </li>\n<li>integer  [‘ɪntɪdʒə]</li>\n<li>height [haɪt]</li>\n<li>shallow  肤浅的 </li>\n<li>tenant  租户，房客</li>\n<li>coerce [kəʊˈɜːs]  强制 </li>\n<li>indeterminate  [ˌɪndɪˈtɜːrmɪnət]</li>\n<li>sup 一口；饮酒  </li>\n<li>crumb 面包屑   </li>\n<li>prune  修剪；减少；</li>\n<li>Unify 整合、统一 </li>\n<li><p>contiguous  kənˈtɪɡjuəs</p>\n</li>\n<li><p>无论你使用的是解释型语言(JavaScript、Python、Ruby)还是编译型语言(c#、Java、Rust)，都有一个共同的部分:将源代码作为纯文本解析为 抽象语法树(abstract syntax tree, AST) 的数据结构。</p>\n</li>\n<li><p>AST 不仅以结构化的方式显示源代码，而且在语义分析中扮演着重要角色。在语义分析中，编译器验证程序和语言元素的语法使用是否正确。之后，使用 AST 来生成实际的字节码或者机器码。</p>\n</li>\n<li><p>要应用更新，Virtual DOM核心功能将发挥作用，即 协调算法，它的工作是提供最优的解决方案来解决以前和当前虚拟DOM 状态之间的差异。</p>\n</li>\n</ol>\n<h2 id=\"opentracing\"><a href=\"#opentracing\" class=\"headerlink\" title=\"opentracing\"></a>opentracing</h2><ol>\n<li>Opentracing 的carrier 有多种实现，tracer 的inject（客户端进程） 和 extract（服务端进程），这样 客户端和服务端 就可以拥有相同的trace context。</li>\n<li>Server 首先extract check 有没有注入的span，没有的话启动一个新的span</li>\n</ol>\n<h2 id=\"mac\"><a href=\"#mac\" class=\"headerlink\" title=\"mac\"></a>mac</h2><ol>\n<li>Mac 设置path  export PATH=$PATH:</li>\n<li>查看端口占用：lsof -i:3001</li>\n<li>export http_proxy=”<a href=\"http://localhost:8899&quot;\" target=\"_blank\" rel=\"noopener\">http://localhost:8899&quot;</a></li>\n<li>Grep -A 5 显示后面5行信息</li>\n<li><p>Mac 配置：<br>Oh my zsh<br>brew install autojump  </p>\n<p>git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions</p>\n<p>git clone <a href=\"https://github.com/zsh-users/zsh-syntax-highlighting.git\" target=\"_blank\" rel=\"noopener\">https://github.com/zsh-users/zsh-syntax-highlighting.git</a> ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting</p>\n<p>plugins=(<br>  git zsh-autosuggestions autojump zsh-syntax-highlighting<br>)</p>\n</li>\n</ol>\n<h2 id=\"npm\"><a href=\"#npm\" class=\"headerlink\" title=\"npm\"></a>npm</h2><ol>\n<li>npm config edit</li>\n<li>npm config set init.author.name “ryansecreat”</li>\n<li>npm config set <a href=\"mailto:init.email=&#39;chenjingnan@jd.com\" target=\"_blank\" rel=\"noopener\">init.email=&#39;chenjingnan@jd.com</a>’</li>\n<li>npm config set init.license “MIT”</li>\n<li>npm start –prefix path/to/your/folder   //指定目录下运行</li>\n<li>npm repo   浏览器中打开repo</li>\n<li>npm publish –registry=<a href=\"http://registry.npmjs.org\" target=\"_blank\" rel=\"noopener\">http://registry.npmjs.org</a>  –registry=<a href=\"https://registry.npm.taobao.org\" target=\"_blank\" rel=\"noopener\">https://registry.npm.taobao.org</a></li>\n<li>npm outdated  查看过时package</li>\n<li>npm publish –tag=beta.</li>\n<li>npm version patch -m “Upgrade to %s for reasons”</li>\n<li>npm dist-tag add <a href=\"mailto:n-n-n-n@1.0.2-1\" target=\"_blank\" rel=\"noopener\">n-n-n-n@1.0.2-1</a> latest  将某个预发版本更新为最新   </li>\n<li>npm ping [–registry <registry>]</registry></li>\n<li>Npm install  –unsafe-perm</li>\n</ol>\n<h3 id=\"vim\"><a href=\"#vim\" class=\"headerlink\" title=\"vim\"></a>vim</h3><p>j: 下移一行；</p>\n<p>k: 上移一行；</p>\n<p>w: 前移一个单词，光标停在下一个单词开头；</p>\n<p>e: 前移一个单词，光标停在下一个单词末尾；</p>\n<p>0: 移动到行首。</p>\n<p>$: 移动到行尾。</p>\n<p>n|: 把光标移到递n列上</p>\n<p>zz: 将当前行移动到屏幕中央。</p>\n<p>o: 在下面新建一行插入；</p>\n<p>O: 在上面新建一行插入；</p>\n<p>a: 在光标后插入；</p>\n<p>A: 在当前行最后插入；</p>\n<p>u: 取消一(n)个改动。</p>\n<p>ctrl + r: 重做最后的改动。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>:smile:</p>\n<h3 id=\"发版\"><a href=\"#发版\" class=\"headerlink\" title=\"发版\"></a>发版</h3><ol>\n<li>发布阶段：更新chagelog ,打 git tag 。</li>\n</ol>\n<h3 id=\"react\"><a href=\"#react\" class=\"headerlink\" title=\"react\"></a>react</h3><ol>\n<li>useMemo是将父组件传递给子组件的值缓存起来,useMemo 是在DOM渲染之前执行的</li>\n<li>usecallback是将父组件传给子组件的方法给缓存下来</li>\n<li>dva   connect Model 的组件通过 props 可以访问到 dispatch，可以调用 Model 中的 Reducer 或者 Effects</li>\n<li>向主进程发送消息   ipcRenderer.send(channel, …args)</li>\n<li>webContens.send  向渲染进程发送消息 <h3 id=\"word\"><a href=\"#word\" class=\"headerlink\" title=\"word\"></a>word</h3></li>\n<li>analogy 类比 [əˈnælədʒi]</li>\n<li>pache [ə’pætʃɪ]</li>\n<li>deflate 放气，紧缩</li>\n<li>Sanitize 消毒，净化</li>\n<li>access [‘ækses]</li>\n<li>Azure [‘æʒə]</li>\n<li>avatar [‘ævətɑː]</li>\n<li>ASCII [‘æski]</li>\n<li>archive [‘ɑːkaɪv]</li>\n<li>debt  [det]</li>\n<li>typical [‘tɪpɪkl]  </li>\n<li>parameter [pə’ræmɪtə] </li>\n<li>integer  [‘ɪntɪdʒə]</li>\n<li>height [haɪt]</li>\n<li>shallow  肤浅的 </li>\n<li>tenant  租户，房客</li>\n<li>coerce [kəʊˈɜːs]  强制 </li>\n<li>indeterminate  [ˌɪndɪˈtɜːrmɪnət]</li>\n<li>sup 一口；饮酒  </li>\n<li>crumb 面包屑   </li>\n<li>prune  修剪；减少；</li>\n<li>Unify 整合、统一 </li>\n<li><p>contiguous  kənˈtɪɡjuəs</p>\n</li>\n<li><p>无论你使用的是解释型语言(JavaScript、Python、Ruby)还是编译型语言(c#、Java、Rust)，都有一个共同的部分:将源代码作为纯文本解析为 抽象语法树(abstract syntax tree, AST) 的数据结构。</p>\n</li>\n<li><p>AST 不仅以结构化的方式显示源代码，而且在语义分析中扮演着重要角色。在语义分析中，编译器验证程序和语言元素的语法使用是否正确。之后，使用 AST 来生成实际的字节码或者机器码。</p>\n</li>\n<li><p>要应用更新，Virtual DOM核心功能将发挥作用，即 协调算法，它的工作是提供最优的解决方案来解决以前和当前虚拟DOM 状态之间的差异。</p>\n</li>\n</ol>\n<h2 id=\"opentracing\"><a href=\"#opentracing\" class=\"headerlink\" title=\"opentracing\"></a>opentracing</h2><ol>\n<li>Opentracing 的carrier 有多种实现，tracer 的inject（客户端进程） 和 extract（服务端进程），这样 客户端和服务端 就可以拥有相同的trace context。</li>\n<li>Server 首先extract check 有没有注入的span，没有的话启动一个新的span</li>\n</ol>\n<h2 id=\"mac\"><a href=\"#mac\" class=\"headerlink\" title=\"mac\"></a>mac</h2><ol>\n<li>Mac 设置path  export PATH=$PATH:</li>\n<li>查看端口占用：lsof -i:3001</li>\n<li>export http_proxy=”<a href=\"http://localhost:8899&quot;\" target=\"_blank\" rel=\"noopener\">http://localhost:8899&quot;</a></li>\n<li>Grep -A 5 显示后面5行信息</li>\n<li><p>Mac 配置：<br>Oh my zsh<br>brew install autojump  </p>\n<p>git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions</p>\n<p>git clone <a href=\"https://github.com/zsh-users/zsh-syntax-highlighting.git\" target=\"_blank\" rel=\"noopener\">https://github.com/zsh-users/zsh-syntax-highlighting.git</a> ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting</p>\n<p>plugins=(<br>  git zsh-autosuggestions autojump zsh-syntax-highlighting<br>)</p>\n</li>\n</ol>\n<h2 id=\"npm\"><a href=\"#npm\" class=\"headerlink\" title=\"npm\"></a>npm</h2><ol>\n<li>npm config edit</li>\n<li>npm config set init.author.name “ryansecreat”</li>\n<li>npm config set <a href=\"mailto:init.email=&#39;chenjingnan@jd.com\" target=\"_blank\" rel=\"noopener\">init.email=&#39;chenjingnan@jd.com</a>’</li>\n<li>npm config set init.license “MIT”</li>\n<li>npm start –prefix path/to/your/folder   //指定目录下运行</li>\n<li>npm repo   浏览器中打开repo</li>\n<li>npm publish –registry=<a href=\"http://registry.npmjs.org\" target=\"_blank\" rel=\"noopener\">http://registry.npmjs.org</a>  –registry=<a href=\"https://registry.npm.taobao.org\" target=\"_blank\" rel=\"noopener\">https://registry.npm.taobao.org</a></li>\n<li>npm outdated  查看过时package</li>\n<li>npm publish –tag=beta.</li>\n<li>npm version patch -m “Upgrade to %s for reasons”</li>\n<li>npm dist-tag add <a href=\"mailto:n-n-n-n@1.0.2-1\" target=\"_blank\" rel=\"noopener\">n-n-n-n@1.0.2-1</a> latest  将某个预发版本更新为最新   </li>\n<li>npm ping [–registry <registry>]</registry></li>\n<li>Npm install  –unsafe-perm</li>\n</ol>\n<h3 id=\"vim\"><a href=\"#vim\" class=\"headerlink\" title=\"vim\"></a>vim</h3><p>j: 下移一行；</p>\n<p>k: 上移一行；</p>\n<p>w: 前移一个单词，光标停在下一个单词开头；</p>\n<p>e: 前移一个单词，光标停在下一个单词末尾；</p>\n<p>0: 移动到行首。</p>\n<p>$: 移动到行尾。</p>\n<p>n|: 把光标移到递n列上</p>\n<p>zz: 将当前行移动到屏幕中央。</p>\n<p>o: 在下面新建一行插入；</p>\n<p>O: 在上面新建一行插入；</p>\n<p>a: 在光标后插入；</p>\n<p>A: 在当前行最后插入；</p>\n<p>u: 取消一(n)个改动。</p>\n<p>ctrl + r: 重做最后的改动。</p>\n"},{"title":"Let's Encrypt","date":"2016-12-21T03:47:39.000Z","_content":"\n### 使用Let's Encrypt生成免费SSL证书\n\n官网：[Let's Encrypt](https://letsencrypt.org/)\n\nLet's Encrypt是由互联网安全研究小组（ISRG，一个公益组织）提供的服务。提供免费、自动化、开放的证书签发服务。\n\nLet's Encrypt颁发的证书有期是90天，需要在过期前进行续期，好在Let's Encrypt已经提供了自动续期的脚本。\n\n官网推荐使用[Certbot](https://certbot.eff.org/)工具来部署Https证书。在Certbot首页上选择Web服务器及服务器OS类型，我们在这里以Nginx + CentOS 6为例来说明。\n\n原文链接：[https://certbot.eff.org/#centos6-nginx](https://certbot.eff.org/#centos6-nginx)\n\n0. #### 生成证书\n\n\t0. 安装证书生成工具certbot-auto：\n\n\t\t```\n\t\twget https://dl.eff.org/certbot-auto\n\t\tchmod a+x certbot-auto\n\t\t```\n\t0. 安装依赖\n\n\t\t运行```./certbot-auto```，安装所有依赖项。过程中可能会提示```Virtualenv Command Not Found```，需要[安装pip](https://pip.pypa.io/en/stable/installing/)、virtualenv包：```pip install virtualenv```。\n\n\t0. 配置Nginx\n\t\t\n\t\t为需要配置https的站点添加以下配置，将访问/.well-known的请求指向本地目录。Let's Encrypt在生成证书的过程中，会在/var/www/www.xxx.com/.well-known目录生成一个临时文件，并且会访问类似于http://www.xxx.com/.well-known/acme-challenge/HGr8U1IeTW4kY_Z6UIyaakzOkyQgPr_7ArlLgtZE8SX的url，来检查域名配置是否有效。\n\n\t\t添加以下配置，并重启Nginx：nginx -s reload，如果reload不生效，可以试试restart。\n\t\t\n\t\t```\n\t\tserver {\n\n\t\t\t...\t\t\t\n\n\t\t\tlocation /.well-known {\n\t        \talias /var/www/www.xxx.com/.well-known;\n\t    \t}\n\n\t\t\t...\n\n\t\t}\n\t\t```\n\n\t\t*即使证书生成之后，也需要保留Nginx的这一个配置，因为证书的续期还需要这一个配置。*\n\n\t0. 通过向导生成证书\n\n\t\t运行```./certbot-auto certonly```，会通过向导方式一步一步来生成证书。过程中间会用到上一步在Nginx中配置的本地目录。\n\n\t\t**对证书生成过程和原理比较熟悉的话，可以不使用向导方式，直接使用certbot-auto命令```./certbot-auto certonly --webroot -w /var/www/www.xxx.com -d xxx.com -d www.xxx.com -w /var/www/thing -d thing.is -d m.thing.is```可以快速高效地生成证书**\n\n\t\t生成的证书默认在/etc/letsencrypt/live/www.xxx.com/目录。\n\n0. #### 配置Nginx使用证书\n\n\t添加以下配置，并重启Nginx：```nginx -s reload```，如果reload不生效，可以试试restart。\n\n\t```\n\tserver {\n\n\t\t...\n\t\tlisten 443;\n\n\t    ssl on;\n        ssl_stapling_verify on;\n        ssl_certificate         /etc/letsencrypt/live/www.xxx.com/fullchain.pem;\n        ssl_certificate_key     /etc/letsencrypt/live/www.xxx.com/privkey.pem;\n\n\t\t...\n\n\t}\n\t```\n\n0. #### 检查证书的有效性\n\n\t打开浏览器，检查证书的有效性。\n\n0. #### 证书续期\n\n\tLet's Encrypt颁发的证书有期是90天，需要在过期前进行续期，好在Let's Encrypt已经提供了自动续期的脚本。\n\n\t官网说明，可以一天调用两次，如果检测到证书不需要更新，是什么都不做的，以减少意外造成的故障。\n\n\t先运行```certbot-auto renew --dry-run```命令检查证书自动续期是否正常，如果正常，将```certbot-auto renew --quiet```命令添加到系统的计划任务cron中，就可以实现证书自动续期了。\n\n\t```\n\t01 1 * * * ./path/to/certbot-auto renew --quiet\n\t```\n\t表示每天的1点1分自动执行续期脚本。\n\n\n\n\n\n","source":"_posts/Let's Encrypt SSL.md","raw":"---\ntitle: Let's Encrypt\ndate: 2016-12-21 11:47:39\ntags: https\n---\n\n### 使用Let's Encrypt生成免费SSL证书\n\n官网：[Let's Encrypt](https://letsencrypt.org/)\n\nLet's Encrypt是由互联网安全研究小组（ISRG，一个公益组织）提供的服务。提供免费、自动化、开放的证书签发服务。\n\nLet's Encrypt颁发的证书有期是90天，需要在过期前进行续期，好在Let's Encrypt已经提供了自动续期的脚本。\n\n官网推荐使用[Certbot](https://certbot.eff.org/)工具来部署Https证书。在Certbot首页上选择Web服务器及服务器OS类型，我们在这里以Nginx + CentOS 6为例来说明。\n\n原文链接：[https://certbot.eff.org/#centos6-nginx](https://certbot.eff.org/#centos6-nginx)\n\n0. #### 生成证书\n\n\t0. 安装证书生成工具certbot-auto：\n\n\t\t```\n\t\twget https://dl.eff.org/certbot-auto\n\t\tchmod a+x certbot-auto\n\t\t```\n\t0. 安装依赖\n\n\t\t运行```./certbot-auto```，安装所有依赖项。过程中可能会提示```Virtualenv Command Not Found```，需要[安装pip](https://pip.pypa.io/en/stable/installing/)、virtualenv包：```pip install virtualenv```。\n\n\t0. 配置Nginx\n\t\t\n\t\t为需要配置https的站点添加以下配置，将访问/.well-known的请求指向本地目录。Let's Encrypt在生成证书的过程中，会在/var/www/www.xxx.com/.well-known目录生成一个临时文件，并且会访问类似于http://www.xxx.com/.well-known/acme-challenge/HGr8U1IeTW4kY_Z6UIyaakzOkyQgPr_7ArlLgtZE8SX的url，来检查域名配置是否有效。\n\n\t\t添加以下配置，并重启Nginx：nginx -s reload，如果reload不生效，可以试试restart。\n\t\t\n\t\t```\n\t\tserver {\n\n\t\t\t...\t\t\t\n\n\t\t\tlocation /.well-known {\n\t        \talias /var/www/www.xxx.com/.well-known;\n\t    \t}\n\n\t\t\t...\n\n\t\t}\n\t\t```\n\n\t\t*即使证书生成之后，也需要保留Nginx的这一个配置，因为证书的续期还需要这一个配置。*\n\n\t0. 通过向导生成证书\n\n\t\t运行```./certbot-auto certonly```，会通过向导方式一步一步来生成证书。过程中间会用到上一步在Nginx中配置的本地目录。\n\n\t\t**对证书生成过程和原理比较熟悉的话，可以不使用向导方式，直接使用certbot-auto命令```./certbot-auto certonly --webroot -w /var/www/www.xxx.com -d xxx.com -d www.xxx.com -w /var/www/thing -d thing.is -d m.thing.is```可以快速高效地生成证书**\n\n\t\t生成的证书默认在/etc/letsencrypt/live/www.xxx.com/目录。\n\n0. #### 配置Nginx使用证书\n\n\t添加以下配置，并重启Nginx：```nginx -s reload```，如果reload不生效，可以试试restart。\n\n\t```\n\tserver {\n\n\t\t...\n\t\tlisten 443;\n\n\t    ssl on;\n        ssl_stapling_verify on;\n        ssl_certificate         /etc/letsencrypt/live/www.xxx.com/fullchain.pem;\n        ssl_certificate_key     /etc/letsencrypt/live/www.xxx.com/privkey.pem;\n\n\t\t...\n\n\t}\n\t```\n\n0. #### 检查证书的有效性\n\n\t打开浏览器，检查证书的有效性。\n\n0. #### 证书续期\n\n\tLet's Encrypt颁发的证书有期是90天，需要在过期前进行续期，好在Let's Encrypt已经提供了自动续期的脚本。\n\n\t官网说明，可以一天调用两次，如果检测到证书不需要更新，是什么都不做的，以减少意外造成的故障。\n\n\t先运行```certbot-auto renew --dry-run```命令检查证书自动续期是否正常，如果正常，将```certbot-auto renew --quiet```命令添加到系统的计划任务cron中，就可以实现证书自动续期了。\n\n\t```\n\t01 1 * * * ./path/to/certbot-auto renew --quiet\n\t```\n\t表示每天的1点1分自动执行续期脚本。\n\n\n\n\n\n","slug":"Let's Encrypt SSL","published":1,"updated":"2020-06-29T06:22:24.359Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckzf5sdyx0001yy8kr15yui10","content":"<h3 id=\"使用Let’s-Encrypt生成免费SSL证书\"><a href=\"#使用Let’s-Encrypt生成免费SSL证书\" class=\"headerlink\" title=\"使用Let’s Encrypt生成免费SSL证书\"></a>使用Let’s Encrypt生成免费SSL证书</h3><p>官网：<a href=\"https://letsencrypt.org/\" target=\"_blank\" rel=\"noopener\">Let’s Encrypt</a></p>\n<p>Let’s Encrypt是由互联网安全研究小组（ISRG，一个公益组织）提供的服务。提供免费、自动化、开放的证书签发服务。</p>\n<p>Let’s Encrypt颁发的证书有期是90天，需要在过期前进行续期，好在Let’s Encrypt已经提供了自动续期的脚本。</p>\n<p>官网推荐使用<a href=\"https://certbot.eff.org/\" target=\"_blank\" rel=\"noopener\">Certbot</a>工具来部署Https证书。在Certbot首页上选择Web服务器及服务器OS类型，我们在这里以Nginx + CentOS 6为例来说明。</p>\n<p>原文链接：<a href=\"https://certbot.eff.org/#centos6-nginx\" target=\"_blank\" rel=\"noopener\">https://certbot.eff.org/#centos6-nginx</a></p>\n<ol start=\"0\">\n<li><h4 id=\"生成证书\"><a href=\"#生成证书\" class=\"headerlink\" title=\"生成证书\"></a>生成证书</h4><ol start=\"0\">\n<li><p>安装证书生成工具certbot-auto：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://dl.eff.org/certbot-auto</span><br><span class=\"line\">chmod a+x certbot-auto</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>安装依赖</p>\n<p> 运行<figure class=\"highlight plain\"><figcaption><span>Command Not Found```，需要[安装pip](https://pip.pypa.io/en/stable/installing/)、virtualenv包：```pip install virtualenv```。</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">0. 配置Nginx</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t为需要配置https的站点添加以下配置，将访问/.well-known的请求指向本地目录。Let&apos;s Encrypt在生成证书的过程中，会在/var/www/www.xxx.com/.well-known目录生成一个临时文件，并且会访问类似于http://www.xxx.com/.well-known/acme-challenge/HGr8U1IeTW4kY_Z6UIyaakzOkyQgPr_7ArlLgtZE8SX的url，来检查域名配置是否有效。</span><br><span class=\"line\"></span><br><span class=\"line\">\t添加以下配置，并重启Nginx：nginx -s reload，如果reload不生效，可以试试restart。</span><br></pre></td></tr></table></figure></p>\n<p> server {</p>\n<pre><code>...            \n\nlocation /.well-known {\n    alias /var/www/www.xxx.com/.well-known;\n}\n\n...\n</code></pre><p> }</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">\t\t*即使证书生成之后，也需要保留Nginx的这一个配置，因为证书的续期还需要这一个配置。*</span><br><span class=\"line\"></span><br><span class=\"line\">\t0. 通过向导生成证书</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t运行```./certbot-auto certonly```，会通过向导方式一步一步来生成证书。过程中间会用到上一步在Nginx中配置的本地目录。</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t**对证书生成过程和原理比较熟悉的话，可以不使用向导方式，直接使用certbot-auto命令```./certbot-auto certonly --webroot -w /var/www/www.xxx.com -d xxx.com -d www.xxx.com -w /var/www/thing -d thing.is -d m.thing.is```可以快速高效地生成证书**</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t生成的证书默认在/etc/letsencrypt/live/www.xxx.com/目录。</span><br><span class=\"line\"></span><br><span class=\"line\">0. #### 配置Nginx使用证书</span><br><span class=\"line\"></span><br><span class=\"line\">\t添加以下配置，并重启Nginx：```nginx -s reload```，如果reload不生效，可以试试restart。</span><br></pre></td></tr></table></figure>\n<p>server {</p>\n<p> …<br> listen 443;</p>\n<p> ssl on;<br> ssl_stapling_verify on;<br> ssl_certificate         /etc/letsencrypt/live/<a href=\"http://www.xxx.com/fullchain.pem\" target=\"_blank\" rel=\"noopener\">www.xxx.com/fullchain.pem</a>;<br> ssl_certificate_key     /etc/letsencrypt/live/<a href=\"http://www.xxx.com/privkey.pem\" target=\"_blank\" rel=\"noopener\">www.xxx.com/privkey.pem</a>;</p>\n<p> …</p>\n<p>}</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">0. #### 检查证书的有效性</span><br><span class=\"line\"></span><br><span class=\"line\">\t打开浏览器，检查证书的有效性。</span><br><span class=\"line\"></span><br><span class=\"line\">0. #### 证书续期</span><br><span class=\"line\"></span><br><span class=\"line\">\tLet&apos;s Encrypt颁发的证书有期是90天，需要在过期前进行续期，好在Let&apos;s Encrypt已经提供了自动续期的脚本。</span><br><span class=\"line\"></span><br><span class=\"line\">\t官网说明，可以一天调用两次，如果检测到证书不需要更新，是什么都不做的，以减少意外造成的故障。</span><br><span class=\"line\"></span><br><span class=\"line\">\t先运行```certbot-auto renew --dry-run```命令检查证书自动续期是否正常，如果正常，将```certbot-auto renew --quiet```命令添加到系统的计划任务cron中，就可以实现证书自动续期了。</span><br></pre></td></tr></table></figure>\n<p>01 1 <em> </em> * ./path/to/certbot-auto renew –quiet<br><code>`</code><br>表示每天的1点1分自动执行续期脚本。</p>\n</li>\n</ol>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"使用Let’s-Encrypt生成免费SSL证书\"><a href=\"#使用Let’s-Encrypt生成免费SSL证书\" class=\"headerlink\" title=\"使用Let’s Encrypt生成免费SSL证书\"></a>使用Let’s Encrypt生成免费SSL证书</h3><p>官网：<a href=\"https://letsencrypt.org/\" target=\"_blank\" rel=\"noopener\">Let’s Encrypt</a></p>\n<p>Let’s Encrypt是由互联网安全研究小组（ISRG，一个公益组织）提供的服务。提供免费、自动化、开放的证书签发服务。</p>\n<p>Let’s Encrypt颁发的证书有期是90天，需要在过期前进行续期，好在Let’s Encrypt已经提供了自动续期的脚本。</p>\n<p>官网推荐使用<a href=\"https://certbot.eff.org/\" target=\"_blank\" rel=\"noopener\">Certbot</a>工具来部署Https证书。在Certbot首页上选择Web服务器及服务器OS类型，我们在这里以Nginx + CentOS 6为例来说明。</p>\n<p>原文链接：<a href=\"https://certbot.eff.org/#centos6-nginx\" target=\"_blank\" rel=\"noopener\">https://certbot.eff.org/#centos6-nginx</a></p>\n<ol start=\"0\">\n<li><h4 id=\"生成证书\"><a href=\"#生成证书\" class=\"headerlink\" title=\"生成证书\"></a>生成证书</h4><ol start=\"0\">\n<li><p>安装证书生成工具certbot-auto：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://dl.eff.org/certbot-auto</span><br><span class=\"line\">chmod a+x certbot-auto</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>安装依赖</p>\n<p> 运行<figure class=\"highlight plain\"><figcaption><span>Command Not Found```，需要[安装pip](https://pip.pypa.io/en/stable/installing/)、virtualenv包：```pip install virtualenv```。</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">0. 配置Nginx</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t为需要配置https的站点添加以下配置，将访问/.well-known的请求指向本地目录。Let&apos;s Encrypt在生成证书的过程中，会在/var/www/www.xxx.com/.well-known目录生成一个临时文件，并且会访问类似于http://www.xxx.com/.well-known/acme-challenge/HGr8U1IeTW4kY_Z6UIyaakzOkyQgPr_7ArlLgtZE8SX的url，来检查域名配置是否有效。</span><br><span class=\"line\"></span><br><span class=\"line\">\t添加以下配置，并重启Nginx：nginx -s reload，如果reload不生效，可以试试restart。</span><br></pre></td></tr></table></figure></p>\n<p> server {</p>\n<pre><code>...            \n\nlocation /.well-known {\n    alias /var/www/www.xxx.com/.well-known;\n}\n\n...\n</code></pre><p> }</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">\t\t*即使证书生成之后，也需要保留Nginx的这一个配置，因为证书的续期还需要这一个配置。*</span><br><span class=\"line\"></span><br><span class=\"line\">\t0. 通过向导生成证书</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t运行```./certbot-auto certonly```，会通过向导方式一步一步来生成证书。过程中间会用到上一步在Nginx中配置的本地目录。</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t**对证书生成过程和原理比较熟悉的话，可以不使用向导方式，直接使用certbot-auto命令```./certbot-auto certonly --webroot -w /var/www/www.xxx.com -d xxx.com -d www.xxx.com -w /var/www/thing -d thing.is -d m.thing.is```可以快速高效地生成证书**</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t生成的证书默认在/etc/letsencrypt/live/www.xxx.com/目录。</span><br><span class=\"line\"></span><br><span class=\"line\">0. #### 配置Nginx使用证书</span><br><span class=\"line\"></span><br><span class=\"line\">\t添加以下配置，并重启Nginx：```nginx -s reload```，如果reload不生效，可以试试restart。</span><br></pre></td></tr></table></figure>\n<p>server {</p>\n<p> …<br> listen 443;</p>\n<p> ssl on;<br> ssl_stapling_verify on;<br> ssl_certificate         /etc/letsencrypt/live/<a href=\"http://www.xxx.com/fullchain.pem\" target=\"_blank\" rel=\"noopener\">www.xxx.com/fullchain.pem</a>;<br> ssl_certificate_key     /etc/letsencrypt/live/<a href=\"http://www.xxx.com/privkey.pem\" target=\"_blank\" rel=\"noopener\">www.xxx.com/privkey.pem</a>;</p>\n<p> …</p>\n<p>}</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">0. #### 检查证书的有效性</span><br><span class=\"line\"></span><br><span class=\"line\">\t打开浏览器，检查证书的有效性。</span><br><span class=\"line\"></span><br><span class=\"line\">0. #### 证书续期</span><br><span class=\"line\"></span><br><span class=\"line\">\tLet&apos;s Encrypt颁发的证书有期是90天，需要在过期前进行续期，好在Let&apos;s Encrypt已经提供了自动续期的脚本。</span><br><span class=\"line\"></span><br><span class=\"line\">\t官网说明，可以一天调用两次，如果检测到证书不需要更新，是什么都不做的，以减少意外造成的故障。</span><br><span class=\"line\"></span><br><span class=\"line\">\t先运行```certbot-auto renew --dry-run```命令检查证书自动续期是否正常，如果正常，将```certbot-auto renew --quiet```命令添加到系统的计划任务cron中，就可以实现证书自动续期了。</span><br></pre></td></tr></table></figure>\n<p>01 1 <em> </em> * ./path/to/certbot-auto renew –quiet<br><code>`</code><br>表示每天的1点1分自动执行续期脚本。</p>\n</li>\n</ol>\n</li>\n</ol>\n"},{"title":"css","date":"2019-05-07T07:12:57.000Z","_content":"1. 它的定位效果完全受限于父级元素们。如果父元素的overflow属性设置了scroll，auto,overlay值，那么，粘性定位将会失效\n\n  当粘性约束矩形在可视范围内为relative，反之，则为fixed\n1. Webpack会先用css-loader去解析这个文件，遇到@import等语句就将相应样式文件引入，最后所有的CSS将使用style-loader生成一个内容为最终解析完的CSS代码的Style标签，放到head标签里。\n1. link属于HTML标签，而@import是css提供的；\n   页面被加载时，link会同时被加载，而 @import引用的css会等到页面被加载完再加载；\n   @import只在IE5以上才能识别，而link是XHTML标签，无兼容问题；\n   link方式的样式的权重高于@import的权重。\n1.  块级元素垂直居中—-高度不固定：transform(0,-50%) 或者 display:  table-cell vertical:middle\n1. flex-basis  可以设置比例\n1. 内联 > ID选择器 > 类选择器 > 标签选择器。\n1. transform 属于合成属性（composite property），对合成属性进行 transition/animation 动画将会创建一个合成层（composite layer），这使得被动画元素在一个独立的层中进行动画。通常情况下，浏览器会将一个层的内容先绘制进一个位图中，然后再作为纹理（texture）上传到 GPU，只要该层的内容不发生改变，就没必要进行重绘（repaint），浏览器会通过重新复合（recomposite）来形成一个新的帧。\n1. CSS3中，伪类与伪元素在语法上也有所区别，伪元素修改为以::开头。\n   \n``` text\n伪元素控制的内容和元素是没有差别的，但是它本身只是基于元素的抽象，并不存在于⽂档中，所以称为伪元素。⽤于将特殊的效果添加到某些选择器\n伪类：其核⼼就是⽤来选择DOM树之外的信息,不能够被普通选择器选择的⽂档之外的元素，⽤来添加⼀些选择器的特殊效果。\n⽐如:hover :active :visited :link :visited :first-child :focus :lang等\n\n伪类和伪元素都不出现在源⽂件和DOM树中。也就是说在html源⽂件中是看不到伪类和伪元素的。\n不同之处：\n伪类其实就是基于普通DOM元素⽽产⽣的不同状态，他是DOM元素的某⼀特征。\n伪元素能够创建在DOM树中不存在的抽象对象，⽽且这些抽象对象是能够访问到的。\n```\n\n1. Bem 是块（block）、元素（element）、修饰符（modifier）的简写，由 Yandex 团队提出的一种前端 CSS 命名方法论。\n   \n   `-` 中划线 ：仅作为连字符使用，表示某个块或者某个子元素的多单词之间的连接记号。\n\n   __ 双下划线：双下划线用来连接块和块的子元素\n\n   _ 单下划线：单下划线用来描述一个块或者块的子元素的一种状态\n\n2.  HTMLElement.offsetParent 是一个只读属性，返回一个指向最近的（指包含层级上的最近）包含该元素的定位元素或者最近的 table,td,th,body元素。当元素的 style.display 设置为 \"none\" 时，offsetParent 返回 null。offsetParent 很有用，因为 offsetTop 和 offsetLeft 都是相对于其内边距边界的。\n \n4. flex-basis 分配多余空间之前占据的主轴空间。\n5. 多行文本溢出隐藏变为...\n     p {\n       overflow: hidden;\n       \n       /* 限制在一个块元素显示的文本的行数，即行数设置 */\n       line-clamp: 3;\n      \n     }\n6. !important，作用是提高指定样式规则的应用优先权\n7. $border-color:#ccc !default; //声明变量 !default只能使用与变量中\n8.  sass 的控制指令\n```text \n      .el-col-0 {\n         display: none;\n       }\n\n       @for $i from 0 through 24 {\n         .el-col-#{$i} {\n           width: (1 / 24 * $i * 100) * 1%;\n         }\n       }\n ```\n1. 使用%定义一个被继承的样式，类似静态语言中的抽象类，他本身不起作用，只用于被其他人继承。\n  \n2. SCSS 是 Sass 3 引入新的语法，其语法完全兼容 CSS3，并且继承了 Sass 的强大功能。也就是说，任何标准的 CSS3 样式表都是具有相同语义的有效的 SCSS 文件\n\n3. SCSS提供了一个选择器可以选中当前元素的父元素，使用&表示.\n4. CSS的transition-delay属性规定了在过渡效果开始作用之前需要等待的时间。\n5. object-fit CSS 属性指定可替换元素的内容应该如何适应到其使用的高度和宽度确定的框。\n6. transform-origin CSS属性让你更改一个元素变形的原点。\n7.  响应式图像 srcSet \n```javastript\nreturn <img\n     src={src}\n     onError={this.handleError}\n     alt={alt}\n     srcSet={srcSet}\n     style={{ 'object-fit': fit }}/>;\n```\n1. CSS 的 outline 属性是在一条声明中设置多个轮廓属性的简写属性 ， 例如 outline-style, outline-width 和 outline-color。\n2. transition-property transition-duration transition-timing-function and transition-delay.\n1. cursor: not-allowed;\n1. inline-block的默认对齐方式是vertical-block：baseline，  vertical-align :middle\n1. !default 声明赋值的变量赋值，此时，如果变量已经被赋值，不会再被重新赋值，但是如果变量还没有被赋值，则会被赋予新的值。\n2. 属性嵌套：\n```css\ndiv {  \n\n  font: {  \n\n    size: 10px;  \n\n    weight: bold;  \n\n  }  }\n```\n\n4.   @minxin @include  @extend \n ```css\n @for $i from 1 through 1000 {\n    .#{unique-id()}-#{$i} {\n        ...\n    }\n}\n ```\n\n\n1. 支持布尔型的 and or 以及 not 运算。  @if  or or \n```css\n$i: 6;\n@while $i > 0 {\n  .item-#{$i} { width: 2em * $i; }\n  $i: $i - 2;\n}\n\n@for $i from 1 through 3 {\n  .item-#{$i} { width: 2em * $i; }\n}\n\n@each $animal in puma, sea-slug, egret, salamander {\n  .#{$animal}-icon {\n    background-image: url('/images/#{$animal}.png');\n  }\n}\n\n@each $animal, $color, $cursor in (puma, black, default),\n                                  (sea-slug, blue, pointer),\n                                  (egret, white, move) {\n  .#{$animal}-icon {\n    background-image: url('/images/#{$animal}.png');\n    border: 2px solid $color;\n    cursor: $cursor;\n  }\n}\n```\n1. css3 选择器\n```text\n:first-of-type\tp:first-of-type\t选择属于其父元素的首个 <p> 元素的每个 <p> 元素。\n:last-of-type\tp:last-of-type\t选择属于其父元素的最后 <p> 元素的每个 <p> 元素。\n\nelement element\tdiv p\t选择 <div> 元素内部的所有 <p> 元素。\t\nelement>element\tdiv>p\t选择父元素为 <div> 元素的所有 <p> 元素。\t\nelement+element\tdiv+p\t选择紧接在 <div> 元素之后的所有 <p> 元素。\n```\n1. scss \n   >@content\n ```text\n   @mixin colors($color: blue) {\n  background-color: $color;\n  @content;\n  border-color: $color;\n}\n.colors {\n  @include colors { color: $color; }\n}\n```\n1. async 会打乱html解析，defer 总是在html解析完成后执行。\n1. 伪元素(Pseudo-elements)\nDOM树没有定义的虚拟元素\n```text\n核⼼就是需要创建通常不存在于⽂档中的元素，\n\n```\n1.  fr 关键字：Grid 布局还引入了一个另外的长度单位来帮助我们创建灵活的网格轨道。fr 单位代表网格容器中可用空间的一等份。grid-template-columns: 200px 1fr 2fr 表示第一个列宽设置为 200px，后面剩余的宽度分为两部分，宽度分别为剩余宽度的 1/3 和 2/3。\n1. auto-fill 关键字：表示自动填充，让一行（或者一列）中尽可能的容纳更多的单元格。grid-template-columns: repeat(auto-fill, 200px) 表示列宽是 200 px，但列的数量是不固定的，只要浏览器能够容纳得下，就可以放置元素\n   \n2. flex Flex-grow flex-shrink flex-basis\n3. Flex 主轴（x）、交叉轴(y)\n4. calc函数是css3新增的功能，可以使用calc()计算border、margin、pading、font-size和width等属性设置动态值。   width: calc(100% - 200px);\n\n5. 触发BFC条件  BFC（Block Formatting Context）格式化上下文，把它理解成是一个独立的容器，并且这个容器里box的布局与这个容器外的box毫不相干。\n\n6. 递归 o(2**n)-》带备忘录 o(n),自顶向下-》动态规划（自底向上）\n  ```text\n  根元素\n  float的值不为none\n  overflow的值不为visible\n  display的值为inline-block、table-cell、table-caption\n  position的值为absolute、fixed\n  弹性盒（flex或inline-flex）\n  display: flow-root\n```\n\n1. Stylelint css 的lint  \n1. 多行文本： Table cell 垂直居中  vertical-align\n1. 块级：1. position absolute margin-top:-50px(translate(0,-50%))  2. Top 0 bottom 0  margin:auto\n1. 当元素浮动后不会影响块级元素的布局 只会影响内联元素的布局\n   \n   双飞布局时中间栏内容部分为两边腾开位置。\n\n1. 使用vw设置，vw也是一个相对单位，100vw等于屏幕宽度\n \n1. max-width/min-width > flex-basis > width > box\n \n1. writing-mode: vertical-rl;  设置文字方向\n1. text-align-last  描述的是一段文本中最后一行在被强制换行之前的对齐规则\n```text\njustify\n\n最后一行文字的开头与内容盒子的左侧对齐，末尾与右侧对齐\n\n```\n1.设置打印样式\n  \n  @media print {\n    /* print styles here. */\n  }. \n1. line-clamp 定义文字显示行数\n1. pointer-events: none; 禁用点击事件\n1. focus-within是一个伪类，现在已经被列入到CSS选择器中。当元素本身或其后代元素获得焦点时，:focus-within伪类的元素就会有效。 \n \n1. 但是有个好处是当元素没有内容时候，设置height:100%该元素不会被撑开，\n   \n   但是设置height:100vh，该元素会被撑开屏幕高度一致。 \n\n1. 伪类：\n   https://user-gold-cdn.xitu.io/2019/12/12/16ef8eecad4f1adb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\n   \n1. 伪元素用于创建一些不在文档树中的元素，并为其添加样式。比如说，我们可以通过:before来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。常见的伪元素有：::before，::after，::first-line，::first-letter，::selection、::placeholder等. 伪类和伪元素的区别在于有没有创建一个文档书之外的元素。\n1.    \n1. 这是一个叫做@font-face 的CSS @规则 ，它允许网页开发者为其网页指定在线字体。 通过这种作者自备字体的方式，@font-face 可以消除对用户电脑字体的依赖。\n\n2. overflow:https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow\n\n3. Element.scrollTop 属性可以获取或设置一个元素的内容垂直滚动的像素数。\n\n   offsetTop: 当前元素顶部距离最近父元素顶部的距离,和有没有滚动条没有关系。单位px，只读元素。\n\n  scrollHeight: 因为子元素比父元素高，父元素不想被子元素撑的一样高就显示出了滚动条，在滚动的过程中本元素有部分被隐藏了，scrollHeight代表包括当前不可见部分的元素的高度。而可见部分的高度其实就是clientHeight，也就是scrollHeight>=clientHeight恒成立。在有滚动条时讨论scrollHeight才有意义，在没有滚动条时scrollHeight==clientHeight恒成立。单位px，只读元素。\n\n   https://imweb.io/topic/57c5409e808fd2fb204eef52\n\n   clientheight offsetheight \n\n\n1. 相对位置：\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/position\n\n1. Image alt 属性是一个必需的属性，它规定在图像无法显示时的替代文本。\n\ntext-decoration 设置下划线等\nhttps://jsfiddle.net/ryansecreat/58um7k43/\n\n document​.active​Element\n\n 返回当前页面中获得焦点的元素,也就是说,如果此时用户按下了键盘上某个键,会在该元素上触发键盘事件.该属性是只读的.\n \n #### 性能  \n1. 尽量使用 flexbox 而不是老的布局模型。它运行速度更快，可为你的应用程序创造巨大的性能优势。\n1. 根据 Google Developer，渲染线程分为 主线程 (main thread) 和 合成线程 (compositor thread)。如果 CSS 动画只是改变 transforms 和 opacity，这时整个 CSS 动画得以在 合成线程完成（而JS动画则会在 主线程 执行，然后触发合成线程进行下一步操作），在 JS 执行一些昂贵的任务时，主线程繁忙，CSS 动画由于使用了合成线程可以保持流畅\n1. CSS动画有天然事件支持（TransitionEnd、AnimationEnd，但是它们都需要针对浏览器加前缀），JS则需要自己写事件。\n1. 在实现一些小的交互动效的时候，就多考虑考虑 CSS 动画。对于一些复杂控制的动画，使用 javascript 比较可靠。\n\n \n#### 内容对齐（justify-content）属性应用在弹性容器上，把弹性项沿着弹性容器的主轴线（main axis）对齐。\n       \n   align-items 设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式。\n\n   设置\"margin\"值为\"auto\"值，自动获取弹性容器中剩余的空间。所以设置垂直方向margin值为\"auto\"，可以使弹性子元素在弹性容器的两上轴方向都完全居中。 当容器为flex时会自动居中。\n   \n   如果在元素上设置了 box-sizing: border-box; 则 padding(内边距) 和 border(边框) 也包含在 width 和 height 中:\n   \n   transform: rotateX(120deg);  x轴旋转 \n   \n#### 不被选中\nbody{\n\n-webkit-touch-callout: none;\n\n-webkit-user-select: none;\n\n-khtml-user-select: none;\n\n-moz-user-select: none;\n\n-ms-user-select: none;\n\nuser-select: none;\n\n}\n\n#### 隐藏\n\n1.opacity：0,该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定了一些事件，如click事件也能触发 2.visibility:hidden,该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件 3.display:node, 把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删掉\n#### html 生成\n将html代码按照深度优先遍历来生成DOM树。 css文件下载完后也会进行渲染，生成相应的CSSOM。 当所有的css文件下载完且所有的CSSOM构建结束后，就会和DOM一起生成Render Tree。 接下来，浏览器就会进入Layout环节，将所有的节点位置计算出来。 最后，通过Painting环节将所有的节点内容呈现到屏幕上。\n #### base64\n TMLCanvasElement.toDataURL() 方法返回一个包含图片展示的 data URI 。可以使用 type 参数其类型，默认为 PNG 格式。图片的分辨率为96dpi。\n \n#### base64 渲染图片\n\n使用 Base64 编码渲染图片有以下优点：\n\n有效减少 HTTP 请求次数\n可对数据进行简单加密，无法肉眼获取信息\n没有跨域问题，无需考虑图片缓存\n凡事皆有利弊，使用 Base64 编码同时也会带来一些问题：\n\n编码后文件体积增大，仅适用于小体积图片编码\n增加了编码和解码的工作量\n不支持 IE 8.0 以下版本   \n\n#### 单位\n\n1. px：绝对单位，页面按精确像素展示\n2. em：相对单位，基准点为父节点字体的大小，如果自身定义了font-size按自身来计算（浏览器默认字体是16px），整个页面内1em不是一个固定的值\n3. rem：相对单位，可理解为”root em”, 相对根节点html的字体大小来计算，CSS3新加属性，chrome/firefox/IE9+支持\n4. vw：viewpoint width，视窗宽度，1vw等于视窗宽度的1%\n5. vh：viewpoint height，视窗高度，1vh等于视窗高度的1%\n6. vmin：vw和vh中较小的那个\n7. vmax：vw和vh中较大的那个\n8. %:百分比\n\n","source":"_posts/css.md","raw":"---\ntitle: css\ndate: 2019-05-07 15:12:57\ntags: css\n---\n1. 它的定位效果完全受限于父级元素们。如果父元素的overflow属性设置了scroll，auto,overlay值，那么，粘性定位将会失效\n\n  当粘性约束矩形在可视范围内为relative，反之，则为fixed\n1. Webpack会先用css-loader去解析这个文件，遇到@import等语句就将相应样式文件引入，最后所有的CSS将使用style-loader生成一个内容为最终解析完的CSS代码的Style标签，放到head标签里。\n1. link属于HTML标签，而@import是css提供的；\n   页面被加载时，link会同时被加载，而 @import引用的css会等到页面被加载完再加载；\n   @import只在IE5以上才能识别，而link是XHTML标签，无兼容问题；\n   link方式的样式的权重高于@import的权重。\n1.  块级元素垂直居中—-高度不固定：transform(0,-50%) 或者 display:  table-cell vertical:middle\n1. flex-basis  可以设置比例\n1. 内联 > ID选择器 > 类选择器 > 标签选择器。\n1. transform 属于合成属性（composite property），对合成属性进行 transition/animation 动画将会创建一个合成层（composite layer），这使得被动画元素在一个独立的层中进行动画。通常情况下，浏览器会将一个层的内容先绘制进一个位图中，然后再作为纹理（texture）上传到 GPU，只要该层的内容不发生改变，就没必要进行重绘（repaint），浏览器会通过重新复合（recomposite）来形成一个新的帧。\n1. CSS3中，伪类与伪元素在语法上也有所区别，伪元素修改为以::开头。\n   \n``` text\n伪元素控制的内容和元素是没有差别的，但是它本身只是基于元素的抽象，并不存在于⽂档中，所以称为伪元素。⽤于将特殊的效果添加到某些选择器\n伪类：其核⼼就是⽤来选择DOM树之外的信息,不能够被普通选择器选择的⽂档之外的元素，⽤来添加⼀些选择器的特殊效果。\n⽐如:hover :active :visited :link :visited :first-child :focus :lang等\n\n伪类和伪元素都不出现在源⽂件和DOM树中。也就是说在html源⽂件中是看不到伪类和伪元素的。\n不同之处：\n伪类其实就是基于普通DOM元素⽽产⽣的不同状态，他是DOM元素的某⼀特征。\n伪元素能够创建在DOM树中不存在的抽象对象，⽽且这些抽象对象是能够访问到的。\n```\n\n1. Bem 是块（block）、元素（element）、修饰符（modifier）的简写，由 Yandex 团队提出的一种前端 CSS 命名方法论。\n   \n   `-` 中划线 ：仅作为连字符使用，表示某个块或者某个子元素的多单词之间的连接记号。\n\n   __ 双下划线：双下划线用来连接块和块的子元素\n\n   _ 单下划线：单下划线用来描述一个块或者块的子元素的一种状态\n\n2.  HTMLElement.offsetParent 是一个只读属性，返回一个指向最近的（指包含层级上的最近）包含该元素的定位元素或者最近的 table,td,th,body元素。当元素的 style.display 设置为 \"none\" 时，offsetParent 返回 null。offsetParent 很有用，因为 offsetTop 和 offsetLeft 都是相对于其内边距边界的。\n \n4. flex-basis 分配多余空间之前占据的主轴空间。\n5. 多行文本溢出隐藏变为...\n     p {\n       overflow: hidden;\n       \n       /* 限制在一个块元素显示的文本的行数，即行数设置 */\n       line-clamp: 3;\n      \n     }\n6. !important，作用是提高指定样式规则的应用优先权\n7. $border-color:#ccc !default; //声明变量 !default只能使用与变量中\n8.  sass 的控制指令\n```text \n      .el-col-0 {\n         display: none;\n       }\n\n       @for $i from 0 through 24 {\n         .el-col-#{$i} {\n           width: (1 / 24 * $i * 100) * 1%;\n         }\n       }\n ```\n1. 使用%定义一个被继承的样式，类似静态语言中的抽象类，他本身不起作用，只用于被其他人继承。\n  \n2. SCSS 是 Sass 3 引入新的语法，其语法完全兼容 CSS3，并且继承了 Sass 的强大功能。也就是说，任何标准的 CSS3 样式表都是具有相同语义的有效的 SCSS 文件\n\n3. SCSS提供了一个选择器可以选中当前元素的父元素，使用&表示.\n4. CSS的transition-delay属性规定了在过渡效果开始作用之前需要等待的时间。\n5. object-fit CSS 属性指定可替换元素的内容应该如何适应到其使用的高度和宽度确定的框。\n6. transform-origin CSS属性让你更改一个元素变形的原点。\n7.  响应式图像 srcSet \n```javastript\nreturn <img\n     src={src}\n     onError={this.handleError}\n     alt={alt}\n     srcSet={srcSet}\n     style={{ 'object-fit': fit }}/>;\n```\n1. CSS 的 outline 属性是在一条声明中设置多个轮廓属性的简写属性 ， 例如 outline-style, outline-width 和 outline-color。\n2. transition-property transition-duration transition-timing-function and transition-delay.\n1. cursor: not-allowed;\n1. inline-block的默认对齐方式是vertical-block：baseline，  vertical-align :middle\n1. !default 声明赋值的变量赋值，此时，如果变量已经被赋值，不会再被重新赋值，但是如果变量还没有被赋值，则会被赋予新的值。\n2. 属性嵌套：\n```css\ndiv {  \n\n  font: {  \n\n    size: 10px;  \n\n    weight: bold;  \n\n  }  }\n```\n\n4.   @minxin @include  @extend \n ```css\n @for $i from 1 through 1000 {\n    .#{unique-id()}-#{$i} {\n        ...\n    }\n}\n ```\n\n\n1. 支持布尔型的 and or 以及 not 运算。  @if  or or \n```css\n$i: 6;\n@while $i > 0 {\n  .item-#{$i} { width: 2em * $i; }\n  $i: $i - 2;\n}\n\n@for $i from 1 through 3 {\n  .item-#{$i} { width: 2em * $i; }\n}\n\n@each $animal in puma, sea-slug, egret, salamander {\n  .#{$animal}-icon {\n    background-image: url('/images/#{$animal}.png');\n  }\n}\n\n@each $animal, $color, $cursor in (puma, black, default),\n                                  (sea-slug, blue, pointer),\n                                  (egret, white, move) {\n  .#{$animal}-icon {\n    background-image: url('/images/#{$animal}.png');\n    border: 2px solid $color;\n    cursor: $cursor;\n  }\n}\n```\n1. css3 选择器\n```text\n:first-of-type\tp:first-of-type\t选择属于其父元素的首个 <p> 元素的每个 <p> 元素。\n:last-of-type\tp:last-of-type\t选择属于其父元素的最后 <p> 元素的每个 <p> 元素。\n\nelement element\tdiv p\t选择 <div> 元素内部的所有 <p> 元素。\t\nelement>element\tdiv>p\t选择父元素为 <div> 元素的所有 <p> 元素。\t\nelement+element\tdiv+p\t选择紧接在 <div> 元素之后的所有 <p> 元素。\n```\n1. scss \n   >@content\n ```text\n   @mixin colors($color: blue) {\n  background-color: $color;\n  @content;\n  border-color: $color;\n}\n.colors {\n  @include colors { color: $color; }\n}\n```\n1. async 会打乱html解析，defer 总是在html解析完成后执行。\n1. 伪元素(Pseudo-elements)\nDOM树没有定义的虚拟元素\n```text\n核⼼就是需要创建通常不存在于⽂档中的元素，\n\n```\n1.  fr 关键字：Grid 布局还引入了一个另外的长度单位来帮助我们创建灵活的网格轨道。fr 单位代表网格容器中可用空间的一等份。grid-template-columns: 200px 1fr 2fr 表示第一个列宽设置为 200px，后面剩余的宽度分为两部分，宽度分别为剩余宽度的 1/3 和 2/3。\n1. auto-fill 关键字：表示自动填充，让一行（或者一列）中尽可能的容纳更多的单元格。grid-template-columns: repeat(auto-fill, 200px) 表示列宽是 200 px，但列的数量是不固定的，只要浏览器能够容纳得下，就可以放置元素\n   \n2. flex Flex-grow flex-shrink flex-basis\n3. Flex 主轴（x）、交叉轴(y)\n4. calc函数是css3新增的功能，可以使用calc()计算border、margin、pading、font-size和width等属性设置动态值。   width: calc(100% - 200px);\n\n5. 触发BFC条件  BFC（Block Formatting Context）格式化上下文，把它理解成是一个独立的容器，并且这个容器里box的布局与这个容器外的box毫不相干。\n\n6. 递归 o(2**n)-》带备忘录 o(n),自顶向下-》动态规划（自底向上）\n  ```text\n  根元素\n  float的值不为none\n  overflow的值不为visible\n  display的值为inline-block、table-cell、table-caption\n  position的值为absolute、fixed\n  弹性盒（flex或inline-flex）\n  display: flow-root\n```\n\n1. Stylelint css 的lint  \n1. 多行文本： Table cell 垂直居中  vertical-align\n1. 块级：1. position absolute margin-top:-50px(translate(0,-50%))  2. Top 0 bottom 0  margin:auto\n1. 当元素浮动后不会影响块级元素的布局 只会影响内联元素的布局\n   \n   双飞布局时中间栏内容部分为两边腾开位置。\n\n1. 使用vw设置，vw也是一个相对单位，100vw等于屏幕宽度\n \n1. max-width/min-width > flex-basis > width > box\n \n1. writing-mode: vertical-rl;  设置文字方向\n1. text-align-last  描述的是一段文本中最后一行在被强制换行之前的对齐规则\n```text\njustify\n\n最后一行文字的开头与内容盒子的左侧对齐，末尾与右侧对齐\n\n```\n1.设置打印样式\n  \n  @media print {\n    /* print styles here. */\n  }. \n1. line-clamp 定义文字显示行数\n1. pointer-events: none; 禁用点击事件\n1. focus-within是一个伪类，现在已经被列入到CSS选择器中。当元素本身或其后代元素获得焦点时，:focus-within伪类的元素就会有效。 \n \n1. 但是有个好处是当元素没有内容时候，设置height:100%该元素不会被撑开，\n   \n   但是设置height:100vh，该元素会被撑开屏幕高度一致。 \n\n1. 伪类：\n   https://user-gold-cdn.xitu.io/2019/12/12/16ef8eecad4f1adb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\n   \n1. 伪元素用于创建一些不在文档树中的元素，并为其添加样式。比如说，我们可以通过:before来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。常见的伪元素有：::before，::after，::first-line，::first-letter，::selection、::placeholder等. 伪类和伪元素的区别在于有没有创建一个文档书之外的元素。\n1.    \n1. 这是一个叫做@font-face 的CSS @规则 ，它允许网页开发者为其网页指定在线字体。 通过这种作者自备字体的方式，@font-face 可以消除对用户电脑字体的依赖。\n\n2. overflow:https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow\n\n3. Element.scrollTop 属性可以获取或设置一个元素的内容垂直滚动的像素数。\n\n   offsetTop: 当前元素顶部距离最近父元素顶部的距离,和有没有滚动条没有关系。单位px，只读元素。\n\n  scrollHeight: 因为子元素比父元素高，父元素不想被子元素撑的一样高就显示出了滚动条，在滚动的过程中本元素有部分被隐藏了，scrollHeight代表包括当前不可见部分的元素的高度。而可见部分的高度其实就是clientHeight，也就是scrollHeight>=clientHeight恒成立。在有滚动条时讨论scrollHeight才有意义，在没有滚动条时scrollHeight==clientHeight恒成立。单位px，只读元素。\n\n   https://imweb.io/topic/57c5409e808fd2fb204eef52\n\n   clientheight offsetheight \n\n\n1. 相对位置：\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/position\n\n1. Image alt 属性是一个必需的属性，它规定在图像无法显示时的替代文本。\n\ntext-decoration 设置下划线等\nhttps://jsfiddle.net/ryansecreat/58um7k43/\n\n document​.active​Element\n\n 返回当前页面中获得焦点的元素,也就是说,如果此时用户按下了键盘上某个键,会在该元素上触发键盘事件.该属性是只读的.\n \n #### 性能  \n1. 尽量使用 flexbox 而不是老的布局模型。它运行速度更快，可为你的应用程序创造巨大的性能优势。\n1. 根据 Google Developer，渲染线程分为 主线程 (main thread) 和 合成线程 (compositor thread)。如果 CSS 动画只是改变 transforms 和 opacity，这时整个 CSS 动画得以在 合成线程完成（而JS动画则会在 主线程 执行，然后触发合成线程进行下一步操作），在 JS 执行一些昂贵的任务时，主线程繁忙，CSS 动画由于使用了合成线程可以保持流畅\n1. CSS动画有天然事件支持（TransitionEnd、AnimationEnd，但是它们都需要针对浏览器加前缀），JS则需要自己写事件。\n1. 在实现一些小的交互动效的时候，就多考虑考虑 CSS 动画。对于一些复杂控制的动画，使用 javascript 比较可靠。\n\n \n#### 内容对齐（justify-content）属性应用在弹性容器上，把弹性项沿着弹性容器的主轴线（main axis）对齐。\n       \n   align-items 设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式。\n\n   设置\"margin\"值为\"auto\"值，自动获取弹性容器中剩余的空间。所以设置垂直方向margin值为\"auto\"，可以使弹性子元素在弹性容器的两上轴方向都完全居中。 当容器为flex时会自动居中。\n   \n   如果在元素上设置了 box-sizing: border-box; 则 padding(内边距) 和 border(边框) 也包含在 width 和 height 中:\n   \n   transform: rotateX(120deg);  x轴旋转 \n   \n#### 不被选中\nbody{\n\n-webkit-touch-callout: none;\n\n-webkit-user-select: none;\n\n-khtml-user-select: none;\n\n-moz-user-select: none;\n\n-ms-user-select: none;\n\nuser-select: none;\n\n}\n\n#### 隐藏\n\n1.opacity：0,该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定了一些事件，如click事件也能触发 2.visibility:hidden,该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件 3.display:node, 把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删掉\n#### html 生成\n将html代码按照深度优先遍历来生成DOM树。 css文件下载完后也会进行渲染，生成相应的CSSOM。 当所有的css文件下载完且所有的CSSOM构建结束后，就会和DOM一起生成Render Tree。 接下来，浏览器就会进入Layout环节，将所有的节点位置计算出来。 最后，通过Painting环节将所有的节点内容呈现到屏幕上。\n #### base64\n TMLCanvasElement.toDataURL() 方法返回一个包含图片展示的 data URI 。可以使用 type 参数其类型，默认为 PNG 格式。图片的分辨率为96dpi。\n \n#### base64 渲染图片\n\n使用 Base64 编码渲染图片有以下优点：\n\n有效减少 HTTP 请求次数\n可对数据进行简单加密，无法肉眼获取信息\n没有跨域问题，无需考虑图片缓存\n凡事皆有利弊，使用 Base64 编码同时也会带来一些问题：\n\n编码后文件体积增大，仅适用于小体积图片编码\n增加了编码和解码的工作量\n不支持 IE 8.0 以下版本   \n\n#### 单位\n\n1. px：绝对单位，页面按精确像素展示\n2. em：相对单位，基准点为父节点字体的大小，如果自身定义了font-size按自身来计算（浏览器默认字体是16px），整个页面内1em不是一个固定的值\n3. rem：相对单位，可理解为”root em”, 相对根节点html的字体大小来计算，CSS3新加属性，chrome/firefox/IE9+支持\n4. vw：viewpoint width，视窗宽度，1vw等于视窗宽度的1%\n5. vh：viewpoint height，视窗高度，1vh等于视窗高度的1%\n6. vmin：vw和vh中较小的那个\n7. vmax：vw和vh中较大的那个\n8. %:百分比\n\n","slug":"css","published":1,"updated":"2020-08-26T02:20:35.523Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckzf5sdz00003yy8kwrbubbr1","content":"<ol>\n<li><p>它的定位效果完全受限于父级元素们。如果父元素的overflow属性设置了scroll，auto,overlay值，那么，粘性定位将会失效</p>\n<p>当粘性约束矩形在可视范围内为relative，反之，则为fixed</p>\n</li>\n<li>Webpack会先用css-loader去解析这个文件，遇到@import等语句就将相应样式文件引入，最后所有的CSS将使用style-loader生成一个内容为最终解析完的CSS代码的Style标签，放到head标签里。</li>\n<li>link属于HTML标签，而@import是css提供的；<br>页面被加载时，link会同时被加载，而 @import引用的css会等到页面被加载完再加载；<br>@import只在IE5以上才能识别，而link是XHTML标签，无兼容问题；<br>link方式的样式的权重高于@import的权重。</li>\n<li>块级元素垂直居中—-高度不固定：transform(0,-50%) 或者 display:  table-cell vertical:middle</li>\n<li>flex-basis  可以设置比例</li>\n<li>内联 &gt; ID选择器 &gt; 类选择器 &gt; 标签选择器。</li>\n<li>transform 属于合成属性（composite property），对合成属性进行 transition/animation 动画将会创建一个合成层（composite layer），这使得被动画元素在一个独立的层中进行动画。通常情况下，浏览器会将一个层的内容先绘制进一个位图中，然后再作为纹理（texture）上传到 GPU，只要该层的内容不发生改变，就没必要进行重绘（repaint），浏览器会通过重新复合（recomposite）来形成一个新的帧。</li>\n<li>CSS3中，伪类与伪元素在语法上也有所区别，伪元素修改为以::开头。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">伪元素控制的内容和元素是没有差别的，但是它本身只是基于元素的抽象，并不存在于⽂档中，所以称为伪元素。⽤于将特殊的效果添加到某些选择器</span><br><span class=\"line\">伪类：其核⼼就是⽤来选择DOM树之外的信息,不能够被普通选择器选择的⽂档之外的元素，⽤来添加⼀些选择器的特殊效果。</span><br><span class=\"line\">⽐如:hover :active :visited :link :visited :first-child :focus :lang等</span><br><span class=\"line\"></span><br><span class=\"line\">伪类和伪元素都不出现在源⽂件和DOM树中。也就是说在html源⽂件中是看不到伪类和伪元素的。</span><br><span class=\"line\">不同之处：</span><br><span class=\"line\">伪类其实就是基于普通DOM元素⽽产⽣的不同状态，他是DOM元素的某⼀特征。</span><br><span class=\"line\">伪元素能够创建在DOM树中不存在的抽象对象，⽽且这些抽象对象是能够访问到的。</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p>Bem 是块（block）、元素（element）、修饰符（modifier）的简写，由 Yandex 团队提出的一种前端 CSS 命名方法论。</p>\n<p><code>-</code> 中划线 ：仅作为连字符使用，表示某个块或者某个子元素的多单词之间的连接记号。</p>\n<p>__ 双下划线：双下划线用来连接块和块的子元素</p>\n<p>_ 单下划线：单下划线用来描述一个块或者块的子元素的一种状态</p>\n</li>\n<li><p>HTMLElement.offsetParent 是一个只读属性，返回一个指向最近的（指包含层级上的最近）包含该元素的定位元素或者最近的 table,td,th,body元素。当元素的 style.display 设置为 “none” 时，offsetParent 返回 null。offsetParent 很有用，因为 offsetTop 和 offsetLeft 都是相对于其内边距边界的。</p>\n</li>\n<li><p>flex-basis 分配多余空间之前占据的主轴空间。</p>\n</li>\n<li><p>多行文本溢出隐藏变为…<br>  p {</p>\n<pre><code>overflow: hidden;\n\n/* 限制在一个块元素显示的文本的行数，即行数设置 */\nline-clamp: 3;\n</code></pre><p>  }</p>\n</li>\n<li>!important，作用是提高指定样式规则的应用优先权</li>\n<li>$border-color:#ccc !default; //声明变量 !default只能使用与变量中</li>\n<li><p>sass 的控制指令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.el-col-0 &#123;</span><br><span class=\"line\">   display: none;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> @for $i from 0 through 24 &#123;</span><br><span class=\"line\">   .el-col-#&#123;$i&#125; &#123;</span><br><span class=\"line\">     width: (1 / 24 * $i * 100) * 1%;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用%定义一个被继承的样式，类似静态语言中的抽象类，他本身不起作用，只用于被其他人继承。</p>\n</li>\n<li><p>SCSS 是 Sass 3 引入新的语法，其语法完全兼容 CSS3，并且继承了 Sass 的强大功能。也就是说，任何标准的 CSS3 样式表都是具有相同语义的有效的 SCSS 文件</p>\n</li>\n<li><p>SCSS提供了一个选择器可以选中当前元素的父元素，使用&amp;表示.</p>\n</li>\n<li>CSS的transition-delay属性规定了在过渡效果开始作用之前需要等待的时间。</li>\n<li>object-fit CSS 属性指定可替换元素的内容应该如何适应到其使用的高度和宽度确定的框。</li>\n<li>transform-origin CSS属性让你更改一个元素变形的原点。</li>\n<li><p>响应式图像 srcSet </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">return &lt;img</span><br><span class=\"line\">     src=&#123;src&#125;</span><br><span class=\"line\">     onError=&#123;this.handleError&#125;</span><br><span class=\"line\">     alt=&#123;alt&#125;</span><br><span class=\"line\">     srcSet=&#123;srcSet&#125;</span><br><span class=\"line\">     style=&#123;&#123; &apos;object-fit&apos;: fit &#125;&#125;/&gt;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>CSS 的 outline 属性是在一条声明中设置多个轮廓属性的简写属性 ， 例如 outline-style, outline-width 和 outline-color。</p>\n</li>\n<li>transition-property transition-duration transition-timing-function and transition-delay.</li>\n<li>cursor: not-allowed;</li>\n<li>inline-block的默认对齐方式是vertical-block：baseline，  vertical-align :middle</li>\n<li>!default 声明赋值的变量赋值，此时，如果变量已经被赋值，不会再被重新赋值，但是如果变量还没有被赋值，则会被赋予新的值。</li>\n<li><p>属性嵌套：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span> &#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attribute\">font</span>: &#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">    size: <span class=\"number\">10px</span>;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attribute\">weight</span>: bold;  </span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;  &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>@minxin @include  @extend </p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">@for</span> $i from <span class=\"number\">1</span> through <span class=\"number\">1000</span> &#123;</span><br><span class=\"line\">    .#&#123;unique-id()&#125;-#&#123;$i&#125; &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>支持布尔型的 and or 以及 not 运算。  @if  or or </p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$i: 6;</span><br><span class=\"line\"><span class=\"keyword\">@while</span> $i &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">  .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125;</span><br><span class=\"line\">  $i: $i - 2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@for</span> $i from <span class=\"number\">1</span> through <span class=\"number\">3</span> &#123;</span><br><span class=\"line\">  .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@each</span> $animal in puma, sea-slug, egret, salamander &#123;</span><br><span class=\"line\">  .#&#123;$animal&#125;-icon &#123;</span><br><span class=\"line\">    background-image: url('/images/#&#123;$animal&#125;.png');</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@each</span> $animal, $color, $cursor in (puma, black, default),</span><br><span class=\"line\">                                  (sea-slug, blue, pointer),</span><br><span class=\"line\">                                  (egret, white, move) &#123;</span><br><span class=\"line\">  .#&#123;$animal&#125;-icon &#123;</span><br><span class=\"line\">    background-image: url('/images/#&#123;$animal&#125;.png');</span><br><span class=\"line\">    border: 2px solid $color;</span><br><span class=\"line\">    cursor: $cursor;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>css3 选择器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:first-of-type\tp:first-of-type\t选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class=\"line\">:last-of-type\tp:last-of-type\t选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class=\"line\"></span><br><span class=\"line\">element element\tdiv p\t选择 &lt;div&gt; 元素内部的所有 &lt;p&gt; 元素。\t</span><br><span class=\"line\">element&gt;element\tdiv&gt;p\t选择父元素为 &lt;div&gt; 元素的所有 &lt;p&gt; 元素。\t</span><br><span class=\"line\">element+element\tdiv+p\t选择紧接在 &lt;div&gt; 元素之后的所有 &lt;p&gt; 元素。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>scss </p>\n<blockquote>\n<p>@content</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   @mixin colors($color: blue) &#123;</span><br><span class=\"line\">  background-color: $color;</span><br><span class=\"line\">  @content;</span><br><span class=\"line\">  border-color: $color;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.colors &#123;</span><br><span class=\"line\">  @include colors &#123; color: $color; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n<li><p>async 会打乱html解析，defer 总是在html解析完成后执行。</p>\n</li>\n<li><p>伪元素(Pseudo-elements)<br>DOM树没有定义的虚拟元素</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">核⼼就是需要创建通常不存在于⽂档中的元素，</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>fr 关键字：Grid 布局还引入了一个另外的长度单位来帮助我们创建灵活的网格轨道。fr 单位代表网格容器中可用空间的一等份。grid-template-columns: 200px 1fr 2fr 表示第一个列宽设置为 200px，后面剩余的宽度分为两部分，宽度分别为剩余宽度的 1/3 和 2/3。</p>\n</li>\n<li><p>auto-fill 关键字：表示自动填充，让一行（或者一列）中尽可能的容纳更多的单元格。grid-template-columns: repeat(auto-fill, 200px) 表示列宽是 200 px，但列的数量是不固定的，只要浏览器能够容纳得下，就可以放置元素</p>\n</li>\n<li><p>flex Flex-grow flex-shrink flex-basis</p>\n</li>\n<li>Flex 主轴（x）、交叉轴(y)</li>\n<li><p>calc函数是css3新增的功能，可以使用calc()计算border、margin、pading、font-size和width等属性设置动态值。   width: calc(100% - 200px);</p>\n</li>\n<li><p>触发BFC条件  BFC（Block Formatting Context）格式化上下文，把它理解成是一个独立的容器，并且这个容器里box的布局与这个容器外的box毫不相干。</p>\n</li>\n<li><p>递归 o(2**n)-》带备忘录 o(n),自顶向下-》动态规划（自底向上）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">根元素</span><br><span class=\"line\">float的值不为none</span><br><span class=\"line\">overflow的值不为visible</span><br><span class=\"line\">display的值为inline-block、table-cell、table-caption</span><br><span class=\"line\">position的值为absolute、fixed</span><br><span class=\"line\">弹性盒（flex或inline-flex）</span><br><span class=\"line\">display: flow-root</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Stylelint css 的lint  </p>\n</li>\n<li>多行文本： Table cell 垂直居中  vertical-align</li>\n<li>块级：1. position absolute margin-top:-50px(translate(0,-50%))  2. Top 0 bottom 0  margin:auto</li>\n<li><p>当元素浮动后不会影响块级元素的布局 只会影响内联元素的布局</p>\n<p>双飞布局时中间栏内容部分为两边腾开位置。</p>\n</li>\n<li><p>使用vw设置，vw也是一个相对单位，100vw等于屏幕宽度</p>\n</li>\n<li><p>max-width/min-width &gt; flex-basis &gt; width &gt; box</p>\n</li>\n<li><p>writing-mode: vertical-rl;  设置文字方向</p>\n</li>\n<li>text-align-last  描述的是一段文本中最后一行在被强制换行之前的对齐规则<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">justify</span><br><span class=\"line\"></span><br><span class=\"line\">最后一行文字的开头与内容盒子的左侧对齐，末尾与右侧对齐</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>1.设置打印样式</p>\n<p>  @media print {<br>    /<em> print styles here. </em>/<br>  }. </p>\n<ol>\n<li>line-clamp 定义文字显示行数</li>\n<li>pointer-events: none; 禁用点击事件</li>\n<li><p>focus-within是一个伪类，现在已经被列入到CSS选择器中。当元素本身或其后代元素获得焦点时，:focus-within伪类的元素就会有效。 </p>\n</li>\n<li><p>但是有个好处是当元素没有内容时候，设置height:100%该元素不会被撑开，</p>\n<p>但是设置height:100vh，该元素会被撑开屏幕高度一致。 </p>\n</li>\n<li><p>伪类：<br><a href=\"https://user-gold-cdn.xitu.io/2019/12/12/16ef8eecad4f1adb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" target=\"_blank\" rel=\"noopener\">https://user-gold-cdn.xitu.io/2019/12/12/16ef8eecad4f1adb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1</a></p>\n</li>\n<li><p>伪元素用于创建一些不在文档树中的元素，并为其添加样式。比如说，我们可以通过:before来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。常见的伪元素有：::before，::after，::first-line，::first-letter，::selection、::placeholder等. 伪类和伪元素的区别在于有没有创建一个文档书之外的元素。</p>\n</li>\n<li></li>\n<li><p>这是一个叫做@font-face 的CSS @规则 ，它允许网页开发者为其网页指定在线字体。 通过这种作者自备字体的方式，@font-face 可以消除对用户电脑字体的依赖。</p>\n</li>\n<li><p>overflow:<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow</a></p>\n</li>\n<li><p>Element.scrollTop 属性可以获取或设置一个元素的内容垂直滚动的像素数。</p>\n<p>offsetTop: 当前元素顶部距离最近父元素顶部的距离,和有没有滚动条没有关系。单位px，只读元素。</p>\n<p>scrollHeight: 因为子元素比父元素高，父元素不想被子元素撑的一样高就显示出了滚动条，在滚动的过程中本元素有部分被隐藏了，scrollHeight代表包括当前不可见部分的元素的高度。而可见部分的高度其实就是clientHeight，也就是scrollHeight&gt;=clientHeight恒成立。在有滚动条时讨论scrollHeight才有意义，在没有滚动条时scrollHeight==clientHeight恒成立。单位px，只读元素。</p>\n<p><a href=\"https://imweb.io/topic/57c5409e808fd2fb204eef52\" target=\"_blank\" rel=\"noopener\">https://imweb.io/topic/57c5409e808fd2fb204eef52</a></p>\n<p>clientheight offsetheight </p>\n</li>\n</ol>\n<ol>\n<li><p>相对位置：<br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/position\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/position</a></p>\n</li>\n<li><p>Image alt 属性是一个必需的属性，它规定在图像无法显示时的替代文本。</p>\n</li>\n</ol>\n<p>text-decoration 设置下划线等<br><a href=\"https://jsfiddle.net/ryansecreat/58um7k43/\" target=\"_blank\" rel=\"noopener\">https://jsfiddle.net/ryansecreat/58um7k43/</a></p>\n<p> document​.active​Element</p>\n<p> 返回当前页面中获得焦点的元素,也就是说,如果此时用户按下了键盘上某个键,会在该元素上触发键盘事件.该属性是只读的.</p>\n<h4 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h4><ol>\n<li>尽量使用 flexbox 而不是老的布局模型。它运行速度更快，可为你的应用程序创造巨大的性能优势。</li>\n<li>根据 Google Developer，渲染线程分为 主线程 (main thread) 和 合成线程 (compositor thread)。如果 CSS 动画只是改变 transforms 和 opacity，这时整个 CSS 动画得以在 合成线程完成（而JS动画则会在 主线程 执行，然后触发合成线程进行下一步操作），在 JS 执行一些昂贵的任务时，主线程繁忙，CSS 动画由于使用了合成线程可以保持流畅</li>\n<li>CSS动画有天然事件支持（TransitionEnd、AnimationEnd，但是它们都需要针对浏览器加前缀），JS则需要自己写事件。</li>\n<li>在实现一些小的交互动效的时候，就多考虑考虑 CSS 动画。对于一些复杂控制的动画，使用 javascript 比较可靠。</li>\n</ol>\n<h4 id=\"内容对齐（justify-content）属性应用在弹性容器上，把弹性项沿着弹性容器的主轴线（main-axis）对齐。\"><a href=\"#内容对齐（justify-content）属性应用在弹性容器上，把弹性项沿着弹性容器的主轴线（main-axis）对齐。\" class=\"headerlink\" title=\"内容对齐（justify-content）属性应用在弹性容器上，把弹性项沿着弹性容器的主轴线（main axis）对齐。\"></a>内容对齐（justify-content）属性应用在弹性容器上，把弹性项沿着弹性容器的主轴线（main axis）对齐。</h4><p>   align-items 设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式。</p>\n<p>   设置”margin”值为”auto”值，自动获取弹性容器中剩余的空间。所以设置垂直方向margin值为”auto”，可以使弹性子元素在弹性容器的两上轴方向都完全居中。 当容器为flex时会自动居中。</p>\n<p>   如果在元素上设置了 box-sizing: border-box; 则 padding(内边距) 和 border(边框) 也包含在 width 和 height 中:</p>\n<p>   transform: rotateX(120deg);  x轴旋转 </p>\n<h4 id=\"不被选中\"><a href=\"#不被选中\" class=\"headerlink\" title=\"不被选中\"></a>不被选中</h4><p>body{</p>\n<p>-webkit-touch-callout: none;</p>\n<p>-webkit-user-select: none;</p>\n<p>-khtml-user-select: none;</p>\n<p>-moz-user-select: none;</p>\n<p>-ms-user-select: none;</p>\n<p>user-select: none;</p>\n<p>}</p>\n<h4 id=\"隐藏\"><a href=\"#隐藏\" class=\"headerlink\" title=\"隐藏\"></a>隐藏</h4><p>1.opacity：0,该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定了一些事件，如click事件也能触发 2.visibility:hidden,该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件 3.display:node, 把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删掉</p>\n<h4 id=\"html-生成\"><a href=\"#html-生成\" class=\"headerlink\" title=\"html 生成\"></a>html 生成</h4><p>将html代码按照深度优先遍历来生成DOM树。 css文件下载完后也会进行渲染，生成相应的CSSOM。 当所有的css文件下载完且所有的CSSOM构建结束后，就会和DOM一起生成Render Tree。 接下来，浏览器就会进入Layout环节，将所有的节点位置计算出来。 最后，通过Painting环节将所有的节点内容呈现到屏幕上。</p>\n<h4 id=\"base64\"><a href=\"#base64\" class=\"headerlink\" title=\"base64\"></a>base64</h4><p> TMLCanvasElement.toDataURL() 方法返回一个包含图片展示的 data URI 。可以使用 type 参数其类型，默认为 PNG 格式。图片的分辨率为96dpi。</p>\n<h4 id=\"base64-渲染图片\"><a href=\"#base64-渲染图片\" class=\"headerlink\" title=\"base64 渲染图片\"></a>base64 渲染图片</h4><p>使用 Base64 编码渲染图片有以下优点：</p>\n<p>有效减少 HTTP 请求次数<br>可对数据进行简单加密，无法肉眼获取信息<br>没有跨域问题，无需考虑图片缓存<br>凡事皆有利弊，使用 Base64 编码同时也会带来一些问题：</p>\n<p>编码后文件体积增大，仅适用于小体积图片编码<br>增加了编码和解码的工作量<br>不支持 IE 8.0 以下版本   </p>\n<h4 id=\"单位\"><a href=\"#单位\" class=\"headerlink\" title=\"单位\"></a>单位</h4><ol>\n<li>px：绝对单位，页面按精确像素展示</li>\n<li>em：相对单位，基准点为父节点字体的大小，如果自身定义了font-size按自身来计算（浏览器默认字体是16px），整个页面内1em不是一个固定的值</li>\n<li>rem：相对单位，可理解为”root em”, 相对根节点html的字体大小来计算，CSS3新加属性，chrome/firefox/IE9+支持</li>\n<li>vw：viewpoint width，视窗宽度，1vw等于视窗宽度的1%</li>\n<li>vh：viewpoint height，视窗高度，1vh等于视窗高度的1%</li>\n<li>vmin：vw和vh中较小的那个</li>\n<li>vmax：vw和vh中较大的那个</li>\n<li>%:百分比</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><p>它的定位效果完全受限于父级元素们。如果父元素的overflow属性设置了scroll，auto,overlay值，那么，粘性定位将会失效</p>\n<p>当粘性约束矩形在可视范围内为relative，反之，则为fixed</p>\n</li>\n<li>Webpack会先用css-loader去解析这个文件，遇到@import等语句就将相应样式文件引入，最后所有的CSS将使用style-loader生成一个内容为最终解析完的CSS代码的Style标签，放到head标签里。</li>\n<li>link属于HTML标签，而@import是css提供的；<br>页面被加载时，link会同时被加载，而 @import引用的css会等到页面被加载完再加载；<br>@import只在IE5以上才能识别，而link是XHTML标签，无兼容问题；<br>link方式的样式的权重高于@import的权重。</li>\n<li>块级元素垂直居中—-高度不固定：transform(0,-50%) 或者 display:  table-cell vertical:middle</li>\n<li>flex-basis  可以设置比例</li>\n<li>内联 &gt; ID选择器 &gt; 类选择器 &gt; 标签选择器。</li>\n<li>transform 属于合成属性（composite property），对合成属性进行 transition/animation 动画将会创建一个合成层（composite layer），这使得被动画元素在一个独立的层中进行动画。通常情况下，浏览器会将一个层的内容先绘制进一个位图中，然后再作为纹理（texture）上传到 GPU，只要该层的内容不发生改变，就没必要进行重绘（repaint），浏览器会通过重新复合（recomposite）来形成一个新的帧。</li>\n<li>CSS3中，伪类与伪元素在语法上也有所区别，伪元素修改为以::开头。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">伪元素控制的内容和元素是没有差别的，但是它本身只是基于元素的抽象，并不存在于⽂档中，所以称为伪元素。⽤于将特殊的效果添加到某些选择器</span><br><span class=\"line\">伪类：其核⼼就是⽤来选择DOM树之外的信息,不能够被普通选择器选择的⽂档之外的元素，⽤来添加⼀些选择器的特殊效果。</span><br><span class=\"line\">⽐如:hover :active :visited :link :visited :first-child :focus :lang等</span><br><span class=\"line\"></span><br><span class=\"line\">伪类和伪元素都不出现在源⽂件和DOM树中。也就是说在html源⽂件中是看不到伪类和伪元素的。</span><br><span class=\"line\">不同之处：</span><br><span class=\"line\">伪类其实就是基于普通DOM元素⽽产⽣的不同状态，他是DOM元素的某⼀特征。</span><br><span class=\"line\">伪元素能够创建在DOM树中不存在的抽象对象，⽽且这些抽象对象是能够访问到的。</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p>Bem 是块（block）、元素（element）、修饰符（modifier）的简写，由 Yandex 团队提出的一种前端 CSS 命名方法论。</p>\n<p><code>-</code> 中划线 ：仅作为连字符使用，表示某个块或者某个子元素的多单词之间的连接记号。</p>\n<p>__ 双下划线：双下划线用来连接块和块的子元素</p>\n<p>_ 单下划线：单下划线用来描述一个块或者块的子元素的一种状态</p>\n</li>\n<li><p>HTMLElement.offsetParent 是一个只读属性，返回一个指向最近的（指包含层级上的最近）包含该元素的定位元素或者最近的 table,td,th,body元素。当元素的 style.display 设置为 “none” 时，offsetParent 返回 null。offsetParent 很有用，因为 offsetTop 和 offsetLeft 都是相对于其内边距边界的。</p>\n</li>\n<li><p>flex-basis 分配多余空间之前占据的主轴空间。</p>\n</li>\n<li><p>多行文本溢出隐藏变为…<br>  p {</p>\n<pre><code>overflow: hidden;\n\n/* 限制在一个块元素显示的文本的行数，即行数设置 */\nline-clamp: 3;\n</code></pre><p>  }</p>\n</li>\n<li>!important，作用是提高指定样式规则的应用优先权</li>\n<li>$border-color:#ccc !default; //声明变量 !default只能使用与变量中</li>\n<li><p>sass 的控制指令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.el-col-0 &#123;</span><br><span class=\"line\">   display: none;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> @for $i from 0 through 24 &#123;</span><br><span class=\"line\">   .el-col-#&#123;$i&#125; &#123;</span><br><span class=\"line\">     width: (1 / 24 * $i * 100) * 1%;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用%定义一个被继承的样式，类似静态语言中的抽象类，他本身不起作用，只用于被其他人继承。</p>\n</li>\n<li><p>SCSS 是 Sass 3 引入新的语法，其语法完全兼容 CSS3，并且继承了 Sass 的强大功能。也就是说，任何标准的 CSS3 样式表都是具有相同语义的有效的 SCSS 文件</p>\n</li>\n<li><p>SCSS提供了一个选择器可以选中当前元素的父元素，使用&amp;表示.</p>\n</li>\n<li>CSS的transition-delay属性规定了在过渡效果开始作用之前需要等待的时间。</li>\n<li>object-fit CSS 属性指定可替换元素的内容应该如何适应到其使用的高度和宽度确定的框。</li>\n<li>transform-origin CSS属性让你更改一个元素变形的原点。</li>\n<li><p>响应式图像 srcSet </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">return &lt;img</span><br><span class=\"line\">     src=&#123;src&#125;</span><br><span class=\"line\">     onError=&#123;this.handleError&#125;</span><br><span class=\"line\">     alt=&#123;alt&#125;</span><br><span class=\"line\">     srcSet=&#123;srcSet&#125;</span><br><span class=\"line\">     style=&#123;&#123; &apos;object-fit&apos;: fit &#125;&#125;/&gt;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>CSS 的 outline 属性是在一条声明中设置多个轮廓属性的简写属性 ， 例如 outline-style, outline-width 和 outline-color。</p>\n</li>\n<li>transition-property transition-duration transition-timing-function and transition-delay.</li>\n<li>cursor: not-allowed;</li>\n<li>inline-block的默认对齐方式是vertical-block：baseline，  vertical-align :middle</li>\n<li>!default 声明赋值的变量赋值，此时，如果变量已经被赋值，不会再被重新赋值，但是如果变量还没有被赋值，则会被赋予新的值。</li>\n<li><p>属性嵌套：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span> &#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attribute\">font</span>: &#123;  </span><br><span class=\"line\"></span><br><span class=\"line\">    size: <span class=\"number\">10px</span>;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attribute\">weight</span>: bold;  </span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;  &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>@minxin @include  @extend </p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">@for</span> $i from <span class=\"number\">1</span> through <span class=\"number\">1000</span> &#123;</span><br><span class=\"line\">    .#&#123;unique-id()&#125;-#&#123;$i&#125; &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>支持布尔型的 and or 以及 not 运算。  @if  or or </p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$i: 6;</span><br><span class=\"line\"><span class=\"keyword\">@while</span> $i &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">  .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125;</span><br><span class=\"line\">  $i: $i - 2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@for</span> $i from <span class=\"number\">1</span> through <span class=\"number\">3</span> &#123;</span><br><span class=\"line\">  .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@each</span> $animal in puma, sea-slug, egret, salamander &#123;</span><br><span class=\"line\">  .#&#123;$animal&#125;-icon &#123;</span><br><span class=\"line\">    background-image: url('/images/#&#123;$animal&#125;.png');</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@each</span> $animal, $color, $cursor in (puma, black, default),</span><br><span class=\"line\">                                  (sea-slug, blue, pointer),</span><br><span class=\"line\">                                  (egret, white, move) &#123;</span><br><span class=\"line\">  .#&#123;$animal&#125;-icon &#123;</span><br><span class=\"line\">    background-image: url('/images/#&#123;$animal&#125;.png');</span><br><span class=\"line\">    border: 2px solid $color;</span><br><span class=\"line\">    cursor: $cursor;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>css3 选择器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:first-of-type\tp:first-of-type\t选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class=\"line\">:last-of-type\tp:last-of-type\t选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class=\"line\"></span><br><span class=\"line\">element element\tdiv p\t选择 &lt;div&gt; 元素内部的所有 &lt;p&gt; 元素。\t</span><br><span class=\"line\">element&gt;element\tdiv&gt;p\t选择父元素为 &lt;div&gt; 元素的所有 &lt;p&gt; 元素。\t</span><br><span class=\"line\">element+element\tdiv+p\t选择紧接在 &lt;div&gt; 元素之后的所有 &lt;p&gt; 元素。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>scss </p>\n<blockquote>\n<p>@content</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   @mixin colors($color: blue) &#123;</span><br><span class=\"line\">  background-color: $color;</span><br><span class=\"line\">  @content;</span><br><span class=\"line\">  border-color: $color;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.colors &#123;</span><br><span class=\"line\">  @include colors &#123; color: $color; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n<li><p>async 会打乱html解析，defer 总是在html解析完成后执行。</p>\n</li>\n<li><p>伪元素(Pseudo-elements)<br>DOM树没有定义的虚拟元素</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">核⼼就是需要创建通常不存在于⽂档中的元素，</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>fr 关键字：Grid 布局还引入了一个另外的长度单位来帮助我们创建灵活的网格轨道。fr 单位代表网格容器中可用空间的一等份。grid-template-columns: 200px 1fr 2fr 表示第一个列宽设置为 200px，后面剩余的宽度分为两部分，宽度分别为剩余宽度的 1/3 和 2/3。</p>\n</li>\n<li><p>auto-fill 关键字：表示自动填充，让一行（或者一列）中尽可能的容纳更多的单元格。grid-template-columns: repeat(auto-fill, 200px) 表示列宽是 200 px，但列的数量是不固定的，只要浏览器能够容纳得下，就可以放置元素</p>\n</li>\n<li><p>flex Flex-grow flex-shrink flex-basis</p>\n</li>\n<li>Flex 主轴（x）、交叉轴(y)</li>\n<li><p>calc函数是css3新增的功能，可以使用calc()计算border、margin、pading、font-size和width等属性设置动态值。   width: calc(100% - 200px);</p>\n</li>\n<li><p>触发BFC条件  BFC（Block Formatting Context）格式化上下文，把它理解成是一个独立的容器，并且这个容器里box的布局与这个容器外的box毫不相干。</p>\n</li>\n<li><p>递归 o(2**n)-》带备忘录 o(n),自顶向下-》动态规划（自底向上）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">根元素</span><br><span class=\"line\">float的值不为none</span><br><span class=\"line\">overflow的值不为visible</span><br><span class=\"line\">display的值为inline-block、table-cell、table-caption</span><br><span class=\"line\">position的值为absolute、fixed</span><br><span class=\"line\">弹性盒（flex或inline-flex）</span><br><span class=\"line\">display: flow-root</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Stylelint css 的lint  </p>\n</li>\n<li>多行文本： Table cell 垂直居中  vertical-align</li>\n<li>块级：1. position absolute margin-top:-50px(translate(0,-50%))  2. Top 0 bottom 0  margin:auto</li>\n<li><p>当元素浮动后不会影响块级元素的布局 只会影响内联元素的布局</p>\n<p>双飞布局时中间栏内容部分为两边腾开位置。</p>\n</li>\n<li><p>使用vw设置，vw也是一个相对单位，100vw等于屏幕宽度</p>\n</li>\n<li><p>max-width/min-width &gt; flex-basis &gt; width &gt; box</p>\n</li>\n<li><p>writing-mode: vertical-rl;  设置文字方向</p>\n</li>\n<li>text-align-last  描述的是一段文本中最后一行在被强制换行之前的对齐规则<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">justify</span><br><span class=\"line\"></span><br><span class=\"line\">最后一行文字的开头与内容盒子的左侧对齐，末尾与右侧对齐</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>1.设置打印样式</p>\n<p>  @media print {<br>    /<em> print styles here. </em>/<br>  }. </p>\n<ol>\n<li>line-clamp 定义文字显示行数</li>\n<li>pointer-events: none; 禁用点击事件</li>\n<li><p>focus-within是一个伪类，现在已经被列入到CSS选择器中。当元素本身或其后代元素获得焦点时，:focus-within伪类的元素就会有效。 </p>\n</li>\n<li><p>但是有个好处是当元素没有内容时候，设置height:100%该元素不会被撑开，</p>\n<p>但是设置height:100vh，该元素会被撑开屏幕高度一致。 </p>\n</li>\n<li><p>伪类：<br><a href=\"https://user-gold-cdn.xitu.io/2019/12/12/16ef8eecad4f1adb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" target=\"_blank\" rel=\"noopener\">https://user-gold-cdn.xitu.io/2019/12/12/16ef8eecad4f1adb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1</a></p>\n</li>\n<li><p>伪元素用于创建一些不在文档树中的元素，并为其添加样式。比如说，我们可以通过:before来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。常见的伪元素有：::before，::after，::first-line，::first-letter，::selection、::placeholder等. 伪类和伪元素的区别在于有没有创建一个文档书之外的元素。</p>\n</li>\n<li></li>\n<li><p>这是一个叫做@font-face 的CSS @规则 ，它允许网页开发者为其网页指定在线字体。 通过这种作者自备字体的方式，@font-face 可以消除对用户电脑字体的依赖。</p>\n</li>\n<li><p>overflow:<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow</a></p>\n</li>\n<li><p>Element.scrollTop 属性可以获取或设置一个元素的内容垂直滚动的像素数。</p>\n<p>offsetTop: 当前元素顶部距离最近父元素顶部的距离,和有没有滚动条没有关系。单位px，只读元素。</p>\n<p>scrollHeight: 因为子元素比父元素高，父元素不想被子元素撑的一样高就显示出了滚动条，在滚动的过程中本元素有部分被隐藏了，scrollHeight代表包括当前不可见部分的元素的高度。而可见部分的高度其实就是clientHeight，也就是scrollHeight&gt;=clientHeight恒成立。在有滚动条时讨论scrollHeight才有意义，在没有滚动条时scrollHeight==clientHeight恒成立。单位px，只读元素。</p>\n<p><a href=\"https://imweb.io/topic/57c5409e808fd2fb204eef52\" target=\"_blank\" rel=\"noopener\">https://imweb.io/topic/57c5409e808fd2fb204eef52</a></p>\n<p>clientheight offsetheight </p>\n</li>\n</ol>\n<ol>\n<li><p>相对位置：<br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/position\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/position</a></p>\n</li>\n<li><p>Image alt 属性是一个必需的属性，它规定在图像无法显示时的替代文本。</p>\n</li>\n</ol>\n<p>text-decoration 设置下划线等<br><a href=\"https://jsfiddle.net/ryansecreat/58um7k43/\" target=\"_blank\" rel=\"noopener\">https://jsfiddle.net/ryansecreat/58um7k43/</a></p>\n<p> document​.active​Element</p>\n<p> 返回当前页面中获得焦点的元素,也就是说,如果此时用户按下了键盘上某个键,会在该元素上触发键盘事件.该属性是只读的.</p>\n<h4 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h4><ol>\n<li>尽量使用 flexbox 而不是老的布局模型。它运行速度更快，可为你的应用程序创造巨大的性能优势。</li>\n<li>根据 Google Developer，渲染线程分为 主线程 (main thread) 和 合成线程 (compositor thread)。如果 CSS 动画只是改变 transforms 和 opacity，这时整个 CSS 动画得以在 合成线程完成（而JS动画则会在 主线程 执行，然后触发合成线程进行下一步操作），在 JS 执行一些昂贵的任务时，主线程繁忙，CSS 动画由于使用了合成线程可以保持流畅</li>\n<li>CSS动画有天然事件支持（TransitionEnd、AnimationEnd，但是它们都需要针对浏览器加前缀），JS则需要自己写事件。</li>\n<li>在实现一些小的交互动效的时候，就多考虑考虑 CSS 动画。对于一些复杂控制的动画，使用 javascript 比较可靠。</li>\n</ol>\n<h4 id=\"内容对齐（justify-content）属性应用在弹性容器上，把弹性项沿着弹性容器的主轴线（main-axis）对齐。\"><a href=\"#内容对齐（justify-content）属性应用在弹性容器上，把弹性项沿着弹性容器的主轴线（main-axis）对齐。\" class=\"headerlink\" title=\"内容对齐（justify-content）属性应用在弹性容器上，把弹性项沿着弹性容器的主轴线（main axis）对齐。\"></a>内容对齐（justify-content）属性应用在弹性容器上，把弹性项沿着弹性容器的主轴线（main axis）对齐。</h4><p>   align-items 设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式。</p>\n<p>   设置”margin”值为”auto”值，自动获取弹性容器中剩余的空间。所以设置垂直方向margin值为”auto”，可以使弹性子元素在弹性容器的两上轴方向都完全居中。 当容器为flex时会自动居中。</p>\n<p>   如果在元素上设置了 box-sizing: border-box; 则 padding(内边距) 和 border(边框) 也包含在 width 和 height 中:</p>\n<p>   transform: rotateX(120deg);  x轴旋转 </p>\n<h4 id=\"不被选中\"><a href=\"#不被选中\" class=\"headerlink\" title=\"不被选中\"></a>不被选中</h4><p>body{</p>\n<p>-webkit-touch-callout: none;</p>\n<p>-webkit-user-select: none;</p>\n<p>-khtml-user-select: none;</p>\n<p>-moz-user-select: none;</p>\n<p>-ms-user-select: none;</p>\n<p>user-select: none;</p>\n<p>}</p>\n<h4 id=\"隐藏\"><a href=\"#隐藏\" class=\"headerlink\" title=\"隐藏\"></a>隐藏</h4><p>1.opacity：0,该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定了一些事件，如click事件也能触发 2.visibility:hidden,该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件 3.display:node, 把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删掉</p>\n<h4 id=\"html-生成\"><a href=\"#html-生成\" class=\"headerlink\" title=\"html 生成\"></a>html 生成</h4><p>将html代码按照深度优先遍历来生成DOM树。 css文件下载完后也会进行渲染，生成相应的CSSOM。 当所有的css文件下载完且所有的CSSOM构建结束后，就会和DOM一起生成Render Tree。 接下来，浏览器就会进入Layout环节，将所有的节点位置计算出来。 最后，通过Painting环节将所有的节点内容呈现到屏幕上。</p>\n<h4 id=\"base64\"><a href=\"#base64\" class=\"headerlink\" title=\"base64\"></a>base64</h4><p> TMLCanvasElement.toDataURL() 方法返回一个包含图片展示的 data URI 。可以使用 type 参数其类型，默认为 PNG 格式。图片的分辨率为96dpi。</p>\n<h4 id=\"base64-渲染图片\"><a href=\"#base64-渲染图片\" class=\"headerlink\" title=\"base64 渲染图片\"></a>base64 渲染图片</h4><p>使用 Base64 编码渲染图片有以下优点：</p>\n<p>有效减少 HTTP 请求次数<br>可对数据进行简单加密，无法肉眼获取信息<br>没有跨域问题，无需考虑图片缓存<br>凡事皆有利弊，使用 Base64 编码同时也会带来一些问题：</p>\n<p>编码后文件体积增大，仅适用于小体积图片编码<br>增加了编码和解码的工作量<br>不支持 IE 8.0 以下版本   </p>\n<h4 id=\"单位\"><a href=\"#单位\" class=\"headerlink\" title=\"单位\"></a>单位</h4><ol>\n<li>px：绝对单位，页面按精确像素展示</li>\n<li>em：相对单位，基准点为父节点字体的大小，如果自身定义了font-size按自身来计算（浏览器默认字体是16px），整个页面内1em不是一个固定的值</li>\n<li>rem：相对单位，可理解为”root em”, 相对根节点html的字体大小来计算，CSS3新加属性，chrome/firefox/IE9+支持</li>\n<li>vw：viewpoint width，视窗宽度，1vw等于视窗宽度的1%</li>\n<li>vh：viewpoint height，视窗高度，1vh等于视窗高度的1%</li>\n<li>vmin：vw和vh中较小的那个</li>\n<li>vmax：vw和vh中较大的那个</li>\n<li>%:百分比</li>\n</ol>\n"},{"title":"docker 常用命令","date":"2016-12-14T09:56:03.000Z","_content":"总结一下常用命令:\n\n其中<>阔起来的参数为必选，[]阔起来为可选\n\ndocker version 查看docker的版本号，包括客户端、服务端、依赖的Go等\ndocker info 查看系统(docker)层面信息，包括管理的images, containers数等\ndocker search <image> 在docker index中搜索image\ndocker pull <image> 从docker registry server 中下拉image\ndocker push <image|repository> 推送一个image或repository到registry\ndocker push <image|repository>:TAG 同上，指定tag\ndocker inspect <image|container> 查看image或container的底层信息\ndocker images TODO filter out the intermediate image layers (intermediate image layers 是什么)\ndocker images -a 列出所有的images\ndocker ps 默认显示正在运行中的container\ndocker ps -l 显示最后一次创建的container，包括未运行的\ndocker ps -a 显示所有的container，包括未运行的\ndocker logs <container> 查看container的日志，也就是执行命令的一些输出\ndocker rm <container...> 删除一个或多个container\ndocker rm `docker ps -a -q` 删除所有的container\ndocker ps -a -q | xargs docker rm 同上, 删除所有的container\ndocker rmi <image...> 删除一个或多个image\ndocker start/stop/restart <container> 开启/停止/重启container\ndocker start -i <container> 启动一个container并进入交互模式\ndocker attach <container> attach一个运行中的container\ndocker run <image> <command> 使用image创建container并执行相应命令，然后停止\ndocker run -i -t <image> /bin/bash 使用image创建container并进入交互模式, login shell是/bin/bash\ndocker run -i -t -p <host_port:contain_port> 将container的端口映射到宿主机的端口\ndocker commit <container> [repo:tag] 将一个container固化为一个新的image，后面的repo:tag可选\ndocker build <path> 寻找path路径下名为的Dockerfile的配置文件，使用此配置生成新的image\ndocker build -t repo[:tag] 同上，可以指定repo和可选的tag\ndocker build - < <dockerfile> 使用指定的dockerfile配置文件，docker以stdin方式获取内容，使用此配置生成新的image\ndocker port <container> <container port> 查看本地哪个端口映射到container的指定端口，其实用docker ps 也可以看到\n\n\n### 安装docker\n1. 利用官方脚本：\n\n```\n$ sudo yum update\n$ sudo curl -sSL https://get.docker.com/ | sh\n```\n2.  用黄狗安装：\n\n```\n$ sudo yum update\n$ sudo yum -y install docker\n$ sudo systemctl start docker\n```\n### 删除操作\n##### 删除所有已经停止的continer  -q 列出所有id\n\n```\ndocker rm $(docker ps -a -q)\n```\n##### 删除所有镜像\n\n```\ndocker rmi $(docker images | grep none | awk '{print $3}' | sort -r)\n```\n### 命令说明\n1. 其中go的语法模板\n \n```\ndocker images --format \"{{.ID}}: {{.Repository}}\"\ndocker images --format \"table {{.ID}}\\t{{.Repository}}\\t{{.Tag}}\"\n```\n2. filter 过滤参数\n \n```\ndocker images -f since=mongo:3.2\n```\n 表示自从3.2 版本以来所有的镜像。\n3. docker run -it --rm --name ryanserver ubuntu:14.04 bash \n   \n   it 表示交互终端 \n   rm 推出后删除\n   ubuntu  镜像名称\n   bash bash命令\n   naem 指定container名称\n```\ndocker run --name webserver -d -p 85:80 nginx\n```\n\n4. docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]\n- -a :提交的镜像作者；\n- -c :使用Dockerfile指令来创建镜像；\n- -m :提交时的说明文字；\n- -p :在commit时，将容器暂停。\n如：\n\n```\n$ docker commit \\\n    --author \"Tao Wang <twang2218@gmail.com>\" \\\n    --message \"修改了默认网页\" \\\n    webserver \\\n    nginx:v2\n```\n5.通过dockfile制作镜像\n\n```\nFROM nginx\nRUN echo '<h1>Hello, Docker!</h1>' > /usr/share/nginx/html/index.html\n```\nfrom 指定基础镜像 \n\nDockerfile中每次运行run 都执行了一层。&& 将各个所需命令串联起来\n\nDockerfile 支持 Shell 类的行尾添加 \\ 的命令换行方式，以及行首# 进行注释的格式\n一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。\n\ncopy 文件时可使用通配符，其通配符规则要满足 Go 的 filepath.Match 规则，如：\n\n```\nCOPY hom* /mydir/\nCOPY hom?.txt /mydir/\n```\nAdd 功能和copy 类似，不过自带解压功能：\n\n```\nFROM scratch\nADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /\n```\n###### 环境变量的配置\n格式有两种：\n  ● ENV <key> <value>\n  ● ENV <key1>=<value1> <key2>=<value2>...\n例如 ENV VERSION=1.0 DEBUG=on \\\n     NAME=\"Happy Feet\n######  匿名卷\n在 Dockerfile 中，我们可以事先指定某些目录挂载为匿名卷，\n任何向 /data 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如：\ndocker run -d -v mydata:/data xxxx\n###### 挂载host目录\n将host机中的文件挂载到container中：\ndocker可以支持把一个宿主机上的目录挂载到镜像里。\n\n```\ndocker run -it -v /home/dock/Downloads:/usr/Downloads ubuntu64 /bin/bash\n```\n\n通过-v参数，冒号前为宿主机目录，必须为绝对路径，冒号后为镜像内挂载的路径。\n\n一个dockfile:\n \n```\nMAINTAINER Anna Doe <anna@example.com>\nnodejs pm2:\nFROM node:0.11.13\n# or just node, without tag\n\nRUN npm install -g pm2\nRUN pm2 dump\n# dump will start pm2 daemon and create everything needed\n\nVOLUME [\"/srv/apps\", \"/srv/logs\", \"/srv/server.json\"]\n# don't put the files in docker container, user -v\n\nEXPOSE 3000\n\nCMD [\"pm2\", \"start\", \"/srv/server.json\", \"--no-daemon\"]\n# no daemon mode for docker\n```\n\n6. docker build -t repo[:tag] . \n   \n可以指定repo和可选的tag\n如果注意，会看到 docker build 命令最后有一个 .。. 表示当前目录\ncopy命令只有在当前上下文有有效\n\n7. 从container中导出\n导出(Export)\nExport命令用于持久化容器（不是镜像）\n接着执行导出：\nsudo docker export <CONTAINER ID> > /home/export.tar\n\n导出后，可以通过docker import   导入，如\n\n```\ncat busy.tar | sudo docker import - busy:v1.0\n\n```\n\n8. 保存镜像\n   sudo docker save busybox-1 > /home/save.tar\n\n\n```\n用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以使用 docker import 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。\n```\n\n9. docker 自启动配置\n\n自动启动container 如下：\n\n```\ndocker run -ti --restart=on-failure:3   \n失败后会启动三次\n```\n10. 用非root用户操作docker\n下面是使用非root用户操作的步骤\n\n```\n创建docker组\nsudo groupadd docker\n将当前用户加入docker组\nsudo gpasswd -a ${USER} docker\n重新启动docker服务（下面是CentOS7的命令）\nsudo systemctl restart docker\n当前用户退出系统重新登陆\n运行docker命令\ndocker ps\n```\n\n11.用docker 启动zookeeper \n\n```\nps -aux | grep docker\ndocker run  --name alizookeeper --restart always -d -P zookeeper\n```\n\n ","source":"_posts/docker.md","raw":"---\ntitle: docker 常用命令\ndate: 2016-12-14 17:56:03\ntags: docker\n---\n总结一下常用命令:\n\n其中<>阔起来的参数为必选，[]阔起来为可选\n\ndocker version 查看docker的版本号，包括客户端、服务端、依赖的Go等\ndocker info 查看系统(docker)层面信息，包括管理的images, containers数等\ndocker search <image> 在docker index中搜索image\ndocker pull <image> 从docker registry server 中下拉image\ndocker push <image|repository> 推送一个image或repository到registry\ndocker push <image|repository>:TAG 同上，指定tag\ndocker inspect <image|container> 查看image或container的底层信息\ndocker images TODO filter out the intermediate image layers (intermediate image layers 是什么)\ndocker images -a 列出所有的images\ndocker ps 默认显示正在运行中的container\ndocker ps -l 显示最后一次创建的container，包括未运行的\ndocker ps -a 显示所有的container，包括未运行的\ndocker logs <container> 查看container的日志，也就是执行命令的一些输出\ndocker rm <container...> 删除一个或多个container\ndocker rm `docker ps -a -q` 删除所有的container\ndocker ps -a -q | xargs docker rm 同上, 删除所有的container\ndocker rmi <image...> 删除一个或多个image\ndocker start/stop/restart <container> 开启/停止/重启container\ndocker start -i <container> 启动一个container并进入交互模式\ndocker attach <container> attach一个运行中的container\ndocker run <image> <command> 使用image创建container并执行相应命令，然后停止\ndocker run -i -t <image> /bin/bash 使用image创建container并进入交互模式, login shell是/bin/bash\ndocker run -i -t -p <host_port:contain_port> 将container的端口映射到宿主机的端口\ndocker commit <container> [repo:tag] 将一个container固化为一个新的image，后面的repo:tag可选\ndocker build <path> 寻找path路径下名为的Dockerfile的配置文件，使用此配置生成新的image\ndocker build -t repo[:tag] 同上，可以指定repo和可选的tag\ndocker build - < <dockerfile> 使用指定的dockerfile配置文件，docker以stdin方式获取内容，使用此配置生成新的image\ndocker port <container> <container port> 查看本地哪个端口映射到container的指定端口，其实用docker ps 也可以看到\n\n\n### 安装docker\n1. 利用官方脚本：\n\n```\n$ sudo yum update\n$ sudo curl -sSL https://get.docker.com/ | sh\n```\n2.  用黄狗安装：\n\n```\n$ sudo yum update\n$ sudo yum -y install docker\n$ sudo systemctl start docker\n```\n### 删除操作\n##### 删除所有已经停止的continer  -q 列出所有id\n\n```\ndocker rm $(docker ps -a -q)\n```\n##### 删除所有镜像\n\n```\ndocker rmi $(docker images | grep none | awk '{print $3}' | sort -r)\n```\n### 命令说明\n1. 其中go的语法模板\n \n```\ndocker images --format \"{{.ID}}: {{.Repository}}\"\ndocker images --format \"table {{.ID}}\\t{{.Repository}}\\t{{.Tag}}\"\n```\n2. filter 过滤参数\n \n```\ndocker images -f since=mongo:3.2\n```\n 表示自从3.2 版本以来所有的镜像。\n3. docker run -it --rm --name ryanserver ubuntu:14.04 bash \n   \n   it 表示交互终端 \n   rm 推出后删除\n   ubuntu  镜像名称\n   bash bash命令\n   naem 指定container名称\n```\ndocker run --name webserver -d -p 85:80 nginx\n```\n\n4. docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]\n- -a :提交的镜像作者；\n- -c :使用Dockerfile指令来创建镜像；\n- -m :提交时的说明文字；\n- -p :在commit时，将容器暂停。\n如：\n\n```\n$ docker commit \\\n    --author \"Tao Wang <twang2218@gmail.com>\" \\\n    --message \"修改了默认网页\" \\\n    webserver \\\n    nginx:v2\n```\n5.通过dockfile制作镜像\n\n```\nFROM nginx\nRUN echo '<h1>Hello, Docker!</h1>' > /usr/share/nginx/html/index.html\n```\nfrom 指定基础镜像 \n\nDockerfile中每次运行run 都执行了一层。&& 将各个所需命令串联起来\n\nDockerfile 支持 Shell 类的行尾添加 \\ 的命令换行方式，以及行首# 进行注释的格式\n一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。\n\ncopy 文件时可使用通配符，其通配符规则要满足 Go 的 filepath.Match 规则，如：\n\n```\nCOPY hom* /mydir/\nCOPY hom?.txt /mydir/\n```\nAdd 功能和copy 类似，不过自带解压功能：\n\n```\nFROM scratch\nADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /\n```\n###### 环境变量的配置\n格式有两种：\n  ● ENV <key> <value>\n  ● ENV <key1>=<value1> <key2>=<value2>...\n例如 ENV VERSION=1.0 DEBUG=on \\\n     NAME=\"Happy Feet\n######  匿名卷\n在 Dockerfile 中，我们可以事先指定某些目录挂载为匿名卷，\n任何向 /data 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如：\ndocker run -d -v mydata:/data xxxx\n###### 挂载host目录\n将host机中的文件挂载到container中：\ndocker可以支持把一个宿主机上的目录挂载到镜像里。\n\n```\ndocker run -it -v /home/dock/Downloads:/usr/Downloads ubuntu64 /bin/bash\n```\n\n通过-v参数，冒号前为宿主机目录，必须为绝对路径，冒号后为镜像内挂载的路径。\n\n一个dockfile:\n \n```\nMAINTAINER Anna Doe <anna@example.com>\nnodejs pm2:\nFROM node:0.11.13\n# or just node, without tag\n\nRUN npm install -g pm2\nRUN pm2 dump\n# dump will start pm2 daemon and create everything needed\n\nVOLUME [\"/srv/apps\", \"/srv/logs\", \"/srv/server.json\"]\n# don't put the files in docker container, user -v\n\nEXPOSE 3000\n\nCMD [\"pm2\", \"start\", \"/srv/server.json\", \"--no-daemon\"]\n# no daemon mode for docker\n```\n\n6. docker build -t repo[:tag] . \n   \n可以指定repo和可选的tag\n如果注意，会看到 docker build 命令最后有一个 .。. 表示当前目录\ncopy命令只有在当前上下文有有效\n\n7. 从container中导出\n导出(Export)\nExport命令用于持久化容器（不是镜像）\n接着执行导出：\nsudo docker export <CONTAINER ID> > /home/export.tar\n\n导出后，可以通过docker import   导入，如\n\n```\ncat busy.tar | sudo docker import - busy:v1.0\n\n```\n\n8. 保存镜像\n   sudo docker save busybox-1 > /home/save.tar\n\n\n```\n用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以使用 docker import 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。\n```\n\n9. docker 自启动配置\n\n自动启动container 如下：\n\n```\ndocker run -ti --restart=on-failure:3   \n失败后会启动三次\n```\n10. 用非root用户操作docker\n下面是使用非root用户操作的步骤\n\n```\n创建docker组\nsudo groupadd docker\n将当前用户加入docker组\nsudo gpasswd -a ${USER} docker\n重新启动docker服务（下面是CentOS7的命令）\nsudo systemctl restart docker\n当前用户退出系统重新登陆\n运行docker命令\ndocker ps\n```\n\n11.用docker 启动zookeeper \n\n```\nps -aux | grep docker\ndocker run  --name alizookeeper --restart always -d -P zookeeper\n```\n\n ","slug":"docker","published":1,"updated":"2020-06-29T06:22:24.360Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckzf5sdz10004yy8kzjoaknzp","content":"<p>总结一下常用命令:</p>\n<p>其中&lt;&gt;阔起来的参数为必选，[]阔起来为可选</p>\n<p>docker version 查看docker的版本号，包括客户端、服务端、依赖的Go等<br>docker info 查看系统(docker)层面信息，包括管理的images, containers数等<br>docker search <image> 在docker index中搜索image<br>docker pull <image> 从docker registry server 中下拉image<br>docker push &lt;image|repository&gt; 推送一个image或repository到registry<br>docker push &lt;image|repository&gt;:TAG 同上，指定tag<br>docker inspect &lt;image|container&gt; 查看image或container的底层信息<br>docker images TODO filter out the intermediate image layers (intermediate image layers 是什么)<br>docker images -a 列出所有的images<br>docker ps 默认显示正在运行中的container<br>docker ps -l 显示最后一次创建的container，包括未运行的<br>docker ps -a 显示所有的container，包括未运行的<br>docker logs <container> 查看container的日志，也就是执行命令的一些输出<br>docker rm &lt;container…&gt; 删除一个或多个container<br>docker rm <code>docker ps -a -q</code> 删除所有的container<br>docker ps -a -q | xargs docker rm 同上, 删除所有的container<br>docker rmi &lt;image…&gt; 删除一个或多个image<br>docker start/stop/restart <container> 开启/停止/重启container<br>docker start -i <container> 启动一个container并进入交互模式<br>docker attach <container> attach一个运行中的container<br>docker run <image> <command> 使用image创建container并执行相应命令，然后停止<br>docker run -i -t <image> /bin/bash 使用image创建container并进入交互模式, login shell是/bin/bash<br>docker run -i -t -p &lt;host_port:contain_port&gt; 将container的端口映射到宿主机的端口<br>docker commit <container> [repo:tag] 将一个container固化为一个新的image，后面的repo:tag可选<br>docker build <path> 寻找path路径下名为的Dockerfile的配置文件，使用此配置生成新的image<br>docker build -t repo[:tag] 同上，可以指定repo和可选的tag<br>docker build - &lt; <dockerfile> 使用指定的dockerfile配置文件，docker以stdin方式获取内容，使用此配置生成新的image<br>docker port <container> <container port> 查看本地哪个端口映射到container的指定端口，其实用docker ps 也可以看到</container></container></dockerfile></path></container></image></image></container></container></container></container></image></image></p>\n<h3 id=\"安装docker\"><a href=\"#安装docker\" class=\"headerlink\" title=\"安装docker\"></a>安装docker</h3><ol>\n<li>利用官方脚本：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo yum update</span><br><span class=\"line\">$ sudo curl -sSL https://get.docker.com/ | sh</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>用黄狗安装：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo yum update</span><br><span class=\"line\">$ sudo yum -y install docker</span><br><span class=\"line\">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除操作\"><a href=\"#删除操作\" class=\"headerlink\" title=\"删除操作\"></a>删除操作</h3><h5 id=\"删除所有已经停止的continer-q-列出所有id\"><a href=\"#删除所有已经停止的continer-q-列出所有id\" class=\"headerlink\" title=\"删除所有已经停止的continer  -q 列出所有id\"></a>删除所有已经停止的continer  -q 列出所有id</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker rm $(docker ps -a -q)</span><br></pre></td></tr></table></figure>\n<h5 id=\"删除所有镜像\"><a href=\"#删除所有镜像\" class=\"headerlink\" title=\"删除所有镜像\"></a>删除所有镜像</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker rmi $(docker images | grep none | awk &apos;&#123;print $3&#125;&apos; | sort -r)</span><br></pre></td></tr></table></figure>\n<h3 id=\"命令说明\"><a href=\"#命令说明\" class=\"headerlink\" title=\"命令说明\"></a>命令说明</h3><ol>\n<li>其中go的语法模板</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker images --format &quot;&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;&quot;</span><br><span class=\"line\">docker images --format &quot;table &#123;&#123;.ID&#125;&#125;\\t&#123;&#123;.Repository&#125;&#125;\\t&#123;&#123;.Tag&#125;&#125;&quot;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>filter 过滤参数</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker images -f since=mongo:3.2</span><br></pre></td></tr></table></figure>\n<p> 表示自从3.2 版本以来所有的镜像。</p>\n<ol start=\"3\">\n<li><p>docker run -it –rm –name ryanserver ubuntu:14.04 bash </p>\n<p>it 表示交互终端<br>rm 推出后删除<br>ubuntu  镜像名称<br>bash bash命令<br>naem 指定container名称</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run --name webserver -d -p 85:80 nginx</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</p>\n</li>\n</ol>\n<ul>\n<li>-a :提交的镜像作者；</li>\n<li>-c :使用Dockerfile指令来创建镜像；</li>\n<li>-m :提交时的说明文字；</li>\n<li>-p :在commit时，将容器暂停。<br>如：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker commit \\</span><br><span class=\"line\">    --author &quot;Tao Wang &lt;twang2218@gmail.com&gt;&quot; \\</span><br><span class=\"line\">    --message &quot;修改了默认网页&quot; \\</span><br><span class=\"line\">    webserver \\</span><br><span class=\"line\">    nginx:v2</span><br></pre></td></tr></table></figure>\n<p>5.通过dockfile制作镜像</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM nginx</span><br><span class=\"line\">RUN echo &apos;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure>\n<p>from 指定基础镜像 </p>\n<p>Dockerfile中每次运行run 都执行了一层。&amp;&amp; 将各个所需命令串联起来</p>\n<p>Dockerfile 支持 Shell 类的行尾添加 \\ 的命令换行方式，以及行首# 进行注释的格式<br>一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p>\n<p>copy 文件时可使用通配符，其通配符规则要满足 Go 的 filepath.Match 规则，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">COPY hom* /mydir/</span><br><span class=\"line\">COPY hom?.txt /mydir/</span><br></pre></td></tr></table></figure>\n<p>Add 功能和copy 类似，不过自带解压功能：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM scratch</span><br><span class=\"line\">ADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /</span><br></pre></td></tr></table></figure>\n<h6 id=\"环境变量的配置\"><a href=\"#环境变量的配置\" class=\"headerlink\" title=\"环境变量的配置\"></a>环境变量的配置</h6><p>格式有两种：<br>  ● ENV <key> <value><br>  ● ENV <key1>=<value1> <key2>=<value2>…<br>例如 ENV VERSION=1.0 DEBUG=on \\<br>     NAME=”Happy Feet</value2></key2></value1></key1></value></key></p>\n<h6 id=\"匿名卷\"><a href=\"#匿名卷\" class=\"headerlink\" title=\"匿名卷\"></a>匿名卷</h6><p>在 Dockerfile 中，我们可以事先指定某些目录挂载为匿名卷，<br>任何向 /data 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如：<br>docker run -d -v mydata:/data xxxx</p>\n<h6 id=\"挂载host目录\"><a href=\"#挂载host目录\" class=\"headerlink\" title=\"挂载host目录\"></a>挂载host目录</h6><p>将host机中的文件挂载到container中：<br>docker可以支持把一个宿主机上的目录挂载到镜像里。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -it -v /home/dock/Downloads:/usr/Downloads ubuntu64 /bin/bash</span><br></pre></td></tr></table></figure>\n<p>通过-v参数，冒号前为宿主机目录，必须为绝对路径，冒号后为镜像内挂载的路径。</p>\n<p>一个dockfile:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MAINTAINER Anna Doe &lt;anna@example.com&gt;</span><br><span class=\"line\">nodejs pm2:</span><br><span class=\"line\">FROM node:0.11.13</span><br><span class=\"line\"># or just node, without tag</span><br><span class=\"line\"></span><br><span class=\"line\">RUN npm install -g pm2</span><br><span class=\"line\">RUN pm2 dump</span><br><span class=\"line\"># dump will start pm2 daemon and create everything needed</span><br><span class=\"line\"></span><br><span class=\"line\">VOLUME [&quot;/srv/apps&quot;, &quot;/srv/logs&quot;, &quot;/srv/server.json&quot;]</span><br><span class=\"line\"># don&apos;t put the files in docker container, user -v</span><br><span class=\"line\"></span><br><span class=\"line\">EXPOSE 3000</span><br><span class=\"line\"></span><br><span class=\"line\">CMD [&quot;pm2&quot;, &quot;start&quot;, &quot;/srv/server.json&quot;, &quot;--no-daemon&quot;]</span><br><span class=\"line\"># no daemon mode for docker</span><br></pre></td></tr></table></figure>\n<ol start=\"6\">\n<li>docker build -t repo[:tag] . </li>\n</ol>\n<p>可以指定repo和可选的tag<br>如果注意，会看到 docker build 命令最后有一个 .。. 表示当前目录<br>copy命令只有在当前上下文有有效</p>\n<ol start=\"7\">\n<li>从container中导出<br>导出(Export)<br>Export命令用于持久化容器（不是镜像）<br>接着执行导出：<br>sudo docker export <container id> &gt; /home/export.tar</container></li>\n</ol>\n<p>导出后，可以通过docker import   导入，如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat busy.tar | sudo docker import - busy:v1.0</span><br></pre></td></tr></table></figure>\n<ol start=\"8\">\n<li>保存镜像<br>sudo docker save busybox-1 &gt; /home/save.tar</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以使用 docker import 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</span><br></pre></td></tr></table></figure>\n<ol start=\"9\">\n<li>docker 自启动配置</li>\n</ol>\n<p>自动启动container 如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -ti --restart=on-failure:3   </span><br><span class=\"line\">失败后会启动三次</span><br></pre></td></tr></table></figure>\n<ol start=\"10\">\n<li>用非root用户操作docker<br>下面是使用非root用户操作的步骤</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">创建docker组</span><br><span class=\"line\">sudo groupadd docker</span><br><span class=\"line\">将当前用户加入docker组</span><br><span class=\"line\">sudo gpasswd -a $&#123;USER&#125; docker</span><br><span class=\"line\">重新启动docker服务（下面是CentOS7的命令）</span><br><span class=\"line\">sudo systemctl restart docker</span><br><span class=\"line\">当前用户退出系统重新登陆</span><br><span class=\"line\">运行docker命令</span><br><span class=\"line\">docker ps</span><br></pre></td></tr></table></figure>\n<p>11.用docker 启动zookeeper </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ps -aux | grep docker</span><br><span class=\"line\">docker run  --name alizookeeper --restart always -d -P zookeeper</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>总结一下常用命令:</p>\n<p>其中&lt;&gt;阔起来的参数为必选，[]阔起来为可选</p>\n<p>docker version 查看docker的版本号，包括客户端、服务端、依赖的Go等<br>docker info 查看系统(docker)层面信息，包括管理的images, containers数等<br>docker search <image> 在docker index中搜索image<br>docker pull <image> 从docker registry server 中下拉image<br>docker push &lt;image|repository&gt; 推送一个image或repository到registry<br>docker push &lt;image|repository&gt;:TAG 同上，指定tag<br>docker inspect &lt;image|container&gt; 查看image或container的底层信息<br>docker images TODO filter out the intermediate image layers (intermediate image layers 是什么)<br>docker images -a 列出所有的images<br>docker ps 默认显示正在运行中的container<br>docker ps -l 显示最后一次创建的container，包括未运行的<br>docker ps -a 显示所有的container，包括未运行的<br>docker logs <container> 查看container的日志，也就是执行命令的一些输出<br>docker rm &lt;container…&gt; 删除一个或多个container<br>docker rm <code>docker ps -a -q</code> 删除所有的container<br>docker ps -a -q | xargs docker rm 同上, 删除所有的container<br>docker rmi &lt;image…&gt; 删除一个或多个image<br>docker start/stop/restart <container> 开启/停止/重启container<br>docker start -i <container> 启动一个container并进入交互模式<br>docker attach <container> attach一个运行中的container<br>docker run <image> <command> 使用image创建container并执行相应命令，然后停止<br>docker run -i -t <image> /bin/bash 使用image创建container并进入交互模式, login shell是/bin/bash<br>docker run -i -t -p &lt;host_port:contain_port&gt; 将container的端口映射到宿主机的端口<br>docker commit <container> [repo:tag] 将一个container固化为一个新的image，后面的repo:tag可选<br>docker build <path> 寻找path路径下名为的Dockerfile的配置文件，使用此配置生成新的image<br>docker build -t repo[:tag] 同上，可以指定repo和可选的tag<br>docker build - &lt; <dockerfile> 使用指定的dockerfile配置文件，docker以stdin方式获取内容，使用此配置生成新的image<br>docker port <container> <container port> 查看本地哪个端口映射到container的指定端口，其实用docker ps 也可以看到</container></container></dockerfile></path></container></image></image></container></container></container></container></image></image></p>\n<h3 id=\"安装docker\"><a href=\"#安装docker\" class=\"headerlink\" title=\"安装docker\"></a>安装docker</h3><ol>\n<li>利用官方脚本：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo yum update</span><br><span class=\"line\">$ sudo curl -sSL https://get.docker.com/ | sh</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>用黄狗安装：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo yum update</span><br><span class=\"line\">$ sudo yum -y install docker</span><br><span class=\"line\">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除操作\"><a href=\"#删除操作\" class=\"headerlink\" title=\"删除操作\"></a>删除操作</h3><h5 id=\"删除所有已经停止的continer-q-列出所有id\"><a href=\"#删除所有已经停止的continer-q-列出所有id\" class=\"headerlink\" title=\"删除所有已经停止的continer  -q 列出所有id\"></a>删除所有已经停止的continer  -q 列出所有id</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker rm $(docker ps -a -q)</span><br></pre></td></tr></table></figure>\n<h5 id=\"删除所有镜像\"><a href=\"#删除所有镜像\" class=\"headerlink\" title=\"删除所有镜像\"></a>删除所有镜像</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker rmi $(docker images | grep none | awk &apos;&#123;print $3&#125;&apos; | sort -r)</span><br></pre></td></tr></table></figure>\n<h3 id=\"命令说明\"><a href=\"#命令说明\" class=\"headerlink\" title=\"命令说明\"></a>命令说明</h3><ol>\n<li>其中go的语法模板</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker images --format &quot;&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;&quot;</span><br><span class=\"line\">docker images --format &quot;table &#123;&#123;.ID&#125;&#125;\\t&#123;&#123;.Repository&#125;&#125;\\t&#123;&#123;.Tag&#125;&#125;&quot;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>filter 过滤参数</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker images -f since=mongo:3.2</span><br></pre></td></tr></table></figure>\n<p> 表示自从3.2 版本以来所有的镜像。</p>\n<ol start=\"3\">\n<li><p>docker run -it –rm –name ryanserver ubuntu:14.04 bash </p>\n<p>it 表示交互终端<br>rm 推出后删除<br>ubuntu  镜像名称<br>bash bash命令<br>naem 指定container名称</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run --name webserver -d -p 85:80 nginx</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</p>\n</li>\n</ol>\n<ul>\n<li>-a :提交的镜像作者；</li>\n<li>-c :使用Dockerfile指令来创建镜像；</li>\n<li>-m :提交时的说明文字；</li>\n<li>-p :在commit时，将容器暂停。<br>如：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker commit \\</span><br><span class=\"line\">    --author &quot;Tao Wang &lt;twang2218@gmail.com&gt;&quot; \\</span><br><span class=\"line\">    --message &quot;修改了默认网页&quot; \\</span><br><span class=\"line\">    webserver \\</span><br><span class=\"line\">    nginx:v2</span><br></pre></td></tr></table></figure>\n<p>5.通过dockfile制作镜像</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM nginx</span><br><span class=\"line\">RUN echo &apos;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure>\n<p>from 指定基础镜像 </p>\n<p>Dockerfile中每次运行run 都执行了一层。&amp;&amp; 将各个所需命令串联起来</p>\n<p>Dockerfile 支持 Shell 类的行尾添加 \\ 的命令换行方式，以及行首# 进行注释的格式<br>一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p>\n<p>copy 文件时可使用通配符，其通配符规则要满足 Go 的 filepath.Match 规则，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">COPY hom* /mydir/</span><br><span class=\"line\">COPY hom?.txt /mydir/</span><br></pre></td></tr></table></figure>\n<p>Add 功能和copy 类似，不过自带解压功能：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM scratch</span><br><span class=\"line\">ADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /</span><br></pre></td></tr></table></figure>\n<h6 id=\"环境变量的配置\"><a href=\"#环境变量的配置\" class=\"headerlink\" title=\"环境变量的配置\"></a>环境变量的配置</h6><p>格式有两种：<br>  ● ENV <key> <value><br>  ● ENV <key1>=<value1> <key2>=<value2>…<br>例如 ENV VERSION=1.0 DEBUG=on \\<br>     NAME=”Happy Feet</value2></key2></value1></key1></value></key></p>\n<h6 id=\"匿名卷\"><a href=\"#匿名卷\" class=\"headerlink\" title=\"匿名卷\"></a>匿名卷</h6><p>在 Dockerfile 中，我们可以事先指定某些目录挂载为匿名卷，<br>任何向 /data 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如：<br>docker run -d -v mydata:/data xxxx</p>\n<h6 id=\"挂载host目录\"><a href=\"#挂载host目录\" class=\"headerlink\" title=\"挂载host目录\"></a>挂载host目录</h6><p>将host机中的文件挂载到container中：<br>docker可以支持把一个宿主机上的目录挂载到镜像里。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -it -v /home/dock/Downloads:/usr/Downloads ubuntu64 /bin/bash</span><br></pre></td></tr></table></figure>\n<p>通过-v参数，冒号前为宿主机目录，必须为绝对路径，冒号后为镜像内挂载的路径。</p>\n<p>一个dockfile:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MAINTAINER Anna Doe &lt;anna@example.com&gt;</span><br><span class=\"line\">nodejs pm2:</span><br><span class=\"line\">FROM node:0.11.13</span><br><span class=\"line\"># or just node, without tag</span><br><span class=\"line\"></span><br><span class=\"line\">RUN npm install -g pm2</span><br><span class=\"line\">RUN pm2 dump</span><br><span class=\"line\"># dump will start pm2 daemon and create everything needed</span><br><span class=\"line\"></span><br><span class=\"line\">VOLUME [&quot;/srv/apps&quot;, &quot;/srv/logs&quot;, &quot;/srv/server.json&quot;]</span><br><span class=\"line\"># don&apos;t put the files in docker container, user -v</span><br><span class=\"line\"></span><br><span class=\"line\">EXPOSE 3000</span><br><span class=\"line\"></span><br><span class=\"line\">CMD [&quot;pm2&quot;, &quot;start&quot;, &quot;/srv/server.json&quot;, &quot;--no-daemon&quot;]</span><br><span class=\"line\"># no daemon mode for docker</span><br></pre></td></tr></table></figure>\n<ol start=\"6\">\n<li>docker build -t repo[:tag] . </li>\n</ol>\n<p>可以指定repo和可选的tag<br>如果注意，会看到 docker build 命令最后有一个 .。. 表示当前目录<br>copy命令只有在当前上下文有有效</p>\n<ol start=\"7\">\n<li>从container中导出<br>导出(Export)<br>Export命令用于持久化容器（不是镜像）<br>接着执行导出：<br>sudo docker export <container id> &gt; /home/export.tar</container></li>\n</ol>\n<p>导出后，可以通过docker import   导入，如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat busy.tar | sudo docker import - busy:v1.0</span><br></pre></td></tr></table></figure>\n<ol start=\"8\">\n<li>保存镜像<br>sudo docker save busybox-1 &gt; /home/save.tar</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以使用 docker import 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</span><br></pre></td></tr></table></figure>\n<ol start=\"9\">\n<li>docker 自启动配置</li>\n</ol>\n<p>自动启动container 如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -ti --restart=on-failure:3   </span><br><span class=\"line\">失败后会启动三次</span><br></pre></td></tr></table></figure>\n<ol start=\"10\">\n<li>用非root用户操作docker<br>下面是使用非root用户操作的步骤</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">创建docker组</span><br><span class=\"line\">sudo groupadd docker</span><br><span class=\"line\">将当前用户加入docker组</span><br><span class=\"line\">sudo gpasswd -a $&#123;USER&#125; docker</span><br><span class=\"line\">重新启动docker服务（下面是CentOS7的命令）</span><br><span class=\"line\">sudo systemctl restart docker</span><br><span class=\"line\">当前用户退出系统重新登陆</span><br><span class=\"line\">运行docker命令</span><br><span class=\"line\">docker ps</span><br></pre></td></tr></table></figure>\n<p>11.用docker 启动zookeeper </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ps -aux | grep docker</span><br><span class=\"line\">docker run  --name alizookeeper --restart always -d -P zookeeper</span><br></pre></td></tr></table></figure>\n"},{"title":"encoding","date":"2019-11-08T06:11:43.000Z","_content":"1. charCodeAt() 返回表示给定索引的字符的Unicode的值。 codePointAt() 返回使用UTF-16编码的给定位置的值的非负整数。\n1. Transfer-Encoding   数据以一系列分块的形式进行发送。 Content-Length 首部在这种情况下不被发送。。在每一个分块的开头需要添加当前分块的长度，以十六进制的形式表示，后面紧跟着 '\\r\\n' ，之后是分块本身，后面也是'\\r\\n' 。终止块是一个常规的分块，不同之处在于其长度为0。终止块后面是一个挂载（trailer），由一系列（或者为空）的实体消息首部构成。\n1. ascii 第一个bit为0，也就是当第一个bit是0时仍表示之前那些常用的字符.当为1时就表示其他补充的字符，例如西欧国家的文字。\n1. utf-8  Refer:https://segmentfault.com/a/1190000014324711\n```text\n0xxxxxxx,如果是这样的01串,也就是以0开头后面是啥就不用管了XX代表任意bit.就表示把一个字节做为一个单元.就跟ASCII完全一样.\n   110xxxxx 10xxxxxx.如果是这样的格式,则把两个字节当一个单元\n   \n   1110xxxx 10xxxxxx 10xxxxxx 如果是这种格式则是三个字节当一个单元\n```   \n\n1. ","source":"_posts/encoding.md","raw":"---\ntitle: encoding\ndate: 2019-11-08 14:11:43\ntags:\n---\n1. charCodeAt() 返回表示给定索引的字符的Unicode的值。 codePointAt() 返回使用UTF-16编码的给定位置的值的非负整数。\n1. Transfer-Encoding   数据以一系列分块的形式进行发送。 Content-Length 首部在这种情况下不被发送。。在每一个分块的开头需要添加当前分块的长度，以十六进制的形式表示，后面紧跟着 '\\r\\n' ，之后是分块本身，后面也是'\\r\\n' 。终止块是一个常规的分块，不同之处在于其长度为0。终止块后面是一个挂载（trailer），由一系列（或者为空）的实体消息首部构成。\n1. ascii 第一个bit为0，也就是当第一个bit是0时仍表示之前那些常用的字符.当为1时就表示其他补充的字符，例如西欧国家的文字。\n1. utf-8  Refer:https://segmentfault.com/a/1190000014324711\n```text\n0xxxxxxx,如果是这样的01串,也就是以0开头后面是啥就不用管了XX代表任意bit.就表示把一个字节做为一个单元.就跟ASCII完全一样.\n   110xxxxx 10xxxxxx.如果是这样的格式,则把两个字节当一个单元\n   \n   1110xxxx 10xxxxxx 10xxxxxx 如果是这种格式则是三个字节当一个单元\n```   \n\n1. ","slug":"encoding","published":1,"updated":"2020-06-29T06:22:24.360Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckzf5sdz20005yy8kcz7igmby","content":"<ol>\n<li>charCodeAt() 返回表示给定索引的字符的Unicode的值。 codePointAt() 返回使用UTF-16编码的给定位置的值的非负整数。</li>\n<li>Transfer-Encoding   数据以一系列分块的形式进行发送。 Content-Length 首部在这种情况下不被发送。。在每一个分块的开头需要添加当前分块的长度，以十六进制的形式表示，后面紧跟着 ‘\\r\\n’ ，之后是分块本身，后面也是’\\r\\n’ 。终止块是一个常规的分块，不同之处在于其长度为0。终止块后面是一个挂载（trailer），由一系列（或者为空）的实体消息首部构成。</li>\n<li>ascii 第一个bit为0，也就是当第一个bit是0时仍表示之前那些常用的字符.当为1时就表示其他补充的字符，例如西欧国家的文字。</li>\n<li><p>utf-8  Refer:<a href=\"https://segmentfault.com/a/1190000014324711\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000014324711</a></p>\n<pre><code class=\"text\">0xxxxxxx,如果是这样的01串,也就是以0开头后面是啥就不用管了XX代表任意bit.就表示把一个字节做为一个单元.就跟ASCII完全一样.\n110xxxxx 10xxxxxx.如果是这样的格式,则把两个字节当一个单元\n\n1110xxxx 10xxxxxx 10xxxxxx 如果是这种格式则是三个字节当一个单元\n</code></pre>\n</li>\n<li></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>charCodeAt() 返回表示给定索引的字符的Unicode的值。 codePointAt() 返回使用UTF-16编码的给定位置的值的非负整数。</li>\n<li>Transfer-Encoding   数据以一系列分块的形式进行发送。 Content-Length 首部在这种情况下不被发送。。在每一个分块的开头需要添加当前分块的长度，以十六进制的形式表示，后面紧跟着 ‘\\r\\n’ ，之后是分块本身，后面也是’\\r\\n’ 。终止块是一个常规的分块，不同之处在于其长度为0。终止块后面是一个挂载（trailer），由一系列（或者为空）的实体消息首部构成。</li>\n<li>ascii 第一个bit为0，也就是当第一个bit是0时仍表示之前那些常用的字符.当为1时就表示其他补充的字符，例如西欧国家的文字。</li>\n<li><p>utf-8  Refer:<a href=\"https://segmentfault.com/a/1190000014324711\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000014324711</a></p>\n<pre><code class=\"text\">0xxxxxxx,如果是这样的01串,也就是以0开头后面是啥就不用管了XX代表任意bit.就表示把一个字节做为一个单元.就跟ASCII完全一样.\n110xxxxx 10xxxxxx.如果是这样的格式,则把两个字节当一个单元\n\n1110xxxx 10xxxxxx 10xxxxxx 如果是这种格式则是三个字节当一个单元\n</code></pre>\n</li>\n<li></li>\n</ol>\n"},{"title":"cloud","date":"2020-11-10T03:06:58.000Z","_content":"\n1. 增量数据迁移\n\n数据复制：由于业务原因，需要将数据从一个空间迁移至另一个空间。\n\n合规性要求：合规性要求所规定的数据需要跨一定距离保存一份副本。\n\n数据备份与容灾：如果您对所有写入的数据都希望在异地存储区域维护一份副本，以备发生如海啸、地震等特大灾难导致存储区域损毁时，还能启用异地存储区域的备份数据。\n\n最大限度减少延迟：用户处于两个地理位置。为了最大限度缩短访问对象时的延迟，可以在地理位置与用户较近的存储区域维护对象副本。\n\n2. 增量数据同步是跨不同的Bucket自动、异步复制文件，它会将对源Bucket中的对象的改动（除删除操作）同步到目标Bucket。\n\n3. 对象锁定\n\n对象锁定功能可以禁止文件的删除和覆盖，以保障数据可靠性和满足某些行业的合规性要求，实现一次写入，多次读取（WORM）模式。\n部分行业规定要求重要数据必须保存一定的时间后才可以被删除，如金融服务，医疗、政务部门等；为了满足该场景，对象存储需要支持WORM(对象锁定)模式，即一次写入，多次读取。\n\n除特殊行业的强制需求外，如有其他需求需要在一定时间或永久禁止某些文件的删除和覆盖，也可以使用对象锁定功能。\n\n4. \n动态加速：通过路由优化、传输优化等动态加速技术解决跨运营商、网络不稳定等因素导致的响应慢、丢包、服务不稳定等问题，适用于较差网络环境下上传下载的场景。\n\n大文件下载加速：通过CDN边缘节点缓存源站内容来实现文件加速分发，提供低成本、高性能、可扩展的互联网内容分发服务，适用于相同内容反复下载的使用场景\n\n5.\n管理元数据\n管理元数据功能可以修改文件的HTTP响应头，实现控制客户端缓存时间、文件强制下载等策略。除一些通用响应头外，还支持配置自定义元数据。\n\nContent-Disposition 响应头指示回复的内容该以何种形式展示，是以内联的形式（即网页或者页面的一部分），还是以附件的形式下载并保存到本地。","source":"_posts/cloud.md","raw":"---\ntitle: cloud\ndate: 2020-11-10 11:06:58\ntags:\n---\n\n1. 增量数据迁移\n\n数据复制：由于业务原因，需要将数据从一个空间迁移至另一个空间。\n\n合规性要求：合规性要求所规定的数据需要跨一定距离保存一份副本。\n\n数据备份与容灾：如果您对所有写入的数据都希望在异地存储区域维护一份副本，以备发生如海啸、地震等特大灾难导致存储区域损毁时，还能启用异地存储区域的备份数据。\n\n最大限度减少延迟：用户处于两个地理位置。为了最大限度缩短访问对象时的延迟，可以在地理位置与用户较近的存储区域维护对象副本。\n\n2. 增量数据同步是跨不同的Bucket自动、异步复制文件，它会将对源Bucket中的对象的改动（除删除操作）同步到目标Bucket。\n\n3. 对象锁定\n\n对象锁定功能可以禁止文件的删除和覆盖，以保障数据可靠性和满足某些行业的合规性要求，实现一次写入，多次读取（WORM）模式。\n部分行业规定要求重要数据必须保存一定的时间后才可以被删除，如金融服务，医疗、政务部门等；为了满足该场景，对象存储需要支持WORM(对象锁定)模式，即一次写入，多次读取。\n\n除特殊行业的强制需求外，如有其他需求需要在一定时间或永久禁止某些文件的删除和覆盖，也可以使用对象锁定功能。\n\n4. \n动态加速：通过路由优化、传输优化等动态加速技术解决跨运营商、网络不稳定等因素导致的响应慢、丢包、服务不稳定等问题，适用于较差网络环境下上传下载的场景。\n\n大文件下载加速：通过CDN边缘节点缓存源站内容来实现文件加速分发，提供低成本、高性能、可扩展的互联网内容分发服务，适用于相同内容反复下载的使用场景\n\n5.\n管理元数据\n管理元数据功能可以修改文件的HTTP响应头，实现控制客户端缓存时间、文件强制下载等策略。除一些通用响应头外，还支持配置自定义元数据。\n\nContent-Disposition 响应头指示回复的内容该以何种形式展示，是以内联的形式（即网页或者页面的一部分），还是以附件的形式下载并保存到本地。","slug":"cloud","published":1,"updated":"2020-11-10T03:34:46.003Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckzf5sdz40008yy8kebjjnfxb","content":"<ol>\n<li>增量数据迁移</li>\n</ol>\n<p>数据复制：由于业务原因，需要将数据从一个空间迁移至另一个空间。</p>\n<p>合规性要求：合规性要求所规定的数据需要跨一定距离保存一份副本。</p>\n<p>数据备份与容灾：如果您对所有写入的数据都希望在异地存储区域维护一份副本，以备发生如海啸、地震等特大灾难导致存储区域损毁时，还能启用异地存储区域的备份数据。</p>\n<p>最大限度减少延迟：用户处于两个地理位置。为了最大限度缩短访问对象时的延迟，可以在地理位置与用户较近的存储区域维护对象副本。</p>\n<ol start=\"2\">\n<li><p>增量数据同步是跨不同的Bucket自动、异步复制文件，它会将对源Bucket中的对象的改动（除删除操作）同步到目标Bucket。</p>\n</li>\n<li><p>对象锁定</p>\n</li>\n</ol>\n<p>对象锁定功能可以禁止文件的删除和覆盖，以保障数据可靠性和满足某些行业的合规性要求，实现一次写入，多次读取（WORM）模式。<br>部分行业规定要求重要数据必须保存一定的时间后才可以被删除，如金融服务，医疗、政务部门等；为了满足该场景，对象存储需要支持WORM(对象锁定)模式，即一次写入，多次读取。</p>\n<p>除特殊行业的强制需求外，如有其他需求需要在一定时间或永久禁止某些文件的删除和覆盖，也可以使用对象锁定功能。</p>\n<ol start=\"4\">\n<li>动态加速：通过路由优化、传输优化等动态加速技术解决跨运营商、网络不稳定等因素导致的响应慢、丢包、服务不稳定等问题，适用于较差网络环境下上传下载的场景。</li>\n</ol>\n<p>大文件下载加速：通过CDN边缘节点缓存源站内容来实现文件加速分发，提供低成本、高性能、可扩展的互联网内容分发服务，适用于相同内容反复下载的使用场景</p>\n<p>5.<br>管理元数据<br>管理元数据功能可以修改文件的HTTP响应头，实现控制客户端缓存时间、文件强制下载等策略。除一些通用响应头外，还支持配置自定义元数据。</p>\n<p>Content-Disposition 响应头指示回复的内容该以何种形式展示，是以内联的形式（即网页或者页面的一部分），还是以附件的形式下载并保存到本地。</p>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>增量数据迁移</li>\n</ol>\n<p>数据复制：由于业务原因，需要将数据从一个空间迁移至另一个空间。</p>\n<p>合规性要求：合规性要求所规定的数据需要跨一定距离保存一份副本。</p>\n<p>数据备份与容灾：如果您对所有写入的数据都希望在异地存储区域维护一份副本，以备发生如海啸、地震等特大灾难导致存储区域损毁时，还能启用异地存储区域的备份数据。</p>\n<p>最大限度减少延迟：用户处于两个地理位置。为了最大限度缩短访问对象时的延迟，可以在地理位置与用户较近的存储区域维护对象副本。</p>\n<ol start=\"2\">\n<li><p>增量数据同步是跨不同的Bucket自动、异步复制文件，它会将对源Bucket中的对象的改动（除删除操作）同步到目标Bucket。</p>\n</li>\n<li><p>对象锁定</p>\n</li>\n</ol>\n<p>对象锁定功能可以禁止文件的删除和覆盖，以保障数据可靠性和满足某些行业的合规性要求，实现一次写入，多次读取（WORM）模式。<br>部分行业规定要求重要数据必须保存一定的时间后才可以被删除，如金融服务，医疗、政务部门等；为了满足该场景，对象存储需要支持WORM(对象锁定)模式，即一次写入，多次读取。</p>\n<p>除特殊行业的强制需求外，如有其他需求需要在一定时间或永久禁止某些文件的删除和覆盖，也可以使用对象锁定功能。</p>\n<ol start=\"4\">\n<li>动态加速：通过路由优化、传输优化等动态加速技术解决跨运营商、网络不稳定等因素导致的响应慢、丢包、服务不稳定等问题，适用于较差网络环境下上传下载的场景。</li>\n</ol>\n<p>大文件下载加速：通过CDN边缘节点缓存源站内容来实现文件加速分发，提供低成本、高性能、可扩展的互联网内容分发服务，适用于相同内容反复下载的使用场景</p>\n<p>5.<br>管理元数据<br>管理元数据功能可以修改文件的HTTP响应头，实现控制客户端缓存时间、文件强制下载等策略。除一些通用响应头外，还支持配置自定义元数据。</p>\n<p>Content-Disposition 响应头指示回复的内容该以何种形式展示，是以内联的形式（即网页或者页面的一部分），还是以附件的形式下载并保存到本地。</p>\n"},{"title":"es6","date":"2019-06-28T03:58:20.000Z","_content":"### reflect \n1. 修改某些Object方法的返回结果，让其变得更合理\n```javascript\n// 老写法\ntry {\n  Object.defineProperty(target, property, attributes);\n  // success\n} catch (e) {\n  // failure\n}\n\n// 新写法\nif (Reflect.defineProperty(target, property, attributes)) {\n  // success\n} else {\n  // failure\n}\n```\n\n1. Reflect对象的方法与Proxy对象的方法一一对应\n```javascript\nProxy(target, {\n  set: function(target, name, value, receiver) {\n    var success = Reflect.set(target, name, value, receiver);\n    if (success) {\n      console.log('property ' + name + ' on ' + target + ' set to ' + value);\n    }\n    return success;\n  }\n});\n```\n \n### lit\n1. 数组的空位 [,,,]\n\n1. parentheses to be omitted, as in\n\ntry {\n  // ...\n} catch {\n  // ...\n}\n\n \n### proxy\n\n1. Proxy 的 construct 用于拦截 new()\n   isExtensible方法拦截Object.isExtensible操作。\n   ownKeys方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作。\n   \n   Object.getOwnPropertyNames()\n   Object.getOwnPropertySymbols()\n   Object.keys()\n   for...in循环\n```javascript\nvar obj = new Proxy({}, {\n     get: function (target, key, receiver) {\n       console.log(`getting ${key}!`);\n       return Reflect.get(target, key, receiver);\n     },\n     set: function (target, key, value, receiver) {\n       console.log(`setting ${key}!`);\n       return Reflect.set(target, key, value, receiver);\n     }\n   });\n```\n\n1. 绑定上下文\n\n```javascript\nfunction selfish (target) {\n  const cache = new WeakMap();\n  const handler = {\n    get (target, key) {\n      const value = Reflect.get(target, key);\n      if (typeof value !== 'function') {\n        return value;\n      }\n      if (!cache.has(value)) {\n        cache.set(value, value.bind(target));\n      }\n      return cache.get(value);\n    }\n  };\n  const proxy = new Proxy(target, handler);\n  return proxy;\n}\n\nconst logger = selfish(new Logger());\n```   \n\n#### console \n```javascript\n\nconsole.table()\nconsole.dir()\nconsole.count()\nConsole.time() \nconsoel.timeLog()\nconsole.time(\"answer time\");\nalert(\"Click to continue\");\nconsole.timeEnd(\"answer time”);\n\n```","source":"_posts/es6.md","raw":"---\ntitle: es6\ndate: 2019-06-28 11:58:20\ntags: es\n---\n### reflect \n1. 修改某些Object方法的返回结果，让其变得更合理\n```javascript\n// 老写法\ntry {\n  Object.defineProperty(target, property, attributes);\n  // success\n} catch (e) {\n  // failure\n}\n\n// 新写法\nif (Reflect.defineProperty(target, property, attributes)) {\n  // success\n} else {\n  // failure\n}\n```\n\n1. Reflect对象的方法与Proxy对象的方法一一对应\n```javascript\nProxy(target, {\n  set: function(target, name, value, receiver) {\n    var success = Reflect.set(target, name, value, receiver);\n    if (success) {\n      console.log('property ' + name + ' on ' + target + ' set to ' + value);\n    }\n    return success;\n  }\n});\n```\n \n### lit\n1. 数组的空位 [,,,]\n\n1. parentheses to be omitted, as in\n\ntry {\n  // ...\n} catch {\n  // ...\n}\n\n \n### proxy\n\n1. Proxy 的 construct 用于拦截 new()\n   isExtensible方法拦截Object.isExtensible操作。\n   ownKeys方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作。\n   \n   Object.getOwnPropertyNames()\n   Object.getOwnPropertySymbols()\n   Object.keys()\n   for...in循环\n```javascript\nvar obj = new Proxy({}, {\n     get: function (target, key, receiver) {\n       console.log(`getting ${key}!`);\n       return Reflect.get(target, key, receiver);\n     },\n     set: function (target, key, value, receiver) {\n       console.log(`setting ${key}!`);\n       return Reflect.set(target, key, value, receiver);\n     }\n   });\n```\n\n1. 绑定上下文\n\n```javascript\nfunction selfish (target) {\n  const cache = new WeakMap();\n  const handler = {\n    get (target, key) {\n      const value = Reflect.get(target, key);\n      if (typeof value !== 'function') {\n        return value;\n      }\n      if (!cache.has(value)) {\n        cache.set(value, value.bind(target));\n      }\n      return cache.get(value);\n    }\n  };\n  const proxy = new Proxy(target, handler);\n  return proxy;\n}\n\nconst logger = selfish(new Logger());\n```   \n\n#### console \n```javascript\n\nconsole.table()\nconsole.dir()\nconsole.count()\nConsole.time() \nconsoel.timeLog()\nconsole.time(\"answer time\");\nalert(\"Click to continue\");\nconsole.timeEnd(\"answer time”);\n\n```","slug":"es6","published":1,"updated":"2020-08-18T08:37:18.147Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckzf5sdz50009yy8kz8op9s2m","content":"<h3 id=\"reflect\"><a href=\"#reflect\" class=\"headerlink\" title=\"reflect\"></a>reflect</h3><ol>\n<li><p>修改某些Object方法的返回结果，让其变得更合理</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 老写法</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.defineProperty(target, property, attributes);</span><br><span class=\"line\">  <span class=\"comment\">// success</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// failure</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 新写法</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">Reflect</span>.defineProperty(target, property, attributes)) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// success</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// failure</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Reflect对象的方法与Proxy对象的方法一一对应</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Proxy</span>(target, &#123;</span><br><span class=\"line\">  <span class=\"keyword\">set</span>: function(target, name, value, receiver) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> success = <span class=\"built_in\">Reflect</span>.set(target, name, value, receiver);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (success) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'property '</span> + name + <span class=\"string\">' on '</span> + target + <span class=\"string\">' set to '</span> + value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> success;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"lit\"><a href=\"#lit\" class=\"headerlink\" title=\"lit\"></a>lit</h3><ol>\n<li><p>数组的空位 [,,,]</p>\n</li>\n<li><p>parentheses to be omitted, as in</p>\n</li>\n</ol>\n<p>try {<br>  // …<br>} catch {<br>  // …<br>}</p>\n<h3 id=\"proxy\"><a href=\"#proxy\" class=\"headerlink\" title=\"proxy\"></a>proxy</h3><ol>\n<li><p>Proxy 的 construct 用于拦截 new()<br>isExtensible方法拦截Object.isExtensible操作。<br>ownKeys方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作。</p>\n<p>Object.getOwnPropertyNames()<br>Object.getOwnPropertySymbols()<br>Object.keys()<br>for…in循环</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(&#123;&#125;, &#123;</span><br><span class=\"line\">     <span class=\"keyword\">get</span>: function (target, key, receiver) &#123;</span><br><span class=\"line\">       <span class=\"built_in\">console</span>.log(<span class=\"string\">`getting <span class=\"subst\">$&#123;key&#125;</span>!`</span>);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.get(target, key, receiver);</span><br><span class=\"line\">     &#125;,</span><br><span class=\"line\">     <span class=\"keyword\">set</span>: function (target, key, value, receiver) &#123;</span><br><span class=\"line\">       <span class=\"built_in\">console</span>.log(<span class=\"string\">`setting <span class=\"subst\">$&#123;key&#125;</span>!`</span>);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.set(target, key, value, receiver);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>绑定上下文</p>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">selfish</span> (<span class=\"params\">target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> cache = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> handler = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span> (target, key) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> value = <span class=\"built_in\">Reflect</span>.get(target, key);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> value !== <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!cache.has(value)) &#123;</span><br><span class=\"line\">        cache.set(value, value.bind(target));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> cache.get(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> proxy = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target, handler);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> proxy;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> logger = selfish(<span class=\"keyword\">new</span> Logger());</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`   </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">#### console </span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>javascript</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.table()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.dir()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.count()</span><br><span class=\"line\">Console.time() </span><br><span class=\"line\">consoel.timeLog()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.time(<span class=\"string\">\"answer time\"</span>);</span><br><span class=\"line\">alert(<span class=\"string\">\"Click to continue\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">\"answer time”);</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"reflect\"><a href=\"#reflect\" class=\"headerlink\" title=\"reflect\"></a>reflect</h3><ol>\n<li><p>修改某些Object方法的返回结果，让其变得更合理</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 老写法</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.defineProperty(target, property, attributes);</span><br><span class=\"line\">  <span class=\"comment\">// success</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// failure</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 新写法</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">Reflect</span>.defineProperty(target, property, attributes)) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// success</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// failure</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Reflect对象的方法与Proxy对象的方法一一对应</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Proxy</span>(target, &#123;</span><br><span class=\"line\">  <span class=\"keyword\">set</span>: function(target, name, value, receiver) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> success = <span class=\"built_in\">Reflect</span>.set(target, name, value, receiver);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (success) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'property '</span> + name + <span class=\"string\">' on '</span> + target + <span class=\"string\">' set to '</span> + value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> success;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"lit\"><a href=\"#lit\" class=\"headerlink\" title=\"lit\"></a>lit</h3><ol>\n<li><p>数组的空位 [,,,]</p>\n</li>\n<li><p>parentheses to be omitted, as in</p>\n</li>\n</ol>\n<p>try {<br>  // …<br>} catch {<br>  // …<br>}</p>\n<h3 id=\"proxy\"><a href=\"#proxy\" class=\"headerlink\" title=\"proxy\"></a>proxy</h3><ol>\n<li><p>Proxy 的 construct 用于拦截 new()<br>isExtensible方法拦截Object.isExtensible操作。<br>ownKeys方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作。</p>\n<p>Object.getOwnPropertyNames()<br>Object.getOwnPropertySymbols()<br>Object.keys()<br>for…in循环</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(&#123;&#125;, &#123;</span><br><span class=\"line\">     <span class=\"keyword\">get</span>: function (target, key, receiver) &#123;</span><br><span class=\"line\">       <span class=\"built_in\">console</span>.log(<span class=\"string\">`getting <span class=\"subst\">$&#123;key&#125;</span>!`</span>);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.get(target, key, receiver);</span><br><span class=\"line\">     &#125;,</span><br><span class=\"line\">     <span class=\"keyword\">set</span>: function (target, key, value, receiver) &#123;</span><br><span class=\"line\">       <span class=\"built_in\">console</span>.log(<span class=\"string\">`setting <span class=\"subst\">$&#123;key&#125;</span>!`</span>);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.set(target, key, value, receiver);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>绑定上下文</p>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">selfish</span> (<span class=\"params\">target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> cache = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> handler = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span> (target, key) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> value = <span class=\"built_in\">Reflect</span>.get(target, key);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> value !== <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!cache.has(value)) &#123;</span><br><span class=\"line\">        cache.set(value, value.bind(target));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> cache.get(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> proxy = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target, handler);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> proxy;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> logger = selfish(<span class=\"keyword\">new</span> Logger());</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`   </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">#### console </span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>javascript</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.table()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.dir()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.count()</span><br><span class=\"line\">Console.time() </span><br><span class=\"line\">consoel.timeLog()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.time(<span class=\"string\">\"answer time\"</span>);</span><br><span class=\"line\">alert(<span class=\"string\">\"Click to continue\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">\"answer time”);</span></span><br></pre></td></tr></table></figure>"},{"title":"es8","date":"2019-07-02T03:37:11.000Z","_content":"\n1. Stage 0: strawman——最初想法的提交。\n   Stage 1: proposal（提案）——由TC39至少一名成员倡导的正式提案文件，该文件包括API事例。\n   Stage 2: draft（草案）——功能规范的初始版本，该版本包含功能规范的两个实验实现。\n   Stage 3: candidate（候选）——提案规范通过审查并从厂商那里收集反馈\n   Stage 4: finished（完成）——提案准备加入ECMAScript，但是到浏览器或者Nodejs中可能需要更长的时间\n   \n2. es2018(es9) \n promise.finally  正则表达式匹配组 \n regex 先行断言和反向断言、dotall  \n \n1. Template Literals\n\n1. \n \n","source":"_posts/es8.md","raw":"---\ntitle: es8\ndate: 2019-07-02 11:37:11\ntags: es\n---\n\n1. Stage 0: strawman——最初想法的提交。\n   Stage 1: proposal（提案）——由TC39至少一名成员倡导的正式提案文件，该文件包括API事例。\n   Stage 2: draft（草案）——功能规范的初始版本，该版本包含功能规范的两个实验实现。\n   Stage 3: candidate（候选）——提案规范通过审查并从厂商那里收集反馈\n   Stage 4: finished（完成）——提案准备加入ECMAScript，但是到浏览器或者Nodejs中可能需要更长的时间\n   \n2. es2018(es9) \n promise.finally  正则表达式匹配组 \n regex 先行断言和反向断言、dotall  \n \n1. Template Literals\n\n1. \n \n","slug":"es8","published":1,"updated":"2020-06-29T06:22:24.360Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckzf5sdz7000byy8kfpyjem2w","content":"<ol>\n<li><p>Stage 0: strawman——最初想法的提交。<br>Stage 1: proposal（提案）——由TC39至少一名成员倡导的正式提案文件，该文件包括API事例。<br>Stage 2: draft（草案）——功能规范的初始版本，该版本包含功能规范的两个实验实现。<br>Stage 3: candidate（候选）——提案规范通过审查并从厂商那里收集反馈<br>Stage 4: finished（完成）——提案准备加入ECMAScript，但是到浏览器或者Nodejs中可能需要更长的时间</p>\n</li>\n<li><p>es2018(es9)<br>promise.finally  正则表达式匹配组<br>regex 先行断言和反向断言、dotall  </p>\n</li>\n<li><p>Template Literals</p>\n</li>\n<li></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><p>Stage 0: strawman——最初想法的提交。<br>Stage 1: proposal（提案）——由TC39至少一名成员倡导的正式提案文件，该文件包括API事例。<br>Stage 2: draft（草案）——功能规范的初始版本，该版本包含功能规范的两个实验实现。<br>Stage 3: candidate（候选）——提案规范通过审查并从厂商那里收集反馈<br>Stage 4: finished（完成）——提案准备加入ECMAScript，但是到浏览器或者Nodejs中可能需要更长的时间</p>\n</li>\n<li><p>es2018(es9)<br>promise.finally  正则表达式匹配组<br>regex 先行断言和反向断言、dotall  </p>\n</li>\n<li><p>Template Literals</p>\n</li>\n<li></li>\n</ol>\n"},{"title":"eslint","date":"2016-12-25T05:31:39.000Z","_content":"\nESLint 一旦发现配置文件中有 \"root\": true，它就会停止在父级目录中寻找。\n\n```\n\n在整个文件中取消eslint检查：\n\n/* eslint-disable */\n\n// Disables all rules for the rest of the file \nalert(‘foo’);\n\n在整个文件中禁用某一项eslint规则的检查：\n\n/* eslint-disable no-alert */\n\n// Disables no-alert for the rest of the file \nalert(‘foo’);\n\n针对某一行禁用eslint检查：\n\nalert(‘foo’); // eslint-disable-line\n\n// eslint-disable-next-line \nalert(‘foo’);\n\n针对某一行的某一具体规则禁用eslint检查：\n\nalert(‘foo’); // eslint-disable-line no-alert\n\n// eslint-disable-next-line no-alert \nalert(‘foo’);\n\n针对某一行禁用多项具体规则的检查：\n\nalert(‘foo’); // eslint-disable-line no-alert, quotes, semi\n\n// eslint-disable-next-line no-alert, quotes, semi \nalert(‘foo’);\n```\n\n```\n行内配置\n\n\n/*eslint-disable*/ 和 /*eslint-enable*/\n\n/*global*/\n/*eslint*/\n/*eslint-env*/\n\n\n命令行选项：\n\n--global\n--rule\n--env\n\n-c、--config\n\n\n\n项目级配置：\n\n与要检测的文件在同一目录下的 .eslintrc.* 或 package.json 文件\n继续在父级目录寻找 .eslintrc 或 package.json文件，直到根目录（包括根目录）或直到发现一个有\"root\": true的配置。\n如果不是（1）到（3）中的任何一种情况，退回到 ~/.eslintrc 中自定义的默认配置。\n\n```\n\nglob 模式的配置\n```json  \n{\n  \"rules\": {\n    \"quotes\": [ 2, \"double\" ]\n  },\n\n  \"overrides\": [\n    {\n      \"files\": [ \"bin/*.js\", \"lib/*.js\" ],\n      \"excludedFiles\": \"*.test.js\",\n      \"rules\": {\n        \"quotes\": [ 2, \"single\" ]\n      }\n    }\n  ]\n}\n\n```\n\nignore 文件配置：\n\n# Ignore built files except build/index.js\nbuild/*\n!build/index.js\n\n全局变量\n```javascript\n  globals: {\n        MyGlobal: true\n    }\n```\n\n\n ","source":"_posts/eslint.md","raw":"---\ntitle: eslint\ndate: 2016-12-25 13:31:39\ntags: eslint\n---\n\nESLint 一旦发现配置文件中有 \"root\": true，它就会停止在父级目录中寻找。\n\n```\n\n在整个文件中取消eslint检查：\n\n/* eslint-disable */\n\n// Disables all rules for the rest of the file \nalert(‘foo’);\n\n在整个文件中禁用某一项eslint规则的检查：\n\n/* eslint-disable no-alert */\n\n// Disables no-alert for the rest of the file \nalert(‘foo’);\n\n针对某一行禁用eslint检查：\n\nalert(‘foo’); // eslint-disable-line\n\n// eslint-disable-next-line \nalert(‘foo’);\n\n针对某一行的某一具体规则禁用eslint检查：\n\nalert(‘foo’); // eslint-disable-line no-alert\n\n// eslint-disable-next-line no-alert \nalert(‘foo’);\n\n针对某一行禁用多项具体规则的检查：\n\nalert(‘foo’); // eslint-disable-line no-alert, quotes, semi\n\n// eslint-disable-next-line no-alert, quotes, semi \nalert(‘foo’);\n```\n\n```\n行内配置\n\n\n/*eslint-disable*/ 和 /*eslint-enable*/\n\n/*global*/\n/*eslint*/\n/*eslint-env*/\n\n\n命令行选项：\n\n--global\n--rule\n--env\n\n-c、--config\n\n\n\n项目级配置：\n\n与要检测的文件在同一目录下的 .eslintrc.* 或 package.json 文件\n继续在父级目录寻找 .eslintrc 或 package.json文件，直到根目录（包括根目录）或直到发现一个有\"root\": true的配置。\n如果不是（1）到（3）中的任何一种情况，退回到 ~/.eslintrc 中自定义的默认配置。\n\n```\n\nglob 模式的配置\n```json  \n{\n  \"rules\": {\n    \"quotes\": [ 2, \"double\" ]\n  },\n\n  \"overrides\": [\n    {\n      \"files\": [ \"bin/*.js\", \"lib/*.js\" ],\n      \"excludedFiles\": \"*.test.js\",\n      \"rules\": {\n        \"quotes\": [ 2, \"single\" ]\n      }\n    }\n  ]\n}\n\n```\n\nignore 文件配置：\n\n# Ignore built files except build/index.js\nbuild/*\n!build/index.js\n\n全局变量\n```javascript\n  globals: {\n        MyGlobal: true\n    }\n```\n\n\n ","slug":"eslint","published":1,"updated":"2020-07-03T07:12:45.925Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckzf5sdz8000dyy8k29g6ve88","content":"<p>ESLint 一旦发现配置文件中有 “root”: true，它就会停止在父级目录中寻找。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">在整个文件中取消eslint检查：</span><br><span class=\"line\"></span><br><span class=\"line\">/* eslint-disable */</span><br><span class=\"line\"></span><br><span class=\"line\">// Disables all rules for the rest of the file </span><br><span class=\"line\">alert(‘foo’);</span><br><span class=\"line\"></span><br><span class=\"line\">在整个文件中禁用某一项eslint规则的检查：</span><br><span class=\"line\"></span><br><span class=\"line\">/* eslint-disable no-alert */</span><br><span class=\"line\"></span><br><span class=\"line\">// Disables no-alert for the rest of the file </span><br><span class=\"line\">alert(‘foo’);</span><br><span class=\"line\"></span><br><span class=\"line\">针对某一行禁用eslint检查：</span><br><span class=\"line\"></span><br><span class=\"line\">alert(‘foo’); // eslint-disable-line</span><br><span class=\"line\"></span><br><span class=\"line\">// eslint-disable-next-line </span><br><span class=\"line\">alert(‘foo’);</span><br><span class=\"line\"></span><br><span class=\"line\">针对某一行的某一具体规则禁用eslint检查：</span><br><span class=\"line\"></span><br><span class=\"line\">alert(‘foo’); // eslint-disable-line no-alert</span><br><span class=\"line\"></span><br><span class=\"line\">// eslint-disable-next-line no-alert </span><br><span class=\"line\">alert(‘foo’);</span><br><span class=\"line\"></span><br><span class=\"line\">针对某一行禁用多项具体规则的检查：</span><br><span class=\"line\"></span><br><span class=\"line\">alert(‘foo’); // eslint-disable-line no-alert, quotes, semi</span><br><span class=\"line\"></span><br><span class=\"line\">// eslint-disable-next-line no-alert, quotes, semi </span><br><span class=\"line\">alert(‘foo’);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">行内配置</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">/*eslint-disable*/ 和 /*eslint-enable*/</span><br><span class=\"line\"></span><br><span class=\"line\">/*global*/</span><br><span class=\"line\">/*eslint*/</span><br><span class=\"line\">/*eslint-env*/</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">命令行选项：</span><br><span class=\"line\"></span><br><span class=\"line\">--global</span><br><span class=\"line\">--rule</span><br><span class=\"line\">--env</span><br><span class=\"line\"></span><br><span class=\"line\">-c、--config</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">项目级配置：</span><br><span class=\"line\"></span><br><span class=\"line\">与要检测的文件在同一目录下的 .eslintrc.* 或 package.json 文件</span><br><span class=\"line\">继续在父级目录寻找 .eslintrc 或 package.json文件，直到根目录（包括根目录）或直到发现一个有&quot;root&quot;: true的配置。</span><br><span class=\"line\">如果不是（1）到（3）中的任何一种情况，退回到 ~/.eslintrc 中自定义的默认配置。</span><br></pre></td></tr></table></figure>\n<p>glob 模式的配置<br><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"rules\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"quotes\"</span>: [ <span class=\"number\">2</span>, <span class=\"string\">\"double\"</span> ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">\"overrides\"</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"files\"</span>: [ <span class=\"string\">\"bin/*.js\"</span>, <span class=\"string\">\"lib/*.js\"</span> ],</span><br><span class=\"line\">      <span class=\"attr\">\"excludedFiles\"</span>: <span class=\"string\">\"*.test.js\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"rules\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"quotes\"</span>: [ <span class=\"number\">2</span>, <span class=\"string\">\"single\"</span> ]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>ignore 文件配置：</p>\n<h1 id=\"Ignore-built-files-except-build-index-js\"><a href=\"#Ignore-built-files-except-build-index-js\" class=\"headerlink\" title=\"Ignore built files except build/index.js\"></a>Ignore built files except build/index.js</h1><p>build/*<br>!build/index.js</p>\n<p>全局变量<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">globals: &#123;</span><br><span class=\"line\">      MyGlobal: <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>ESLint 一旦发现配置文件中有 “root”: true，它就会停止在父级目录中寻找。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">在整个文件中取消eslint检查：</span><br><span class=\"line\"></span><br><span class=\"line\">/* eslint-disable */</span><br><span class=\"line\"></span><br><span class=\"line\">// Disables all rules for the rest of the file </span><br><span class=\"line\">alert(‘foo’);</span><br><span class=\"line\"></span><br><span class=\"line\">在整个文件中禁用某一项eslint规则的检查：</span><br><span class=\"line\"></span><br><span class=\"line\">/* eslint-disable no-alert */</span><br><span class=\"line\"></span><br><span class=\"line\">// Disables no-alert for the rest of the file </span><br><span class=\"line\">alert(‘foo’);</span><br><span class=\"line\"></span><br><span class=\"line\">针对某一行禁用eslint检查：</span><br><span class=\"line\"></span><br><span class=\"line\">alert(‘foo’); // eslint-disable-line</span><br><span class=\"line\"></span><br><span class=\"line\">// eslint-disable-next-line </span><br><span class=\"line\">alert(‘foo’);</span><br><span class=\"line\"></span><br><span class=\"line\">针对某一行的某一具体规则禁用eslint检查：</span><br><span class=\"line\"></span><br><span class=\"line\">alert(‘foo’); // eslint-disable-line no-alert</span><br><span class=\"line\"></span><br><span class=\"line\">// eslint-disable-next-line no-alert </span><br><span class=\"line\">alert(‘foo’);</span><br><span class=\"line\"></span><br><span class=\"line\">针对某一行禁用多项具体规则的检查：</span><br><span class=\"line\"></span><br><span class=\"line\">alert(‘foo’); // eslint-disable-line no-alert, quotes, semi</span><br><span class=\"line\"></span><br><span class=\"line\">// eslint-disable-next-line no-alert, quotes, semi </span><br><span class=\"line\">alert(‘foo’);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">行内配置</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">/*eslint-disable*/ 和 /*eslint-enable*/</span><br><span class=\"line\"></span><br><span class=\"line\">/*global*/</span><br><span class=\"line\">/*eslint*/</span><br><span class=\"line\">/*eslint-env*/</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">命令行选项：</span><br><span class=\"line\"></span><br><span class=\"line\">--global</span><br><span class=\"line\">--rule</span><br><span class=\"line\">--env</span><br><span class=\"line\"></span><br><span class=\"line\">-c、--config</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">项目级配置：</span><br><span class=\"line\"></span><br><span class=\"line\">与要检测的文件在同一目录下的 .eslintrc.* 或 package.json 文件</span><br><span class=\"line\">继续在父级目录寻找 .eslintrc 或 package.json文件，直到根目录（包括根目录）或直到发现一个有&quot;root&quot;: true的配置。</span><br><span class=\"line\">如果不是（1）到（3）中的任何一种情况，退回到 ~/.eslintrc 中自定义的默认配置。</span><br></pre></td></tr></table></figure>\n<p>glob 模式的配置<br><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"rules\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"quotes\"</span>: [ <span class=\"number\">2</span>, <span class=\"string\">\"double\"</span> ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">\"overrides\"</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"files\"</span>: [ <span class=\"string\">\"bin/*.js\"</span>, <span class=\"string\">\"lib/*.js\"</span> ],</span><br><span class=\"line\">      <span class=\"attr\">\"excludedFiles\"</span>: <span class=\"string\">\"*.test.js\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"rules\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"quotes\"</span>: [ <span class=\"number\">2</span>, <span class=\"string\">\"single\"</span> ]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>ignore 文件配置：</p>\n<h1 id=\"Ignore-built-files-except-build-index-js\"><a href=\"#Ignore-built-files-except-build-index-js\" class=\"headerlink\" title=\"Ignore built files except build/index.js\"></a>Ignore built files except build/index.js</h1><p>build/*<br>!build/index.js</p>\n<p>全局变量<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">globals: &#123;</span><br><span class=\"line\">      MyGlobal: <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"graphql","date":"2019-08-23T08:19:28.000Z","_content":"1. \n```text\nfunction(parent, args, ctx, info) {\n    …\n其中的参数的意义如下：\n\nparent: 当前上一个Resolver的返回值\nargs: 传入某个Query中的函数（比如上面例子中article(id: Int)中的id）\nctx: 在Resolver解析链中不断传递的中间变量（类似中间件架构中的context）\ninfo: 当前Query的AST对象\n}\n```\n2. query（查询）：当获取数据时，应当选取Query类型\n\n   mutation（更改）：当尝试修改数据时，应当使用mutation类型\n   \n   subscription（订阅）：当希望数据更改时，可以进行消息推送，使用subscription类型\n","source":"_posts/graphql.md","raw":"---\ntitle: graphql\ndate: 2019-08-23 16:19:28\ntags:\n---\n1. \n```text\nfunction(parent, args, ctx, info) {\n    …\n其中的参数的意义如下：\n\nparent: 当前上一个Resolver的返回值\nargs: 传入某个Query中的函数（比如上面例子中article(id: Int)中的id）\nctx: 在Resolver解析链中不断传递的中间变量（类似中间件架构中的context）\ninfo: 当前Query的AST对象\n}\n```\n2. query（查询）：当获取数据时，应当选取Query类型\n\n   mutation（更改）：当尝试修改数据时，应当使用mutation类型\n   \n   subscription（订阅）：当希望数据更改时，可以进行消息推送，使用subscription类型\n","slug":"graphql","published":1,"updated":"2020-06-29T06:22:24.361Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckzf5sdz9000fyy8k63fh6ysm","content":"<ol>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function(parent, args, ctx, info) &#123;</span><br><span class=\"line\">    …</span><br><span class=\"line\">其中的参数的意义如下：</span><br><span class=\"line\"></span><br><span class=\"line\">parent: 当前上一个Resolver的返回值</span><br><span class=\"line\">args: 传入某个Query中的函数（比如上面例子中article(id: Int)中的id）</span><br><span class=\"line\">ctx: 在Resolver解析链中不断传递的中间变量（类似中间件架构中的context）</span><br><span class=\"line\">info: 当前Query的AST对象</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>query（查询）：当获取数据时，应当选取Query类型</p>\n<p>mutation（更改）：当尝试修改数据时，应当使用mutation类型</p>\n<p>subscription（订阅）：当希望数据更改时，可以进行消息推送，使用subscription类型</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function(parent, args, ctx, info) &#123;</span><br><span class=\"line\">    …</span><br><span class=\"line\">其中的参数的意义如下：</span><br><span class=\"line\"></span><br><span class=\"line\">parent: 当前上一个Resolver的返回值</span><br><span class=\"line\">args: 传入某个Query中的函数（比如上面例子中article(id: Int)中的id）</span><br><span class=\"line\">ctx: 在Resolver解析链中不断传递的中间变量（类似中间件架构中的context）</span><br><span class=\"line\">info: 当前Query的AST对象</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>query（查询）：当获取数据时，应当选取Query类型</p>\n<p>mutation（更改）：当尝试修改数据时，应当使用mutation类型</p>\n<p>subscription（订阅）：当希望数据更改时，可以进行消息推送，使用subscription类型</p>\n</li>\n</ol>\n"},{"title":"hexo","date":"2016-12-21T03:47:39.000Z","_content":"# install\nNode和Git都安装好后,首先创建一个文件夹,如blog,用户存放hexo的配置文件,然后进入blog里安装Hexo。\n\n执行如下命令安装Hexo：\n\nsudo npm install -g hexo\n\n初始化然后，执行init命令初始化hexo,命令：\n\nhexo init\n\n好啦，至此，全部安装工作已经完成！blog就是你的博客根目录，所有的操作都在里面进行。\n\n生成静态页面\n\nhexo generate（hexo g也可以）\n\n本地启动\n\n启动本地服务，进行文章预览调试，命令：\n\nhexo server\n\n浏览器输入http://localhost:4000\n\n我不知道你们能不能，反正我不能，因为我还有环境没配置好\n\n# 配置Github\n建立Repository\n\n建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】，固定写法\n\n然后建立关联，我的blog在本地/Users/leopard/blog，blog是我之前建的东西也全在这里面，有：\n\n    _config.yml    node_modules    public      source\n\n    db.json        package.json    scaffolds  themes\n\n现在我们需要_config.yml文件，来建立关联，命令：\n\nvim _config.yml\n\n翻到最下面，改成我这样子的\n\ndeploy:\n\n     type: git\n\n     repo: https://github.com/leopardpan/leopardpan.github.io.git\n\n     branch: master\n\n然后执行命令：\n\nnpm install hexo-deployer-git --save\n\n \n# 一些常用命令：\n\nhexo new\"postName\" #新建文章\n\nhexo new page\"pageName\" #新建页面\n\nhexo generate #生成静态页面至public目录\n\nhexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\n\nhexo deploy #将.deploy目录部署到GitHub\n\nhexo help # 查看帮助\n\nhexo version #查看Hexo的版本\n\n ","source":"_posts/hexo.md","raw":"---\ntitle: hexo\ndate: 2016-12-21 11:47:39\ntags: hexo \n---\n# install\nNode和Git都安装好后,首先创建一个文件夹,如blog,用户存放hexo的配置文件,然后进入blog里安装Hexo。\n\n执行如下命令安装Hexo：\n\nsudo npm install -g hexo\n\n初始化然后，执行init命令初始化hexo,命令：\n\nhexo init\n\n好啦，至此，全部安装工作已经完成！blog就是你的博客根目录，所有的操作都在里面进行。\n\n生成静态页面\n\nhexo generate（hexo g也可以）\n\n本地启动\n\n启动本地服务，进行文章预览调试，命令：\n\nhexo server\n\n浏览器输入http://localhost:4000\n\n我不知道你们能不能，反正我不能，因为我还有环境没配置好\n\n# 配置Github\n建立Repository\n\n建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】，固定写法\n\n然后建立关联，我的blog在本地/Users/leopard/blog，blog是我之前建的东西也全在这里面，有：\n\n    _config.yml    node_modules    public      source\n\n    db.json        package.json    scaffolds  themes\n\n现在我们需要_config.yml文件，来建立关联，命令：\n\nvim _config.yml\n\n翻到最下面，改成我这样子的\n\ndeploy:\n\n     type: git\n\n     repo: https://github.com/leopardpan/leopardpan.github.io.git\n\n     branch: master\n\n然后执行命令：\n\nnpm install hexo-deployer-git --save\n\n \n# 一些常用命令：\n\nhexo new\"postName\" #新建文章\n\nhexo new page\"pageName\" #新建页面\n\nhexo generate #生成静态页面至public目录\n\nhexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\n\nhexo deploy #将.deploy目录部署到GitHub\n\nhexo help # 查看帮助\n\nhexo version #查看Hexo的版本\n\n ","slug":"hexo","published":1,"updated":"2020-06-29T06:22:24.361Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckzf5sdza000hyy8ktd9jwllr","content":"<h1 id=\"install\"><a href=\"#install\" class=\"headerlink\" title=\"install\"></a>install</h1><p>Node和Git都安装好后,首先创建一个文件夹,如blog,用户存放hexo的配置文件,然后进入blog里安装Hexo。</p>\n<p>执行如下命令安装Hexo：</p>\n<p>sudo npm install -g hexo</p>\n<p>初始化然后，执行init命令初始化hexo,命令：</p>\n<p>hexo init</p>\n<p>好啦，至此，全部安装工作已经完成！blog就是你的博客根目录，所有的操作都在里面进行。</p>\n<p>生成静态页面</p>\n<p>hexo generate（hexo g也可以）</p>\n<p>本地启动</p>\n<p>启动本地服务，进行文章预览调试，命令：</p>\n<p>hexo server</p>\n<p>浏览器输入<a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a></p>\n<p>我不知道你们能不能，反正我不能，因为我还有环境没配置好</p>\n<h1 id=\"配置Github\"><a href=\"#配置Github\" class=\"headerlink\" title=\"配置Github\"></a>配置Github</h1><p>建立Repository</p>\n<p>建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】，固定写法</p>\n<p>然后建立关联，我的blog在本地/Users/leopard/blog，blog是我之前建的东西也全在这里面，有：</p>\n<pre><code>_config.yml    node_modules    public      source\n\ndb.json        package.json    scaffolds  themes\n</code></pre><p>现在我们需要_config.yml文件，来建立关联，命令：</p>\n<p>vim _config.yml</p>\n<p>翻到最下面，改成我这样子的</p>\n<p>deploy:</p>\n<pre><code>type: git\n\nrepo: https://github.com/leopardpan/leopardpan.github.io.git\n\nbranch: master\n</code></pre><p>然后执行命令：</p>\n<p>npm install hexo-deployer-git –save</p>\n<h1 id=\"一些常用命令：\"><a href=\"#一些常用命令：\" class=\"headerlink\" title=\"一些常用命令：\"></a>一些常用命令：</h1><p>hexo new”postName” #新建文章</p>\n<p>hexo new page”pageName” #新建页面</p>\n<p>hexo generate #生成静态页面至public目录</p>\n<p>hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）</p>\n<p>hexo deploy #将.deploy目录部署到GitHub</p>\n<p>hexo help # 查看帮助</p>\n<p>hexo version #查看Hexo的版本</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"install\"><a href=\"#install\" class=\"headerlink\" title=\"install\"></a>install</h1><p>Node和Git都安装好后,首先创建一个文件夹,如blog,用户存放hexo的配置文件,然后进入blog里安装Hexo。</p>\n<p>执行如下命令安装Hexo：</p>\n<p>sudo npm install -g hexo</p>\n<p>初始化然后，执行init命令初始化hexo,命令：</p>\n<p>hexo init</p>\n<p>好啦，至此，全部安装工作已经完成！blog就是你的博客根目录，所有的操作都在里面进行。</p>\n<p>生成静态页面</p>\n<p>hexo generate（hexo g也可以）</p>\n<p>本地启动</p>\n<p>启动本地服务，进行文章预览调试，命令：</p>\n<p>hexo server</p>\n<p>浏览器输入<a href=\"http://localhost:4000\" target=\"_blank\" rel=\"noopener\">http://localhost:4000</a></p>\n<p>我不知道你们能不能，反正我不能，因为我还有环境没配置好</p>\n<h1 id=\"配置Github\"><a href=\"#配置Github\" class=\"headerlink\" title=\"配置Github\"></a>配置Github</h1><p>建立Repository</p>\n<p>建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】，固定写法</p>\n<p>然后建立关联，我的blog在本地/Users/leopard/blog，blog是我之前建的东西也全在这里面，有：</p>\n<pre><code>_config.yml    node_modules    public      source\n\ndb.json        package.json    scaffolds  themes\n</code></pre><p>现在我们需要_config.yml文件，来建立关联，命令：</p>\n<p>vim _config.yml</p>\n<p>翻到最下面，改成我这样子的</p>\n<p>deploy:</p>\n<pre><code>type: git\n\nrepo: https://github.com/leopardpan/leopardpan.github.io.git\n\nbranch: master\n</code></pre><p>然后执行命令：</p>\n<p>npm install hexo-deployer-git –save</p>\n<h1 id=\"一些常用命令：\"><a href=\"#一些常用命令：\" class=\"headerlink\" title=\"一些常用命令：\"></a>一些常用命令：</h1><p>hexo new”postName” #新建文章</p>\n<p>hexo new page”pageName” #新建页面</p>\n<p>hexo generate #生成静态页面至public目录</p>\n<p>hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）</p>\n<p>hexo deploy #将.deploy目录部署到GitHub</p>\n<p>hexo help # 查看帮助</p>\n<p>hexo version #查看Hexo的版本</p>\n"},{"title":"fresh","date":"2020-06-04T02:33:26.000Z","_content":"\n1. ① 不能通过 new 关键字调用, 没有原型\n   ② 不可以改变 this 绑定，由外层非箭头函数决定，所以使用 call, apply, bind 也不会影响\n   ③ 不支持 arguments，所以根据作用域链，会拿到外层函数的 arguments\n   ④ 不支持重复命名参数\n   ⑤ 隐式返回\n1. v-once v-pre\n1. readystate  \n```text\n 是HTTP请求的状态，当一个XMLHttpRequest初次创建时，这个属性的值从0开始，直到接收到完整的HTTP响应，这个值增加到4\n \n4：（完成）数据接收完毕，此时可以通过responseXml和responseText获取完整的回应数据\n```\n1. babel-register 则提供了动态编译。换句话说，我们的源代码能够真正运行在生产环境下，不需要 babel 编译这一环节。坏处是动态编译，导致程序在速度、性能上有所损耗。（ npx babel-node app.js） babel-node\n\n1. UMD先判断是否支持Node.js的模块（exports）是否存在，存在则使用Node.js模块模式。再判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块。\n1. Ztext.js 3d化文本支持中文\n1. Data URLs 由四个部分组成：前缀(data:)、指示数据类型的MIME类型、如果非文本则为可选的base64标记、数据本身：\n```text\ndata:[<mediatype>][;base64],<data>\nmediatype 是个 MIME 类型的字符串，例如 \"image/jpeg\" 表示 JPEG 图像文件。如果被省略，则默认值为 text/plain;charset=US-ASCII\n\n如果数据是文本类型，你可以直接将文本嵌入 (根据文档类型，使用合适的实体字符或转义字符)。如果是二进制数据，你可以将数据进行base64编码之后再进行嵌入。\n\n下面是一些示例：\n\ndata:,Hello%2C%20World!\n简单的 text/plain 类型数据\ndata:text/plain;base64,SGVsbG8sIFdvcmxkIQ%3D%3D\n上一条示例的 base64 编码版本\ndata:text/html,%3Ch1%3EHello%2C%20World!%3C%2Fh1%3E\n一个HTML文档源代码 <h1>Hello, World</h1>\ndata:text/html,<script>alert('hi');</script>\n一个会执行 JavaScript alert 的 HTML 文档。注意 script 标签必须封闭。\n\n```\n1. Url-loader 是将资源转换为base64\n4. 浏览器进程 1. 插件 2. 网络 3.Gpu 4.浏览器 5.渲染进程 浏览器为每个tab创建一个渲染进程，运行在沙箱模式下。包括 gui 线程等。\n\n1.  jest.spyOn()方法同样创建一个mock函数，但是该mock函数不仅能够捕获函数的调用情况，还可以正常的执行被spy的函数。实际上，jest.spyOn()是jest.fn()的语法糖，它创建了一个和被spy的函数具有相同内部代码的mock函数。\n \n2.  Vue Test Utils 允许你通过 shallowMount 方法只挂载一个组件而不渲染其子组件 (即保留它们的存根)：\n    \n\n12. 而对于作用域插槽，父组件在编译和渲染阶段并不会直接生成 vnodes，而是在父节点 vnode 的 data 中保留一个 scopedSlots 对象，存储着不同名称的插槽以及它们对应的渲染函数，\n只有在编译和渲染子组件阶段才会执行这个渲染函数生成 vnodes，由于是在子组件环境执行的，所以对应的数据作用域是子组件实例。\n\n\n1. 红黑树\n其实红黑树和上面的平衡二叉树类似，本质上都是为了解决排序二叉树在极端情况下退化成链表导致检索效率大大降低的问题，\n```text\n1.节点是红色或黑色。\n\n2.根节点是黑色。\n\n3.每个叶子节点都是黑色的空节点（NIL节点）。\n\n4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)\n\n5.从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。\n\n```\n\n\n\n2. 这种可以并行执行、交换执行权的线程（或函数），就称为协程。\n   \n   从实现上看，在内存中，子例程只使用一个栈（stack），而协程是同时存在多个栈，但只有一个栈是在运行状态，也就是说，协程是以多占用内存为代价，实现多任务的并行。\n   普通的线程是抢先式的，到底哪个线程优先得到资源，必须由运行环境决定，但是协程是合作式的，执行权由协程自己分配。\n   \n \n\n\n","source":"_posts/fresh.md","raw":"---\ntitle: fresh\ndate: 2020-06-04 10:33:26\ntags:\n---\n\n1. ① 不能通过 new 关键字调用, 没有原型\n   ② 不可以改变 this 绑定，由外层非箭头函数决定，所以使用 call, apply, bind 也不会影响\n   ③ 不支持 arguments，所以根据作用域链，会拿到外层函数的 arguments\n   ④ 不支持重复命名参数\n   ⑤ 隐式返回\n1. v-once v-pre\n1. readystate  \n```text\n 是HTTP请求的状态，当一个XMLHttpRequest初次创建时，这个属性的值从0开始，直到接收到完整的HTTP响应，这个值增加到4\n \n4：（完成）数据接收完毕，此时可以通过responseXml和responseText获取完整的回应数据\n```\n1. babel-register 则提供了动态编译。换句话说，我们的源代码能够真正运行在生产环境下，不需要 babel 编译这一环节。坏处是动态编译，导致程序在速度、性能上有所损耗。（ npx babel-node app.js） babel-node\n\n1. UMD先判断是否支持Node.js的模块（exports）是否存在，存在则使用Node.js模块模式。再判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块。\n1. Ztext.js 3d化文本支持中文\n1. Data URLs 由四个部分组成：前缀(data:)、指示数据类型的MIME类型、如果非文本则为可选的base64标记、数据本身：\n```text\ndata:[<mediatype>][;base64],<data>\nmediatype 是个 MIME 类型的字符串，例如 \"image/jpeg\" 表示 JPEG 图像文件。如果被省略，则默认值为 text/plain;charset=US-ASCII\n\n如果数据是文本类型，你可以直接将文本嵌入 (根据文档类型，使用合适的实体字符或转义字符)。如果是二进制数据，你可以将数据进行base64编码之后再进行嵌入。\n\n下面是一些示例：\n\ndata:,Hello%2C%20World!\n简单的 text/plain 类型数据\ndata:text/plain;base64,SGVsbG8sIFdvcmxkIQ%3D%3D\n上一条示例的 base64 编码版本\ndata:text/html,%3Ch1%3EHello%2C%20World!%3C%2Fh1%3E\n一个HTML文档源代码 <h1>Hello, World</h1>\ndata:text/html,<script>alert('hi');</script>\n一个会执行 JavaScript alert 的 HTML 文档。注意 script 标签必须封闭。\n\n```\n1. Url-loader 是将资源转换为base64\n4. 浏览器进程 1. 插件 2. 网络 3.Gpu 4.浏览器 5.渲染进程 浏览器为每个tab创建一个渲染进程，运行在沙箱模式下。包括 gui 线程等。\n\n1.  jest.spyOn()方法同样创建一个mock函数，但是该mock函数不仅能够捕获函数的调用情况，还可以正常的执行被spy的函数。实际上，jest.spyOn()是jest.fn()的语法糖，它创建了一个和被spy的函数具有相同内部代码的mock函数。\n \n2.  Vue Test Utils 允许你通过 shallowMount 方法只挂载一个组件而不渲染其子组件 (即保留它们的存根)：\n    \n\n12. 而对于作用域插槽，父组件在编译和渲染阶段并不会直接生成 vnodes，而是在父节点 vnode 的 data 中保留一个 scopedSlots 对象，存储着不同名称的插槽以及它们对应的渲染函数，\n只有在编译和渲染子组件阶段才会执行这个渲染函数生成 vnodes，由于是在子组件环境执行的，所以对应的数据作用域是子组件实例。\n\n\n1. 红黑树\n其实红黑树和上面的平衡二叉树类似，本质上都是为了解决排序二叉树在极端情况下退化成链表导致检索效率大大降低的问题，\n```text\n1.节点是红色或黑色。\n\n2.根节点是黑色。\n\n3.每个叶子节点都是黑色的空节点（NIL节点）。\n\n4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)\n\n5.从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。\n\n```\n\n\n\n2. 这种可以并行执行、交换执行权的线程（或函数），就称为协程。\n   \n   从实现上看，在内存中，子例程只使用一个栈（stack），而协程是同时存在多个栈，但只有一个栈是在运行状态，也就是说，协程是以多占用内存为代价，实现多任务的并行。\n   普通的线程是抢先式的，到底哪个线程优先得到资源，必须由运行环境决定，但是协程是合作式的，执行权由协程自己分配。\n   \n \n\n\n","slug":"fresh","published":1,"updated":"2020-09-23T12:54:36.982Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckzf5sdzb000jyy8kz036vf77","content":"<ol>\n<li>① 不能通过 new 关键字调用, 没有原型<br>② 不可以改变 this 绑定，由外层非箭头函数决定，所以使用 call, apply, bind 也不会影响<br>③ 不支持 arguments，所以根据作用域链，会拿到外层函数的 arguments<br>④ 不支持重复命名参数<br>⑤ 隐式返回</li>\n<li>v-once v-pre</li>\n<li><p>readystate  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 是HTTP请求的状态，当一个XMLHttpRequest初次创建时，这个属性的值从0开始，直到接收到完整的HTTP响应，这个值增加到4</span><br><span class=\"line\"> </span><br><span class=\"line\">4：（完成）数据接收完毕，此时可以通过responseXml和responseText获取完整的回应数据</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>babel-register 则提供了动态编译。换句话说，我们的源代码能够真正运行在生产环境下，不需要 babel 编译这一环节。坏处是动态编译，导致程序在速度、性能上有所损耗。（ npx babel-node app.js） babel-node</p>\n</li>\n<li><p>UMD先判断是否支持Node.js的模块（exports）是否存在，存在则使用Node.js模块模式。再判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块。</p>\n</li>\n<li>Ztext.js 3d化文本支持中文</li>\n<li><p>Data URLs 由四个部分组成：前缀(data:)、指示数据类型的MIME类型、如果非文本则为可选的base64标记、数据本身：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data:[&lt;mediatype&gt;][;base64],&lt;data&gt;</span><br><span class=\"line\">mediatype 是个 MIME 类型的字符串，例如 &quot;image/jpeg&quot; 表示 JPEG 图像文件。如果被省略，则默认值为 text/plain;charset=US-ASCII</span><br><span class=\"line\"></span><br><span class=\"line\">如果数据是文本类型，你可以直接将文本嵌入 (根据文档类型，使用合适的实体字符或转义字符)。如果是二进制数据，你可以将数据进行base64编码之后再进行嵌入。</span><br><span class=\"line\"></span><br><span class=\"line\">下面是一些示例：</span><br><span class=\"line\"></span><br><span class=\"line\">data:,Hello%2C%20World!</span><br><span class=\"line\">简单的 text/plain 类型数据</span><br><span class=\"line\">data:text/plain;base64,SGVsbG8sIFdvcmxkIQ%3D%3D</span><br><span class=\"line\">上一条示例的 base64 编码版本</span><br><span class=\"line\">data:text/html,%3Ch1%3EHello%2C%20World!%3C%2Fh1%3E</span><br><span class=\"line\">一个HTML文档源代码 &lt;h1&gt;Hello, World&lt;/h1&gt;</span><br><span class=\"line\">data:text/html,&lt;script&gt;alert(&apos;hi&apos;);&lt;/script&gt;</span><br><span class=\"line\">一个会执行 JavaScript alert 的 HTML 文档。注意 script 标签必须封闭。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Url-loader 是将资源转换为base64</p>\n</li>\n<li><p>浏览器进程 1. 插件 2. 网络 3.Gpu 4.浏览器 5.渲染进程 浏览器为每个tab创建一个渲染进程，运行在沙箱模式下。包括 gui 线程等。</p>\n</li>\n<li><p>jest.spyOn()方法同样创建一个mock函数，但是该mock函数不仅能够捕获函数的调用情况，还可以正常的执行被spy的函数。实际上，jest.spyOn()是jest.fn()的语法糖，它创建了一个和被spy的函数具有相同内部代码的mock函数。</p>\n</li>\n<li><p>Vue Test Utils 允许你通过 shallowMount 方法只挂载一个组件而不渲染其子组件 (即保留它们的存根)：</p>\n</li>\n</ol>\n<ol start=\"12\">\n<li>而对于作用域插槽，父组件在编译和渲染阶段并不会直接生成 vnodes，而是在父节点 vnode 的 data 中保留一个 scopedSlots 对象，存储着不同名称的插槽以及它们对应的渲染函数，<br>只有在编译和渲染子组件阶段才会执行这个渲染函数生成 vnodes，由于是在子组件环境执行的，所以对应的数据作用域是子组件实例。</li>\n</ol>\n<ol>\n<li><p>红黑树<br>其实红黑树和上面的平衡二叉树类似，本质上都是为了解决排序二叉树在极端情况下退化成链表导致检索效率大大降低的问题，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.节点是红色或黑色。</span><br><span class=\"line\"></span><br><span class=\"line\">2.根节点是黑色。</span><br><span class=\"line\"></span><br><span class=\"line\">3.每个叶子节点都是黑色的空节点（NIL节点）。</span><br><span class=\"line\"></span><br><span class=\"line\">4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</span><br><span class=\"line\"></span><br><span class=\"line\">5.从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>这种可以并行执行、交换执行权的线程（或函数），就称为协程。</p>\n<p>从实现上看，在内存中，子例程只使用一个栈（stack），而协程是同时存在多个栈，但只有一个栈是在运行状态，也就是说，协程是以多占用内存为代价，实现多任务的并行。<br>普通的线程是抢先式的，到底哪个线程优先得到资源，必须由运行环境决定，但是协程是合作式的，执行权由协程自己分配。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>① 不能通过 new 关键字调用, 没有原型<br>② 不可以改变 this 绑定，由外层非箭头函数决定，所以使用 call, apply, bind 也不会影响<br>③ 不支持 arguments，所以根据作用域链，会拿到外层函数的 arguments<br>④ 不支持重复命名参数<br>⑤ 隐式返回</li>\n<li>v-once v-pre</li>\n<li><p>readystate  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 是HTTP请求的状态，当一个XMLHttpRequest初次创建时，这个属性的值从0开始，直到接收到完整的HTTP响应，这个值增加到4</span><br><span class=\"line\"> </span><br><span class=\"line\">4：（完成）数据接收完毕，此时可以通过responseXml和responseText获取完整的回应数据</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>babel-register 则提供了动态编译。换句话说，我们的源代码能够真正运行在生产环境下，不需要 babel 编译这一环节。坏处是动态编译，导致程序在速度、性能上有所损耗。（ npx babel-node app.js） babel-node</p>\n</li>\n<li><p>UMD先判断是否支持Node.js的模块（exports）是否存在，存在则使用Node.js模块模式。再判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块。</p>\n</li>\n<li>Ztext.js 3d化文本支持中文</li>\n<li><p>Data URLs 由四个部分组成：前缀(data:)、指示数据类型的MIME类型、如果非文本则为可选的base64标记、数据本身：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data:[&lt;mediatype&gt;][;base64],&lt;data&gt;</span><br><span class=\"line\">mediatype 是个 MIME 类型的字符串，例如 &quot;image/jpeg&quot; 表示 JPEG 图像文件。如果被省略，则默认值为 text/plain;charset=US-ASCII</span><br><span class=\"line\"></span><br><span class=\"line\">如果数据是文本类型，你可以直接将文本嵌入 (根据文档类型，使用合适的实体字符或转义字符)。如果是二进制数据，你可以将数据进行base64编码之后再进行嵌入。</span><br><span class=\"line\"></span><br><span class=\"line\">下面是一些示例：</span><br><span class=\"line\"></span><br><span class=\"line\">data:,Hello%2C%20World!</span><br><span class=\"line\">简单的 text/plain 类型数据</span><br><span class=\"line\">data:text/plain;base64,SGVsbG8sIFdvcmxkIQ%3D%3D</span><br><span class=\"line\">上一条示例的 base64 编码版本</span><br><span class=\"line\">data:text/html,%3Ch1%3EHello%2C%20World!%3C%2Fh1%3E</span><br><span class=\"line\">一个HTML文档源代码 &lt;h1&gt;Hello, World&lt;/h1&gt;</span><br><span class=\"line\">data:text/html,&lt;script&gt;alert(&apos;hi&apos;);&lt;/script&gt;</span><br><span class=\"line\">一个会执行 JavaScript alert 的 HTML 文档。注意 script 标签必须封闭。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Url-loader 是将资源转换为base64</p>\n</li>\n<li><p>浏览器进程 1. 插件 2. 网络 3.Gpu 4.浏览器 5.渲染进程 浏览器为每个tab创建一个渲染进程，运行在沙箱模式下。包括 gui 线程等。</p>\n</li>\n<li><p>jest.spyOn()方法同样创建一个mock函数，但是该mock函数不仅能够捕获函数的调用情况，还可以正常的执行被spy的函数。实际上，jest.spyOn()是jest.fn()的语法糖，它创建了一个和被spy的函数具有相同内部代码的mock函数。</p>\n</li>\n<li><p>Vue Test Utils 允许你通过 shallowMount 方法只挂载一个组件而不渲染其子组件 (即保留它们的存根)：</p>\n</li>\n</ol>\n<ol start=\"12\">\n<li>而对于作用域插槽，父组件在编译和渲染阶段并不会直接生成 vnodes，而是在父节点 vnode 的 data 中保留一个 scopedSlots 对象，存储着不同名称的插槽以及它们对应的渲染函数，<br>只有在编译和渲染子组件阶段才会执行这个渲染函数生成 vnodes，由于是在子组件环境执行的，所以对应的数据作用域是子组件实例。</li>\n</ol>\n<ol>\n<li><p>红黑树<br>其实红黑树和上面的平衡二叉树类似，本质上都是为了解决排序二叉树在极端情况下退化成链表导致检索效率大大降低的问题，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.节点是红色或黑色。</span><br><span class=\"line\"></span><br><span class=\"line\">2.根节点是黑色。</span><br><span class=\"line\"></span><br><span class=\"line\">3.每个叶子节点都是黑色的空节点（NIL节点）。</span><br><span class=\"line\"></span><br><span class=\"line\">4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</span><br><span class=\"line\"></span><br><span class=\"line\">5.从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>这种可以并行执行、交换执行权的线程（或函数），就称为协程。</p>\n<p>从实现上看，在内存中，子例程只使用一个栈（stack），而协程是同时存在多个栈，但只有一个栈是在运行状态，也就是说，协程是以多占用内存为代价，实现多任务的并行。<br>普通的线程是抢先式的，到底哪个线程优先得到资源，必须由运行环境决定，但是协程是合作式的，执行权由协程自己分配。</p>\n</li>\n</ol>\n"},{"title":"gitInfo","date":"2019-02-20T09:58:18.000Z","_content":"1. git reflog 命令获取到的内容为本地仓库所有发生过的变更\n1. git branch -m feature/stor-13711 feature/story-13711  修改分支名称\n1. git config --global --edit\n1. git rm --cached  从git索引和缓存中删除 \n2. git mv 重命名或者移动文件\n3. git reset --soft \"HEAD^\" 留下当前变更内容\n4. git reset head 从当前缓存区删除\n5. git checkout .  撤销当前工作区修改\n6. git commit --amend 修改上次提交信息\n7. git log --oneline/--raw \n8. checkout只会移动HEAD指针，reset会改变HEAD的引用值。\n9. git config --global user.name [user.email]\n10. git tag -a 'annotate' -m 'message'\n11. git remote set-url --add <name> <newurl>  添加多个url\n12. git tag -d <tag-name>  \n13. git status --ignored  显示忽略掉文件\n14. git checkout --orphan <branch-name>  新建没有commit的分支\n1. git push origin :refs/tags/<tag-name>  删除远程tag\n2. git branch -u <origin/mybranch> 设置远程分支 \n2. git branch -vv 查看本地分之关联情况\n2. git checkout -  最近两个分子间切换\n1. git commit -m \"Big-ass commit\" --allow-empty\n1. git commit --amend，撤销上一次提交到暂存区，并重新提交内容；\n1. 修改分支名称\n```\ngit branch -m feature-modifySpec feature-tpaas-modifySpec  \ngit push origin -u feature-tpaas-modifySpec    \n```\n1. ","source":"_posts/gitInfo.md","raw":"---\ntitle: gitInfo\ndate: 2019-02-20 17:58:18\ntags: git\n---\n1. git reflog 命令获取到的内容为本地仓库所有发生过的变更\n1. git branch -m feature/stor-13711 feature/story-13711  修改分支名称\n1. git config --global --edit\n1. git rm --cached  从git索引和缓存中删除 \n2. git mv 重命名或者移动文件\n3. git reset --soft \"HEAD^\" 留下当前变更内容\n4. git reset head 从当前缓存区删除\n5. git checkout .  撤销当前工作区修改\n6. git commit --amend 修改上次提交信息\n7. git log --oneline/--raw \n8. checkout只会移动HEAD指针，reset会改变HEAD的引用值。\n9. git config --global user.name [user.email]\n10. git tag -a 'annotate' -m 'message'\n11. git remote set-url --add <name> <newurl>  添加多个url\n12. git tag -d <tag-name>  \n13. git status --ignored  显示忽略掉文件\n14. git checkout --orphan <branch-name>  新建没有commit的分支\n1. git push origin :refs/tags/<tag-name>  删除远程tag\n2. git branch -u <origin/mybranch> 设置远程分支 \n2. git branch -vv 查看本地分之关联情况\n2. git checkout -  最近两个分子间切换\n1. git commit -m \"Big-ass commit\" --allow-empty\n1. git commit --amend，撤销上一次提交到暂存区，并重新提交内容；\n1. 修改分支名称\n```\ngit branch -m feature-modifySpec feature-tpaas-modifySpec  \ngit push origin -u feature-tpaas-modifySpec    \n```\n1. ","slug":"gitInfo","published":1,"updated":"2021-12-22T13:08:52.753Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckzf5sdzc000lyy8k9vpw6foi","content":"<ol>\n<li>git reflog 命令获取到的内容为本地仓库所有发生过的变更</li>\n<li>git branch -m feature/stor-13711 feature/story-13711  修改分支名称</li>\n<li>git config –global –edit</li>\n<li>git rm –cached  从git索引和缓存中删除 </li>\n<li>git mv 重命名或者移动文件</li>\n<li>git reset –soft “HEAD^” 留下当前变更内容</li>\n<li>git reset head 从当前缓存区删除</li>\n<li>git checkout .  撤销当前工作区修改</li>\n<li>git commit –amend 修改上次提交信息</li>\n<li>git log –oneline/–raw </li>\n<li>checkout只会移动HEAD指针，reset会改变HEAD的引用值。</li>\n<li>git config –global user.name [user.email]</li>\n<li>git tag -a ‘annotate’ -m ‘message’</li>\n<li>git remote set-url –add <name> <newurl>  添加多个url</newurl></name></li>\n<li>git tag -d <tag-name>  </tag-name></li>\n<li>git status –ignored  显示忽略掉文件</li>\n<li>git checkout –orphan <branch-name>  新建没有commit的分支</branch-name></li>\n<li>git push origin :refs/tags/<tag-name>  删除远程tag</tag-name></li>\n<li>git branch -u &lt;origin/mybranch&gt; 设置远程分支 </li>\n<li>git branch -vv 查看本地分之关联情况</li>\n<li>git checkout -  最近两个分子间切换</li>\n<li>git commit -m “Big-ass commit” –allow-empty</li>\n<li>git commit –amend，撤销上一次提交到暂存区，并重新提交内容；</li>\n<li><p>修改分支名称</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -m feature-modifySpec feature-tpaas-modifySpec  </span><br><span class=\"line\">git push origin -u feature-tpaas-modifySpec</span><br></pre></td></tr></table></figure>\n</li>\n<li></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>git reflog 命令获取到的内容为本地仓库所有发生过的变更</li>\n<li>git branch -m feature/stor-13711 feature/story-13711  修改分支名称</li>\n<li>git config –global –edit</li>\n<li>git rm –cached  从git索引和缓存中删除 </li>\n<li>git mv 重命名或者移动文件</li>\n<li>git reset –soft “HEAD^” 留下当前变更内容</li>\n<li>git reset head 从当前缓存区删除</li>\n<li>git checkout .  撤销当前工作区修改</li>\n<li>git commit –amend 修改上次提交信息</li>\n<li>git log –oneline/–raw </li>\n<li>checkout只会移动HEAD指针，reset会改变HEAD的引用值。</li>\n<li>git config –global user.name [user.email]</li>\n<li>git tag -a ‘annotate’ -m ‘message’</li>\n<li>git remote set-url –add <name> <newurl>  添加多个url</newurl></name></li>\n<li>git tag -d <tag-name>  </tag-name></li>\n<li>git status –ignored  显示忽略掉文件</li>\n<li>git checkout –orphan <branch-name>  新建没有commit的分支</branch-name></li>\n<li>git push origin :refs/tags/<tag-name>  删除远程tag</tag-name></li>\n<li>git branch -u &lt;origin/mybranch&gt; 设置远程分支 </li>\n<li>git branch -vv 查看本地分之关联情况</li>\n<li>git checkout -  最近两个分子间切换</li>\n<li>git commit -m “Big-ass commit” –allow-empty</li>\n<li>git commit –amend，撤销上一次提交到暂存区，并重新提交内容；</li>\n<li><p>修改分支名称</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -m feature-modifySpec feature-tpaas-modifySpec  </span><br><span class=\"line\">git push origin -u feature-tpaas-modifySpec</span><br></pre></td></tr></table></figure>\n</li>\n<li></li>\n</ol>\n"},{"title":"interview","date":"2017-01-23T10:25:52.000Z","_content":"\n\n1. 企业级的特点：\n```text\n是高效 + 成熟方案的整合\n关注生产的整个链路，而不是某个环节\n有更强的约束和限制\n更严苛的要求。性能、可扩展性(以应对不同的需求)、健壮性、稳定性、可用性、安全性\n标准化\n经过生产环境验证, 有较多用例保证\n\n```\n1. Last-Modified,Etag,Expires 三个同时使用时。先判断 Expire ，然后发送 Http 请求，服务器先判断 last-modified ，再判断 Etag ，必须都没有过期，才能返回 304 响应\n\n1. \n\n1. \n 而在底层，Node.js借助libuv来作为抽象封装层， 从而屏蔽不同操作系统的差异，Node可以借助livuv来来实现多线程。\n \n ![image](http://www.admin10000.com/UploadFiles/Document/201509/30/20150930072020634231.PNG)\n \n 事件循环是单线程的，从下图可以看出\n \n ![image](http://www.admin10000.com/UploadFiles/Document/201509/30/20150930072028113909.PNG)\n \n 所有的同步任务在主线程上执行，形成一个任务栈。所有的异步任务的回调在另一队列中，只有执行完\n \n tTimeout()只是将事件插入了\"任务队列\"，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行。\n \n Node.js也是单线程的Event Loop，但是它的运行机制不同于浏览器环境。\n \n ![image](http://image.beekka.com/blog/2014/bg2014100803.png)\n \n\n```\nprocess.nextTick(function A() {\n  console.log(1);\n  process.nextTick(function B(){console.log(2);});\n});\n\nsetTimeout(function timeout() {\n  console.log('TIMEOUT FIRED');\n}, 0)\n// 1\n// 2\n// TIMEOUT FIRED\n```\n\n上面代码中，由于process.nextTick方法指定的回调函数，总是在当前\"执行栈\"的尾部触发，所以不仅函数A比setTimeout指定的回调函数timeout先执行，而且函数B也比timeout先执行。这说明，如果有多个process.nextTick语句（不管它们是否嵌套），将全部在当前\"执行栈\"执行。   setImmediate总是将事件注册到下一轮Event Loop\n\n\n　测试金字塔指的是： 当我们在编写测试用例时，底层的单元测试应该远比上层的端到端测试要多。\n　\n\n数组的shift和unshift  push 和 pop \n\nnode 优势：非阻塞IO、高并发、丰富的生态环境\n\n node有哪些全局对象?\n参考答案: process, console, Buffer和exports\n![image](https://camo.githubusercontent.com/233315761d49d4c75fe7969e36bda22ecf5bbc0f/687474703a2f2f6a6f616f7073696c76612e6769746875622e696f2f74616c6b732f456e642d746f2d456e642d4a6176615363726970742d776974682d7468652d4d45414e2d537461636b2f696d672f6e6f64656a732d617263682d7070742e706e67)\n\nprocess有哪些常用方法?\n参考答案: process.stdin, process.stdout, process.stderr, process.on, process.env, process.argv, process.arch, process.platform, process.exit\n\n通过domain获取eventemmiter 的异常：\n\n```\nvar domain = require('domain');\n    var myDomain = domain.create();\n    myDomain.on('error', function(err){\n        console.log('domain接收到的错误事件:', err);\n    }); // 接收事件并打印\n    myDomain.run(function(){\n        var emitter1 = new MyEmitter();\n        emitter1.emit('error', '错误事件来自emitter1');\n        emitter2 = new MyEmitter();\n        emitter2.emit('error', '错误事件来自emitter2');\n    });\n```\n\nsupper 代表父类构造函数和原形\n\n\n原生构造函数：\nBoolean()\nNumber()\nString()\nArray()\nDate()\nFunction()\nRegExp()\nError()\nObject()\n\nEs6 可以继承这些原生的构造函数\n \n```\nclass MyArray extends Array {\n  constructor(...args) {\n    super(...args);\n  }\n}\n\nvar arr = new MyArray();\narr[0] = 12;\narr.length // 1\n\narr.length = 0;\narr[0] // undefined\n```\n\n```\nclass ExtendableError extends Error {\n  constructor(message) {\n    super();\n    this.message = message;\n    this.stack = (new Error()).stack;\n    this.name = this.constructor.name;\n  }\n}\n\nclass MyError extends ExtendableError {\n  constructor(m) {\n    super(m);\n  }\n}\n\nvar myerror = new MyError('ll');\nmyerror.message // \"ll\"\nmyerror instanceof Error // true\nmyerror.name // \"MyError\"\nmyerror.stack\n```\n\nStream有什么好处?\n参考答案: 非阻塞式数据处理提升效率，片断处理节省内存，管道处理方便可扩展等.\n\n\nfs.watch和fs.watchFile有什么区别，怎么应用?\n参考答案: 二者主要用来监听文件变动．fs.watch利用操作系统原生机制来监听，可能不适用网络文件系统; fs.watchFile则是定期检查文件状态变更，适用于网络文件系统，但是相比fs.watch有些慢，因为不是实时机制．\n\n实现一个简单的HTTP 服务器。\nrequire('http').createServer(function(req,res){}).listen(300);\n\nspawn应用来运行返回大量数据的子进程，如图像处理，文件读取等。而exec则应用来运行只返回少量返回值的子进程，如只返回一个状态码。\n\n有哪些常用方法可以防止程序崩溃?\n\n参考答案: 1) try-catch-finally 2) EventEmitter/Stream error事件处理 3) domain统一控制 4) jshint静态检查 5) jasmine/mocha进行单元测试\n\n\n要监控nodejs的内存使用的话，需要安装memwathch 模块\n\nnodejs C++ 扩展的实现：\nhttps://my.oschina.net/yushulx/blog/423704\n\nprocess.argv 数组的第一个元素永远都会是 node，并且第二个参数总是指向你的程序的路径，所以，你应该从第三个元素\n\n \n使用 socket.write(data) 可以写数据到 socket 中，用 socket.end() 可以关闭一个 socket。另外， .end() 方法也可以接收一个数据对象作为参数，因此，你可简单地使用 socket.end(data) 来完成写数据和关闭两个操作。\n\nconcat-stream：会连接多个stream,参数中不指定encoding 的话，会自行推断。\n\n```\nvar arrays = concat({ encoding: 'array' }, function(out) {\n    t.deepEqual(out, [1,2,3,4,5,6])\n  })\n  arrays.write([1,2,3])\n  arrays.write([4,5,6])\n  arrays.end()\n```\n\n```\nfs.createReadStream(file).pipe(process.stdout);\n```\n使用through2 对流数据进行转换：\n\n通过split 将流中的数据分行：\n\nYou can use the `split` module to split input by newlines. For example:\n```\n    var split = require('split');\n    process.stdin\n        .pipe(split())\n        .pipe(through2(function (line, _, next) {\n            console.dir(line.toString());\n            next();\n        }))\n    ;\n```","source":"_posts/interview.md","raw":"---\ntitle: interview\ndate: 2017-01-23 18:25:52\ntags: interview\n---\n\n\n1. 企业级的特点：\n```text\n是高效 + 成熟方案的整合\n关注生产的整个链路，而不是某个环节\n有更强的约束和限制\n更严苛的要求。性能、可扩展性(以应对不同的需求)、健壮性、稳定性、可用性、安全性\n标准化\n经过生产环境验证, 有较多用例保证\n\n```\n1. Last-Modified,Etag,Expires 三个同时使用时。先判断 Expire ，然后发送 Http 请求，服务器先判断 last-modified ，再判断 Etag ，必须都没有过期，才能返回 304 响应\n\n1. \n\n1. \n 而在底层，Node.js借助libuv来作为抽象封装层， 从而屏蔽不同操作系统的差异，Node可以借助livuv来来实现多线程。\n \n ![image](http://www.admin10000.com/UploadFiles/Document/201509/30/20150930072020634231.PNG)\n \n 事件循环是单线程的，从下图可以看出\n \n ![image](http://www.admin10000.com/UploadFiles/Document/201509/30/20150930072028113909.PNG)\n \n 所有的同步任务在主线程上执行，形成一个任务栈。所有的异步任务的回调在另一队列中，只有执行完\n \n tTimeout()只是将事件插入了\"任务队列\"，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行。\n \n Node.js也是单线程的Event Loop，但是它的运行机制不同于浏览器环境。\n \n ![image](http://image.beekka.com/blog/2014/bg2014100803.png)\n \n\n```\nprocess.nextTick(function A() {\n  console.log(1);\n  process.nextTick(function B(){console.log(2);});\n});\n\nsetTimeout(function timeout() {\n  console.log('TIMEOUT FIRED');\n}, 0)\n// 1\n// 2\n// TIMEOUT FIRED\n```\n\n上面代码中，由于process.nextTick方法指定的回调函数，总是在当前\"执行栈\"的尾部触发，所以不仅函数A比setTimeout指定的回调函数timeout先执行，而且函数B也比timeout先执行。这说明，如果有多个process.nextTick语句（不管它们是否嵌套），将全部在当前\"执行栈\"执行。   setImmediate总是将事件注册到下一轮Event Loop\n\n\n　测试金字塔指的是： 当我们在编写测试用例时，底层的单元测试应该远比上层的端到端测试要多。\n　\n\n数组的shift和unshift  push 和 pop \n\nnode 优势：非阻塞IO、高并发、丰富的生态环境\n\n node有哪些全局对象?\n参考答案: process, console, Buffer和exports\n![image](https://camo.githubusercontent.com/233315761d49d4c75fe7969e36bda22ecf5bbc0f/687474703a2f2f6a6f616f7073696c76612e6769746875622e696f2f74616c6b732f456e642d746f2d456e642d4a6176615363726970742d776974682d7468652d4d45414e2d537461636b2f696d672f6e6f64656a732d617263682d7070742e706e67)\n\nprocess有哪些常用方法?\n参考答案: process.stdin, process.stdout, process.stderr, process.on, process.env, process.argv, process.arch, process.platform, process.exit\n\n通过domain获取eventemmiter 的异常：\n\n```\nvar domain = require('domain');\n    var myDomain = domain.create();\n    myDomain.on('error', function(err){\n        console.log('domain接收到的错误事件:', err);\n    }); // 接收事件并打印\n    myDomain.run(function(){\n        var emitter1 = new MyEmitter();\n        emitter1.emit('error', '错误事件来自emitter1');\n        emitter2 = new MyEmitter();\n        emitter2.emit('error', '错误事件来自emitter2');\n    });\n```\n\nsupper 代表父类构造函数和原形\n\n\n原生构造函数：\nBoolean()\nNumber()\nString()\nArray()\nDate()\nFunction()\nRegExp()\nError()\nObject()\n\nEs6 可以继承这些原生的构造函数\n \n```\nclass MyArray extends Array {\n  constructor(...args) {\n    super(...args);\n  }\n}\n\nvar arr = new MyArray();\narr[0] = 12;\narr.length // 1\n\narr.length = 0;\narr[0] // undefined\n```\n\n```\nclass ExtendableError extends Error {\n  constructor(message) {\n    super();\n    this.message = message;\n    this.stack = (new Error()).stack;\n    this.name = this.constructor.name;\n  }\n}\n\nclass MyError extends ExtendableError {\n  constructor(m) {\n    super(m);\n  }\n}\n\nvar myerror = new MyError('ll');\nmyerror.message // \"ll\"\nmyerror instanceof Error // true\nmyerror.name // \"MyError\"\nmyerror.stack\n```\n\nStream有什么好处?\n参考答案: 非阻塞式数据处理提升效率，片断处理节省内存，管道处理方便可扩展等.\n\n\nfs.watch和fs.watchFile有什么区别，怎么应用?\n参考答案: 二者主要用来监听文件变动．fs.watch利用操作系统原生机制来监听，可能不适用网络文件系统; fs.watchFile则是定期检查文件状态变更，适用于网络文件系统，但是相比fs.watch有些慢，因为不是实时机制．\n\n实现一个简单的HTTP 服务器。\nrequire('http').createServer(function(req,res){}).listen(300);\n\nspawn应用来运行返回大量数据的子进程，如图像处理，文件读取等。而exec则应用来运行只返回少量返回值的子进程，如只返回一个状态码。\n\n有哪些常用方法可以防止程序崩溃?\n\n参考答案: 1) try-catch-finally 2) EventEmitter/Stream error事件处理 3) domain统一控制 4) jshint静态检查 5) jasmine/mocha进行单元测试\n\n\n要监控nodejs的内存使用的话，需要安装memwathch 模块\n\nnodejs C++ 扩展的实现：\nhttps://my.oschina.net/yushulx/blog/423704\n\nprocess.argv 数组的第一个元素永远都会是 node，并且第二个参数总是指向你的程序的路径，所以，你应该从第三个元素\n\n \n使用 socket.write(data) 可以写数据到 socket 中，用 socket.end() 可以关闭一个 socket。另外， .end() 方法也可以接收一个数据对象作为参数，因此，你可简单地使用 socket.end(data) 来完成写数据和关闭两个操作。\n\nconcat-stream：会连接多个stream,参数中不指定encoding 的话，会自行推断。\n\n```\nvar arrays = concat({ encoding: 'array' }, function(out) {\n    t.deepEqual(out, [1,2,3,4,5,6])\n  })\n  arrays.write([1,2,3])\n  arrays.write([4,5,6])\n  arrays.end()\n```\n\n```\nfs.createReadStream(file).pipe(process.stdout);\n```\n使用through2 对流数据进行转换：\n\n通过split 将流中的数据分行：\n\nYou can use the `split` module to split input by newlines. For example:\n```\n    var split = require('split');\n    process.stdin\n        .pipe(split())\n        .pipe(through2(function (line, _, next) {\n            console.dir(line.toString());\n            next();\n        }))\n    ;\n```","slug":"interview","published":1,"updated":"2020-08-18T02:20:33.076Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckzf5sdzd000myy8k7p79iiia","content":"<ol>\n<li><p>企业级的特点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">是高效 + 成熟方案的整合</span><br><span class=\"line\">关注生产的整个链路，而不是某个环节</span><br><span class=\"line\">有更强的约束和限制</span><br><span class=\"line\">更严苛的要求。性能、可扩展性(以应对不同的需求)、健壮性、稳定性、可用性、安全性</span><br><span class=\"line\">标准化</span><br><span class=\"line\">经过生产环境验证, 有较多用例保证</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Last-Modified,Etag,Expires 三个同时使用时。先判断 Expire ，然后发送 Http 请求，服务器先判断 last-modified ，再判断 Etag ，必须都没有过期，才能返回 304 响应</p>\n</li>\n<li></li>\n<li><p>而在底层，Node.js借助libuv来作为抽象封装层， 从而屏蔽不同操作系统的差异，Node可以借助livuv来来实现多线程。</p>\n<p><img src=\"http://www.admin10000.com/UploadFiles/Document/201509/30/20150930072020634231.PNG\" alt=\"image\"></p>\n<p>事件循环是单线程的，从下图可以看出</p>\n<p><img src=\"http://www.admin10000.com/UploadFiles/Document/201509/30/20150930072028113909.PNG\" alt=\"image\"></p>\n<p>所有的同步任务在主线程上执行，形成一个任务栈。所有的异步任务的回调在另一队列中，只有执行完</p>\n<p>tTimeout()只是将事件插入了”任务队列”，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行。</p>\n<p>Node.js也是单线程的Event Loop，但是它的运行机制不同于浏览器环境。</p>\n<p><img src=\"http://image.beekka.com/blog/2014/bg2014100803.png\" alt=\"image\"></p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">process.nextTick(function A() &#123;</span><br><span class=\"line\">  console.log(1);</span><br><span class=\"line\">  process.nextTick(function B()&#123;console.log(2);&#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(function timeout() &#123;</span><br><span class=\"line\">  console.log(&apos;TIMEOUT FIRED&apos;);</span><br><span class=\"line\">&#125;, 0)</span><br><span class=\"line\">// 1</span><br><span class=\"line\">// 2</span><br><span class=\"line\">// TIMEOUT FIRED</span><br></pre></td></tr></table></figure>\n<p>上面代码中，由于process.nextTick方法指定的回调函数，总是在当前”执行栈”的尾部触发，所以不仅函数A比setTimeout指定的回调函数timeout先执行，而且函数B也比timeout先执行。这说明，如果有多个process.nextTick语句（不管它们是否嵌套），将全部在当前”执行栈”执行。   setImmediate总是将事件注册到下一轮Event Loop</p>\n<p>　测试金字塔指的是： 当我们在编写测试用例时，底层的单元测试应该远比上层的端到端测试要多。\n　</p>\n<p>数组的shift和unshift  push 和 pop </p>\n<p>node 优势：非阻塞IO、高并发、丰富的生态环境</p>\n<p> node有哪些全局对象?<br>参考答案: process, console, Buffer和exports<br><img src=\"https://camo.githubusercontent.com/233315761d49d4c75fe7969e36bda22ecf5bbc0f/687474703a2f2f6a6f616f7073696c76612e6769746875622e696f2f74616c6b732f456e642d746f2d456e642d4a6176615363726970742d776974682d7468652d4d45414e2d537461636b2f696d672f6e6f64656a732d617263682d7070742e706e67\" alt=\"image\"></p>\n<p>process有哪些常用方法?<br>参考答案: process.stdin, process.stdout, process.stderr, process.on, process.env, process.argv, process.arch, process.platform, process.exit</p>\n<p>通过domain获取eventemmiter 的异常：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var domain = require(&apos;domain&apos;);</span><br><span class=\"line\">    var myDomain = domain.create();</span><br><span class=\"line\">    myDomain.on(&apos;error&apos;, function(err)&#123;</span><br><span class=\"line\">        console.log(&apos;domain接收到的错误事件:&apos;, err);</span><br><span class=\"line\">    &#125;); // 接收事件并打印</span><br><span class=\"line\">    myDomain.run(function()&#123;</span><br><span class=\"line\">        var emitter1 = new MyEmitter();</span><br><span class=\"line\">        emitter1.emit(&apos;error&apos;, &apos;错误事件来自emitter1&apos;);</span><br><span class=\"line\">        emitter2 = new MyEmitter();</span><br><span class=\"line\">        emitter2.emit(&apos;error&apos;, &apos;错误事件来自emitter2&apos;);</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>supper 代表父类构造函数和原形</p>\n<p>原生构造函数：<br>Boolean()<br>Number()<br>String()<br>Array()<br>Date()<br>Function()<br>RegExp()<br>Error()<br>Object()</p>\n<p>Es6 可以继承这些原生的构造函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyArray extends Array &#123;</span><br><span class=\"line\">  constructor(...args) &#123;</span><br><span class=\"line\">    super(...args);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var arr = new MyArray();</span><br><span class=\"line\">arr[0] = 12;</span><br><span class=\"line\">arr.length // 1</span><br><span class=\"line\"></span><br><span class=\"line\">arr.length = 0;</span><br><span class=\"line\">arr[0] // undefined</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class ExtendableError extends Error &#123;</span><br><span class=\"line\">  constructor(message) &#123;</span><br><span class=\"line\">    super();</span><br><span class=\"line\">    this.message = message;</span><br><span class=\"line\">    this.stack = (new Error()).stack;</span><br><span class=\"line\">    this.name = this.constructor.name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class MyError extends ExtendableError &#123;</span><br><span class=\"line\">  constructor(m) &#123;</span><br><span class=\"line\">    super(m);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var myerror = new MyError(&apos;ll&apos;);</span><br><span class=\"line\">myerror.message // &quot;ll&quot;</span><br><span class=\"line\">myerror instanceof Error // true</span><br><span class=\"line\">myerror.name // &quot;MyError&quot;</span><br><span class=\"line\">myerror.stack</span><br></pre></td></tr></table></figure>\n<p>Stream有什么好处?<br>参考答案: 非阻塞式数据处理提升效率，片断处理节省内存，管道处理方便可扩展等.</p>\n<p>fs.watch和fs.watchFile有什么区别，怎么应用?<br>参考答案: 二者主要用来监听文件变动．fs.watch利用操作系统原生机制来监听，可能不适用网络文件系统; fs.watchFile则是定期检查文件状态变更，适用于网络文件系统，但是相比fs.watch有些慢，因为不是实时机制．</p>\n<p>实现一个简单的HTTP 服务器。<br>require(‘http’).createServer(function(req,res){}).listen(300);</p>\n<p>spawn应用来运行返回大量数据的子进程，如图像处理，文件读取等。而exec则应用来运行只返回少量返回值的子进程，如只返回一个状态码。</p>\n<p>有哪些常用方法可以防止程序崩溃?</p>\n<p>参考答案: 1) try-catch-finally 2) EventEmitter/Stream error事件处理 3) domain统一控制 4) jshint静态检查 5) jasmine/mocha进行单元测试</p>\n<p>要监控nodejs的内存使用的话，需要安装memwathch 模块</p>\n<p>nodejs C++ 扩展的实现：<br><a href=\"https://my.oschina.net/yushulx/blog/423704\" target=\"_blank\" rel=\"noopener\">https://my.oschina.net/yushulx/blog/423704</a></p>\n<p>process.argv 数组的第一个元素永远都会是 node，并且第二个参数总是指向你的程序的路径，所以，你应该从第三个元素</p>\n<p>使用 socket.write(data) 可以写数据到 socket 中，用 socket.end() 可以关闭一个 socket。另外， .end() 方法也可以接收一个数据对象作为参数，因此，你可简单地使用 socket.end(data) 来完成写数据和关闭两个操作。</p>\n<p>concat-stream：会连接多个stream,参数中不指定encoding 的话，会自行推断。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arrays = concat(&#123; encoding: &apos;array&apos; &#125;, function(out) &#123;</span><br><span class=\"line\">    t.deepEqual(out, [1,2,3,4,5,6])</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  arrays.write([1,2,3])</span><br><span class=\"line\">  arrays.write([4,5,6])</span><br><span class=\"line\">  arrays.end()</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fs.createReadStream(file).pipe(process.stdout);</span><br></pre></td></tr></table></figure>\n<p>使用through2 对流数据进行转换：</p>\n<p>通过split 将流中的数据分行：</p>\n<p>You can use the <code>split</code> module to split input by newlines. For example:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var split = require(&apos;split&apos;);</span><br><span class=\"line\">process.stdin</span><br><span class=\"line\">    .pipe(split())</span><br><span class=\"line\">    .pipe(through2(function (line, _, next) &#123;</span><br><span class=\"line\">        console.dir(line.toString());</span><br><span class=\"line\">        next();</span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><p>企业级的特点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">是高效 + 成熟方案的整合</span><br><span class=\"line\">关注生产的整个链路，而不是某个环节</span><br><span class=\"line\">有更强的约束和限制</span><br><span class=\"line\">更严苛的要求。性能、可扩展性(以应对不同的需求)、健壮性、稳定性、可用性、安全性</span><br><span class=\"line\">标准化</span><br><span class=\"line\">经过生产环境验证, 有较多用例保证</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Last-Modified,Etag,Expires 三个同时使用时。先判断 Expire ，然后发送 Http 请求，服务器先判断 last-modified ，再判断 Etag ，必须都没有过期，才能返回 304 响应</p>\n</li>\n<li></li>\n<li><p>而在底层，Node.js借助libuv来作为抽象封装层， 从而屏蔽不同操作系统的差异，Node可以借助livuv来来实现多线程。</p>\n<p><img src=\"http://www.admin10000.com/UploadFiles/Document/201509/30/20150930072020634231.PNG\" alt=\"image\"></p>\n<p>事件循环是单线程的，从下图可以看出</p>\n<p><img src=\"http://www.admin10000.com/UploadFiles/Document/201509/30/20150930072028113909.PNG\" alt=\"image\"></p>\n<p>所有的同步任务在主线程上执行，形成一个任务栈。所有的异步任务的回调在另一队列中，只有执行完</p>\n<p>tTimeout()只是将事件插入了”任务队列”，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行。</p>\n<p>Node.js也是单线程的Event Loop，但是它的运行机制不同于浏览器环境。</p>\n<p><img src=\"http://image.beekka.com/blog/2014/bg2014100803.png\" alt=\"image\"></p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">process.nextTick(function A() &#123;</span><br><span class=\"line\">  console.log(1);</span><br><span class=\"line\">  process.nextTick(function B()&#123;console.log(2);&#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(function timeout() &#123;</span><br><span class=\"line\">  console.log(&apos;TIMEOUT FIRED&apos;);</span><br><span class=\"line\">&#125;, 0)</span><br><span class=\"line\">// 1</span><br><span class=\"line\">// 2</span><br><span class=\"line\">// TIMEOUT FIRED</span><br></pre></td></tr></table></figure>\n<p>上面代码中，由于process.nextTick方法指定的回调函数，总是在当前”执行栈”的尾部触发，所以不仅函数A比setTimeout指定的回调函数timeout先执行，而且函数B也比timeout先执行。这说明，如果有多个process.nextTick语句（不管它们是否嵌套），将全部在当前”执行栈”执行。   setImmediate总是将事件注册到下一轮Event Loop</p>\n<p>　测试金字塔指的是： 当我们在编写测试用例时，底层的单元测试应该远比上层的端到端测试要多。\n　</p>\n<p>数组的shift和unshift  push 和 pop </p>\n<p>node 优势：非阻塞IO、高并发、丰富的生态环境</p>\n<p> node有哪些全局对象?<br>参考答案: process, console, Buffer和exports<br><img src=\"https://camo.githubusercontent.com/233315761d49d4c75fe7969e36bda22ecf5bbc0f/687474703a2f2f6a6f616f7073696c76612e6769746875622e696f2f74616c6b732f456e642d746f2d456e642d4a6176615363726970742d776974682d7468652d4d45414e2d537461636b2f696d672f6e6f64656a732d617263682d7070742e706e67\" alt=\"image\"></p>\n<p>process有哪些常用方法?<br>参考答案: process.stdin, process.stdout, process.stderr, process.on, process.env, process.argv, process.arch, process.platform, process.exit</p>\n<p>通过domain获取eventemmiter 的异常：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var domain = require(&apos;domain&apos;);</span><br><span class=\"line\">    var myDomain = domain.create();</span><br><span class=\"line\">    myDomain.on(&apos;error&apos;, function(err)&#123;</span><br><span class=\"line\">        console.log(&apos;domain接收到的错误事件:&apos;, err);</span><br><span class=\"line\">    &#125;); // 接收事件并打印</span><br><span class=\"line\">    myDomain.run(function()&#123;</span><br><span class=\"line\">        var emitter1 = new MyEmitter();</span><br><span class=\"line\">        emitter1.emit(&apos;error&apos;, &apos;错误事件来自emitter1&apos;);</span><br><span class=\"line\">        emitter2 = new MyEmitter();</span><br><span class=\"line\">        emitter2.emit(&apos;error&apos;, &apos;错误事件来自emitter2&apos;);</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>supper 代表父类构造函数和原形</p>\n<p>原生构造函数：<br>Boolean()<br>Number()<br>String()<br>Array()<br>Date()<br>Function()<br>RegExp()<br>Error()<br>Object()</p>\n<p>Es6 可以继承这些原生的构造函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyArray extends Array &#123;</span><br><span class=\"line\">  constructor(...args) &#123;</span><br><span class=\"line\">    super(...args);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var arr = new MyArray();</span><br><span class=\"line\">arr[0] = 12;</span><br><span class=\"line\">arr.length // 1</span><br><span class=\"line\"></span><br><span class=\"line\">arr.length = 0;</span><br><span class=\"line\">arr[0] // undefined</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class ExtendableError extends Error &#123;</span><br><span class=\"line\">  constructor(message) &#123;</span><br><span class=\"line\">    super();</span><br><span class=\"line\">    this.message = message;</span><br><span class=\"line\">    this.stack = (new Error()).stack;</span><br><span class=\"line\">    this.name = this.constructor.name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class MyError extends ExtendableError &#123;</span><br><span class=\"line\">  constructor(m) &#123;</span><br><span class=\"line\">    super(m);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var myerror = new MyError(&apos;ll&apos;);</span><br><span class=\"line\">myerror.message // &quot;ll&quot;</span><br><span class=\"line\">myerror instanceof Error // true</span><br><span class=\"line\">myerror.name // &quot;MyError&quot;</span><br><span class=\"line\">myerror.stack</span><br></pre></td></tr></table></figure>\n<p>Stream有什么好处?<br>参考答案: 非阻塞式数据处理提升效率，片断处理节省内存，管道处理方便可扩展等.</p>\n<p>fs.watch和fs.watchFile有什么区别，怎么应用?<br>参考答案: 二者主要用来监听文件变动．fs.watch利用操作系统原生机制来监听，可能不适用网络文件系统; fs.watchFile则是定期检查文件状态变更，适用于网络文件系统，但是相比fs.watch有些慢，因为不是实时机制．</p>\n<p>实现一个简单的HTTP 服务器。<br>require(‘http’).createServer(function(req,res){}).listen(300);</p>\n<p>spawn应用来运行返回大量数据的子进程，如图像处理，文件读取等。而exec则应用来运行只返回少量返回值的子进程，如只返回一个状态码。</p>\n<p>有哪些常用方法可以防止程序崩溃?</p>\n<p>参考答案: 1) try-catch-finally 2) EventEmitter/Stream error事件处理 3) domain统一控制 4) jshint静态检查 5) jasmine/mocha进行单元测试</p>\n<p>要监控nodejs的内存使用的话，需要安装memwathch 模块</p>\n<p>nodejs C++ 扩展的实现：<br><a href=\"https://my.oschina.net/yushulx/blog/423704\" target=\"_blank\" rel=\"noopener\">https://my.oschina.net/yushulx/blog/423704</a></p>\n<p>process.argv 数组的第一个元素永远都会是 node，并且第二个参数总是指向你的程序的路径，所以，你应该从第三个元素</p>\n<p>使用 socket.write(data) 可以写数据到 socket 中，用 socket.end() 可以关闭一个 socket。另外， .end() 方法也可以接收一个数据对象作为参数，因此，你可简单地使用 socket.end(data) 来完成写数据和关闭两个操作。</p>\n<p>concat-stream：会连接多个stream,参数中不指定encoding 的话，会自行推断。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arrays = concat(&#123; encoding: &apos;array&apos; &#125;, function(out) &#123;</span><br><span class=\"line\">    t.deepEqual(out, [1,2,3,4,5,6])</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  arrays.write([1,2,3])</span><br><span class=\"line\">  arrays.write([4,5,6])</span><br><span class=\"line\">  arrays.end()</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fs.createReadStream(file).pipe(process.stdout);</span><br></pre></td></tr></table></figure>\n<p>使用through2 对流数据进行转换：</p>\n<p>通过split 将流中的数据分行：</p>\n<p>You can use the <code>split</code> module to split input by newlines. For example:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var split = require(&apos;split&apos;);</span><br><span class=\"line\">process.stdin</span><br><span class=\"line\">    .pipe(split())</span><br><span class=\"line\">    .pipe(through2(function (line, _, next) &#123;</span><br><span class=\"line\">        console.dir(line.toString());</span><br><span class=\"line\">        next();</span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"http","date":"2019-05-14T07:17:39.000Z","_content":"1. Origin:scheme, host, and port.\n    same origin 更加严格 \n#### Quic \n1. 多路复用，避免队头阻塞\n1. 减少 RTT，请求更快速\n1. 快速迭代，广泛支持\n\n传统的 HTTP2 + SSL + TCP 协议栈有哪些缺点？\n1.SSL 的会话恢复依然需要一个 RTT，而且难以合并到 TCP 层\n1. TCP 的滑动窗口存在队头阻塞问题\n1. TCP 的重传纠错会浪费一个 RTT\n\n网络请求中一个常见的名词是 RTT(Round Trip Time)，表示客户端从发出一个请求数据，到接收到响应数据之间间隔的时间。\n\n#### Dns 本地dns解析器和host->本地dns服务器 \n#### http 请求限制\n默认情况下，浏览器会针对这些情况使用同一个连接：\n\n同一域名下的资源；\n\n不同域名下的资源，但是满足两个条件：1）解析到同一个 IP；2）使用同一个证书；\n\n使用多域名加上相同的 IP 和证书部署 Web 服务有特殊的意义：让支持 HTTP/2 的终端只建立一个连接，用上 HTTP/2 协议带来的各种好处；而只支持 HTTP/1.1 的终端则会建立多个连接，达到同时更多并发请求的目的。这在 HTTP/2 完全普及前也是一个不错的选择。\n\n####cors\n简单请求 可以直接发不用预检。简单请求\n1. Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain\n1. Method head,get,post\n\n\n####XST 的全称是 Cross-Site Tracing\n\n    客户端发 TRACE 请求至服务器，如果服务器按照标准实现了 TRACE 响应，则在 response body 里会返回此次请求的完整头信息。通过这种方式，客户端可以获取某些敏感的头字段，例如 httpOnly 的 Cookie。\n\n    TRACE方法让客户端测试到服务器的网络通路，回路的意思如发送一个请返回一个响应，这就是一个请求响应回路\n\n####Set-Cookie\n    用于设置Cookie。\n    \n    Set-Cookie: name=value; secure; HttpOnly\n    secure 只在进行HTTP通信时发送Cookie。\n    HttpOnly 指定不能从JavaScript脚本代码访问Cookie值。\n    \n ####X-Download-Options: noopen\n    noopen 用于指定IE 8以上版本的用户不打开文件而直接保存文件。在下载对话框中不显示“打开”选项。\n \n ####keepalive \n \n    若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;   \n    http 1.0中默认是关闭的，需要在http头加入\"Connection: Keep-Alive\"，才能启用Keep-Alive；http 1.1中默认启用Keep-Alive，如果加入\"Connection: close \"，才关闭。目前大部分浏览器都是用http1.1协议，也就是说默认都会发起Keep-Alive的连接请求了，所以是否能完成一个完整的Keep-Alive连接就看服务器设置情况。\n    \n ####headers\n \n Accept-Charset： 浏览器申明自己接收的字符集 \n Accept-Encoding： 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate） \n \n  Age：当代理服务器用自己缓存的实体去响应请求时，用该头部表明该实体从产生到现在经过多长时间了。   \n  \n   http header 中使用location 进行302跳转 \n   \n   URL.createObjectURL() 静态方法会创建一个 DOMString，其中包含一个表示参数中给出的对象的URL。这个 URL 的生命周期和创建它的窗口中的 document 绑定。这个新的URL 对象表示指定的 File 对象或 Blob 对象。\n\n####http \n```text\nhttp 1.1 添加cache-contol \n\n长连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个长连接，而HTP1.1默认支持长连接\n节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）\nhost域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端口）：HTTP1.0没有host域\n\n\nhttp 2.0\n采用二进制格式传输;\n多路复用，其实就是将请求数据分成帧乱序发送到 TCP 中。TCP 只能有一个 steam，所以还是会阻塞;\n报头压缩;\n服务器推送主动向 B 端发送静态资源，避免往返延迟。\n1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好\n2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量\n3.多路复用：一个连接可以并发处理多个请求\n4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源\n\nhttp 3.0\n采用 QUIC 协议,自定义连接机制;自定义重传机制;无阻塞的多路复用\n\n2.按缓存分：强缓存和协商缓存：\n2.1强缓存：利用 cache-control 和 expires 设置，直接返回一个过期时间，所以在缓存期间不请求，If-modify-since；\n2.2协商缓存：响应头返回 etag 或 last-modified 的哈希值，第二次请求头 If-none-match 或 IF-modify-since 携带上次哈希值，一致则返回 304。\nF5 刷新会忽略强缓存不会忽略协商缓存，ctrl+f5 都失效\n```       \n\n1. Https https://zhuanlan.zhihu.com/p/27395037    https://blog.51cto.com/11883699/2160032\n1. Ca 使用证书颁发机构的证书中的公钥去解密被颁发者的指纹算法和指纹，并计算比对指纹，正确才能验证身份\n\n1. 缓存的分类：\n```text\n   强缓存：在缓存数据未失效的情况下，不需要再和服务器发生交互.cache-control :no-cache 走协商缓存\n   协商缓存：需要与服务端校验是否使用缓存。etag If-None-Match HTTP 请求头内提供 ETag\n```\n\n\n1. https \n```text\n这些ＣＡ本身也有证书来证明自己的身份，并且ＣＡ的信用是像树一样分级的，高层的ＣＡ给底层的ＣＡ做信用背书，而操作系统／浏览器中会内置一些顶层的ＣＡ的证书，相当于你自动信任了他们。　\n\n公钥+个人信息+其它信息—》hash 算法 —》信息摘要-》用ca的私钥加密—》数字签名   签名+信息=数字证书 \nCa 的公钥解密—》hash hash 算法 —》信息摘要-》对比是否一致\n\n```\n\n1. content-type\n```text\nmultipart/form-data\n\n请求消息头中, Content-Type: multipart/form-data; boundary=----WebKitFormBoundarykALcKBgBaI9xA79y\nboundary为分隔符.\n\napplication/x-www-form-urlencoded\n```\n\n1. Nat network adreess translation 网络地址转换.\n  当访问外网时自动分配一个端口，这个端口和内网的机器建立了映射关系。\n1. Defer\n\n   这个属性的用途是表明脚本在执行时不会影响页面的构造。也就是说，脚本会被延迟到整个页面都解析完毕后再运行。因此，在script元素中设置defer属性，相当于告诉浏览器立即下载，但延迟执行。\n   但与defer不同的是，标记为async的脚本并不保证按照它们的先后顺序执行。\n1.    在 http 1.1 中，在响应头中设置 keep-alive 可以在一个 TCP 连接上发送多个 http 请求\n      \n      避免了重开 TCP 连接的开销\n      避免了刷新时重新建立 SSL 连接的开销\n      避免了QPS过大时，服务器的连接数过大\n      \n1. 缓存协商\n \n ```text\n我们知道协商缓存有两种方式\n\nLast-Modified/if-Modified-Since  ** Last-Modified 是由一个 unix timestamp 表示，则意味着它只能作用于秒级的改变**\nETag/If-None-Match\n```     \n1. window.opener 表示打开当前窗体页面的的父窗体的是谁。例如，在 A 页面中，通过一个带有 target=\"_blank\" 的 a 标签打开了一个新的页面 B，那么在 B 页面里，window.opener 的值为 A 页面的 window 对象。   rel=noopener 规定禁止新页面传递源页面的地址，通过设置了此属性的链接打开的页面，其 window.opener 的值为 null。\n1. Gzip 不要使用再图片以及其它二进制文件上\n\n1. 302 临时重定向会改变method  \n502  收到了上游相应但是无法解析  \n504 上游解析超时\n1. gzip 使用了 LZ77 算法与 Huffman 编码来压缩文件，重复度越高的文件可压缩的空间就越大\n1. Etag etag = '{:x}-{:x}'.format(header.last_modified, header.content_lenth)\n1. Mtime 文件最近内容改变的时间\n1. https 解决三个安全问题 1. 内容隐私 2. 防篡改 3.身份认证\n1. LRU AND LFU  最久未使用 最少使用\n1. [浏览器进程](https://user-gold-cdn.xitu.io/2020/1/7/16f7ee19a85b3c8f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n1. \nHTTP/2引入二进制数据帧和流的概念，其中帧对数据进行顺序标识，如下图所示，这样浏览器收到数据之后，就可以按照序列对数据进行合并，而不会出现合并后数据错乱的情况。同样是因为有了序列，服务器就可以并行的传输数据，这就是流所做的事情。http2 静态资源的推送\n1. 查看network请求发现，每一个文件都有etag响应头，如果Nginx使用了已有的gz文件，那么这个请求的etag值不带有W/，反之，如果是文件是Nginx压缩的，etag值则会带有W/\n\n1. 总是设置 Vary: Origin，避免 CDN 缓存破坏 CORS 配置\n2. QUIC 基于 UDP，UDP 的数据包在接收端没有处理顺序，即使中间 丢失一个包，也不会阻塞整条连接，其他的资源会被正常处理。\n1. 30X 区分\n```text\n301，Moved Permanently。永久重定向，该操作比较危险，需要谨慎操作：如果设置了301，但是一段时间后又想取消，但是浏览器中已经有了缓存，还是会重定向。\n302，Fount。临时重定向，但是会在重定向的时候改变 method: 把 POST 改成 GET，于是有了 307\n307，Temporary Redirect。临时重定向，在重定向时不会改变 method\n```\n\n1.  Tcp 的滑动窗口增大了吞吐量，但是并没有解决队头堵塞得问题\n1.  http 挥手 主动关闭有个time_wait,这个标准的持续时间是4分钟\n\n      ISN(Initial Sequence Number) 是固定的么，\n     \n      客户端的syn_send 状态、服务端的syn_rcvd\n      \n      Tcp 报文段：tcp 首部+tcp 数据部分\n     \n      半链接队列—超时重传\n      \n      等待2个msl 确保服务端能收到ack,能正常关闭\n     \n      关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。\n2. 如果 300 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错。 \n\n3. 而HTTP的204(No Content)响应, 就表示执行成功, 但是没有数据, 浏览器不用刷新页面.也不用导向新的页面.  \n     205 Reset Content, 表示执行成功, 重置页面(Form表单).\n\n1. 子网是所属VPC IP地址范围内的 IP 地址块。目前私有网络中的云资源部署在子网内，如云主机、容器、负载均衡等。子网：子网是对VPC地址空间的再一次划分，用户可以在子网中创建云主机。\n\n1. 可用区（Availability Zone）是电力及网络之间互相独立的物理区域，相同可用区内的实例之间较之同地域不同可用区内实例之间的网络延时更小。同地域内不同可用区之间提供内网互通环境，可用区之间可做到故障隔离。\n  若您的业务要求有较低网络时延，建议将实例或者Pod部署在同一可用区内。\n  \n1. VPC：VPC是用户网络在京东云上的表现形式，包含了一系列的网络功能，与其他的VPC逻辑隔离。VPC有一个网络地址空间，用户可以在其中继续划分子网。\n\n1. NAT 地址网络转换，通过在路由器上安装 NAT 软件，它至少有一个有效的公网 IP 地址，通过 NAT 路由器将内部私有 IP 转换成公网 IP。它的问题在于 NAT 设备自动屏蔽了非内网主机主动发起的连接，也就是说，从外网发往内网的数据包将被 NAT 设备丢弃，这使得位于不同 NAT 设备之后的主机之间无法直接交换信息.\n  \n1. 503 服务器资源不足问题导致的拒绝服务，比如熔断。\n1. Options  \n```text\n   1. 检测服务支持的method\n   2. Cors 预检\n```\n1. HTTP HEAD 方法 请求资源的头部信息, 并且这些头部与 HTTP GET 方法请求时返回的一致. 该请求方法的一个使用场景是在下载一个大文件前先获取其大小再决定是否要下载, 以此可以节约带宽资源.\n1. WebSocket是基于Http协议的，或者说借用了Http协议来完成一部分握手，在握手阶段与Http是相同的。我们来看一个websocket握手协议的实现，基本是2个属性，upgrade，connection。\n```text\nUpgrade:webSocket\nConnection:Upgrade\n```     ","source":"_posts/http.md","raw":"---\ntitle: http\ndate: 2019-05-14 15:17:39\ntags: http\n---\n1. Origin:scheme, host, and port.\n    same origin 更加严格 \n#### Quic \n1. 多路复用，避免队头阻塞\n1. 减少 RTT，请求更快速\n1. 快速迭代，广泛支持\n\n传统的 HTTP2 + SSL + TCP 协议栈有哪些缺点？\n1.SSL 的会话恢复依然需要一个 RTT，而且难以合并到 TCP 层\n1. TCP 的滑动窗口存在队头阻塞问题\n1. TCP 的重传纠错会浪费一个 RTT\n\n网络请求中一个常见的名词是 RTT(Round Trip Time)，表示客户端从发出一个请求数据，到接收到响应数据之间间隔的时间。\n\n#### Dns 本地dns解析器和host->本地dns服务器 \n#### http 请求限制\n默认情况下，浏览器会针对这些情况使用同一个连接：\n\n同一域名下的资源；\n\n不同域名下的资源，但是满足两个条件：1）解析到同一个 IP；2）使用同一个证书；\n\n使用多域名加上相同的 IP 和证书部署 Web 服务有特殊的意义：让支持 HTTP/2 的终端只建立一个连接，用上 HTTP/2 协议带来的各种好处；而只支持 HTTP/1.1 的终端则会建立多个连接，达到同时更多并发请求的目的。这在 HTTP/2 完全普及前也是一个不错的选择。\n\n####cors\n简单请求 可以直接发不用预检。简单请求\n1. Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain\n1. Method head,get,post\n\n\n####XST 的全称是 Cross-Site Tracing\n\n    客户端发 TRACE 请求至服务器，如果服务器按照标准实现了 TRACE 响应，则在 response body 里会返回此次请求的完整头信息。通过这种方式，客户端可以获取某些敏感的头字段，例如 httpOnly 的 Cookie。\n\n    TRACE方法让客户端测试到服务器的网络通路，回路的意思如发送一个请返回一个响应，这就是一个请求响应回路\n\n####Set-Cookie\n    用于设置Cookie。\n    \n    Set-Cookie: name=value; secure; HttpOnly\n    secure 只在进行HTTP通信时发送Cookie。\n    HttpOnly 指定不能从JavaScript脚本代码访问Cookie值。\n    \n ####X-Download-Options: noopen\n    noopen 用于指定IE 8以上版本的用户不打开文件而直接保存文件。在下载对话框中不显示“打开”选项。\n \n ####keepalive \n \n    若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;   \n    http 1.0中默认是关闭的，需要在http头加入\"Connection: Keep-Alive\"，才能启用Keep-Alive；http 1.1中默认启用Keep-Alive，如果加入\"Connection: close \"，才关闭。目前大部分浏览器都是用http1.1协议，也就是说默认都会发起Keep-Alive的连接请求了，所以是否能完成一个完整的Keep-Alive连接就看服务器设置情况。\n    \n ####headers\n \n Accept-Charset： 浏览器申明自己接收的字符集 \n Accept-Encoding： 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate） \n \n  Age：当代理服务器用自己缓存的实体去响应请求时，用该头部表明该实体从产生到现在经过多长时间了。   \n  \n   http header 中使用location 进行302跳转 \n   \n   URL.createObjectURL() 静态方法会创建一个 DOMString，其中包含一个表示参数中给出的对象的URL。这个 URL 的生命周期和创建它的窗口中的 document 绑定。这个新的URL 对象表示指定的 File 对象或 Blob 对象。\n\n####http \n```text\nhttp 1.1 添加cache-contol \n\n长连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个长连接，而HTP1.1默认支持长连接\n节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）\nhost域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端口）：HTTP1.0没有host域\n\n\nhttp 2.0\n采用二进制格式传输;\n多路复用，其实就是将请求数据分成帧乱序发送到 TCP 中。TCP 只能有一个 steam，所以还是会阻塞;\n报头压缩;\n服务器推送主动向 B 端发送静态资源，避免往返延迟。\n1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好\n2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量\n3.多路复用：一个连接可以并发处理多个请求\n4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源\n\nhttp 3.0\n采用 QUIC 协议,自定义连接机制;自定义重传机制;无阻塞的多路复用\n\n2.按缓存分：强缓存和协商缓存：\n2.1强缓存：利用 cache-control 和 expires 设置，直接返回一个过期时间，所以在缓存期间不请求，If-modify-since；\n2.2协商缓存：响应头返回 etag 或 last-modified 的哈希值，第二次请求头 If-none-match 或 IF-modify-since 携带上次哈希值，一致则返回 304。\nF5 刷新会忽略强缓存不会忽略协商缓存，ctrl+f5 都失效\n```       \n\n1. Https https://zhuanlan.zhihu.com/p/27395037    https://blog.51cto.com/11883699/2160032\n1. Ca 使用证书颁发机构的证书中的公钥去解密被颁发者的指纹算法和指纹，并计算比对指纹，正确才能验证身份\n\n1. 缓存的分类：\n```text\n   强缓存：在缓存数据未失效的情况下，不需要再和服务器发生交互.cache-control :no-cache 走协商缓存\n   协商缓存：需要与服务端校验是否使用缓存。etag If-None-Match HTTP 请求头内提供 ETag\n```\n\n\n1. https \n```text\n这些ＣＡ本身也有证书来证明自己的身份，并且ＣＡ的信用是像树一样分级的，高层的ＣＡ给底层的ＣＡ做信用背书，而操作系统／浏览器中会内置一些顶层的ＣＡ的证书，相当于你自动信任了他们。　\n\n公钥+个人信息+其它信息—》hash 算法 —》信息摘要-》用ca的私钥加密—》数字签名   签名+信息=数字证书 \nCa 的公钥解密—》hash hash 算法 —》信息摘要-》对比是否一致\n\n```\n\n1. content-type\n```text\nmultipart/form-data\n\n请求消息头中, Content-Type: multipart/form-data; boundary=----WebKitFormBoundarykALcKBgBaI9xA79y\nboundary为分隔符.\n\napplication/x-www-form-urlencoded\n```\n\n1. Nat network adreess translation 网络地址转换.\n  当访问外网时自动分配一个端口，这个端口和内网的机器建立了映射关系。\n1. Defer\n\n   这个属性的用途是表明脚本在执行时不会影响页面的构造。也就是说，脚本会被延迟到整个页面都解析完毕后再运行。因此，在script元素中设置defer属性，相当于告诉浏览器立即下载，但延迟执行。\n   但与defer不同的是，标记为async的脚本并不保证按照它们的先后顺序执行。\n1.    在 http 1.1 中，在响应头中设置 keep-alive 可以在一个 TCP 连接上发送多个 http 请求\n      \n      避免了重开 TCP 连接的开销\n      避免了刷新时重新建立 SSL 连接的开销\n      避免了QPS过大时，服务器的连接数过大\n      \n1. 缓存协商\n \n ```text\n我们知道协商缓存有两种方式\n\nLast-Modified/if-Modified-Since  ** Last-Modified 是由一个 unix timestamp 表示，则意味着它只能作用于秒级的改变**\nETag/If-None-Match\n```     \n1. window.opener 表示打开当前窗体页面的的父窗体的是谁。例如，在 A 页面中，通过一个带有 target=\"_blank\" 的 a 标签打开了一个新的页面 B，那么在 B 页面里，window.opener 的值为 A 页面的 window 对象。   rel=noopener 规定禁止新页面传递源页面的地址，通过设置了此属性的链接打开的页面，其 window.opener 的值为 null。\n1. Gzip 不要使用再图片以及其它二进制文件上\n\n1. 302 临时重定向会改变method  \n502  收到了上游相应但是无法解析  \n504 上游解析超时\n1. gzip 使用了 LZ77 算法与 Huffman 编码来压缩文件，重复度越高的文件可压缩的空间就越大\n1. Etag etag = '{:x}-{:x}'.format(header.last_modified, header.content_lenth)\n1. Mtime 文件最近内容改变的时间\n1. https 解决三个安全问题 1. 内容隐私 2. 防篡改 3.身份认证\n1. LRU AND LFU  最久未使用 最少使用\n1. [浏览器进程](https://user-gold-cdn.xitu.io/2020/1/7/16f7ee19a85b3c8f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n1. \nHTTP/2引入二进制数据帧和流的概念，其中帧对数据进行顺序标识，如下图所示，这样浏览器收到数据之后，就可以按照序列对数据进行合并，而不会出现合并后数据错乱的情况。同样是因为有了序列，服务器就可以并行的传输数据，这就是流所做的事情。http2 静态资源的推送\n1. 查看network请求发现，每一个文件都有etag响应头，如果Nginx使用了已有的gz文件，那么这个请求的etag值不带有W/，反之，如果是文件是Nginx压缩的，etag值则会带有W/\n\n1. 总是设置 Vary: Origin，避免 CDN 缓存破坏 CORS 配置\n2. QUIC 基于 UDP，UDP 的数据包在接收端没有处理顺序，即使中间 丢失一个包，也不会阻塞整条连接，其他的资源会被正常处理。\n1. 30X 区分\n```text\n301，Moved Permanently。永久重定向，该操作比较危险，需要谨慎操作：如果设置了301，但是一段时间后又想取消，但是浏览器中已经有了缓存，还是会重定向。\n302，Fount。临时重定向，但是会在重定向的时候改变 method: 把 POST 改成 GET，于是有了 307\n307，Temporary Redirect。临时重定向，在重定向时不会改变 method\n```\n\n1.  Tcp 的滑动窗口增大了吞吐量，但是并没有解决队头堵塞得问题\n1.  http 挥手 主动关闭有个time_wait,这个标准的持续时间是4分钟\n\n      ISN(Initial Sequence Number) 是固定的么，\n     \n      客户端的syn_send 状态、服务端的syn_rcvd\n      \n      Tcp 报文段：tcp 首部+tcp 数据部分\n     \n      半链接队列—超时重传\n      \n      等待2个msl 确保服务端能收到ack,能正常关闭\n     \n      关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。\n2. 如果 300 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错。 \n\n3. 而HTTP的204(No Content)响应, 就表示执行成功, 但是没有数据, 浏览器不用刷新页面.也不用导向新的页面.  \n     205 Reset Content, 表示执行成功, 重置页面(Form表单).\n\n1. 子网是所属VPC IP地址范围内的 IP 地址块。目前私有网络中的云资源部署在子网内，如云主机、容器、负载均衡等。子网：子网是对VPC地址空间的再一次划分，用户可以在子网中创建云主机。\n\n1. 可用区（Availability Zone）是电力及网络之间互相独立的物理区域，相同可用区内的实例之间较之同地域不同可用区内实例之间的网络延时更小。同地域内不同可用区之间提供内网互通环境，可用区之间可做到故障隔离。\n  若您的业务要求有较低网络时延，建议将实例或者Pod部署在同一可用区内。\n  \n1. VPC：VPC是用户网络在京东云上的表现形式，包含了一系列的网络功能，与其他的VPC逻辑隔离。VPC有一个网络地址空间，用户可以在其中继续划分子网。\n\n1. NAT 地址网络转换，通过在路由器上安装 NAT 软件，它至少有一个有效的公网 IP 地址，通过 NAT 路由器将内部私有 IP 转换成公网 IP。它的问题在于 NAT 设备自动屏蔽了非内网主机主动发起的连接，也就是说，从外网发往内网的数据包将被 NAT 设备丢弃，这使得位于不同 NAT 设备之后的主机之间无法直接交换信息.\n  \n1. 503 服务器资源不足问题导致的拒绝服务，比如熔断。\n1. Options  \n```text\n   1. 检测服务支持的method\n   2. Cors 预检\n```\n1. HTTP HEAD 方法 请求资源的头部信息, 并且这些头部与 HTTP GET 方法请求时返回的一致. 该请求方法的一个使用场景是在下载一个大文件前先获取其大小再决定是否要下载, 以此可以节约带宽资源.\n1. WebSocket是基于Http协议的，或者说借用了Http协议来完成一部分握手，在握手阶段与Http是相同的。我们来看一个websocket握手协议的实现，基本是2个属性，upgrade，connection。\n```text\nUpgrade:webSocket\nConnection:Upgrade\n```     ","slug":"http","published":1,"updated":"2021-04-30T11:14:48.275Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckzf5sdzf000pyy8ka3xwt8wg","content":"<ol>\n<li>Origin:scheme, host, and port.<br> same origin 更加严格 <h4 id=\"Quic\"><a href=\"#Quic\" class=\"headerlink\" title=\"Quic\"></a>Quic</h4></li>\n<li>多路复用，避免队头阻塞</li>\n<li>减少 RTT，请求更快速</li>\n<li>快速迭代，广泛支持</li>\n</ol>\n<p>传统的 HTTP2 + SSL + TCP 协议栈有哪些缺点？<br>1.SSL 的会话恢复依然需要一个 RTT，而且难以合并到 TCP 层</p>\n<ol>\n<li>TCP 的滑动窗口存在队头阻塞问题</li>\n<li>TCP 的重传纠错会浪费一个 RTT</li>\n</ol>\n<p>网络请求中一个常见的名词是 RTT(Round Trip Time)，表示客户端从发出一个请求数据，到接收到响应数据之间间隔的时间。</p>\n<h4 id=\"Dns-本地dns解析器和host-gt-本地dns服务器\"><a href=\"#Dns-本地dns解析器和host-gt-本地dns服务器\" class=\"headerlink\" title=\"Dns 本地dns解析器和host-&gt;本地dns服务器\"></a>Dns 本地dns解析器和host-&gt;本地dns服务器</h4><h4 id=\"http-请求限制\"><a href=\"#http-请求限制\" class=\"headerlink\" title=\"http 请求限制\"></a>http 请求限制</h4><p>默认情况下，浏览器会针对这些情况使用同一个连接：</p>\n<p>同一域名下的资源；</p>\n<p>不同域名下的资源，但是满足两个条件：1）解析到同一个 IP；2）使用同一个证书；</p>\n<p>使用多域名加上相同的 IP 和证书部署 Web 服务有特殊的意义：让支持 HTTP/2 的终端只建立一个连接，用上 HTTP/2 协议带来的各种好处；而只支持 HTTP/1.1 的终端则会建立多个连接，达到同时更多并发请求的目的。这在 HTTP/2 完全普及前也是一个不错的选择。</p>\n<p>####cors<br>简单请求 可以直接发不用预检。简单请求</p>\n<ol>\n<li>Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</li>\n<li>Method head,get,post</li>\n</ol>\n<p>####XST 的全称是 Cross-Site Tracing</p>\n<pre><code>客户端发 TRACE 请求至服务器，如果服务器按照标准实现了 TRACE 响应，则在 response body 里会返回此次请求的完整头信息。通过这种方式，客户端可以获取某些敏感的头字段，例如 httpOnly 的 Cookie。\n\nTRACE方法让客户端测试到服务器的网络通路，回路的意思如发送一个请返回一个响应，这就是一个请求响应回路\n</code></pre><p>####Set-Cookie<br>    用于设置Cookie。</p>\n<pre><code>Set-Cookie: name=value; secure; HttpOnly\nsecure 只在进行HTTP通信时发送Cookie。\nHttpOnly 指定不能从JavaScript脚本代码访问Cookie值。\n</code></pre><p> ####X-Download-Options: noopen<br>    noopen 用于指定IE 8以上版本的用户不打开文件而直接保存文件。在下载对话框中不显示“打开”选项。</p>\n<p> ####keepalive </p>\n<pre><code>若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;   \nhttp 1.0中默认是关闭的，需要在http头加入&quot;Connection: Keep-Alive&quot;，才能启用Keep-Alive；http 1.1中默认启用Keep-Alive，如果加入&quot;Connection: close &quot;，才关闭。目前大部分浏览器都是用http1.1协议，也就是说默认都会发起Keep-Alive的连接请求了，所以是否能完成一个完整的Keep-Alive连接就看服务器设置情况。\n</code></pre><p> ####headers</p>\n<p> Accept-Charset： 浏览器申明自己接收的字符集<br> Accept-Encoding： 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate） </p>\n<p>  Age：当代理服务器用自己缓存的实体去响应请求时，用该头部表明该实体从产生到现在经过多长时间了。   </p>\n<p>   http header 中使用location 进行302跳转 </p>\n<p>   URL.createObjectURL() 静态方法会创建一个 DOMString，其中包含一个表示参数中给出的对象的URL。这个 URL 的生命周期和创建它的窗口中的 document 绑定。这个新的URL 对象表示指定的 File 对象或 Blob 对象。</p>\n<p>####http<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http 1.1 添加cache-contol </span><br><span class=\"line\"></span><br><span class=\"line\">长连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个长连接，而HTP1.1默认支持长连接</span><br><span class=\"line\">节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）</span><br><span class=\"line\">host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端口）：HTTP1.0没有host域</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">http 2.0</span><br><span class=\"line\">采用二进制格式传输;</span><br><span class=\"line\">多路复用，其实就是将请求数据分成帧乱序发送到 TCP 中。TCP 只能有一个 steam，所以还是会阻塞;</span><br><span class=\"line\">报头压缩;</span><br><span class=\"line\">服务器推送主动向 B 端发送静态资源，避免往返延迟。</span><br><span class=\"line\">1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好</span><br><span class=\"line\">2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量</span><br><span class=\"line\">3.多路复用：一个连接可以并发处理多个请求</span><br><span class=\"line\">4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源</span><br><span class=\"line\"></span><br><span class=\"line\">http 3.0</span><br><span class=\"line\">采用 QUIC 协议,自定义连接机制;自定义重传机制;无阻塞的多路复用</span><br><span class=\"line\"></span><br><span class=\"line\">2.按缓存分：强缓存和协商缓存：</span><br><span class=\"line\">2.1强缓存：利用 cache-control 和 expires 设置，直接返回一个过期时间，所以在缓存期间不请求，If-modify-since；</span><br><span class=\"line\">2.2协商缓存：响应头返回 etag 或 last-modified 的哈希值，第二次请求头 If-none-match 或 IF-modify-since 携带上次哈希值，一致则返回 304。</span><br><span class=\"line\">F5 刷新会忽略强缓存不会忽略协商缓存，ctrl+f5 都失效</span><br><span class=\"line\">```       </span><br><span class=\"line\"></span><br><span class=\"line\">1. Https https://zhuanlan.zhihu.com/p/27395037    https://blog.51cto.com/11883699/2160032</span><br><span class=\"line\">1. Ca 使用证书颁发机构的证书中的公钥去解密被颁发者的指纹算法和指纹，并计算比对指纹，正确才能验证身份</span><br><span class=\"line\"></span><br><span class=\"line\">1. 缓存的分类：</span><br><span class=\"line\">```text</span><br><span class=\"line\">   强缓存：在缓存数据未失效的情况下，不需要再和服务器发生交互.cache-control :no-cache 走协商缓存</span><br><span class=\"line\">   协商缓存：需要与服务端校验是否使用缓存。etag If-None-Match HTTP 请求头内提供 ETag</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li><p>https </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这些ＣＡ本身也有证书来证明自己的身份，并且ＣＡ的信用是像树一样分级的，高层的ＣＡ给底层的ＣＡ做信用背书，而操作系统／浏览器中会内置一些顶层的ＣＡ的证书，相当于你自动信任了他们。　</span><br><span class=\"line\"></span><br><span class=\"line\">公钥+个人信息+其它信息—》hash 算法 —》信息摘要-》用ca的私钥加密—》数字签名   签名+信息=数字证书 </span><br><span class=\"line\">Ca 的公钥解密—》hash hash 算法 —》信息摘要-》对比是否一致</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>content-type</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">multipart/form-data</span><br><span class=\"line\"></span><br><span class=\"line\">请求消息头中, Content-Type: multipart/form-data; boundary=----WebKitFormBoundarykALcKBgBaI9xA79y</span><br><span class=\"line\">boundary为分隔符.</span><br><span class=\"line\"></span><br><span class=\"line\">application/x-www-form-urlencoded</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Nat network adreess translation 网络地址转换.<br>当访问外网时自动分配一个端口，这个端口和内网的机器建立了映射关系。</p>\n</li>\n<li><p>Defer</p>\n<p>这个属性的用途是表明脚本在执行时不会影响页面的构造。也就是说，脚本会被延迟到整个页面都解析完毕后再运行。因此，在script元素中设置defer属性，相当于告诉浏览器立即下载，但延迟执行。<br>但与defer不同的是，标记为async的脚本并不保证按照它们的先后顺序执行。</p>\n</li>\n<li><p>在 http 1.1 中，在响应头中设置 keep-alive 可以在一个 TCP 连接上发送多个 http 请求</p>\n<p>避免了重开 TCP 连接的开销<br>避免了刷新时重新建立 SSL 连接的开销<br>避免了QPS过大时，服务器的连接数过大</p>\n</li>\n<li><p>缓存协商</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我们知道协商缓存有两种方式</span><br><span class=\"line\"></span><br><span class=\"line\">Last-Modified/if-Modified-Since  ** Last-Modified 是由一个 unix timestamp 表示，则意味着它只能作用于秒级的改变**</span><br><span class=\"line\">ETag/If-None-Match</span><br><span class=\"line\">```     </span><br><span class=\"line\">1. window.opener 表示打开当前窗体页面的的父窗体的是谁。例如，在 A 页面中，通过一个带有 target=&quot;_blank&quot; 的 a 标签打开了一个新的页面 B，那么在 B 页面里，window.opener 的值为 A 页面的 window 对象。   rel=noopener 规定禁止新页面传递源页面的地址，通过设置了此属性的链接打开的页面，其 window.opener 的值为 null。</span><br><span class=\"line\">1. Gzip 不要使用再图片以及其它二进制文件上</span><br><span class=\"line\"></span><br><span class=\"line\">1. 302 临时重定向会改变method  </span><br><span class=\"line\">502  收到了上游相应但是无法解析  </span><br><span class=\"line\">504 上游解析超时</span><br><span class=\"line\">1. gzip 使用了 LZ77 算法与 Huffman 编码来压缩文件，重复度越高的文件可压缩的空间就越大</span><br><span class=\"line\">1. Etag etag = &apos;&#123;:x&#125;-&#123;:x&#125;&apos;.format(header.last_modified, header.content_lenth)</span><br><span class=\"line\">1. Mtime 文件最近内容改变的时间</span><br><span class=\"line\">1. https 解决三个安全问题 1. 内容隐私 2. 防篡改 3.身份认证</span><br><span class=\"line\">1. LRU AND LFU  最久未使用 最少使用</span><br><span class=\"line\">1. [浏览器进程](https://user-gold-cdn.xitu.io/2020/1/7/16f7ee19a85b3c8f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)</span><br><span class=\"line\">1. </span><br><span class=\"line\">HTTP/2引入二进制数据帧和流的概念，其中帧对数据进行顺序标识，如下图所示，这样浏览器收到数据之后，就可以按照序列对数据进行合并，而不会出现合并后数据错乱的情况。同样是因为有了序列，服务器就可以并行的传输数据，这就是流所做的事情。http2 静态资源的推送</span><br><span class=\"line\">1. 查看network请求发现，每一个文件都有etag响应头，如果Nginx使用了已有的gz文件，那么这个请求的etag值不带有W/，反之，如果是文件是Nginx压缩的，etag值则会带有W/</span><br><span class=\"line\"></span><br><span class=\"line\">1. 总是设置 Vary: Origin，避免 CDN 缓存破坏 CORS 配置</span><br><span class=\"line\">2. QUIC 基于 UDP，UDP 的数据包在接收端没有处理顺序，即使中间 丢失一个包，也不会阻塞整条连接，其他的资源会被正常处理。</span><br><span class=\"line\">1. 30X 区分</span><br><span class=\"line\">```text</span><br><span class=\"line\">301，Moved Permanently。永久重定向，该操作比较危险，需要谨慎操作：如果设置了301，但是一段时间后又想取消，但是浏览器中已经有了缓存，还是会重定向。</span><br><span class=\"line\">302，Fount。临时重定向，但是会在重定向的时候改变 method: 把 POST 改成 GET，于是有了 307</span><br><span class=\"line\">307，Temporary Redirect。临时重定向，在重定向时不会改变 method</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Tcp 的滑动窗口增大了吞吐量，但是并没有解决队头堵塞得问题</p>\n</li>\n<li><p>http 挥手 主动关闭有个time_wait,这个标准的持续时间是4分钟</p>\n<p>  ISN(Initial Sequence Number) 是固定的么，</p>\n<p>  客户端的syn_send 状态、服务端的syn_rcvd</p>\n<p>  Tcp 报文段：tcp 首部+tcp 数据部分</p>\n<p>  半链接队列—超时重传</p>\n<p>  等待2个msl 确保服务端能收到ack,能正常关闭</p>\n<p>  关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。</p>\n</li>\n<li><p>如果 300 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错。 </p>\n</li>\n<li><p>而HTTP的204(No Content)响应, 就表示执行成功, 但是没有数据, 浏览器不用刷新页面.也不用导向新的页面.<br>  205 Reset Content, 表示执行成功, 重置页面(Form表单).</p>\n</li>\n<li><p>子网是所属VPC IP地址范围内的 IP 地址块。目前私有网络中的云资源部署在子网内，如云主机、容器、负载均衡等。子网：子网是对VPC地址空间的再一次划分，用户可以在子网中创建云主机。</p>\n</li>\n<li><p>可用区（Availability Zone）是电力及网络之间互相独立的物理区域，相同可用区内的实例之间较之同地域不同可用区内实例之间的网络延时更小。同地域内不同可用区之间提供内网互通环境，可用区之间可做到故障隔离。<br>若您的业务要求有较低网络时延，建议将实例或者Pod部署在同一可用区内。</p>\n</li>\n<li><p>VPC：VPC是用户网络在京东云上的表现形式，包含了一系列的网络功能，与其他的VPC逻辑隔离。VPC有一个网络地址空间，用户可以在其中继续划分子网。</p>\n</li>\n<li><p>NAT 地址网络转换，通过在路由器上安装 NAT 软件，它至少有一个有效的公网 IP 地址，通过 NAT 路由器将内部私有 IP 转换成公网 IP。它的问题在于 NAT 设备自动屏蔽了非内网主机主动发起的连接，也就是说，从外网发往内网的数据包将被 NAT 设备丢弃，这使得位于不同 NAT 设备之后的主机之间无法直接交换信息.</p>\n</li>\n<li><p>503 服务器资源不足问题导致的拒绝服务，比如熔断。</p>\n</li>\n<li><p>Options  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 检测服务支持的method</span><br><span class=\"line\">2. Cors 预检</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>HTTP HEAD 方法 请求资源的头部信息, 并且这些头部与 HTTP GET 方法请求时返回的一致. 该请求方法的一个使用场景是在下载一个大文件前先获取其大小再决定是否要下载, 以此可以节约带宽资源.</p>\n</li>\n<li>WebSocket是基于Http协议的，或者说借用了Http协议来完成一部分握手，在握手阶段与Http是相同的。我们来看一个websocket握手协议的实现，基本是2个属性，upgrade，connection。<pre><code class=\"text\">Upgrade:webSocket\nConnection:Upgrade\n</code></pre>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>Origin:scheme, host, and port.<br> same origin 更加严格 <h4 id=\"Quic\"><a href=\"#Quic\" class=\"headerlink\" title=\"Quic\"></a>Quic</h4></li>\n<li>多路复用，避免队头阻塞</li>\n<li>减少 RTT，请求更快速</li>\n<li>快速迭代，广泛支持</li>\n</ol>\n<p>传统的 HTTP2 + SSL + TCP 协议栈有哪些缺点？<br>1.SSL 的会话恢复依然需要一个 RTT，而且难以合并到 TCP 层</p>\n<ol>\n<li>TCP 的滑动窗口存在队头阻塞问题</li>\n<li>TCP 的重传纠错会浪费一个 RTT</li>\n</ol>\n<p>网络请求中一个常见的名词是 RTT(Round Trip Time)，表示客户端从发出一个请求数据，到接收到响应数据之间间隔的时间。</p>\n<h4 id=\"Dns-本地dns解析器和host-gt-本地dns服务器\"><a href=\"#Dns-本地dns解析器和host-gt-本地dns服务器\" class=\"headerlink\" title=\"Dns 本地dns解析器和host-&gt;本地dns服务器\"></a>Dns 本地dns解析器和host-&gt;本地dns服务器</h4><h4 id=\"http-请求限制\"><a href=\"#http-请求限制\" class=\"headerlink\" title=\"http 请求限制\"></a>http 请求限制</h4><p>默认情况下，浏览器会针对这些情况使用同一个连接：</p>\n<p>同一域名下的资源；</p>\n<p>不同域名下的资源，但是满足两个条件：1）解析到同一个 IP；2）使用同一个证书；</p>\n<p>使用多域名加上相同的 IP 和证书部署 Web 服务有特殊的意义：让支持 HTTP/2 的终端只建立一个连接，用上 HTTP/2 协议带来的各种好处；而只支持 HTTP/1.1 的终端则会建立多个连接，达到同时更多并发请求的目的。这在 HTTP/2 完全普及前也是一个不错的选择。</p>\n<p>####cors<br>简单请求 可以直接发不用预检。简单请求</p>\n<ol>\n<li>Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</li>\n<li>Method head,get,post</li>\n</ol>\n<p>####XST 的全称是 Cross-Site Tracing</p>\n<pre><code>客户端发 TRACE 请求至服务器，如果服务器按照标准实现了 TRACE 响应，则在 response body 里会返回此次请求的完整头信息。通过这种方式，客户端可以获取某些敏感的头字段，例如 httpOnly 的 Cookie。\n\nTRACE方法让客户端测试到服务器的网络通路，回路的意思如发送一个请返回一个响应，这就是一个请求响应回路\n</code></pre><p>####Set-Cookie<br>    用于设置Cookie。</p>\n<pre><code>Set-Cookie: name=value; secure; HttpOnly\nsecure 只在进行HTTP通信时发送Cookie。\nHttpOnly 指定不能从JavaScript脚本代码访问Cookie值。\n</code></pre><p> ####X-Download-Options: noopen<br>    noopen 用于指定IE 8以上版本的用户不打开文件而直接保存文件。在下载对话框中不显示“打开”选项。</p>\n<p> ####keepalive </p>\n<pre><code>若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;   \nhttp 1.0中默认是关闭的，需要在http头加入&quot;Connection: Keep-Alive&quot;，才能启用Keep-Alive；http 1.1中默认启用Keep-Alive，如果加入&quot;Connection: close &quot;，才关闭。目前大部分浏览器都是用http1.1协议，也就是说默认都会发起Keep-Alive的连接请求了，所以是否能完成一个完整的Keep-Alive连接就看服务器设置情况。\n</code></pre><p> ####headers</p>\n<p> Accept-Charset： 浏览器申明自己接收的字符集<br> Accept-Encoding： 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate） </p>\n<p>  Age：当代理服务器用自己缓存的实体去响应请求时，用该头部表明该实体从产生到现在经过多长时间了。   </p>\n<p>   http header 中使用location 进行302跳转 </p>\n<p>   URL.createObjectURL() 静态方法会创建一个 DOMString，其中包含一个表示参数中给出的对象的URL。这个 URL 的生命周期和创建它的窗口中的 document 绑定。这个新的URL 对象表示指定的 File 对象或 Blob 对象。</p>\n<p>####http<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http 1.1 添加cache-contol </span><br><span class=\"line\"></span><br><span class=\"line\">长连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个长连接，而HTP1.1默认支持长连接</span><br><span class=\"line\">节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）</span><br><span class=\"line\">host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端口）：HTTP1.0没有host域</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">http 2.0</span><br><span class=\"line\">采用二进制格式传输;</span><br><span class=\"line\">多路复用，其实就是将请求数据分成帧乱序发送到 TCP 中。TCP 只能有一个 steam，所以还是会阻塞;</span><br><span class=\"line\">报头压缩;</span><br><span class=\"line\">服务器推送主动向 B 端发送静态资源，避免往返延迟。</span><br><span class=\"line\">1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好</span><br><span class=\"line\">2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量</span><br><span class=\"line\">3.多路复用：一个连接可以并发处理多个请求</span><br><span class=\"line\">4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源</span><br><span class=\"line\"></span><br><span class=\"line\">http 3.0</span><br><span class=\"line\">采用 QUIC 协议,自定义连接机制;自定义重传机制;无阻塞的多路复用</span><br><span class=\"line\"></span><br><span class=\"line\">2.按缓存分：强缓存和协商缓存：</span><br><span class=\"line\">2.1强缓存：利用 cache-control 和 expires 设置，直接返回一个过期时间，所以在缓存期间不请求，If-modify-since；</span><br><span class=\"line\">2.2协商缓存：响应头返回 etag 或 last-modified 的哈希值，第二次请求头 If-none-match 或 IF-modify-since 携带上次哈希值，一致则返回 304。</span><br><span class=\"line\">F5 刷新会忽略强缓存不会忽略协商缓存，ctrl+f5 都失效</span><br><span class=\"line\">```       </span><br><span class=\"line\"></span><br><span class=\"line\">1. Https https://zhuanlan.zhihu.com/p/27395037    https://blog.51cto.com/11883699/2160032</span><br><span class=\"line\">1. Ca 使用证书颁发机构的证书中的公钥去解密被颁发者的指纹算法和指纹，并计算比对指纹，正确才能验证身份</span><br><span class=\"line\"></span><br><span class=\"line\">1. 缓存的分类：</span><br><span class=\"line\">```text</span><br><span class=\"line\">   强缓存：在缓存数据未失效的情况下，不需要再和服务器发生交互.cache-control :no-cache 走协商缓存</span><br><span class=\"line\">   协商缓存：需要与服务端校验是否使用缓存。etag If-None-Match HTTP 请求头内提供 ETag</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li><p>https </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这些ＣＡ本身也有证书来证明自己的身份，并且ＣＡ的信用是像树一样分级的，高层的ＣＡ给底层的ＣＡ做信用背书，而操作系统／浏览器中会内置一些顶层的ＣＡ的证书，相当于你自动信任了他们。　</span><br><span class=\"line\"></span><br><span class=\"line\">公钥+个人信息+其它信息—》hash 算法 —》信息摘要-》用ca的私钥加密—》数字签名   签名+信息=数字证书 </span><br><span class=\"line\">Ca 的公钥解密—》hash hash 算法 —》信息摘要-》对比是否一致</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>content-type</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">multipart/form-data</span><br><span class=\"line\"></span><br><span class=\"line\">请求消息头中, Content-Type: multipart/form-data; boundary=----WebKitFormBoundarykALcKBgBaI9xA79y</span><br><span class=\"line\">boundary为分隔符.</span><br><span class=\"line\"></span><br><span class=\"line\">application/x-www-form-urlencoded</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Nat network adreess translation 网络地址转换.<br>当访问外网时自动分配一个端口，这个端口和内网的机器建立了映射关系。</p>\n</li>\n<li><p>Defer</p>\n<p>这个属性的用途是表明脚本在执行时不会影响页面的构造。也就是说，脚本会被延迟到整个页面都解析完毕后再运行。因此，在script元素中设置defer属性，相当于告诉浏览器立即下载，但延迟执行。<br>但与defer不同的是，标记为async的脚本并不保证按照它们的先后顺序执行。</p>\n</li>\n<li><p>在 http 1.1 中，在响应头中设置 keep-alive 可以在一个 TCP 连接上发送多个 http 请求</p>\n<p>避免了重开 TCP 连接的开销<br>避免了刷新时重新建立 SSL 连接的开销<br>避免了QPS过大时，服务器的连接数过大</p>\n</li>\n<li><p>缓存协商</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我们知道协商缓存有两种方式</span><br><span class=\"line\"></span><br><span class=\"line\">Last-Modified/if-Modified-Since  ** Last-Modified 是由一个 unix timestamp 表示，则意味着它只能作用于秒级的改变**</span><br><span class=\"line\">ETag/If-None-Match</span><br><span class=\"line\">```     </span><br><span class=\"line\">1. window.opener 表示打开当前窗体页面的的父窗体的是谁。例如，在 A 页面中，通过一个带有 target=&quot;_blank&quot; 的 a 标签打开了一个新的页面 B，那么在 B 页面里，window.opener 的值为 A 页面的 window 对象。   rel=noopener 规定禁止新页面传递源页面的地址，通过设置了此属性的链接打开的页面，其 window.opener 的值为 null。</span><br><span class=\"line\">1. Gzip 不要使用再图片以及其它二进制文件上</span><br><span class=\"line\"></span><br><span class=\"line\">1. 302 临时重定向会改变method  </span><br><span class=\"line\">502  收到了上游相应但是无法解析  </span><br><span class=\"line\">504 上游解析超时</span><br><span class=\"line\">1. gzip 使用了 LZ77 算法与 Huffman 编码来压缩文件，重复度越高的文件可压缩的空间就越大</span><br><span class=\"line\">1. Etag etag = &apos;&#123;:x&#125;-&#123;:x&#125;&apos;.format(header.last_modified, header.content_lenth)</span><br><span class=\"line\">1. Mtime 文件最近内容改变的时间</span><br><span class=\"line\">1. https 解决三个安全问题 1. 内容隐私 2. 防篡改 3.身份认证</span><br><span class=\"line\">1. LRU AND LFU  最久未使用 最少使用</span><br><span class=\"line\">1. [浏览器进程](https://user-gold-cdn.xitu.io/2020/1/7/16f7ee19a85b3c8f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)</span><br><span class=\"line\">1. </span><br><span class=\"line\">HTTP/2引入二进制数据帧和流的概念，其中帧对数据进行顺序标识，如下图所示，这样浏览器收到数据之后，就可以按照序列对数据进行合并，而不会出现合并后数据错乱的情况。同样是因为有了序列，服务器就可以并行的传输数据，这就是流所做的事情。http2 静态资源的推送</span><br><span class=\"line\">1. 查看network请求发现，每一个文件都有etag响应头，如果Nginx使用了已有的gz文件，那么这个请求的etag值不带有W/，反之，如果是文件是Nginx压缩的，etag值则会带有W/</span><br><span class=\"line\"></span><br><span class=\"line\">1. 总是设置 Vary: Origin，避免 CDN 缓存破坏 CORS 配置</span><br><span class=\"line\">2. QUIC 基于 UDP，UDP 的数据包在接收端没有处理顺序，即使中间 丢失一个包，也不会阻塞整条连接，其他的资源会被正常处理。</span><br><span class=\"line\">1. 30X 区分</span><br><span class=\"line\">```text</span><br><span class=\"line\">301，Moved Permanently。永久重定向，该操作比较危险，需要谨慎操作：如果设置了301，但是一段时间后又想取消，但是浏览器中已经有了缓存，还是会重定向。</span><br><span class=\"line\">302，Fount。临时重定向，但是会在重定向的时候改变 method: 把 POST 改成 GET，于是有了 307</span><br><span class=\"line\">307，Temporary Redirect。临时重定向，在重定向时不会改变 method</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Tcp 的滑动窗口增大了吞吐量，但是并没有解决队头堵塞得问题</p>\n</li>\n<li><p>http 挥手 主动关闭有个time_wait,这个标准的持续时间是4分钟</p>\n<p>  ISN(Initial Sequence Number) 是固定的么，</p>\n<p>  客户端的syn_send 状态、服务端的syn_rcvd</p>\n<p>  Tcp 报文段：tcp 首部+tcp 数据部分</p>\n<p>  半链接队列—超时重传</p>\n<p>  等待2个msl 确保服务端能收到ack,能正常关闭</p>\n<p>  关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。</p>\n</li>\n<li><p>如果 300 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错。 </p>\n</li>\n<li><p>而HTTP的204(No Content)响应, 就表示执行成功, 但是没有数据, 浏览器不用刷新页面.也不用导向新的页面.<br>  205 Reset Content, 表示执行成功, 重置页面(Form表单).</p>\n</li>\n<li><p>子网是所属VPC IP地址范围内的 IP 地址块。目前私有网络中的云资源部署在子网内，如云主机、容器、负载均衡等。子网：子网是对VPC地址空间的再一次划分，用户可以在子网中创建云主机。</p>\n</li>\n<li><p>可用区（Availability Zone）是电力及网络之间互相独立的物理区域，相同可用区内的实例之间较之同地域不同可用区内实例之间的网络延时更小。同地域内不同可用区之间提供内网互通环境，可用区之间可做到故障隔离。<br>若您的业务要求有较低网络时延，建议将实例或者Pod部署在同一可用区内。</p>\n</li>\n<li><p>VPC：VPC是用户网络在京东云上的表现形式，包含了一系列的网络功能，与其他的VPC逻辑隔离。VPC有一个网络地址空间，用户可以在其中继续划分子网。</p>\n</li>\n<li><p>NAT 地址网络转换，通过在路由器上安装 NAT 软件，它至少有一个有效的公网 IP 地址，通过 NAT 路由器将内部私有 IP 转换成公网 IP。它的问题在于 NAT 设备自动屏蔽了非内网主机主动发起的连接，也就是说，从外网发往内网的数据包将被 NAT 设备丢弃，这使得位于不同 NAT 设备之后的主机之间无法直接交换信息.</p>\n</li>\n<li><p>503 服务器资源不足问题导致的拒绝服务，比如熔断。</p>\n</li>\n<li><p>Options  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 检测服务支持的method</span><br><span class=\"line\">2. Cors 预检</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>HTTP HEAD 方法 请求资源的头部信息, 并且这些头部与 HTTP GET 方法请求时返回的一致. 该请求方法的一个使用场景是在下载一个大文件前先获取其大小再决定是否要下载, 以此可以节约带宽资源.</p>\n</li>\n<li>WebSocket是基于Http协议的，或者说借用了Http协议来完成一部分握手，在握手阶段与Http是相同的。我们来看一个websocket握手协议的实现，基本是2个属性，upgrade，connection。<pre><code class=\"text\">Upgrade:webSocket\nConnection:Upgrade\n</code></pre>\n</li>\n</ol>\n"},{"title":"k8s","date":"2021-11-18T09:10:24.000Z","_content":"\n### helm \n\n1. helm pull itg/rds-console —version=XXXX —untar\n\n1. helm uninstall $rds_console_chart_name -n ${{out._predefine.NAMESPACE}}\n\n1. helm add repo\n\n`helm repo add itg ${{helm_repo}} --username ${{cred.helm_zhangchong.username}}   --password ${{cred.helm_zhangchong.password}}  `\n\n`helm repo update`\n\n1. 由 helm install -f 或 helm upgrade -f 提供的 value 文件\n\n```\n# 安装本地 chart\nhelm install -f myvalues.yaml myredis ./redis\n# 指定变量\nhelm install --set name=prod myredis ./redis\n```\n\n### k8s\n\n1. Service的IP地址，此为虚拟IP地址。外部网络无法ping通，只有kubernetes集群内部访问使用。\n\n1. 由于 Kubernetes 集群中每个 Pod（容器组）都有一个唯一的 IP 地址（即使是同一个 Node 上的不同 Pod），我们需要一种机制，为前端系统屏蔽后端系统的 Pod（容器组）在销毁、创建过程中所带来的 IP 地址的变化。\n\n\n1. 可以通过 set-context 命令改变当前 kubectl 上下文 的名称空间，后续所有命令都默认在此名称空间下执行。\n\n1. port表示Service对外提供的端口，可以通过“ClusterIP:端口”访问服务。●targetPort表示对应的后端应用（即Pod）的端口。\n\n1.  Sh  -c string：命令从-c后的字符串读取。\n\n1. helm list是区分命名空间的。默认情况下，Helm将Kubernetes配置文件设置的命名空间作为默认命名空间（通常名为default）。\n\n1.   helm get notes mysite  用来打印发布说明\n\n1. helm get values <release-name>  \n\n1. heml install \n\n```\n使用--generate name标志，我们不再需要提供名称作为helm install的第一个参数。Helm根据chart名称和时间戳的组合生成名称。在前面的输出中，我们可以看到生成的名称：wordpress-1597689085。\n\n通过添加--create-namespace，我们已经向Helm表明，我们知道可能还没有具有该名称的命名空间，只希望创建一个。当然，请确保如果在生产实例上使用此标志，会有其他机制来强制执行此新命名空间的安全性。\n\n```\n\n1. apiVersion告诉Helm此chart使用的是什么结构。apiVerison v2是为Helm v3设计的。\n\n1. appVersion属性是唯一的。它既是描述性的，也是模板中经常使用的。appVersion属性表示主应用程序或组合应用程序的版本。例如，如果被打包的应用程序是WordPress，那么它就是WordPress的版本。\n\n1. 重启Pod  \n\nkubectl get pod {podname} -n {namespace} -o yaml | kubectl replace -f -\n","source":"_posts/k8s.md","raw":"---\ntitle: k8s\ndate: 2021-11-18 17:10:24\ntags: k8s\n---\n\n### helm \n\n1. helm pull itg/rds-console —version=XXXX —untar\n\n1. helm uninstall $rds_console_chart_name -n ${{out._predefine.NAMESPACE}}\n\n1. helm add repo\n\n`helm repo add itg ${{helm_repo}} --username ${{cred.helm_zhangchong.username}}   --password ${{cred.helm_zhangchong.password}}  `\n\n`helm repo update`\n\n1. 由 helm install -f 或 helm upgrade -f 提供的 value 文件\n\n```\n# 安装本地 chart\nhelm install -f myvalues.yaml myredis ./redis\n# 指定变量\nhelm install --set name=prod myredis ./redis\n```\n\n### k8s\n\n1. Service的IP地址，此为虚拟IP地址。外部网络无法ping通，只有kubernetes集群内部访问使用。\n\n1. 由于 Kubernetes 集群中每个 Pod（容器组）都有一个唯一的 IP 地址（即使是同一个 Node 上的不同 Pod），我们需要一种机制，为前端系统屏蔽后端系统的 Pod（容器组）在销毁、创建过程中所带来的 IP 地址的变化。\n\n\n1. 可以通过 set-context 命令改变当前 kubectl 上下文 的名称空间，后续所有命令都默认在此名称空间下执行。\n\n1. port表示Service对外提供的端口，可以通过“ClusterIP:端口”访问服务。●targetPort表示对应的后端应用（即Pod）的端口。\n\n1.  Sh  -c string：命令从-c后的字符串读取。\n\n1. helm list是区分命名空间的。默认情况下，Helm将Kubernetes配置文件设置的命名空间作为默认命名空间（通常名为default）。\n\n1.   helm get notes mysite  用来打印发布说明\n\n1. helm get values <release-name>  \n\n1. heml install \n\n```\n使用--generate name标志，我们不再需要提供名称作为helm install的第一个参数。Helm根据chart名称和时间戳的组合生成名称。在前面的输出中，我们可以看到生成的名称：wordpress-1597689085。\n\n通过添加--create-namespace，我们已经向Helm表明，我们知道可能还没有具有该名称的命名空间，只希望创建一个。当然，请确保如果在生产实例上使用此标志，会有其他机制来强制执行此新命名空间的安全性。\n\n```\n\n1. apiVersion告诉Helm此chart使用的是什么结构。apiVerison v2是为Helm v3设计的。\n\n1. appVersion属性是唯一的。它既是描述性的，也是模板中经常使用的。appVersion属性表示主应用程序或组合应用程序的版本。例如，如果被打包的应用程序是WordPress，那么它就是WordPress的版本。\n\n1. 重启Pod  \n\nkubectl get pod {podname} -n {namespace} -o yaml | kubectl replace -f -\n","slug":"k8s","published":1,"updated":"2022-01-04T08:25:24.585Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckzf5sdzt0011yy8km8m96hpl","content":"<h3 id=\"helm\"><a href=\"#helm\" class=\"headerlink\" title=\"helm\"></a>helm</h3><ol>\n<li><p>helm pull itg/rds-console —version=XXXX —untar</p>\n</li>\n<li><p>helm uninstall $rds_console_chart_name -n $</p>\n</li>\n<li><p>helm add repo</p>\n</li>\n</ol>\n<p><code>helm repo add itg $ --username $   --password $</code></p>\n<p><code>helm repo update</code></p>\n<ol>\n<li>由 helm install -f 或 helm upgrade -f 提供的 value 文件</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 安装本地 chart</span><br><span class=\"line\">helm install -f myvalues.yaml myredis ./redis</span><br><span class=\"line\"># 指定变量</span><br><span class=\"line\">helm install --set name=prod myredis ./redis</span><br></pre></td></tr></table></figure>\n<h3 id=\"k8s\"><a href=\"#k8s\" class=\"headerlink\" title=\"k8s\"></a>k8s</h3><ol>\n<li><p>Service的IP地址，此为虚拟IP地址。外部网络无法ping通，只有kubernetes集群内部访问使用。</p>\n</li>\n<li><p>由于 Kubernetes 集群中每个 Pod（容器组）都有一个唯一的 IP 地址（即使是同一个 Node 上的不同 Pod），我们需要一种机制，为前端系统屏蔽后端系统的 Pod（容器组）在销毁、创建过程中所带来的 IP 地址的变化。</p>\n</li>\n</ol>\n<ol>\n<li><p>可以通过 set-context 命令改变当前 kubectl 上下文 的名称空间，后续所有命令都默认在此名称空间下执行。</p>\n</li>\n<li><p>port表示Service对外提供的端口，可以通过“ClusterIP:端口”访问服务。●targetPort表示对应的后端应用（即Pod）的端口。</p>\n</li>\n<li><p>Sh  -c string：命令从-c后的字符串读取。</p>\n</li>\n<li><p>helm list是区分命名空间的。默认情况下，Helm将Kubernetes配置文件设置的命名空间作为默认命名空间（通常名为default）。</p>\n</li>\n<li><p>helm get notes mysite  用来打印发布说明</p>\n</li>\n<li><p>helm get values <release-name>  </release-name></p>\n</li>\n<li><p>heml install </p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用--generate name标志，我们不再需要提供名称作为helm install的第一个参数。Helm根据chart名称和时间戳的组合生成名称。在前面的输出中，我们可以看到生成的名称：wordpress-1597689085。</span><br><span class=\"line\"></span><br><span class=\"line\">通过添加--create-namespace，我们已经向Helm表明，我们知道可能还没有具有该名称的命名空间，只希望创建一个。当然，请确保如果在生产实例上使用此标志，会有其他机制来强制执行此新命名空间的安全性。</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p>apiVersion告诉Helm此chart使用的是什么结构。apiVerison v2是为Helm v3设计的。</p>\n</li>\n<li><p>appVersion属性是唯一的。它既是描述性的，也是模板中经常使用的。appVersion属性表示主应用程序或组合应用程序的版本。例如，如果被打包的应用程序是WordPress，那么它就是WordPress的版本。</p>\n</li>\n<li><p>重启Pod  </p>\n</li>\n</ol>\n<p>kubectl get pod {podname} -n {namespace} -o yaml | kubectl replace -f -</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"helm\"><a href=\"#helm\" class=\"headerlink\" title=\"helm\"></a>helm</h3><ol>\n<li><p>helm pull itg/rds-console —version=XXXX —untar</p>\n</li>\n<li><p>helm uninstall $rds_console_chart_name -n $</p>\n</li>\n<li><p>helm add repo</p>\n</li>\n</ol>\n<p><code>helm repo add itg $ --username $   --password $</code></p>\n<p><code>helm repo update</code></p>\n<ol>\n<li>由 helm install -f 或 helm upgrade -f 提供的 value 文件</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 安装本地 chart</span><br><span class=\"line\">helm install -f myvalues.yaml myredis ./redis</span><br><span class=\"line\"># 指定变量</span><br><span class=\"line\">helm install --set name=prod myredis ./redis</span><br></pre></td></tr></table></figure>\n<h3 id=\"k8s\"><a href=\"#k8s\" class=\"headerlink\" title=\"k8s\"></a>k8s</h3><ol>\n<li><p>Service的IP地址，此为虚拟IP地址。外部网络无法ping通，只有kubernetes集群内部访问使用。</p>\n</li>\n<li><p>由于 Kubernetes 集群中每个 Pod（容器组）都有一个唯一的 IP 地址（即使是同一个 Node 上的不同 Pod），我们需要一种机制，为前端系统屏蔽后端系统的 Pod（容器组）在销毁、创建过程中所带来的 IP 地址的变化。</p>\n</li>\n</ol>\n<ol>\n<li><p>可以通过 set-context 命令改变当前 kubectl 上下文 的名称空间，后续所有命令都默认在此名称空间下执行。</p>\n</li>\n<li><p>port表示Service对外提供的端口，可以通过“ClusterIP:端口”访问服务。●targetPort表示对应的后端应用（即Pod）的端口。</p>\n</li>\n<li><p>Sh  -c string：命令从-c后的字符串读取。</p>\n</li>\n<li><p>helm list是区分命名空间的。默认情况下，Helm将Kubernetes配置文件设置的命名空间作为默认命名空间（通常名为default）。</p>\n</li>\n<li><p>helm get notes mysite  用来打印发布说明</p>\n</li>\n<li><p>helm get values <release-name>  </release-name></p>\n</li>\n<li><p>heml install </p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用--generate name标志，我们不再需要提供名称作为helm install的第一个参数。Helm根据chart名称和时间戳的组合生成名称。在前面的输出中，我们可以看到生成的名称：wordpress-1597689085。</span><br><span class=\"line\"></span><br><span class=\"line\">通过添加--create-namespace，我们已经向Helm表明，我们知道可能还没有具有该名称的命名空间，只希望创建一个。当然，请确保如果在生产实例上使用此标志，会有其他机制来强制执行此新命名空间的安全性。</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p>apiVersion告诉Helm此chart使用的是什么结构。apiVerison v2是为Helm v3设计的。</p>\n</li>\n<li><p>appVersion属性是唯一的。它既是描述性的，也是模板中经常使用的。appVersion属性表示主应用程序或组合应用程序的版本。例如，如果被打包的应用程序是WordPress，那么它就是WordPress的版本。</p>\n</li>\n<li><p>重启Pod  </p>\n</li>\n</ol>\n<p>kubectl get pod {podname} -n {namespace} -o yaml | kubectl replace -f -</p>\n"},{"title":"html","date":"2020-08-13T08:17:07.000Z","_content":"1. \n1. 当用户输入关键字并键入回车之后，这意味着当前页面即将要被替换成新的页面，不过在这个流程继续之前，浏览器还给了当前页面一次执行 `beforeunload` 事件的机会，`beforeunload` 事件允许页面在退出之前执行一些数据清理操作，还可以询问用户是否要离开当前页面。\n\n1. 对HTML5有什么了解？\n   \n   良好的移动性，以移动设备为主；\n   响应式设计，以适应自动变化的屏幕尺寸；\n   支持离线缓存技术，webStorage本地缓存；\n   新增了canvas，video，audio等新标签元素；以及特殊内容元素：article，footer，header，nav，section等；以及表单控件：calendar，date，time，email，url，search等；\n   新增webSocket/webWork技术；\n   还有新增的地理位置等。\n1. label 标签来定义表单控制间的关系，当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。    \n1.  最新的HTML5标准中的API是什么\n   \n   Canvas ：Canvas由HTML代码中定义的具有高度和宽度属性的可绘制区域组成。JavaScript代码可以通过一组完整的绘图函数访问该区域，这与其他常见的2D API类似，因此允许动态生成图形。Canvas 的一些预期用途包括构建图形、动画、游戏和图像合成。\n   媒体定时回放；\n   离线存储数据库；\n   文档编辑；\n   拖放；\n   跨文档消息传递；\n   浏览器历史管理；\n   MIME类型和协议处理程序注册；\n1. 对布局属性进行动画，浏览器需要为每一帧进行重绘并上传到 GPU 中\n对合成属性进行动画，浏览器会为元素创建一个独立的复合层，当元素内容没有发生改变，该层就不会被重绘，浏览器会通过重新复合来创建动画帧\n1. HTML5文档类型：<!doctype html>    HTML5使用的编码 <meta charset=”UTF-8”>\n1. Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。\n3. visibilitychange,可以用来判断浏览器页签是否显示。\n2. WebP是一种新的图片格式，目标是减少文件大小但达到和JPEG格式相同的图片质量，能够减少网络上的请求时间。\n1. DOMContentLoaded事件触发时：仅当DOM解析完成后，不包括样式表，图片等资源。\n```text\n\nCSS不会阻塞DOM解析，但会阻塞DOM渲染。\nCSS会阻塞JS执行，并不会阻塞JS文件下载\n``` \n1. `<datalist>`标签，用来定义选项列表，与input元素配合使用钙元素，来定义input可能的值。\n  datalist及其选项不会被显示出来，他仅仅是合法的输入列表值。\n  `<input id=\"fruits\" list=\"fruit\" /><datalist id=\"fruit\">  <option value=\"apple\">  <option value=\"orange\">  <option value=\"banana\"></datalist>`\n1. 首屏加载时间\n    performance.timing.domContentLoadedEventStart-performance.timing.navigationStart\n2.  preload 是声明式的 fetch，可以强制浏览器请求资源，同时不阻塞文档 onload 事件。Prefetch 提示浏览器这个资源将来可能需要，但是把决定是否和什么时间加载这个资源的决定权交给浏览器。\n3. 优雅降级 graceful degradation： 一开始就构建完整的功能，然后再针对低版本的浏览器进行兼容。\n4. aside  定义页面的侧边栏内容。\n   progress 原生的进度条\n\n5.  HTML `<sup>` 元素定义了一个文本区域，出于排版的原因，与主要的文本相比，应该展示得更高并且更小。\n6. domPropsInnerHTML  domPropsInnerText\n7. 根据 canvas 可以获取浏览器指纹信息\n```text\n\n绘制 canvas，获取 base64 的 dataurl\n对 dataurl 这个字符串进行 md5 摘要计算，得到指纹信息\n```\n1. 一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。比如VScode采用直接手动操作DOM的方式进行极端的性\n1. 事件传播有三个阶段：\n```text\n捕获阶段–事件从 window 开始，然后向下到每个元素，直到到达目标元素事件或event.target。\n目标阶段–事件已达到目标元素。\n冒泡阶段–事件从目标元素冒泡，然后上升到每个元素，直到到达 window。\n\n```\n\n1.  将图片等未处理的文件放在assets中，打包减少体积。而对于第三方引入的一些资源文件如iconfont.css等可以放在static中，因为这些文件已经经过处理了\n1. 浏览器 Context Group 是一组共享相同上下文的 tab、window或iframe。例如，如果网站（https://a.example）打开弹出窗口（https://b.example），则打开器窗口和弹出窗口共享相同的浏览上下文，并且它们可以通过 DOM API相互访问，例如 window.opener。\n1. 影响dom解析以及渲染都会出现白屏的问题\n1. V8 内存空间越大，执行时间越长，为了性能，限制了\n1. 1.当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片，flash都已经加载完成了。\n   \n   2.当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片，flash。\n1. Host 支持虚拟站点\n1. \n1. 如果有js 在header 中，js会等待css 加载完毕。\n1. Object.prototype 是浏览器底层根据 ECMAScript 规范创造的一个对象。\n1.  重绘 只是影响元素的外观和风格，不影响布局的  回流：元素的布局、隐藏等改变需要重新构建\n1.   data-为前端开发者提供自定义属性，这些属性集可以通过对象的dataset属性获取，\n1. 因为 DOM 是属于渲染引擎中的东西，而 JS 又是 JS 引擎中的东西。当我们通过 JS 操作 DOM 的时候，其实这个操作涉及到了两个线程之间的通信，那么势必会带来一些性能上的损耗。\n2. link属于HTML标签，而@import是CSS提供的页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载。\n3. Web quality  : alt\n4. 该WindowEventHandlers.onstorage属性包含一个在storage事件触发时运行的事件处理程序。当更改存储区域时会发生这种情况（例如，存储新项目）。\n```javascript\n   window.onstorage = function(e) { console.log('The ' + e.key + ' key has been changed from ' + e.oldValue + ' to ' + e.newValue + '.'); };\n```\n1. navigator.sendBeacon() 方法可用于通过HTTP将少量数据异步传输到Web服务器。\n1. preload：  直接请求\n   prefetch： 空闲时间请求\n   \n1. <link rel=\"dns-prefetch\" href=\"//baidu.com”>\n   比较小的图片例如icon，使用base64编码，可以减少一次图片的网络请求；\n1. cache control \n```text\nprivate：客户端可以缓存--打开新的窗口会重新访问、地址栏回车时第一次访问、后退不访问\npublic：客户端和代理服务器都可以缓存\nmax-age=t：缓存内容将在t秒后失效\nno-cache：需要使用协商缓存来验证缓存数据\nno-store：所有内容都不会缓存\n\n```   \n1. 我们可以使用 requestIdleCallback() 在浏览器空闲时运行高耗时、低优先级的任务。\n  \n1. 由于GUI渲染线程与JavaScript执行线程是互斥的关系，当浏览器在执行JavaScript程序的时候，GUI渲染线程会被保存在一个队列中，直到JS程序执行完成，才会接着执行。因此如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。\n1. 浏览器定时计数器并不是由JavaScript引擎计数的, 因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确, 因此通过单独线程来计时并触发定时是更为合理的方案。\n1.  当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等，但由于JS的单线程关系所有这些事件都得排队等待JS引擎处理。\n\n1.   在XMLHttpRequest在连接后是通过浏览器新开一个线程请求， 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript引擎的处理队列中等待处理。\n1. dom树构建完成后document对象会派发事件DOMContentLoaded来通知dom树已构建完成。\n   DOMContentLoaded事件用来标识dom树构建完成，那如何判断另外这些非阻塞型的资源加载完成呢？答案是window.onload。由于该事件派发的过晚，因此一般情况下我们用不着，而更多的是用DOMContentLoaded来尽早的的操作dom。","source":"_posts/html.md","raw":"---\ntitle: html\ndate: 2020-08-13 16:17:07\ntags: html\n---\n1. \n1. 当用户输入关键字并键入回车之后，这意味着当前页面即将要被替换成新的页面，不过在这个流程继续之前，浏览器还给了当前页面一次执行 `beforeunload` 事件的机会，`beforeunload` 事件允许页面在退出之前执行一些数据清理操作，还可以询问用户是否要离开当前页面。\n\n1. 对HTML5有什么了解？\n   \n   良好的移动性，以移动设备为主；\n   响应式设计，以适应自动变化的屏幕尺寸；\n   支持离线缓存技术，webStorage本地缓存；\n   新增了canvas，video，audio等新标签元素；以及特殊内容元素：article，footer，header，nav，section等；以及表单控件：calendar，date，time，email，url，search等；\n   新增webSocket/webWork技术；\n   还有新增的地理位置等。\n1. label 标签来定义表单控制间的关系，当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。    \n1.  最新的HTML5标准中的API是什么\n   \n   Canvas ：Canvas由HTML代码中定义的具有高度和宽度属性的可绘制区域组成。JavaScript代码可以通过一组完整的绘图函数访问该区域，这与其他常见的2D API类似，因此允许动态生成图形。Canvas 的一些预期用途包括构建图形、动画、游戏和图像合成。\n   媒体定时回放；\n   离线存储数据库；\n   文档编辑；\n   拖放；\n   跨文档消息传递；\n   浏览器历史管理；\n   MIME类型和协议处理程序注册；\n1. 对布局属性进行动画，浏览器需要为每一帧进行重绘并上传到 GPU 中\n对合成属性进行动画，浏览器会为元素创建一个独立的复合层，当元素内容没有发生改变，该层就不会被重绘，浏览器会通过重新复合来创建动画帧\n1. HTML5文档类型：<!doctype html>    HTML5使用的编码 <meta charset=”UTF-8”>\n1. Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。\n3. visibilitychange,可以用来判断浏览器页签是否显示。\n2. WebP是一种新的图片格式，目标是减少文件大小但达到和JPEG格式相同的图片质量，能够减少网络上的请求时间。\n1. DOMContentLoaded事件触发时：仅当DOM解析完成后，不包括样式表，图片等资源。\n```text\n\nCSS不会阻塞DOM解析，但会阻塞DOM渲染。\nCSS会阻塞JS执行，并不会阻塞JS文件下载\n``` \n1. `<datalist>`标签，用来定义选项列表，与input元素配合使用钙元素，来定义input可能的值。\n  datalist及其选项不会被显示出来，他仅仅是合法的输入列表值。\n  `<input id=\"fruits\" list=\"fruit\" /><datalist id=\"fruit\">  <option value=\"apple\">  <option value=\"orange\">  <option value=\"banana\"></datalist>`\n1. 首屏加载时间\n    performance.timing.domContentLoadedEventStart-performance.timing.navigationStart\n2.  preload 是声明式的 fetch，可以强制浏览器请求资源，同时不阻塞文档 onload 事件。Prefetch 提示浏览器这个资源将来可能需要，但是把决定是否和什么时间加载这个资源的决定权交给浏览器。\n3. 优雅降级 graceful degradation： 一开始就构建完整的功能，然后再针对低版本的浏览器进行兼容。\n4. aside  定义页面的侧边栏内容。\n   progress 原生的进度条\n\n5.  HTML `<sup>` 元素定义了一个文本区域，出于排版的原因，与主要的文本相比，应该展示得更高并且更小。\n6. domPropsInnerHTML  domPropsInnerText\n7. 根据 canvas 可以获取浏览器指纹信息\n```text\n\n绘制 canvas，获取 base64 的 dataurl\n对 dataurl 这个字符串进行 md5 摘要计算，得到指纹信息\n```\n1. 一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。比如VScode采用直接手动操作DOM的方式进行极端的性\n1. 事件传播有三个阶段：\n```text\n捕获阶段–事件从 window 开始，然后向下到每个元素，直到到达目标元素事件或event.target。\n目标阶段–事件已达到目标元素。\n冒泡阶段–事件从目标元素冒泡，然后上升到每个元素，直到到达 window。\n\n```\n\n1.  将图片等未处理的文件放在assets中，打包减少体积。而对于第三方引入的一些资源文件如iconfont.css等可以放在static中，因为这些文件已经经过处理了\n1. 浏览器 Context Group 是一组共享相同上下文的 tab、window或iframe。例如，如果网站（https://a.example）打开弹出窗口（https://b.example），则打开器窗口和弹出窗口共享相同的浏览上下文，并且它们可以通过 DOM API相互访问，例如 window.opener。\n1. 影响dom解析以及渲染都会出现白屏的问题\n1. V8 内存空间越大，执行时间越长，为了性能，限制了\n1. 1.当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片，flash都已经加载完成了。\n   \n   2.当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片，flash。\n1. Host 支持虚拟站点\n1. \n1. 如果有js 在header 中，js会等待css 加载完毕。\n1. Object.prototype 是浏览器底层根据 ECMAScript 规范创造的一个对象。\n1.  重绘 只是影响元素的外观和风格，不影响布局的  回流：元素的布局、隐藏等改变需要重新构建\n1.   data-为前端开发者提供自定义属性，这些属性集可以通过对象的dataset属性获取，\n1. 因为 DOM 是属于渲染引擎中的东西，而 JS 又是 JS 引擎中的东西。当我们通过 JS 操作 DOM 的时候，其实这个操作涉及到了两个线程之间的通信，那么势必会带来一些性能上的损耗。\n2. link属于HTML标签，而@import是CSS提供的页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载。\n3. Web quality  : alt\n4. 该WindowEventHandlers.onstorage属性包含一个在storage事件触发时运行的事件处理程序。当更改存储区域时会发生这种情况（例如，存储新项目）。\n```javascript\n   window.onstorage = function(e) { console.log('The ' + e.key + ' key has been changed from ' + e.oldValue + ' to ' + e.newValue + '.'); };\n```\n1. navigator.sendBeacon() 方法可用于通过HTTP将少量数据异步传输到Web服务器。\n1. preload：  直接请求\n   prefetch： 空闲时间请求\n   \n1. <link rel=\"dns-prefetch\" href=\"//baidu.com”>\n   比较小的图片例如icon，使用base64编码，可以减少一次图片的网络请求；\n1. cache control \n```text\nprivate：客户端可以缓存--打开新的窗口会重新访问、地址栏回车时第一次访问、后退不访问\npublic：客户端和代理服务器都可以缓存\nmax-age=t：缓存内容将在t秒后失效\nno-cache：需要使用协商缓存来验证缓存数据\nno-store：所有内容都不会缓存\n\n```   \n1. 我们可以使用 requestIdleCallback() 在浏览器空闲时运行高耗时、低优先级的任务。\n  \n1. 由于GUI渲染线程与JavaScript执行线程是互斥的关系，当浏览器在执行JavaScript程序的时候，GUI渲染线程会被保存在一个队列中，直到JS程序执行完成，才会接着执行。因此如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。\n1. 浏览器定时计数器并不是由JavaScript引擎计数的, 因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确, 因此通过单独线程来计时并触发定时是更为合理的方案。\n1.  当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等，但由于JS的单线程关系所有这些事件都得排队等待JS引擎处理。\n\n1.   在XMLHttpRequest在连接后是通过浏览器新开一个线程请求， 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript引擎的处理队列中等待处理。\n1. dom树构建完成后document对象会派发事件DOMContentLoaded来通知dom树已构建完成。\n   DOMContentLoaded事件用来标识dom树构建完成，那如何判断另外这些非阻塞型的资源加载完成呢？答案是window.onload。由于该事件派发的过晚，因此一般情况下我们用不着，而更多的是用DOMContentLoaded来尽早的的操作dom。","slug":"html","published":1,"updated":"2020-08-18T10:28:48.648Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckzf5sdzu0013yy8kbq705u2x","content":"<ol>\n<li></li>\n<li><p>当用户输入关键字并键入回车之后，这意味着当前页面即将要被替换成新的页面，不过在这个流程继续之前，浏览器还给了当前页面一次执行 <code>beforeunload</code> 事件的机会，<code>beforeunload</code> 事件允许页面在退出之前执行一些数据清理操作，还可以询问用户是否要离开当前页面。</p>\n</li>\n<li><p>对HTML5有什么了解？</p>\n<p>良好的移动性，以移动设备为主；<br>响应式设计，以适应自动变化的屏幕尺寸；<br>支持离线缓存技术，webStorage本地缓存；<br>新增了canvas，video，audio等新标签元素；以及特殊内容元素：article，footer，header，nav，section等；以及表单控件：calendar，date，time，email，url，search等；<br>新增webSocket/webWork技术；<br>还有新增的地理位置等。</p>\n</li>\n<li>label 标签来定义表单控制间的关系，当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。    </li>\n<li><p>最新的HTML5标准中的API是什么</p>\n<p>Canvas ：Canvas由HTML代码中定义的具有高度和宽度属性的可绘制区域组成。JavaScript代码可以通过一组完整的绘图函数访问该区域，这与其他常见的2D API类似，因此允许动态生成图形。Canvas 的一些预期用途包括构建图形、动画、游戏和图像合成。<br>媒体定时回放；<br>离线存储数据库；<br>文档编辑；<br>拖放；<br>跨文档消息传递；<br>浏览器历史管理；<br>MIME类型和协议处理程序注册；</p>\n</li>\n<li>对布局属性进行动画，浏览器需要为每一帧进行重绘并上传到 GPU 中<br>对合成属性进行动画，浏览器会为元素创建一个独立的复合层，当元素内容没有发生改变，该层就不会被重绘，浏览器会通过重新复合来创建动画帧</li>\n<li>HTML5文档类型：&lt;!doctype html&gt;    HTML5使用的编码 <meta charset=\"”UTF-8”\"></li>\n<li>Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。</li>\n<li>visibilitychange,可以用来判断浏览器页签是否显示。</li>\n<li>WebP是一种新的图片格式，目标是减少文件大小但达到和JPEG格式相同的图片质量，能够减少网络上的请求时间。</li>\n<li><p>DOMContentLoaded事件触发时：仅当DOM解析完成后，不包括样式表，图片等资源。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">CSS不会阻塞DOM解析，但会阻塞DOM渲染。</span><br><span class=\"line\">CSS会阻塞JS执行，并不会阻塞JS文件下载</span><br><span class=\"line\">``` </span><br><span class=\"line\">1. `&lt;datalist&gt;`标签，用来定义选项列表，与input元素配合使用钙元素，来定义input可能的值。</span><br><span class=\"line\">  datalist及其选项不会被显示出来，他仅仅是合法的输入列表值。</span><br><span class=\"line\">  `&lt;input id=&quot;fruits&quot; list=&quot;fruit&quot; /&gt;&lt;datalist id=&quot;fruit&quot;&gt;  &lt;option value=&quot;apple&quot;&gt;  &lt;option value=&quot;orange&quot;&gt;  &lt;option value=&quot;banana&quot;&gt;&lt;/datalist&gt;`</span><br><span class=\"line\">1. 首屏加载时间</span><br><span class=\"line\">    performance.timing.domContentLoadedEventStart-performance.timing.navigationStart</span><br><span class=\"line\">2.  preload 是声明式的 fetch，可以强制浏览器请求资源，同时不阻塞文档 onload 事件。Prefetch 提示浏览器这个资源将来可能需要，但是把决定是否和什么时间加载这个资源的决定权交给浏览器。</span><br><span class=\"line\">3. 优雅降级 graceful degradation： 一开始就构建完整的功能，然后再针对低版本的浏览器进行兼容。</span><br><span class=\"line\">4. aside  定义页面的侧边栏内容。</span><br><span class=\"line\">   progress 原生的进度条</span><br><span class=\"line\"></span><br><span class=\"line\">5.  HTML `&lt;sup&gt;` 元素定义了一个文本区域，出于排版的原因，与主要的文本相比，应该展示得更高并且更小。</span><br><span class=\"line\">6. domPropsInnerHTML  domPropsInnerText</span><br><span class=\"line\">7. 根据 canvas 可以获取浏览器指纹信息</span><br><span class=\"line\">```text</span><br><span class=\"line\"></span><br><span class=\"line\">绘制 canvas，获取 base64 的 dataurl</span><br><span class=\"line\">对 dataurl 这个字符串进行 md5 摘要计算，得到指纹信息</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。比如VScode采用直接手动操作DOM的方式进行极端的性</p>\n</li>\n<li><p>事件传播有三个阶段：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">捕获阶段–事件从 window 开始，然后向下到每个元素，直到到达目标元素事件或event.target。</span><br><span class=\"line\">目标阶段–事件已达到目标元素。</span><br><span class=\"line\">冒泡阶段–事件从目标元素冒泡，然后上升到每个元素，直到到达 window。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>将图片等未处理的文件放在assets中，打包减少体积。而对于第三方引入的一些资源文件如iconfont.css等可以放在static中，因为这些文件已经经过处理了</p>\n</li>\n<li>浏览器 Context Group 是一组共享相同上下文的 tab、window或iframe。例如，如果网站（<a href=\"https://a.example）打开弹出窗口（https://b.example），则打开器窗口和弹出窗口共享相同的浏览上下文，并且它们可以通过\" target=\"_blank\" rel=\"noopener\">https://a.example）打开弹出窗口（https://b.example），则打开器窗口和弹出窗口共享相同的浏览上下文，并且它们可以通过</a> DOM API相互访问，例如 window.opener。</li>\n<li>影响dom解析以及渲染都会出现白屏的问题</li>\n<li>V8 内存空间越大，执行时间越长，为了性能，限制了</li>\n<li><p>1.当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片，flash都已经加载完成了。</p>\n<p>2.当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片，flash。</p>\n</li>\n<li>Host 支持虚拟站点</li>\n<li></li>\n<li>如果有js 在header 中，js会等待css 加载完毕。</li>\n<li>Object.prototype 是浏览器底层根据 ECMAScript 规范创造的一个对象。</li>\n<li>重绘 只是影响元素的外观和风格，不影响布局的  回流：元素的布局、隐藏等改变需要重新构建</li>\n<li>data-为前端开发者提供自定义属性，这些属性集可以通过对象的dataset属性获取，</li>\n<li>因为 DOM 是属于渲染引擎中的东西，而 JS 又是 JS 引擎中的东西。当我们通过 JS 操作 DOM 的时候，其实这个操作涉及到了两个线程之间的通信，那么势必会带来一些性能上的损耗。</li>\n<li>link属于HTML标签，而@import是CSS提供的页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载。</li>\n<li>Web quality  : alt</li>\n<li><p>该WindowEventHandlers.onstorage属性包含一个在storage事件触发时运行的事件处理程序。当更改存储区域时会发生这种情况（例如，存储新项目）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.onstorage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">'The '</span> + e.key + <span class=\"string\">' key has been changed from '</span> + e.oldValue + <span class=\"string\">' to '</span> + e.newValue + <span class=\"string\">'.'</span>); &#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>navigator.sendBeacon() 方法可用于通过HTTP将少量数据异步传输到Web服务器。</p>\n</li>\n<li><p>preload：  直接请求<br>prefetch： 空闲时间请求</p>\n</li>\n<li><p>&lt;link rel=”dns-prefetch” href=”//baidu.com”&gt;<br>比较小的图片例如icon，使用base64编码，可以减少一次图片的网络请求；</p>\n</li>\n<li>cache control<br><code>`</code>text<br>private：客户端可以缓存–打开新的窗口会重新访问、地址栏回车时第一次访问、后退不访问<br>public：客户端和代理服务器都可以缓存<br>max-age=t：缓存内容将在t秒后失效<br>no-cache：需要使用协商缓存来验证缓存数据<br>no-store：所有内容都不会缓存</li>\n</ol>\n<p><code>`</code>   </p>\n<ol>\n<li><p>我们可以使用 requestIdleCallback() 在浏览器空闲时运行高耗时、低优先级的任务。</p>\n</li>\n<li><p>由于GUI渲染线程与JavaScript执行线程是互斥的关系，当浏览器在执行JavaScript程序的时候，GUI渲染线程会被保存在一个队列中，直到JS程序执行完成，才会接着执行。因此如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。</p>\n</li>\n<li>浏览器定时计数器并不是由JavaScript引擎计数的, 因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确, 因此通过单独线程来计时并触发定时是更为合理的方案。</li>\n<li><p>当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等，但由于JS的单线程关系所有这些事件都得排队等待JS引擎处理。</p>\n</li>\n<li><p>在XMLHttpRequest在连接后是通过浏览器新开一个线程请求， 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript引擎的处理队列中等待处理。</p>\n</li>\n<li>dom树构建完成后document对象会派发事件DOMContentLoaded来通知dom树已构建完成。<br>DOMContentLoaded事件用来标识dom树构建完成，那如何判断另外这些非阻塞型的资源加载完成呢？答案是window.onload。由于该事件派发的过晚，因此一般情况下我们用不着，而更多的是用DOMContentLoaded来尽早的的操作dom。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li></li>\n<li><p>当用户输入关键字并键入回车之后，这意味着当前页面即将要被替换成新的页面，不过在这个流程继续之前，浏览器还给了当前页面一次执行 <code>beforeunload</code> 事件的机会，<code>beforeunload</code> 事件允许页面在退出之前执行一些数据清理操作，还可以询问用户是否要离开当前页面。</p>\n</li>\n<li><p>对HTML5有什么了解？</p>\n<p>良好的移动性，以移动设备为主；<br>响应式设计，以适应自动变化的屏幕尺寸；<br>支持离线缓存技术，webStorage本地缓存；<br>新增了canvas，video，audio等新标签元素；以及特殊内容元素：article，footer，header，nav，section等；以及表单控件：calendar，date，time，email，url，search等；<br>新增webSocket/webWork技术；<br>还有新增的地理位置等。</p>\n</li>\n<li>label 标签来定义表单控制间的关系，当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。    </li>\n<li><p>最新的HTML5标准中的API是什么</p>\n<p>Canvas ：Canvas由HTML代码中定义的具有高度和宽度属性的可绘制区域组成。JavaScript代码可以通过一组完整的绘图函数访问该区域，这与其他常见的2D API类似，因此允许动态生成图形。Canvas 的一些预期用途包括构建图形、动画、游戏和图像合成。<br>媒体定时回放；<br>离线存储数据库；<br>文档编辑；<br>拖放；<br>跨文档消息传递；<br>浏览器历史管理；<br>MIME类型和协议处理程序注册；</p>\n</li>\n<li>对布局属性进行动画，浏览器需要为每一帧进行重绘并上传到 GPU 中<br>对合成属性进行动画，浏览器会为元素创建一个独立的复合层，当元素内容没有发生改变，该层就不会被重绘，浏览器会通过重新复合来创建动画帧</li>\n<li>HTML5文档类型：&lt;!doctype html&gt;    HTML5使用的编码 <meta charset=\"”UTF-8”\"></li>\n<li>Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。</li>\n<li>visibilitychange,可以用来判断浏览器页签是否显示。</li>\n<li>WebP是一种新的图片格式，目标是减少文件大小但达到和JPEG格式相同的图片质量，能够减少网络上的请求时间。</li>\n<li><p>DOMContentLoaded事件触发时：仅当DOM解析完成后，不包括样式表，图片等资源。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">CSS不会阻塞DOM解析，但会阻塞DOM渲染。</span><br><span class=\"line\">CSS会阻塞JS执行，并不会阻塞JS文件下载</span><br><span class=\"line\">``` </span><br><span class=\"line\">1. `&lt;datalist&gt;`标签，用来定义选项列表，与input元素配合使用钙元素，来定义input可能的值。</span><br><span class=\"line\">  datalist及其选项不会被显示出来，他仅仅是合法的输入列表值。</span><br><span class=\"line\">  `&lt;input id=&quot;fruits&quot; list=&quot;fruit&quot; /&gt;&lt;datalist id=&quot;fruit&quot;&gt;  &lt;option value=&quot;apple&quot;&gt;  &lt;option value=&quot;orange&quot;&gt;  &lt;option value=&quot;banana&quot;&gt;&lt;/datalist&gt;`</span><br><span class=\"line\">1. 首屏加载时间</span><br><span class=\"line\">    performance.timing.domContentLoadedEventStart-performance.timing.navigationStart</span><br><span class=\"line\">2.  preload 是声明式的 fetch，可以强制浏览器请求资源，同时不阻塞文档 onload 事件。Prefetch 提示浏览器这个资源将来可能需要，但是把决定是否和什么时间加载这个资源的决定权交给浏览器。</span><br><span class=\"line\">3. 优雅降级 graceful degradation： 一开始就构建完整的功能，然后再针对低版本的浏览器进行兼容。</span><br><span class=\"line\">4. aside  定义页面的侧边栏内容。</span><br><span class=\"line\">   progress 原生的进度条</span><br><span class=\"line\"></span><br><span class=\"line\">5.  HTML `&lt;sup&gt;` 元素定义了一个文本区域，出于排版的原因，与主要的文本相比，应该展示得更高并且更小。</span><br><span class=\"line\">6. domPropsInnerHTML  domPropsInnerText</span><br><span class=\"line\">7. 根据 canvas 可以获取浏览器指纹信息</span><br><span class=\"line\">```text</span><br><span class=\"line\"></span><br><span class=\"line\">绘制 canvas，获取 base64 的 dataurl</span><br><span class=\"line\">对 dataurl 这个字符串进行 md5 摘要计算，得到指纹信息</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。比如VScode采用直接手动操作DOM的方式进行极端的性</p>\n</li>\n<li><p>事件传播有三个阶段：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">捕获阶段–事件从 window 开始，然后向下到每个元素，直到到达目标元素事件或event.target。</span><br><span class=\"line\">目标阶段–事件已达到目标元素。</span><br><span class=\"line\">冒泡阶段–事件从目标元素冒泡，然后上升到每个元素，直到到达 window。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>将图片等未处理的文件放在assets中，打包减少体积。而对于第三方引入的一些资源文件如iconfont.css等可以放在static中，因为这些文件已经经过处理了</p>\n</li>\n<li>浏览器 Context Group 是一组共享相同上下文的 tab、window或iframe。例如，如果网站（<a href=\"https://a.example）打开弹出窗口（https://b.example），则打开器窗口和弹出窗口共享相同的浏览上下文，并且它们可以通过\" target=\"_blank\" rel=\"noopener\">https://a.example）打开弹出窗口（https://b.example），则打开器窗口和弹出窗口共享相同的浏览上下文，并且它们可以通过</a> DOM API相互访问，例如 window.opener。</li>\n<li>影响dom解析以及渲染都会出现白屏的问题</li>\n<li>V8 内存空间越大，执行时间越长，为了性能，限制了</li>\n<li><p>1.当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片，flash都已经加载完成了。</p>\n<p>2.当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片，flash。</p>\n</li>\n<li>Host 支持虚拟站点</li>\n<li></li>\n<li>如果有js 在header 中，js会等待css 加载完毕。</li>\n<li>Object.prototype 是浏览器底层根据 ECMAScript 规范创造的一个对象。</li>\n<li>重绘 只是影响元素的外观和风格，不影响布局的  回流：元素的布局、隐藏等改变需要重新构建</li>\n<li>data-为前端开发者提供自定义属性，这些属性集可以通过对象的dataset属性获取，</li>\n<li>因为 DOM 是属于渲染引擎中的东西，而 JS 又是 JS 引擎中的东西。当我们通过 JS 操作 DOM 的时候，其实这个操作涉及到了两个线程之间的通信，那么势必会带来一些性能上的损耗。</li>\n<li>link属于HTML标签，而@import是CSS提供的页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载。</li>\n<li>Web quality  : alt</li>\n<li><p>该WindowEventHandlers.onstorage属性包含一个在storage事件触发时运行的事件处理程序。当更改存储区域时会发生这种情况（例如，存储新项目）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.onstorage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">'The '</span> + e.key + <span class=\"string\">' key has been changed from '</span> + e.oldValue + <span class=\"string\">' to '</span> + e.newValue + <span class=\"string\">'.'</span>); &#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>navigator.sendBeacon() 方法可用于通过HTTP将少量数据异步传输到Web服务器。</p>\n</li>\n<li><p>preload：  直接请求<br>prefetch： 空闲时间请求</p>\n</li>\n<li><p>&lt;link rel=”dns-prefetch” href=”//baidu.com”&gt;<br>比较小的图片例如icon，使用base64编码，可以减少一次图片的网络请求；</p>\n</li>\n<li>cache control<br><code>`</code>text<br>private：客户端可以缓存–打开新的窗口会重新访问、地址栏回车时第一次访问、后退不访问<br>public：客户端和代理服务器都可以缓存<br>max-age=t：缓存内容将在t秒后失效<br>no-cache：需要使用协商缓存来验证缓存数据<br>no-store：所有内容都不会缓存</li>\n</ol>\n<p><code>`</code>   </p>\n<ol>\n<li><p>我们可以使用 requestIdleCallback() 在浏览器空闲时运行高耗时、低优先级的任务。</p>\n</li>\n<li><p>由于GUI渲染线程与JavaScript执行线程是互斥的关系，当浏览器在执行JavaScript程序的时候，GUI渲染线程会被保存在一个队列中，直到JS程序执行完成，才会接着执行。因此如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。</p>\n</li>\n<li>浏览器定时计数器并不是由JavaScript引擎计数的, 因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确, 因此通过单独线程来计时并触发定时是更为合理的方案。</li>\n<li><p>当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等，但由于JS的单线程关系所有这些事件都得排队等待JS引擎处理。</p>\n</li>\n<li><p>在XMLHttpRequest在连接后是通过浏览器新开一个线程请求， 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript引擎的处理队列中等待处理。</p>\n</li>\n<li>dom树构建完成后document对象会派发事件DOMContentLoaded来通知dom树已构建完成。<br>DOMContentLoaded事件用来标识dom树构建完成，那如何判断另外这些非阻塞型的资源加载完成呢？答案是window.onload。由于该事件派发的过晚，因此一般情况下我们用不着，而更多的是用DOMContentLoaded来尽早的的操作dom。</li>\n</ol>\n"},{"title":"investment","date":"2021-01-08T02:01:56.000Z","_content":"\n1. 不要缺乏耐心，当做T时严格遵守纪律\n2. 眼光长远一点儿，至少看一年后的利润\n","source":"_posts/investment.md","raw":"---\ntitle: investment\ndate: 2021-01-08 10:01:56\ntags: stock\n---\n\n1. 不要缺乏耐心，当做T时严格遵守纪律\n2. 眼光长远一点儿，至少看一年后的利润\n","slug":"investment","published":1,"updated":"2021-01-08T02:04:12.452Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckzf5sdzw0016yy8k0odcnot3","content":"<ol>\n<li>不要缺乏耐心，当做T时严格遵守纪律</li>\n<li>眼光长远一点儿，至少看一年后的利润</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>不要缺乏耐心，当做T时严格遵守纪律</li>\n<li>眼光长远一点儿，至少看一年后的利润</li>\n</ol>\n"},{"title":"loadtest","date":"2017-01-17T01:41:01.000Z","_content":"### loadtest 压力测试\n可用powershell 或linux bash \n\n命令行如果加post body 会报错\n\n常用参数：\n\n-T 表示持续时间\n\n-c 并行数量\n\n-n 总的请求\n\n-m  get,put,post\n\n--rps 每秒发送请求数\n\n-P Request body 数据\n\n-p body 数据存在的文件路径\n\n-H header 添加\n\n-C 设置cookie\n```\nparam(\n    [int] $iterations = 6000,\n    [int] $rps = 500,\n    [string][ValidateSet(\"plaintext\")] $variation = \"plaintext\")\n\nif ($variation -eq \"plaintext\")\n{\n    $url = \"http://wh.etao.cn/auth/test\"\n}\n\nWrite-Host -ForegroundColor Green Beginning workload\nWrite-Host \"`& loadtest -k -n $iterations -c 100 --rps $rps $url\"\nWrite-Host\n\n& loadtest -k -n $iterations -c 100 --rps $rps $url\n```\n\n```\nloadtest -c 5 -t 2 -m post -T 'application/json'  -P '{\"message\":\"hello\"}'  -H \"Accept: application/json; q=0.9, application/xml; q=0.6\" http://cttest.etao.cn:8011/api/auth/test\n```\n","source":"_posts/loadtest.md","raw":"---\ntitle: loadtest\ndate: 2017-01-17 09:41:01\ntags: loadtest\n---\n### loadtest 压力测试\n可用powershell 或linux bash \n\n命令行如果加post body 会报错\n\n常用参数：\n\n-T 表示持续时间\n\n-c 并行数量\n\n-n 总的请求\n\n-m  get,put,post\n\n--rps 每秒发送请求数\n\n-P Request body 数据\n\n-p body 数据存在的文件路径\n\n-H header 添加\n\n-C 设置cookie\n```\nparam(\n    [int] $iterations = 6000,\n    [int] $rps = 500,\n    [string][ValidateSet(\"plaintext\")] $variation = \"plaintext\")\n\nif ($variation -eq \"plaintext\")\n{\n    $url = \"http://wh.etao.cn/auth/test\"\n}\n\nWrite-Host -ForegroundColor Green Beginning workload\nWrite-Host \"`& loadtest -k -n $iterations -c 100 --rps $rps $url\"\nWrite-Host\n\n& loadtest -k -n $iterations -c 100 --rps $rps $url\n```\n\n```\nloadtest -c 5 -t 2 -m post -T 'application/json'  -P '{\"message\":\"hello\"}'  -H \"Accept: application/json; q=0.9, application/xml; q=0.6\" http://cttest.etao.cn:8011/api/auth/test\n```\n","slug":"loadtest","published":1,"updated":"2020-06-29T06:22:24.361Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckzf5sdzy0018yy8kjk235izp","content":"<h3 id=\"loadtest-压力测试\"><a href=\"#loadtest-压力测试\" class=\"headerlink\" title=\"loadtest 压力测试\"></a>loadtest 压力测试</h3><p>可用powershell 或linux bash </p>\n<p>命令行如果加post body 会报错</p>\n<p>常用参数：</p>\n<p>-T 表示持续时间</p>\n<p>-c 并行数量</p>\n<p>-n 总的请求</p>\n<p>-m  get,put,post</p>\n<p>–rps 每秒发送请求数</p>\n<p>-P Request body 数据</p>\n<p>-p body 数据存在的文件路径</p>\n<p>-H header 添加</p>\n<p>-C 设置cookie<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">param(</span><br><span class=\"line\">    [int] $iterations = 6000,</span><br><span class=\"line\">    [int] $rps = 500,</span><br><span class=\"line\">    [string][ValidateSet(&quot;plaintext&quot;)] $variation = &quot;plaintext&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">if ($variation -eq &quot;plaintext&quot;)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    $url = &quot;http://wh.etao.cn/auth/test&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Write-Host -ForegroundColor Green Beginning workload</span><br><span class=\"line\">Write-Host &quot;`&amp; loadtest -k -n $iterations -c 100 --rps $rps $url&quot;</span><br><span class=\"line\">Write-Host</span><br><span class=\"line\"></span><br><span class=\"line\">&amp; loadtest -k -n $iterations -c 100 --rps $rps $url</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loadtest -c 5 -t 2 -m post -T &apos;application/json&apos;  -P &apos;&#123;&quot;message&quot;:&quot;hello&quot;&#125;&apos;  -H &quot;Accept: application/json; q=0.9, application/xml; q=0.6&quot; http://cttest.etao.cn:8011/api/auth/test</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"loadtest-压力测试\"><a href=\"#loadtest-压力测试\" class=\"headerlink\" title=\"loadtest 压力测试\"></a>loadtest 压力测试</h3><p>可用powershell 或linux bash </p>\n<p>命令行如果加post body 会报错</p>\n<p>常用参数：</p>\n<p>-T 表示持续时间</p>\n<p>-c 并行数量</p>\n<p>-n 总的请求</p>\n<p>-m  get,put,post</p>\n<p>–rps 每秒发送请求数</p>\n<p>-P Request body 数据</p>\n<p>-p body 数据存在的文件路径</p>\n<p>-H header 添加</p>\n<p>-C 设置cookie<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">param(</span><br><span class=\"line\">    [int] $iterations = 6000,</span><br><span class=\"line\">    [int] $rps = 500,</span><br><span class=\"line\">    [string][ValidateSet(&quot;plaintext&quot;)] $variation = &quot;plaintext&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">if ($variation -eq &quot;plaintext&quot;)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    $url = &quot;http://wh.etao.cn/auth/test&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Write-Host -ForegroundColor Green Beginning workload</span><br><span class=\"line\">Write-Host &quot;`&amp; loadtest -k -n $iterations -c 100 --rps $rps $url&quot;</span><br><span class=\"line\">Write-Host</span><br><span class=\"line\"></span><br><span class=\"line\">&amp; loadtest -k -n $iterations -c 100 --rps $rps $url</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loadtest -c 5 -t 2 -m post -T &apos;application/json&apos;  -P &apos;&#123;&quot;message&quot;:&quot;hello&quot;&#125;&apos;  -H &quot;Accept: application/json; q=0.9, application/xml; q=0.6&quot; http://cttest.etao.cn:8011/api/auth/test</span><br></pre></td></tr></table></figure>\n"},{"title":"js","date":"2020-08-13T07:17:58.000Z","_content":"\n1. 管道符放到尾部：Hello(?:World|China|) 可以匹配 HelloWorld、HelloChina，也可以只匹配 Hello。\n    >console.log('子君' instanceof String)  \n1. prototype\n```text\n   function f() {}\nvar a = f.prototype, b = Object.getPrototypeOf(f);\na === b    \n解析：a是构造函数f的原型 ： {constructor: ƒ}\nb是实例f的原型对象 ： ƒ () { [native code] }\n```\n1. webpack hmr\n```text\n1.当修改了一个或多个文件；\n2.文件系统接收更改并通知webpack；\n3.webpack重新编译构建一个或多个模块，并通知HMR服务器进行更新；\n4.HMR Server 使用webSocket通知HMR runtime 需要更新，HMR运行时通过HTTP请求更新jsonp；\n5.HMR运行时替换更新中的模块，如果确定这些模块无法更新，则触发整个页面刷新。\n```\n1. Git submodule \n```text\n$ git submodule init\nSubmodule 'assets' (https://github.com/maonx/vimwiki-assets.git) registered for path 'assets'\n```\n\n```text\n$ git submodule add https://github.com/maonx/vimwiki-assets.git assets\n\n$ git submodule update —remote\n```\n\n1.  所以函数防抖适用的场景：监听窗口的滚动，缩放。高频发生的一些事件；函数节流适用的场景：涉及与后端交互的按钮，由于网络原因或者其他原因，导致接口没有返回值，用户一直点点点的问题。 \n2.  最优子结构、边界、动态转移方程。动态规划的核心—》从低向上，从而不会像递归那样保留调用栈。\n3.  十进制转为 2 进制，除 2 取余，然后余数反向\n    \n    十进制转为 2 进制小时，**乘 2 取整**\n    \n4. in操作符:检测指定对象(右边)原型链上是否有对应的属性值。 \n    hasOwnProperty方法:检测指定对象自身上是否有对应的属性值。两者的区别在于in会查找原型链,而hasOwnProperty不会。\n   \n   for...in...遍历对象上除了Symbol以外的可枚举属性,包括原型链上的属性。\n   \n   Object.keys & Object.assign & JSON.stringify: excluding non-enumerable & __proto__\n5. 堆\n堆的底层实际上是一棵完全二叉树，可以用数组实现\n每个的节点元素值不小于其子节点 - 最大堆\n每个的节点元素值不大于其子节点 - 最小堆\n\n1.  浏览器中 customevent\n    \n```js\nvar event = new CustomEvent(\"cat\", {  detail: {    hazcheeseburger: true  }});obj.dispatchEvent(event);\n```\n\n1.  window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行\n1. Element.getBoundingClientRect() 方法返回元素的大小及其相对于视口的位置。\n1.  regex  y stick 粘连修饰符 \n\n1.普通函数在被调用时，JS引擎会创建一个栈帧，在里面准备好局部变量、函数参数、临时值、代码执行的位置（也就是说这个函数的第一行对应到代码区里的第几行机器码），在当前栈帧里设置好返回位置，然后将新帧压入栈顶。待函数执行结束后，这个栈帧将被弹出栈然后销毁，返回值会被传给上一个栈帧。\n\n   当执行到yield语句时，Generator的栈帧同样会被弹出栈外，但Generator在这里耍了个花招——它在堆里保存了栈帧的引用（或拷贝）！这样当iter.next方法被调用时，JS引擎便不会重新创建一个栈帧，而是把堆里的栈帧直接入栈。因为栈帧里保存了函数执行所需的全部上下文以及当前执行的位置，所以当这一切都被恢复如初之时，就好像程序从原本暂停的地方继续向前执行了。\n\n    而因为每次yield和iter.next都对应一次出栈和入栈，所以可以直接利用已有的栈机制，实现值的传出和传入。\n\n1. Array(10)  稀疏矩阵\n2. clone\n```text\nfunction initData(target) {\n  return new target.constructor()\n}\nreturn Object(Symbol.prototype.valueOf.call(targe));\n\nfunction cloneReg(targe) {\n    const reFlags = /\\w*$/;\n    const result = new targe.constructor(targe.source, reFlags.exec(targe));\n    result.lastIndex = targe.lastIndex;\n    return result;\n}\n```     \n\n1. js 在底层存储变量的时候，会在变量的机器码的低位1-3位存储其类型信息👉\n   \n   000：对象\n   010：浮点数\n   100：字符串\n   110：布尔\n   1：整数\n   \n   but, 对于 undefined 和 null 来说，这两个值的信息存储是有点特殊的。\n   \n   null：所有机器码均为0\n   \n   undefined：用 −2^30 整数来表示\n\n1. console 分组\n```javascript\nconsole.group('action', 'A');\n\nconsole.log('%c prev state', \"color: #dddddd\", '\\n', {\n    name: 'a'\n});\nconsole.log('%c next state', \"color: #dddddd\", '\\n',  {\n    name: 'b'\n});\n\nconsole.groupCollapsed();\nconsole.log('我是group折叠内容');\nconsole.groupEnd();\nconsole.groupEnd();\n```\n1.  Object.create(null) 和 {}\n1.  每次JavaScript对DOM的操作都会改变当前页面的呈现，并重新刷新整个页面，从而消耗了大量的时间。而createDocumentFragment()的作用，就是可以创建一个文档碎片，\n把所有的新节点附加其上，然后把文档碎片的内容一次性添加到document中。\n\n1. indexedDB 的特点：存储空间大：存储空间可以达到几百兆甚至更多；\n\n               >> 支持二进制存储：它不仅可以存储字符串，而且还可以存储二进制数据；\n               >> IndexedDB 有同源限制，每一个数据库只能在自身域名下能访问，不能跨域名访问；\n               >> 支持事务型：IndexedDB 执行的操作会按照事务来分组的，在一个事务中，要么所有的操作都成功，要么所有的操作都失败；\n               >> 键值对存储：IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以 “键值对” 的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。\n               >> 数据操作是异步的：使用 IndexedDB 执行的操作是异步执行的，以免阻塞应用程序。\n5. Usecapture:\n   true - 事件句柄在捕获阶段执行。事件捕获从父到子。\n   false- false- 默认。事件句柄在冒泡阶段执行\n1. 浏览器标签页被隐藏或显示的时候会触发visibilitychange事件. document.addEventListener('visibilitychange')\n2. Object.assign 继承的否Object.keys & Object.assign & JSON.stringify: excluding non-enumerable & __proto__\n3. let is not global while var is.\n4. download\n```javascript\nfunction download (url, name) {\n  const a = document.createElement('a')\n  a.download = name\n  a.rel = 'noopener'\n  a.href = url\n  // 触发模拟点击\n  a.dispatchEvent(new MouseEvent('click'))\n  // 或者 a.click()\n}\n\n// 方案一：Text -> DataURL\nconst dataUrl = `data:,${str}`\ndownload(dataUrl, 'demo.json')\n\n// 方案二：Text -> Blob -> ObjectURL\nconst url = URL.createObjectURL(new Blob(str.split('')))\ndownload(url, 'demo1.json')\n\n```  \n1. stringfy 格式化\n```js\n\nconst json = {\n  a: 3,\n  b: 4,\n  c: 5\n}\nconst str = JSON.stringify(json, null, 2)\n\n```  \n\n1. proxy \n```js\nconst negativeArray = els =>\n    new Proxy(els, {\n        get: (target, propKey, receiver) =>\n            Reflect.get(\n                target,\n                +propKey < 0 ? String(target.length + +propKey) : propKey,\n                receiver\n            )\n    });\nconst unicorn = negativeArray([\"京\", \"程\", \"一\", \"灯\"]);\nunicorn[-1]; \n``` \n  \n1.  对于 undeclared 变量的引用，浏览器会报引用错误，如 ReferenceError: b is not defined 。\n1. Es6->babel paser->babel traverse->babel core\n1.  类数组向数组转换 Array.from slice 。 aguments 就是arrarylike   \n1.  xhr  \n```js\n \nvar request = new XMLHttpRequest()\n request.open('GET', 'index/a/b/c?name=TianTian', true);\n request.onreadystatechange = function () {\n   if(request.readyState === 4 && request.status === 200) {\n     console.log(request.responseText);\n   }};\n request.send();\n```   \n1. V8 对重复的js代码有优化 即时编译技术，如果发现一段代码经常使用，则不用转字节码 直接执行机器码\n\n1. 随机字符串 Math.random().toString(36).substr(2));\n\n2. Babel pollyfy 的作用 ：https://zhuanlan.zhihu.com/p/29058936\n\n3. Babel stag2 的功能  https://github.com/babel/babel/tree/master/packages/babel-preset-stage-2\n1. 所有的babel 包  https://github.com/babel/babel/tree/master/packages\n1. npx babel-upgrade\n\n2. ES2019 中为Symbol对象添加了只读属性 description ，该对象返回包含Symbol描述的字符串。\n\n \n3. 如果你传的 context 就 null 或者 undefined，那么 window 对象就是默认的 context（严格模式下默认 context 是 undefined）\n \n4. ES6 模块功能是它的导入模块是导出时模块的实时只读视图。（相比起 CommonJS，导入的是导出模块的拷贝副本，因此也不是实时的）。只读视图和内存拷贝的区别。\n \n5. Broadcast Channel API 允许同一原始域和用户代理下的所有窗口,iFrames 等进行交互。也就是说，如果用户打开了同一个网站的的两个标签窗口，如果网站内容发生了变化，那么两个窗口会同时得到更新通知。\n6. escape 在处理 0xff 之外字符的时候，是直接使用字符的 unicode 在前面加上一个 「%u」，而encodeURI则是先进行 UTF-8，再在 UTF-8 的每个字节码前加上一个 「%」； 所以通过encodeUrI 可以获取utf-8 字节长度\n7. js value\n8. Prototype 包含constructor 和 __proto__. 原型链存储共有的属性和方法，减少内存\n9.  基本的数据类型 \n```text\n基本的数据类型\nundefined\nnull\nstring\nboolean\nnumber\nsymbol(ES6)\n\n```\n1. navigator.userAgent: 返回当前浏览器的user agent字符串\n1. 懒加载：\n   Javascript 脚步通常要等到 DOM 加载完后才会执行，如果加载的资源过多，可能会影响网页的正常使用。\n   能够节省流量和减轻服务器压力，更近一步就是能够为公司省成本。\n\n2. Same origin 可以使用broadcast channel 两页面间通信。\n3. 注意闭包内this的指向\n4. 对于instanceof,无法判断基本类型，但可以正确判断引用类型\n5. let x = 2_3333_3333 \n6. 哪些操作会造成内存泄漏？\n```text\n1.意外的全局变量\n2.被遗忘的计时器或回调函数\n3.脱离 DOM 的引用\n4.闭包\n```\n1.  Map 对象中的数据是根据用户set 的顺序排序的，object 先排数字开头的。\n\n\n### dataStructure\n\n1. BST 查询二叉树\n若任意节点的左⼦子树不不空，则左⼦子树上所有结点的值均⼩小于它的 根结点的值;\n若任意节点的右⼦子树不不空，则右⼦子树上所有结点的值均⼤大于它的 根结点的值;\n任意节点的左、右⼦子树也分别为⼆二叉查找树。","source":"_posts/js.md","raw":"---\ntitle: js\ndate: 2020-08-13 15:17:58\ntags:\n---\n\n1. 管道符放到尾部：Hello(?:World|China|) 可以匹配 HelloWorld、HelloChina，也可以只匹配 Hello。\n    >console.log('子君' instanceof String)  \n1. prototype\n```text\n   function f() {}\nvar a = f.prototype, b = Object.getPrototypeOf(f);\na === b    \n解析：a是构造函数f的原型 ： {constructor: ƒ}\nb是实例f的原型对象 ： ƒ () { [native code] }\n```\n1. webpack hmr\n```text\n1.当修改了一个或多个文件；\n2.文件系统接收更改并通知webpack；\n3.webpack重新编译构建一个或多个模块，并通知HMR服务器进行更新；\n4.HMR Server 使用webSocket通知HMR runtime 需要更新，HMR运行时通过HTTP请求更新jsonp；\n5.HMR运行时替换更新中的模块，如果确定这些模块无法更新，则触发整个页面刷新。\n```\n1. Git submodule \n```text\n$ git submodule init\nSubmodule 'assets' (https://github.com/maonx/vimwiki-assets.git) registered for path 'assets'\n```\n\n```text\n$ git submodule add https://github.com/maonx/vimwiki-assets.git assets\n\n$ git submodule update —remote\n```\n\n1.  所以函数防抖适用的场景：监听窗口的滚动，缩放。高频发生的一些事件；函数节流适用的场景：涉及与后端交互的按钮，由于网络原因或者其他原因，导致接口没有返回值，用户一直点点点的问题。 \n2.  最优子结构、边界、动态转移方程。动态规划的核心—》从低向上，从而不会像递归那样保留调用栈。\n3.  十进制转为 2 进制，除 2 取余，然后余数反向\n    \n    十进制转为 2 进制小时，**乘 2 取整**\n    \n4. in操作符:检测指定对象(右边)原型链上是否有对应的属性值。 \n    hasOwnProperty方法:检测指定对象自身上是否有对应的属性值。两者的区别在于in会查找原型链,而hasOwnProperty不会。\n   \n   for...in...遍历对象上除了Symbol以外的可枚举属性,包括原型链上的属性。\n   \n   Object.keys & Object.assign & JSON.stringify: excluding non-enumerable & __proto__\n5. 堆\n堆的底层实际上是一棵完全二叉树，可以用数组实现\n每个的节点元素值不小于其子节点 - 最大堆\n每个的节点元素值不大于其子节点 - 最小堆\n\n1.  浏览器中 customevent\n    \n```js\nvar event = new CustomEvent(\"cat\", {  detail: {    hazcheeseburger: true  }});obj.dispatchEvent(event);\n```\n\n1.  window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行\n1. Element.getBoundingClientRect() 方法返回元素的大小及其相对于视口的位置。\n1.  regex  y stick 粘连修饰符 \n\n1.普通函数在被调用时，JS引擎会创建一个栈帧，在里面准备好局部变量、函数参数、临时值、代码执行的位置（也就是说这个函数的第一行对应到代码区里的第几行机器码），在当前栈帧里设置好返回位置，然后将新帧压入栈顶。待函数执行结束后，这个栈帧将被弹出栈然后销毁，返回值会被传给上一个栈帧。\n\n   当执行到yield语句时，Generator的栈帧同样会被弹出栈外，但Generator在这里耍了个花招——它在堆里保存了栈帧的引用（或拷贝）！这样当iter.next方法被调用时，JS引擎便不会重新创建一个栈帧，而是把堆里的栈帧直接入栈。因为栈帧里保存了函数执行所需的全部上下文以及当前执行的位置，所以当这一切都被恢复如初之时，就好像程序从原本暂停的地方继续向前执行了。\n\n    而因为每次yield和iter.next都对应一次出栈和入栈，所以可以直接利用已有的栈机制，实现值的传出和传入。\n\n1. Array(10)  稀疏矩阵\n2. clone\n```text\nfunction initData(target) {\n  return new target.constructor()\n}\nreturn Object(Symbol.prototype.valueOf.call(targe));\n\nfunction cloneReg(targe) {\n    const reFlags = /\\w*$/;\n    const result = new targe.constructor(targe.source, reFlags.exec(targe));\n    result.lastIndex = targe.lastIndex;\n    return result;\n}\n```     \n\n1. js 在底层存储变量的时候，会在变量的机器码的低位1-3位存储其类型信息👉\n   \n   000：对象\n   010：浮点数\n   100：字符串\n   110：布尔\n   1：整数\n   \n   but, 对于 undefined 和 null 来说，这两个值的信息存储是有点特殊的。\n   \n   null：所有机器码均为0\n   \n   undefined：用 −2^30 整数来表示\n\n1. console 分组\n```javascript\nconsole.group('action', 'A');\n\nconsole.log('%c prev state', \"color: #dddddd\", '\\n', {\n    name: 'a'\n});\nconsole.log('%c next state', \"color: #dddddd\", '\\n',  {\n    name: 'b'\n});\n\nconsole.groupCollapsed();\nconsole.log('我是group折叠内容');\nconsole.groupEnd();\nconsole.groupEnd();\n```\n1.  Object.create(null) 和 {}\n1.  每次JavaScript对DOM的操作都会改变当前页面的呈现，并重新刷新整个页面，从而消耗了大量的时间。而createDocumentFragment()的作用，就是可以创建一个文档碎片，\n把所有的新节点附加其上，然后把文档碎片的内容一次性添加到document中。\n\n1. indexedDB 的特点：存储空间大：存储空间可以达到几百兆甚至更多；\n\n               >> 支持二进制存储：它不仅可以存储字符串，而且还可以存储二进制数据；\n               >> IndexedDB 有同源限制，每一个数据库只能在自身域名下能访问，不能跨域名访问；\n               >> 支持事务型：IndexedDB 执行的操作会按照事务来分组的，在一个事务中，要么所有的操作都成功，要么所有的操作都失败；\n               >> 键值对存储：IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以 “键值对” 的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。\n               >> 数据操作是异步的：使用 IndexedDB 执行的操作是异步执行的，以免阻塞应用程序。\n5. Usecapture:\n   true - 事件句柄在捕获阶段执行。事件捕获从父到子。\n   false- false- 默认。事件句柄在冒泡阶段执行\n1. 浏览器标签页被隐藏或显示的时候会触发visibilitychange事件. document.addEventListener('visibilitychange')\n2. Object.assign 继承的否Object.keys & Object.assign & JSON.stringify: excluding non-enumerable & __proto__\n3. let is not global while var is.\n4. download\n```javascript\nfunction download (url, name) {\n  const a = document.createElement('a')\n  a.download = name\n  a.rel = 'noopener'\n  a.href = url\n  // 触发模拟点击\n  a.dispatchEvent(new MouseEvent('click'))\n  // 或者 a.click()\n}\n\n// 方案一：Text -> DataURL\nconst dataUrl = `data:,${str}`\ndownload(dataUrl, 'demo.json')\n\n// 方案二：Text -> Blob -> ObjectURL\nconst url = URL.createObjectURL(new Blob(str.split('')))\ndownload(url, 'demo1.json')\n\n```  \n1. stringfy 格式化\n```js\n\nconst json = {\n  a: 3,\n  b: 4,\n  c: 5\n}\nconst str = JSON.stringify(json, null, 2)\n\n```  \n\n1. proxy \n```js\nconst negativeArray = els =>\n    new Proxy(els, {\n        get: (target, propKey, receiver) =>\n            Reflect.get(\n                target,\n                +propKey < 0 ? String(target.length + +propKey) : propKey,\n                receiver\n            )\n    });\nconst unicorn = negativeArray([\"京\", \"程\", \"一\", \"灯\"]);\nunicorn[-1]; \n``` \n  \n1.  对于 undeclared 变量的引用，浏览器会报引用错误，如 ReferenceError: b is not defined 。\n1. Es6->babel paser->babel traverse->babel core\n1.  类数组向数组转换 Array.from slice 。 aguments 就是arrarylike   \n1.  xhr  \n```js\n \nvar request = new XMLHttpRequest()\n request.open('GET', 'index/a/b/c?name=TianTian', true);\n request.onreadystatechange = function () {\n   if(request.readyState === 4 && request.status === 200) {\n     console.log(request.responseText);\n   }};\n request.send();\n```   \n1. V8 对重复的js代码有优化 即时编译技术，如果发现一段代码经常使用，则不用转字节码 直接执行机器码\n\n1. 随机字符串 Math.random().toString(36).substr(2));\n\n2. Babel pollyfy 的作用 ：https://zhuanlan.zhihu.com/p/29058936\n\n3. Babel stag2 的功能  https://github.com/babel/babel/tree/master/packages/babel-preset-stage-2\n1. 所有的babel 包  https://github.com/babel/babel/tree/master/packages\n1. npx babel-upgrade\n\n2. ES2019 中为Symbol对象添加了只读属性 description ，该对象返回包含Symbol描述的字符串。\n\n \n3. 如果你传的 context 就 null 或者 undefined，那么 window 对象就是默认的 context（严格模式下默认 context 是 undefined）\n \n4. ES6 模块功能是它的导入模块是导出时模块的实时只读视图。（相比起 CommonJS，导入的是导出模块的拷贝副本，因此也不是实时的）。只读视图和内存拷贝的区别。\n \n5. Broadcast Channel API 允许同一原始域和用户代理下的所有窗口,iFrames 等进行交互。也就是说，如果用户打开了同一个网站的的两个标签窗口，如果网站内容发生了变化，那么两个窗口会同时得到更新通知。\n6. escape 在处理 0xff 之外字符的时候，是直接使用字符的 unicode 在前面加上一个 「%u」，而encodeURI则是先进行 UTF-8，再在 UTF-8 的每个字节码前加上一个 「%」； 所以通过encodeUrI 可以获取utf-8 字节长度\n7. js value\n8. Prototype 包含constructor 和 __proto__. 原型链存储共有的属性和方法，减少内存\n9.  基本的数据类型 \n```text\n基本的数据类型\nundefined\nnull\nstring\nboolean\nnumber\nsymbol(ES6)\n\n```\n1. navigator.userAgent: 返回当前浏览器的user agent字符串\n1. 懒加载：\n   Javascript 脚步通常要等到 DOM 加载完后才会执行，如果加载的资源过多，可能会影响网页的正常使用。\n   能够节省流量和减轻服务器压力，更近一步就是能够为公司省成本。\n\n2. Same origin 可以使用broadcast channel 两页面间通信。\n3. 注意闭包内this的指向\n4. 对于instanceof,无法判断基本类型，但可以正确判断引用类型\n5. let x = 2_3333_3333 \n6. 哪些操作会造成内存泄漏？\n```text\n1.意外的全局变量\n2.被遗忘的计时器或回调函数\n3.脱离 DOM 的引用\n4.闭包\n```\n1.  Map 对象中的数据是根据用户set 的顺序排序的，object 先排数字开头的。\n\n\n### dataStructure\n\n1. BST 查询二叉树\n若任意节点的左⼦子树不不空，则左⼦子树上所有结点的值均⼩小于它的 根结点的值;\n若任意节点的右⼦子树不不空，则右⼦子树上所有结点的值均⼤大于它的 根结点的值;\n任意节点的左、右⼦子树也分别为⼆二叉查找树。","slug":"js","published":1,"updated":"2020-08-24T02:03:41.383Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckzf5sdzz0019yy8kk3o5nbe5","content":"<ol>\n<li>管道符放到尾部：Hello(?:World|China|) 可以匹配 HelloWorld、HelloChina，也可以只匹配 Hello。<blockquote>\n<p>console.log(‘子君’ instanceof String)  </p>\n</blockquote>\n</li>\n<li><p>prototype</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   function f() &#123;&#125;</span><br><span class=\"line\">var a = f.prototype, b = Object.getPrototypeOf(f);</span><br><span class=\"line\">a === b    </span><br><span class=\"line\">解析：a是构造函数f的原型 ： &#123;constructor: ƒ&#125;</span><br><span class=\"line\">b是实例f的原型对象 ： ƒ () &#123; [native code] &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>webpack hmr</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.当修改了一个或多个文件；</span><br><span class=\"line\">2.文件系统接收更改并通知webpack；</span><br><span class=\"line\">3.webpack重新编译构建一个或多个模块，并通知HMR服务器进行更新；</span><br><span class=\"line\">4.HMR Server 使用webSocket通知HMR runtime 需要更新，HMR运行时通过HTTP请求更新jsonp；</span><br><span class=\"line\">5.HMR运行时替换更新中的模块，如果确定这些模块无法更新，则触发整个页面刷新。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Git submodule </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git submodule init</span><br><span class=\"line\">Submodule &apos;assets&apos; (https://github.com/maonx/vimwiki-assets.git) registered for path &apos;assets&apos;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git submodule add https://github.com/maonx/vimwiki-assets.git assets</span><br><span class=\"line\"></span><br><span class=\"line\">$ git submodule update —remote</span><br></pre></td></tr></table></figure>\n<ol>\n<li>所以函数防抖适用的场景：监听窗口的滚动，缩放。高频发生的一些事件；函数节流适用的场景：涉及与后端交互的按钮，由于网络原因或者其他原因，导致接口没有返回值，用户一直点点点的问题。 </li>\n<li>最优子结构、边界、动态转移方程。动态规划的核心—》从低向上，从而不会像递归那样保留调用栈。</li>\n<li><p>十进制转为 2 进制，除 2 取余，然后余数反向</p>\n<p>十进制转为 2 进制小时，<strong>乘 2 取整</strong></p>\n</li>\n<li><p>in操作符:检测指定对象(右边)原型链上是否有对应的属性值。<br> hasOwnProperty方法:检测指定对象自身上是否有对应的属性值。两者的区别在于in会查找原型链,而hasOwnProperty不会。</p>\n<p>for…in…遍历对象上除了Symbol以外的可枚举属性,包括原型链上的属性。</p>\n<p>Object.keys &amp; Object.assign &amp; JSON.stringify: excluding non-enumerable &amp; <strong>proto</strong></p>\n</li>\n<li><p>堆<br>堆的底层实际上是一棵完全二叉树，可以用数组实现<br>每个的节点元素值不小于其子节点 - 最大堆<br>每个的节点元素值不大于其子节点 - 最小堆</p>\n</li>\n<li><p>浏览器中 customevent</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> event = <span class=\"keyword\">new</span> CustomEvent(<span class=\"string\">\"cat\"</span>, &#123;  <span class=\"attr\">detail</span>: &#123;    <span class=\"attr\">hazcheeseburger</span>: <span class=\"literal\">true</span>  &#125;&#125;);obj.dispatchEvent(event);</span><br></pre></td></tr></table></figure>\n<ol>\n<li>window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行</li>\n<li>Element.getBoundingClientRect() 方法返回元素的大小及其相对于视口的位置。</li>\n<li>regex  y stick 粘连修饰符 </li>\n</ol>\n<p>1.普通函数在被调用时，JS引擎会创建一个栈帧，在里面准备好局部变量、函数参数、临时值、代码执行的位置（也就是说这个函数的第一行对应到代码区里的第几行机器码），在当前栈帧里设置好返回位置，然后将新帧压入栈顶。待函数执行结束后，这个栈帧将被弹出栈然后销毁，返回值会被传给上一个栈帧。</p>\n<p>   当执行到yield语句时，Generator的栈帧同样会被弹出栈外，但Generator在这里耍了个花招——它在堆里保存了栈帧的引用（或拷贝）！这样当iter.next方法被调用时，JS引擎便不会重新创建一个栈帧，而是把堆里的栈帧直接入栈。因为栈帧里保存了函数执行所需的全部上下文以及当前执行的位置，所以当这一切都被恢复如初之时，就好像程序从原本暂停的地方继续向前执行了。</p>\n<pre><code>而因为每次yield和iter.next都对应一次出栈和入栈，所以可以直接利用已有的栈机制，实现值的传出和传入。\n</code></pre><ol>\n<li>Array(10)  稀疏矩阵</li>\n<li><p>clone</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function initData(target) &#123;</span><br><span class=\"line\">  return new target.constructor()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">return Object(Symbol.prototype.valueOf.call(targe));</span><br><span class=\"line\"></span><br><span class=\"line\">function cloneReg(targe) &#123;</span><br><span class=\"line\">    const reFlags = /\\w*$/;</span><br><span class=\"line\">    const result = new targe.constructor(targe.source, reFlags.exec(targe));</span><br><span class=\"line\">    result.lastIndex = targe.lastIndex;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">```     </span><br><span class=\"line\"></span><br><span class=\"line\">1. js 在底层存储变量的时候，会在变量的机器码的低位1-3位存储其类型信息👉</span><br><span class=\"line\">   </span><br><span class=\"line\">   000：对象</span><br><span class=\"line\">   010：浮点数</span><br><span class=\"line\">   100：字符串</span><br><span class=\"line\">   110：布尔</span><br><span class=\"line\">   1：整数</span><br><span class=\"line\">   </span><br><span class=\"line\">   but, 对于 undefined 和 null 来说，这两个值的信息存储是有点特殊的。</span><br><span class=\"line\">   </span><br><span class=\"line\">   null：所有机器码均为0</span><br><span class=\"line\">   </span><br><span class=\"line\">   undefined：用 −2^30 整数来表示</span><br><span class=\"line\"></span><br><span class=\"line\">1. console 分组</span><br><span class=\"line\">```javascript</span><br><span class=\"line\">console.group(&apos;action&apos;, &apos;A&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&apos;%c prev state&apos;, &quot;color: #dddddd&quot;, &apos;\\n&apos;, &#123;</span><br><span class=\"line\">    name: &apos;a&apos;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">console.log(&apos;%c next state&apos;, &quot;color: #dddddd&quot;, &apos;\\n&apos;,  &#123;</span><br><span class=\"line\">    name: &apos;b&apos;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.groupCollapsed();</span><br><span class=\"line\">console.log(&apos;我是group折叠内容&apos;);</span><br><span class=\"line\">console.groupEnd();</span><br><span class=\"line\">console.groupEnd();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Object.create(null) 和 {}</p>\n</li>\n<li><p>每次JavaScript对DOM的操作都会改变当前页面的呈现，并重新刷新整个页面，从而消耗了大量的时间。而createDocumentFragment()的作用，就是可以创建一个文档碎片，<br>把所有的新节点附加其上，然后把文档碎片的内容一次性添加到document中。</p>\n</li>\n<li><p>indexedDB 的特点：存储空间大：存储空间可以达到几百兆甚至更多；</p>\n<pre><code>&gt;&gt; 支持二进制存储：它不仅可以存储字符串，而且还可以存储二进制数据；\n&gt;&gt; IndexedDB 有同源限制，每一个数据库只能在自身域名下能访问，不能跨域名访问；\n&gt;&gt; 支持事务型：IndexedDB 执行的操作会按照事务来分组的，在一个事务中，要么所有的操作都成功，要么所有的操作都失败；\n&gt;&gt; 键值对存储：IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以 “键值对” 的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。\n&gt;&gt; 数据操作是异步的：使用 IndexedDB 执行的操作是异步执行的，以免阻塞应用程序。\n</code></pre></li>\n<li>Usecapture:<br>true - 事件句柄在捕获阶段执行。事件捕获从父到子。<br>false- false- 默认。事件句柄在冒泡阶段执行</li>\n<li>浏览器标签页被隐藏或显示的时候会触发visibilitychange事件. document.addEventListener(‘visibilitychange’)</li>\n<li>Object.assign 继承的否Object.keys &amp; Object.assign &amp; JSON.stringify: excluding non-enumerable &amp; <strong>proto</strong></li>\n<li>let is not global while var is.</li>\n<li><p>download</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">download</span> (<span class=\"params\">url, name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> a = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'a'</span>)</span><br><span class=\"line\">  a.download = name</span><br><span class=\"line\">  a.rel = <span class=\"string\">'noopener'</span></span><br><span class=\"line\">  a.href = url</span><br><span class=\"line\">  <span class=\"comment\">// 触发模拟点击</span></span><br><span class=\"line\">  a.dispatchEvent(<span class=\"keyword\">new</span> MouseEvent(<span class=\"string\">'click'</span>))</span><br><span class=\"line\">  <span class=\"comment\">// 或者 a.click()</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方案一：Text -&gt; DataURL</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> dataUrl = <span class=\"string\">`data:,<span class=\"subst\">$&#123;str&#125;</span>`</span></span><br><span class=\"line\">download(dataUrl, <span class=\"string\">'demo.json'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方案二：Text -&gt; Blob -&gt; ObjectURL</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> url = URL.createObjectURL(<span class=\"keyword\">new</span> Blob(str.split(<span class=\"string\">''</span>)))</span><br><span class=\"line\">download(url, <span class=\"string\">'demo1.json'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`  </span></span><br><span class=\"line\"><span class=\"string\">1. stringfy 格式化</span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> json = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">3</span>,</span><br><span class=\"line\">  b: <span class=\"number\">4</span>,</span><br><span class=\"line\">  c: <span class=\"number\">5</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> str = <span class=\"built_in\">JSON</span>.stringify(json, <span class=\"literal\">null</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`  </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">1. proxy </span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\"><span class=\"keyword\">const</span> negativeArray = <span class=\"function\"><span class=\"params\">els</span> =&gt;</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(els, &#123;</span><br><span class=\"line\">        <span class=\"keyword\">get</span>: (target, propKey, receiver) =&gt;</span><br><span class=\"line\">            Reflect.<span class=\"keyword\">get</span>(</span><br><span class=\"line\">                target,</span><br><span class=\"line\">                +propKey &lt; 0 ? String(target.length + +propKey) : propKey,</span><br><span class=\"line\">                receiver</span><br><span class=\"line\">            )</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">const unicorn = negativeArray([\"京\", \"程\", \"一\", \"灯\"]);</span><br><span class=\"line\">unicorn[-1]; </span><br><span class=\"line\">``` </span><br><span class=\"line\">  </span><br><span class=\"line\">1.  对于 undeclared 变量的引用，浏览器会报引用错误，如 ReferenceError: b is not defined 。</span><br><span class=\"line\">1. Es6-&gt;babel paser-&gt;babel traverse-&gt;babel core</span><br><span class=\"line\">1.  类数组向数组转换 Array.from slice 。 aguments 就是arrarylike   </span><br><span class=\"line\">1.  xhr  </span><br><span class=\"line\">```js</span><br><span class=\"line\"> </span><br><span class=\"line\">var request = new XMLHttpRequest()</span><br><span class=\"line\"> request.open('GET', 'index/a/b/c?name=TianTian', true);</span><br><span class=\"line\"> request.onreadystatechange = function () &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span>(request.readyState === <span class=\"number\">4</span> &amp;&amp; request.status === <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log(request.responseText);</span><br><span class=\"line\">   &#125;&#125;;</span><br><span class=\"line\"> request.send();</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`   </span></span><br><span class=\"line\"><span class=\"string\">1. V8 对重复的js代码有优化 即时编译技术，如果发现一段代码经常使用，则不用转字节码 直接执行机器码</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">1. 随机字符串 Math.random().toString(36).substr(2));</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">2. Babel pollyfy 的作用 ：https://zhuanlan.zhihu.com/p/29058936</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">3. Babel stag2 的功能  https://github.com/babel/babel/tree/master/packages/babel-preset-stage-2</span></span><br><span class=\"line\"><span class=\"string\">1. 所有的babel 包  https://github.com/babel/babel/tree/master/packages</span></span><br><span class=\"line\"><span class=\"string\">1. npx babel-upgrade</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">2. ES2019 中为Symbol对象添加了只读属性 description ，该对象返回包含Symbol描述的字符串。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\"> </span></span><br><span class=\"line\"><span class=\"string\">3. 如果你传的 context 就 null 或者 undefined，那么 window 对象就是默认的 context（严格模式下默认 context 是 undefined）</span></span><br><span class=\"line\"><span class=\"string\"> </span></span><br><span class=\"line\"><span class=\"string\">4. ES6 模块功能是它的导入模块是导出时模块的实时只读视图。（相比起 CommonJS，导入的是导出模块的拷贝副本，因此也不是实时的）。只读视图和内存拷贝的区别。</span></span><br><span class=\"line\"><span class=\"string\"> </span></span><br><span class=\"line\"><span class=\"string\">5. Broadcast Channel API 允许同一原始域和用户代理下的所有窗口,iFrames 等进行交互。也就是说，如果用户打开了同一个网站的的两个标签窗口，如果网站内容发生了变化，那么两个窗口会同时得到更新通知。</span></span><br><span class=\"line\"><span class=\"string\">6. escape 在处理 0xff 之外字符的时候，是直接使用字符的 unicode 在前面加上一个 「%u」，而encodeURI则是先进行 UTF-8，再在 UTF-8 的每个字节码前加上一个 「%」； 所以通过encodeUrI 可以获取utf-8 字节长度</span></span><br><span class=\"line\"><span class=\"string\">7. js value</span></span><br><span class=\"line\"><span class=\"string\">8. Prototype 包含constructor 和 __proto__. 原型链存储共有的属性和方法，减少内存</span></span><br><span class=\"line\"><span class=\"string\">9.  基本的数据类型 </span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>text</span><br><span class=\"line\">基本的数据类型</span><br><span class=\"line\"><span class=\"literal\">undefined</span></span><br><span class=\"line\"><span class=\"literal\">null</span></span><br><span class=\"line\">string</span><br><span class=\"line\">boolean</span><br><span class=\"line\">number</span><br><span class=\"line\">symbol(ES6)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>navigator.userAgent: 返回当前浏览器的user agent字符串</p>\n</li>\n<li><p>懒加载：<br>Javascript 脚步通常要等到 DOM 加载完后才会执行，如果加载的资源过多，可能会影响网页的正常使用。<br>能够节省流量和减轻服务器压力，更近一步就是能够为公司省成本。</p>\n</li>\n<li><p>Same origin 可以使用broadcast channel 两页面间通信。</p>\n</li>\n<li>注意闭包内this的指向</li>\n<li>对于instanceof,无法判断基本类型，但可以正确判断引用类型</li>\n<li>let x = 2_3333_3333 </li>\n<li><p>哪些操作会造成内存泄漏？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.意外的全局变量</span><br><span class=\"line\">2.被遗忘的计时器或回调函数</span><br><span class=\"line\">3.脱离 DOM 的引用</span><br><span class=\"line\">4.闭包</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Map 对象中的数据是根据用户set 的顺序排序的，object 先排数字开头的。</p>\n</li>\n</ol>\n<h3 id=\"dataStructure\"><a href=\"#dataStructure\" class=\"headerlink\" title=\"dataStructure\"></a>dataStructure</h3><ol>\n<li>BST 查询二叉树<br>若任意节点的左⼦子树不不空，则左⼦子树上所有结点的值均⼩小于它的 根结点的值;<br>若任意节点的右⼦子树不不空，则右⼦子树上所有结点的值均⼤大于它的 根结点的值;<br>任意节点的左、右⼦子树也分别为⼆二叉查找树。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>管道符放到尾部：Hello(?:World|China|) 可以匹配 HelloWorld、HelloChina，也可以只匹配 Hello。<blockquote>\n<p>console.log(‘子君’ instanceof String)  </p>\n</blockquote>\n</li>\n<li><p>prototype</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   function f() &#123;&#125;</span><br><span class=\"line\">var a = f.prototype, b = Object.getPrototypeOf(f);</span><br><span class=\"line\">a === b    </span><br><span class=\"line\">解析：a是构造函数f的原型 ： &#123;constructor: ƒ&#125;</span><br><span class=\"line\">b是实例f的原型对象 ： ƒ () &#123; [native code] &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>webpack hmr</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.当修改了一个或多个文件；</span><br><span class=\"line\">2.文件系统接收更改并通知webpack；</span><br><span class=\"line\">3.webpack重新编译构建一个或多个模块，并通知HMR服务器进行更新；</span><br><span class=\"line\">4.HMR Server 使用webSocket通知HMR runtime 需要更新，HMR运行时通过HTTP请求更新jsonp；</span><br><span class=\"line\">5.HMR运行时替换更新中的模块，如果确定这些模块无法更新，则触发整个页面刷新。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Git submodule </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git submodule init</span><br><span class=\"line\">Submodule &apos;assets&apos; (https://github.com/maonx/vimwiki-assets.git) registered for path &apos;assets&apos;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git submodule add https://github.com/maonx/vimwiki-assets.git assets</span><br><span class=\"line\"></span><br><span class=\"line\">$ git submodule update —remote</span><br></pre></td></tr></table></figure>\n<ol>\n<li>所以函数防抖适用的场景：监听窗口的滚动，缩放。高频发生的一些事件；函数节流适用的场景：涉及与后端交互的按钮，由于网络原因或者其他原因，导致接口没有返回值，用户一直点点点的问题。 </li>\n<li>最优子结构、边界、动态转移方程。动态规划的核心—》从低向上，从而不会像递归那样保留调用栈。</li>\n<li><p>十进制转为 2 进制，除 2 取余，然后余数反向</p>\n<p>十进制转为 2 进制小时，<strong>乘 2 取整</strong></p>\n</li>\n<li><p>in操作符:检测指定对象(右边)原型链上是否有对应的属性值。<br> hasOwnProperty方法:检测指定对象自身上是否有对应的属性值。两者的区别在于in会查找原型链,而hasOwnProperty不会。</p>\n<p>for…in…遍历对象上除了Symbol以外的可枚举属性,包括原型链上的属性。</p>\n<p>Object.keys &amp; Object.assign &amp; JSON.stringify: excluding non-enumerable &amp; <strong>proto</strong></p>\n</li>\n<li><p>堆<br>堆的底层实际上是一棵完全二叉树，可以用数组实现<br>每个的节点元素值不小于其子节点 - 最大堆<br>每个的节点元素值不大于其子节点 - 最小堆</p>\n</li>\n<li><p>浏览器中 customevent</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> event = <span class=\"keyword\">new</span> CustomEvent(<span class=\"string\">\"cat\"</span>, &#123;  <span class=\"attr\">detail</span>: &#123;    <span class=\"attr\">hazcheeseburger</span>: <span class=\"literal\">true</span>  &#125;&#125;);obj.dispatchEvent(event);</span><br></pre></td></tr></table></figure>\n<ol>\n<li>window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行</li>\n<li>Element.getBoundingClientRect() 方法返回元素的大小及其相对于视口的位置。</li>\n<li>regex  y stick 粘连修饰符 </li>\n</ol>\n<p>1.普通函数在被调用时，JS引擎会创建一个栈帧，在里面准备好局部变量、函数参数、临时值、代码执行的位置（也就是说这个函数的第一行对应到代码区里的第几行机器码），在当前栈帧里设置好返回位置，然后将新帧压入栈顶。待函数执行结束后，这个栈帧将被弹出栈然后销毁，返回值会被传给上一个栈帧。</p>\n<p>   当执行到yield语句时，Generator的栈帧同样会被弹出栈外，但Generator在这里耍了个花招——它在堆里保存了栈帧的引用（或拷贝）！这样当iter.next方法被调用时，JS引擎便不会重新创建一个栈帧，而是把堆里的栈帧直接入栈。因为栈帧里保存了函数执行所需的全部上下文以及当前执行的位置，所以当这一切都被恢复如初之时，就好像程序从原本暂停的地方继续向前执行了。</p>\n<pre><code>而因为每次yield和iter.next都对应一次出栈和入栈，所以可以直接利用已有的栈机制，实现值的传出和传入。\n</code></pre><ol>\n<li>Array(10)  稀疏矩阵</li>\n<li><p>clone</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function initData(target) &#123;</span><br><span class=\"line\">  return new target.constructor()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">return Object(Symbol.prototype.valueOf.call(targe));</span><br><span class=\"line\"></span><br><span class=\"line\">function cloneReg(targe) &#123;</span><br><span class=\"line\">    const reFlags = /\\w*$/;</span><br><span class=\"line\">    const result = new targe.constructor(targe.source, reFlags.exec(targe));</span><br><span class=\"line\">    result.lastIndex = targe.lastIndex;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">```     </span><br><span class=\"line\"></span><br><span class=\"line\">1. js 在底层存储变量的时候，会在变量的机器码的低位1-3位存储其类型信息👉</span><br><span class=\"line\">   </span><br><span class=\"line\">   000：对象</span><br><span class=\"line\">   010：浮点数</span><br><span class=\"line\">   100：字符串</span><br><span class=\"line\">   110：布尔</span><br><span class=\"line\">   1：整数</span><br><span class=\"line\">   </span><br><span class=\"line\">   but, 对于 undefined 和 null 来说，这两个值的信息存储是有点特殊的。</span><br><span class=\"line\">   </span><br><span class=\"line\">   null：所有机器码均为0</span><br><span class=\"line\">   </span><br><span class=\"line\">   undefined：用 −2^30 整数来表示</span><br><span class=\"line\"></span><br><span class=\"line\">1. console 分组</span><br><span class=\"line\">```javascript</span><br><span class=\"line\">console.group(&apos;action&apos;, &apos;A&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&apos;%c prev state&apos;, &quot;color: #dddddd&quot;, &apos;\\n&apos;, &#123;</span><br><span class=\"line\">    name: &apos;a&apos;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">console.log(&apos;%c next state&apos;, &quot;color: #dddddd&quot;, &apos;\\n&apos;,  &#123;</span><br><span class=\"line\">    name: &apos;b&apos;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.groupCollapsed();</span><br><span class=\"line\">console.log(&apos;我是group折叠内容&apos;);</span><br><span class=\"line\">console.groupEnd();</span><br><span class=\"line\">console.groupEnd();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Object.create(null) 和 {}</p>\n</li>\n<li><p>每次JavaScript对DOM的操作都会改变当前页面的呈现，并重新刷新整个页面，从而消耗了大量的时间。而createDocumentFragment()的作用，就是可以创建一个文档碎片，<br>把所有的新节点附加其上，然后把文档碎片的内容一次性添加到document中。</p>\n</li>\n<li><p>indexedDB 的特点：存储空间大：存储空间可以达到几百兆甚至更多；</p>\n<pre><code>&gt;&gt; 支持二进制存储：它不仅可以存储字符串，而且还可以存储二进制数据；\n&gt;&gt; IndexedDB 有同源限制，每一个数据库只能在自身域名下能访问，不能跨域名访问；\n&gt;&gt; 支持事务型：IndexedDB 执行的操作会按照事务来分组的，在一个事务中，要么所有的操作都成功，要么所有的操作都失败；\n&gt;&gt; 键值对存储：IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以 “键值对” 的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。\n&gt;&gt; 数据操作是异步的：使用 IndexedDB 执行的操作是异步执行的，以免阻塞应用程序。\n</code></pre></li>\n<li>Usecapture:<br>true - 事件句柄在捕获阶段执行。事件捕获从父到子。<br>false- false- 默认。事件句柄在冒泡阶段执行</li>\n<li>浏览器标签页被隐藏或显示的时候会触发visibilitychange事件. document.addEventListener(‘visibilitychange’)</li>\n<li>Object.assign 继承的否Object.keys &amp; Object.assign &amp; JSON.stringify: excluding non-enumerable &amp; <strong>proto</strong></li>\n<li>let is not global while var is.</li>\n<li><p>download</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">download</span> (<span class=\"params\">url, name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> a = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'a'</span>)</span><br><span class=\"line\">  a.download = name</span><br><span class=\"line\">  a.rel = <span class=\"string\">'noopener'</span></span><br><span class=\"line\">  a.href = url</span><br><span class=\"line\">  <span class=\"comment\">// 触发模拟点击</span></span><br><span class=\"line\">  a.dispatchEvent(<span class=\"keyword\">new</span> MouseEvent(<span class=\"string\">'click'</span>))</span><br><span class=\"line\">  <span class=\"comment\">// 或者 a.click()</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方案一：Text -&gt; DataURL</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> dataUrl = <span class=\"string\">`data:,<span class=\"subst\">$&#123;str&#125;</span>`</span></span><br><span class=\"line\">download(dataUrl, <span class=\"string\">'demo.json'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方案二：Text -&gt; Blob -&gt; ObjectURL</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> url = URL.createObjectURL(<span class=\"keyword\">new</span> Blob(str.split(<span class=\"string\">''</span>)))</span><br><span class=\"line\">download(url, <span class=\"string\">'demo1.json'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`  </span></span><br><span class=\"line\"><span class=\"string\">1. stringfy 格式化</span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> json = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">3</span>,</span><br><span class=\"line\">  b: <span class=\"number\">4</span>,</span><br><span class=\"line\">  c: <span class=\"number\">5</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> str = <span class=\"built_in\">JSON</span>.stringify(json, <span class=\"literal\">null</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`  </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">1. proxy </span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\"><span class=\"keyword\">const</span> negativeArray = <span class=\"function\"><span class=\"params\">els</span> =&gt;</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(els, &#123;</span><br><span class=\"line\">        <span class=\"keyword\">get</span>: (target, propKey, receiver) =&gt;</span><br><span class=\"line\">            Reflect.<span class=\"keyword\">get</span>(</span><br><span class=\"line\">                target,</span><br><span class=\"line\">                +propKey &lt; 0 ? String(target.length + +propKey) : propKey,</span><br><span class=\"line\">                receiver</span><br><span class=\"line\">            )</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">const unicorn = negativeArray([\"京\", \"程\", \"一\", \"灯\"]);</span><br><span class=\"line\">unicorn[-1]; </span><br><span class=\"line\">``` </span><br><span class=\"line\">  </span><br><span class=\"line\">1.  对于 undeclared 变量的引用，浏览器会报引用错误，如 ReferenceError: b is not defined 。</span><br><span class=\"line\">1. Es6-&gt;babel paser-&gt;babel traverse-&gt;babel core</span><br><span class=\"line\">1.  类数组向数组转换 Array.from slice 。 aguments 就是arrarylike   </span><br><span class=\"line\">1.  xhr  </span><br><span class=\"line\">```js</span><br><span class=\"line\"> </span><br><span class=\"line\">var request = new XMLHttpRequest()</span><br><span class=\"line\"> request.open('GET', 'index/a/b/c?name=TianTian', true);</span><br><span class=\"line\"> request.onreadystatechange = function () &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span>(request.readyState === <span class=\"number\">4</span> &amp;&amp; request.status === <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log(request.responseText);</span><br><span class=\"line\">   &#125;&#125;;</span><br><span class=\"line\"> request.send();</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`   </span></span><br><span class=\"line\"><span class=\"string\">1. V8 对重复的js代码有优化 即时编译技术，如果发现一段代码经常使用，则不用转字节码 直接执行机器码</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">1. 随机字符串 Math.random().toString(36).substr(2));</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">2. Babel pollyfy 的作用 ：https://zhuanlan.zhihu.com/p/29058936</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">3. Babel stag2 的功能  https://github.com/babel/babel/tree/master/packages/babel-preset-stage-2</span></span><br><span class=\"line\"><span class=\"string\">1. 所有的babel 包  https://github.com/babel/babel/tree/master/packages</span></span><br><span class=\"line\"><span class=\"string\">1. npx babel-upgrade</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">2. ES2019 中为Symbol对象添加了只读属性 description ，该对象返回包含Symbol描述的字符串。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\"> </span></span><br><span class=\"line\"><span class=\"string\">3. 如果你传的 context 就 null 或者 undefined，那么 window 对象就是默认的 context（严格模式下默认 context 是 undefined）</span></span><br><span class=\"line\"><span class=\"string\"> </span></span><br><span class=\"line\"><span class=\"string\">4. ES6 模块功能是它的导入模块是导出时模块的实时只读视图。（相比起 CommonJS，导入的是导出模块的拷贝副本，因此也不是实时的）。只读视图和内存拷贝的区别。</span></span><br><span class=\"line\"><span class=\"string\"> </span></span><br><span class=\"line\"><span class=\"string\">5. Broadcast Channel API 允许同一原始域和用户代理下的所有窗口,iFrames 等进行交互。也就是说，如果用户打开了同一个网站的的两个标签窗口，如果网站内容发生了变化，那么两个窗口会同时得到更新通知。</span></span><br><span class=\"line\"><span class=\"string\">6. escape 在处理 0xff 之外字符的时候，是直接使用字符的 unicode 在前面加上一个 「%u」，而encodeURI则是先进行 UTF-8，再在 UTF-8 的每个字节码前加上一个 「%」； 所以通过encodeUrI 可以获取utf-8 字节长度</span></span><br><span class=\"line\"><span class=\"string\">7. js value</span></span><br><span class=\"line\"><span class=\"string\">8. Prototype 包含constructor 和 __proto__. 原型链存储共有的属性和方法，减少内存</span></span><br><span class=\"line\"><span class=\"string\">9.  基本的数据类型 </span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>text</span><br><span class=\"line\">基本的数据类型</span><br><span class=\"line\"><span class=\"literal\">undefined</span></span><br><span class=\"line\"><span class=\"literal\">null</span></span><br><span class=\"line\">string</span><br><span class=\"line\">boolean</span><br><span class=\"line\">number</span><br><span class=\"line\">symbol(ES6)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>navigator.userAgent: 返回当前浏览器的user agent字符串</p>\n</li>\n<li><p>懒加载：<br>Javascript 脚步通常要等到 DOM 加载完后才会执行，如果加载的资源过多，可能会影响网页的正常使用。<br>能够节省流量和减轻服务器压力，更近一步就是能够为公司省成本。</p>\n</li>\n<li><p>Same origin 可以使用broadcast channel 两页面间通信。</p>\n</li>\n<li>注意闭包内this的指向</li>\n<li>对于instanceof,无法判断基本类型，但可以正确判断引用类型</li>\n<li>let x = 2_3333_3333 </li>\n<li><p>哪些操作会造成内存泄漏？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.意外的全局变量</span><br><span class=\"line\">2.被遗忘的计时器或回调函数</span><br><span class=\"line\">3.脱离 DOM 的引用</span><br><span class=\"line\">4.闭包</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Map 对象中的数据是根据用户set 的顺序排序的，object 先排数字开头的。</p>\n</li>\n</ol>\n<h3 id=\"dataStructure\"><a href=\"#dataStructure\" class=\"headerlink\" title=\"dataStructure\"></a>dataStructure</h3><ol>\n<li>BST 查询二叉树<br>若任意节点的左⼦子树不不空，则左⼦子树上所有结点的值均⼩小于它的 根结点的值;<br>若任意节点的右⼦子树不不空，则右⼦子树上所有结点的值均⼤大于它的 根结点的值;<br>任意节点的左、右⼦子树也分别为⼆二叉查找树。</li>\n</ol>\n"},{"title":"linux","date":"2019-07-02T03:39:34.000Z","_content":"\n### command\n1. Linux touch 命令用于修改文件或者目录的时间属性,包括存取时间和更改时间。若文件不存在,系统会建立一个新的文件。\n\n1. which 指令会在环境变量\\$PATH 设置的目录里查找符合条件的文件。\n   \n1. \n\n```\n二层负载均衡会通过一个虚拟 MAC 地址接收请求，然后再分配到真实的 MAC 地址；\n三层负载均衡会通过一个虚拟 IP 地址接收请求，然后再分配到真实的 IP 地址；\n四层通过虚拟 IP + 端口接收请求，然后再分配到真实的服务器；\n七层通过虚拟的 URL 或主机名接收请求，然后再分配到真实的服务器。\n```\n1. 本地盘 NVMe：相较于本地盘 SSD，提供更高的IOPS, 目前只支持大规格的实例类型。SSD 云盘：相较于本地盘，更灵活的存储空间，并且支持数据加密，更安全。","source":"_posts/linux.md","raw":"---\ntitle: linux\ndate: 2019-07-02 11:39:34\ntags: ops\n---\n\n### command\n1. Linux touch 命令用于修改文件或者目录的时间属性,包括存取时间和更改时间。若文件不存在,系统会建立一个新的文件。\n\n1. which 指令会在环境变量\\$PATH 设置的目录里查找符合条件的文件。\n   \n1. \n\n```\n二层负载均衡会通过一个虚拟 MAC 地址接收请求，然后再分配到真实的 MAC 地址；\n三层负载均衡会通过一个虚拟 IP 地址接收请求，然后再分配到真实的 IP 地址；\n四层通过虚拟 IP + 端口接收请求，然后再分配到真实的服务器；\n七层通过虚拟的 URL 或主机名接收请求，然后再分配到真实的服务器。\n```\n1. 本地盘 NVMe：相较于本地盘 SSD，提供更高的IOPS, 目前只支持大规格的实例类型。SSD 云盘：相较于本地盘，更灵活的存储空间，并且支持数据加密，更安全。","slug":"linux","published":1,"updated":"2021-12-22T13:08:52.754Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckzf5se00001cyy8kexq6tpd4","content":"<h3 id=\"command\"><a href=\"#command\" class=\"headerlink\" title=\"command\"></a>command</h3><ol>\n<li><p>Linux touch 命令用于修改文件或者目录的时间属性,包括存取时间和更改时间。若文件不存在,系统会建立一个新的文件。</p>\n</li>\n<li><p>which 指令会在环境变量\\$PATH 设置的目录里查找符合条件的文件。</p>\n</li>\n<li></li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">二层负载均衡会通过一个虚拟 MAC 地址接收请求，然后再分配到真实的 MAC 地址；</span><br><span class=\"line\">三层负载均衡会通过一个虚拟 IP 地址接收请求，然后再分配到真实的 IP 地址；</span><br><span class=\"line\">四层通过虚拟 IP + 端口接收请求，然后再分配到真实的服务器；</span><br><span class=\"line\">七层通过虚拟的 URL 或主机名接收请求，然后再分配到真实的服务器。</span><br></pre></td></tr></table></figure>\n<ol>\n<li>本地盘 NVMe：相较于本地盘 SSD，提供更高的IOPS, 目前只支持大规格的实例类型。SSD 云盘：相较于本地盘，更灵活的存储空间，并且支持数据加密，更安全。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"command\"><a href=\"#command\" class=\"headerlink\" title=\"command\"></a>command</h3><ol>\n<li><p>Linux touch 命令用于修改文件或者目录的时间属性,包括存取时间和更改时间。若文件不存在,系统会建立一个新的文件。</p>\n</li>\n<li><p>which 指令会在环境变量\\$PATH 设置的目录里查找符合条件的文件。</p>\n</li>\n<li></li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">二层负载均衡会通过一个虚拟 MAC 地址接收请求，然后再分配到真实的 MAC 地址；</span><br><span class=\"line\">三层负载均衡会通过一个虚拟 IP 地址接收请求，然后再分配到真实的 IP 地址；</span><br><span class=\"line\">四层通过虚拟 IP + 端口接收请求，然后再分配到真实的服务器；</span><br><span class=\"line\">七层通过虚拟的 URL 或主机名接收请求，然后再分配到真实的服务器。</span><br></pre></td></tr></table></figure>\n<ol>\n<li>本地盘 NVMe：相较于本地盘 SSD，提供更高的IOPS, 目前只支持大规格的实例类型。SSD 云盘：相较于本地盘，更灵活的存储空间，并且支持数据加密，更安全。</li>\n</ol>\n"},{"title":"node","date":"2020-08-13T08:18:08.000Z","_content":"1.  V8 浏览器会自动执行垃圾回收，但由于 JavaScript 也是运行在主线程上的，一旦执行垃圾回收，就要打断 JavaScript 的运行，可能会或多或少的造成页面的卡顿，影响用户体验，所以 V8 决定采用增量 标记算法回收：\n   即把垃圾回收拆成一个个小任务，穿插在 JavaScript 中执行。\n1. Node 高消耗任务：1. Regex 2. 加密、压缩、fs 同步操作 3.json.stringfy\n1. epoll是event poll的简写，是Linux内核提供的一种由事件驱动的I/O通知机制。\n1. 对第三方包和库做检测：NSP(Node Security Platform)\n1. V8 机器码的体积要比字节码大的多，执行频率高的为热点代码，启动编译器进行编译，其它的解释器执行\n1. Resovle 的任务进入微任务队列，暂停当前的协程，回到父协程\n1. Npm ^ 限定minor 版本 ~限定patch 版本\n1. Stream cork uncork\n1. escape-html  This function will escape the following characters: \", ', &, <, and >.\n1. domain模块，把处理多个不同的IO的操作作为一个组。注册事件和回调到domain，当发生一个错误事件或抛出一个错误时，domain对象会被通知，不会丢失上下文环境，也不导致程序错误立即退出，与process.on('uncaughtException')不同。\n1. stream tranform\n```text\nconst { Transform } = require('stream');\n\nconst myTransform = new Transform({\n  transform(chunk, encoding, callback) {\n    // ...\n  }\n});\n```\n1. 可以引入corejs实现feature\n1. 性能分析\nNode 性能分析，抓取火焰图 node --inspect app.js\nNode  --prof-process  https://github.com/nswbmw/node-in-debugging/blob/master/1.3%20Tick%20Processor.md\n \n1. 一个promise类 \n```javascript\nclass Sleep {\nthen(resolve, reject){\n\n}\n}\n```\n1. Node 内置了pipeline  const { pipeline } = require('stream');\n1. Elastic APM 是 Elastic 公司开源的一款 APM 工具\n1. Error.prepareStackTrace:定制化堆栈信息    Error.captureStackTrace:隐藏内部的实现细节，优化错误栈。\n1. const { EventEmitter } = require('events’);  EventEmitter 的继承\n1. Require.resovle() 获取模块的绝对路径  \n1. peerDependencies 相关模块安装\n1. websocket \n1. cors 新浏览器\nSameSite=Strict: The cookie is only sent if you are currently on the site that the cookie is set for. If you are on a different site and you click a link to a site that the cookie is set for, the cookie is not sent with the first request.\n1. 主垃圾回收器：\n   \n   主垃圾回收器主要负责老生区中的垃圾回收。\n   \n   除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。\n   \n   因此老生区中的对象有两个特点，一个是对象占用空间大，另一个是对象存活时间长。\n   \n1. V8 中会把堆分为新生代和老生代两个区域，\n   \n   新生代中存放的是生存时间短的对象，\n   \n   老生代中存放的生存时间久的对象。\n   \n   垃圾回收重要术语：\n   \n   代际假说\n   大部分对象在内存中存在的时间很短\n   不死的对象，会活得更久\n   分代收集\n   副垃圾回收器：\n   \n   主要负责新生代的垃圾回收。\n   \n   这个区域不大，但是垃圾回收比较频繁。\n   \n   新生代的垃圾回收算法是 Scavenge 算法。\n   \n   主要把新生代空间对半划分为两个区域：对象区域，空闲区域。\n   \n   当对象区域快被写满时，则会进行一次垃圾清理。\n   \n\n\n```text\nWebSocket 使用了自定义的二进制分帧格式，把每个应用消息切分成一或多个帧，发送到目的地之后再组装起来，等到接收到完整的消息后再通知接收端。基本的成帧协议定义了帧类型有操作码、有效载荷的长度，指定位置的Extension data和Application data，统称为Payload data，保留了一些特殊位和操作码供后期扩展。在打开握手完成后，终端发送一个关闭帧之前的任何时间里，数据帧可能由客户端或服务器的任何一方发送。\n\n• 帧：最小的通信单位，包含可变长度的帧首部和净荷部分，净荷可能包含完整或部分应用消息。\n• 消息：一系列帧，与应用消息对等。\n```\n1. jwt 签名算法\n```text\nHS256 使用密钥生成固定的签名，RS256 使用成非对称进行签名。简单地说，HS256 必须与任何想要验证 JWT的 客户端或 API 共享秘密。\nRS256 生成非对称签名，这意味着必须使用私钥来签签名 JWT，并且必须使用对应的公钥来验证签名。与对称算法不同，使用 RS256 可以保证服务端是 JWT 的签名者，因为服务端是唯一拥有私钥的一方。这样做将不再需要在许多应用程序之间共享私钥\n\n这种方法可以让我们分离开签发与验证，签发时需要用一个密钥，验证时使用公钥，也就是有公钥的地方只能做验证，但不能签发 JWT。\n```\n### egg\n1. 启动顺序\n```text\nMaster 启动后先 fork Agent 进程\nAgent 初始化成功后，通过 IPC 通道通知 Master\nMaster 再 fork 多个 App Worker\nApp Worker 初始化成功，通知 Master\n所有的进程初始化成功后，Master 通知 Agent 和 Worker 应用启动成功\n```","source":"_posts/node.md","raw":"---\ntitle: node\ndate: 2020-08-13 16:18:08\ntags: node、egg \n---\n1.  V8 浏览器会自动执行垃圾回收，但由于 JavaScript 也是运行在主线程上的，一旦执行垃圾回收，就要打断 JavaScript 的运行，可能会或多或少的造成页面的卡顿，影响用户体验，所以 V8 决定采用增量 标记算法回收：\n   即把垃圾回收拆成一个个小任务，穿插在 JavaScript 中执行。\n1. Node 高消耗任务：1. Regex 2. 加密、压缩、fs 同步操作 3.json.stringfy\n1. epoll是event poll的简写，是Linux内核提供的一种由事件驱动的I/O通知机制。\n1. 对第三方包和库做检测：NSP(Node Security Platform)\n1. V8 机器码的体积要比字节码大的多，执行频率高的为热点代码，启动编译器进行编译，其它的解释器执行\n1. Resovle 的任务进入微任务队列，暂停当前的协程，回到父协程\n1. Npm ^ 限定minor 版本 ~限定patch 版本\n1. Stream cork uncork\n1. escape-html  This function will escape the following characters: \", ', &, <, and >.\n1. domain模块，把处理多个不同的IO的操作作为一个组。注册事件和回调到domain，当发生一个错误事件或抛出一个错误时，domain对象会被通知，不会丢失上下文环境，也不导致程序错误立即退出，与process.on('uncaughtException')不同。\n1. stream tranform\n```text\nconst { Transform } = require('stream');\n\nconst myTransform = new Transform({\n  transform(chunk, encoding, callback) {\n    // ...\n  }\n});\n```\n1. 可以引入corejs实现feature\n1. 性能分析\nNode 性能分析，抓取火焰图 node --inspect app.js\nNode  --prof-process  https://github.com/nswbmw/node-in-debugging/blob/master/1.3%20Tick%20Processor.md\n \n1. 一个promise类 \n```javascript\nclass Sleep {\nthen(resolve, reject){\n\n}\n}\n```\n1. Node 内置了pipeline  const { pipeline } = require('stream');\n1. Elastic APM 是 Elastic 公司开源的一款 APM 工具\n1. Error.prepareStackTrace:定制化堆栈信息    Error.captureStackTrace:隐藏内部的实现细节，优化错误栈。\n1. const { EventEmitter } = require('events’);  EventEmitter 的继承\n1. Require.resovle() 获取模块的绝对路径  \n1. peerDependencies 相关模块安装\n1. websocket \n1. cors 新浏览器\nSameSite=Strict: The cookie is only sent if you are currently on the site that the cookie is set for. If you are on a different site and you click a link to a site that the cookie is set for, the cookie is not sent with the first request.\n1. 主垃圾回收器：\n   \n   主垃圾回收器主要负责老生区中的垃圾回收。\n   \n   除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。\n   \n   因此老生区中的对象有两个特点，一个是对象占用空间大，另一个是对象存活时间长。\n   \n1. V8 中会把堆分为新生代和老生代两个区域，\n   \n   新生代中存放的是生存时间短的对象，\n   \n   老生代中存放的生存时间久的对象。\n   \n   垃圾回收重要术语：\n   \n   代际假说\n   大部分对象在内存中存在的时间很短\n   不死的对象，会活得更久\n   分代收集\n   副垃圾回收器：\n   \n   主要负责新生代的垃圾回收。\n   \n   这个区域不大，但是垃圾回收比较频繁。\n   \n   新生代的垃圾回收算法是 Scavenge 算法。\n   \n   主要把新生代空间对半划分为两个区域：对象区域，空闲区域。\n   \n   当对象区域快被写满时，则会进行一次垃圾清理。\n   \n\n\n```text\nWebSocket 使用了自定义的二进制分帧格式，把每个应用消息切分成一或多个帧，发送到目的地之后再组装起来，等到接收到完整的消息后再通知接收端。基本的成帧协议定义了帧类型有操作码、有效载荷的长度，指定位置的Extension data和Application data，统称为Payload data，保留了一些特殊位和操作码供后期扩展。在打开握手完成后，终端发送一个关闭帧之前的任何时间里，数据帧可能由客户端或服务器的任何一方发送。\n\n• 帧：最小的通信单位，包含可变长度的帧首部和净荷部分，净荷可能包含完整或部分应用消息。\n• 消息：一系列帧，与应用消息对等。\n```\n1. jwt 签名算法\n```text\nHS256 使用密钥生成固定的签名，RS256 使用成非对称进行签名。简单地说，HS256 必须与任何想要验证 JWT的 客户端或 API 共享秘密。\nRS256 生成非对称签名，这意味着必须使用私钥来签签名 JWT，并且必须使用对应的公钥来验证签名。与对称算法不同，使用 RS256 可以保证服务端是 JWT 的签名者，因为服务端是唯一拥有私钥的一方。这样做将不再需要在许多应用程序之间共享私钥\n\n这种方法可以让我们分离开签发与验证，签发时需要用一个密钥，验证时使用公钥，也就是有公钥的地方只能做验证，但不能签发 JWT。\n```\n### egg\n1. 启动顺序\n```text\nMaster 启动后先 fork Agent 进程\nAgent 初始化成功后，通过 IPC 通道通知 Master\nMaster 再 fork 多个 App Worker\nApp Worker 初始化成功，通知 Master\n所有的进程初始化成功后，Master 通知 Agent 和 Worker 应用启动成功\n```","slug":"node","published":1,"updated":"2020-08-13T09:48:53.556Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckzf5se01001dyy8kqqgbzys3","content":"<ol>\n<li>V8 浏览器会自动执行垃圾回收，但由于 JavaScript 也是运行在主线程上的，一旦执行垃圾回收，就要打断 JavaScript 的运行，可能会或多或少的造成页面的卡顿，影响用户体验，所以 V8 决定采用增量 标记算法回收：<br>即把垃圾回收拆成一个个小任务，穿插在 JavaScript 中执行。</li>\n<li>Node 高消耗任务：1. Regex 2. 加密、压缩、fs 同步操作 3.json.stringfy</li>\n<li>epoll是event poll的简写，是Linux内核提供的一种由事件驱动的I/O通知机制。</li>\n<li>对第三方包和库做检测：NSP(Node Security Platform)</li>\n<li>V8 机器码的体积要比字节码大的多，执行频率高的为热点代码，启动编译器进行编译，其它的解释器执行</li>\n<li>Resovle 的任务进入微任务队列，暂停当前的协程，回到父协程</li>\n<li>Npm ^ 限定minor 版本 ~限定patch 版本</li>\n<li>Stream cork uncork</li>\n<li>escape-html  This function will escape the following characters: “, ‘, &amp;, &lt;, and &gt;.</li>\n<li>domain模块，把处理多个不同的IO的操作作为一个组。注册事件和回调到domain，当发生一个错误事件或抛出一个错误时，domain对象会被通知，不会丢失上下文环境，也不导致程序错误立即退出，与process.on(‘uncaughtException’)不同。</li>\n<li><p>stream tranform</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const &#123; Transform &#125; = require(&apos;stream&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">const myTransform = new Transform(&#123;</span><br><span class=\"line\">  transform(chunk, encoding, callback) &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>可以引入corejs实现feature</p>\n</li>\n<li><p>性能分析<br>Node 性能分析，抓取火焰图 node –inspect app.js<br>Node  –prof-process  <a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/1.3%20Tick%20Processor.md\" target=\"_blank\" rel=\"noopener\">https://github.com/nswbmw/node-in-debugging/blob/master/1.3%20Tick%20Processor.md</a></p>\n</li>\n<li><p>一个promise类 </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sleep</span> </span>&#123;</span><br><span class=\"line\">then(resolve, reject)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Node 内置了pipeline  const { pipeline } = require(‘stream’);</p>\n</li>\n<li>Elastic APM 是 Elastic 公司开源的一款 APM 工具</li>\n<li>Error.prepareStackTrace:定制化堆栈信息    Error.captureStackTrace:隐藏内部的实现细节，优化错误栈。</li>\n<li>const { EventEmitter } = require(‘events’);  EventEmitter 的继承</li>\n<li>Require.resovle() 获取模块的绝对路径  </li>\n<li>peerDependencies 相关模块安装</li>\n<li>websocket </li>\n<li>cors 新浏览器<br>SameSite=Strict: The cookie is only sent if you are currently on the site that the cookie is set for. If you are on a different site and you click a link to a site that the cookie is set for, the cookie is not sent with the first request.</li>\n<li><p>主垃圾回收器：</p>\n<p>主垃圾回收器主要负责老生区中的垃圾回收。</p>\n<p>除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。</p>\n<p>因此老生区中的对象有两个特点，一个是对象占用空间大，另一个是对象存活时间长。</p>\n</li>\n<li><p>V8 中会把堆分为新生代和老生代两个区域，</p>\n<p>新生代中存放的是生存时间短的对象，</p>\n<p>老生代中存放的生存时间久的对象。</p>\n<p>垃圾回收重要术语：</p>\n<p>代际假说<br>大部分对象在内存中存在的时间很短<br>不死的对象，会活得更久<br>分代收集<br>副垃圾回收器：</p>\n<p>主要负责新生代的垃圾回收。</p>\n<p>这个区域不大，但是垃圾回收比较频繁。</p>\n<p>新生代的垃圾回收算法是 Scavenge 算法。</p>\n<p>主要把新生代空间对半划分为两个区域：对象区域，空闲区域。</p>\n<p>当对象区域快被写满时，则会进行一次垃圾清理。</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WebSocket 使用了自定义的二进制分帧格式，把每个应用消息切分成一或多个帧，发送到目的地之后再组装起来，等到接收到完整的消息后再通知接收端。基本的成帧协议定义了帧类型有操作码、有效载荷的长度，指定位置的Extension data和Application data，统称为Payload data，保留了一些特殊位和操作码供后期扩展。在打开握手完成后，终端发送一个关闭帧之前的任何时间里，数据帧可能由客户端或服务器的任何一方发送。</span><br><span class=\"line\"></span><br><span class=\"line\">• 帧：最小的通信单位，包含可变长度的帧首部和净荷部分，净荷可能包含完整或部分应用消息。</span><br><span class=\"line\">• 消息：一系列帧，与应用消息对等。</span><br></pre></td></tr></table></figure>\n<ol>\n<li>jwt 签名算法<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HS256 使用密钥生成固定的签名，RS256 使用成非对称进行签名。简单地说，HS256 必须与任何想要验证 JWT的 客户端或 API 共享秘密。</span><br><span class=\"line\">RS256 生成非对称签名，这意味着必须使用私钥来签签名 JWT，并且必须使用对应的公钥来验证签名。与对称算法不同，使用 RS256 可以保证服务端是 JWT 的签名者，因为服务端是唯一拥有私钥的一方。这样做将不再需要在许多应用程序之间共享私钥</span><br><span class=\"line\"></span><br><span class=\"line\">这种方法可以让我们分离开签发与验证，签发时需要用一个密钥，验证时使用公钥，也就是有公钥的地方只能做验证，但不能签发 JWT。</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"egg\"><a href=\"#egg\" class=\"headerlink\" title=\"egg\"></a>egg</h3><ol>\n<li>启动顺序<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Master 启动后先 fork Agent 进程</span><br><span class=\"line\">Agent 初始化成功后，通过 IPC 通道通知 Master</span><br><span class=\"line\">Master 再 fork 多个 App Worker</span><br><span class=\"line\">App Worker 初始化成功，通知 Master</span><br><span class=\"line\">所有的进程初始化成功后，Master 通知 Agent 和 Worker 应用启动成功</span><br></pre></td></tr></table></figure></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>V8 浏览器会自动执行垃圾回收，但由于 JavaScript 也是运行在主线程上的，一旦执行垃圾回收，就要打断 JavaScript 的运行，可能会或多或少的造成页面的卡顿，影响用户体验，所以 V8 决定采用增量 标记算法回收：<br>即把垃圾回收拆成一个个小任务，穿插在 JavaScript 中执行。</li>\n<li>Node 高消耗任务：1. Regex 2. 加密、压缩、fs 同步操作 3.json.stringfy</li>\n<li>epoll是event poll的简写，是Linux内核提供的一种由事件驱动的I/O通知机制。</li>\n<li>对第三方包和库做检测：NSP(Node Security Platform)</li>\n<li>V8 机器码的体积要比字节码大的多，执行频率高的为热点代码，启动编译器进行编译，其它的解释器执行</li>\n<li>Resovle 的任务进入微任务队列，暂停当前的协程，回到父协程</li>\n<li>Npm ^ 限定minor 版本 ~限定patch 版本</li>\n<li>Stream cork uncork</li>\n<li>escape-html  This function will escape the following characters: “, ‘, &amp;, &lt;, and &gt;.</li>\n<li>domain模块，把处理多个不同的IO的操作作为一个组。注册事件和回调到domain，当发生一个错误事件或抛出一个错误时，domain对象会被通知，不会丢失上下文环境，也不导致程序错误立即退出，与process.on(‘uncaughtException’)不同。</li>\n<li><p>stream tranform</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const &#123; Transform &#125; = require(&apos;stream&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">const myTransform = new Transform(&#123;</span><br><span class=\"line\">  transform(chunk, encoding, callback) &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>可以引入corejs实现feature</p>\n</li>\n<li><p>性能分析<br>Node 性能分析，抓取火焰图 node –inspect app.js<br>Node  –prof-process  <a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/1.3%20Tick%20Processor.md\" target=\"_blank\" rel=\"noopener\">https://github.com/nswbmw/node-in-debugging/blob/master/1.3%20Tick%20Processor.md</a></p>\n</li>\n<li><p>一个promise类 </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sleep</span> </span>&#123;</span><br><span class=\"line\">then(resolve, reject)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Node 内置了pipeline  const { pipeline } = require(‘stream’);</p>\n</li>\n<li>Elastic APM 是 Elastic 公司开源的一款 APM 工具</li>\n<li>Error.prepareStackTrace:定制化堆栈信息    Error.captureStackTrace:隐藏内部的实现细节，优化错误栈。</li>\n<li>const { EventEmitter } = require(‘events’);  EventEmitter 的继承</li>\n<li>Require.resovle() 获取模块的绝对路径  </li>\n<li>peerDependencies 相关模块安装</li>\n<li>websocket </li>\n<li>cors 新浏览器<br>SameSite=Strict: The cookie is only sent if you are currently on the site that the cookie is set for. If you are on a different site and you click a link to a site that the cookie is set for, the cookie is not sent with the first request.</li>\n<li><p>主垃圾回收器：</p>\n<p>主垃圾回收器主要负责老生区中的垃圾回收。</p>\n<p>除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。</p>\n<p>因此老生区中的对象有两个特点，一个是对象占用空间大，另一个是对象存活时间长。</p>\n</li>\n<li><p>V8 中会把堆分为新生代和老生代两个区域，</p>\n<p>新生代中存放的是生存时间短的对象，</p>\n<p>老生代中存放的生存时间久的对象。</p>\n<p>垃圾回收重要术语：</p>\n<p>代际假说<br>大部分对象在内存中存在的时间很短<br>不死的对象，会活得更久<br>分代收集<br>副垃圾回收器：</p>\n<p>主要负责新生代的垃圾回收。</p>\n<p>这个区域不大，但是垃圾回收比较频繁。</p>\n<p>新生代的垃圾回收算法是 Scavenge 算法。</p>\n<p>主要把新生代空间对半划分为两个区域：对象区域，空闲区域。</p>\n<p>当对象区域快被写满时，则会进行一次垃圾清理。</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WebSocket 使用了自定义的二进制分帧格式，把每个应用消息切分成一或多个帧，发送到目的地之后再组装起来，等到接收到完整的消息后再通知接收端。基本的成帧协议定义了帧类型有操作码、有效载荷的长度，指定位置的Extension data和Application data，统称为Payload data，保留了一些特殊位和操作码供后期扩展。在打开握手完成后，终端发送一个关闭帧之前的任何时间里，数据帧可能由客户端或服务器的任何一方发送。</span><br><span class=\"line\"></span><br><span class=\"line\">• 帧：最小的通信单位，包含可变长度的帧首部和净荷部分，净荷可能包含完整或部分应用消息。</span><br><span class=\"line\">• 消息：一系列帧，与应用消息对等。</span><br></pre></td></tr></table></figure>\n<ol>\n<li>jwt 签名算法<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HS256 使用密钥生成固定的签名，RS256 使用成非对称进行签名。简单地说，HS256 必须与任何想要验证 JWT的 客户端或 API 共享秘密。</span><br><span class=\"line\">RS256 生成非对称签名，这意味着必须使用私钥来签签名 JWT，并且必须使用对应的公钥来验证签名。与对称算法不同，使用 RS256 可以保证服务端是 JWT 的签名者，因为服务端是唯一拥有私钥的一方。这样做将不再需要在许多应用程序之间共享私钥</span><br><span class=\"line\"></span><br><span class=\"line\">这种方法可以让我们分离开签发与验证，签发时需要用一个密钥，验证时使用公钥，也就是有公钥的地方只能做验证，但不能签发 JWT。</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"egg\"><a href=\"#egg\" class=\"headerlink\" title=\"egg\"></a>egg</h3><ol>\n<li>启动顺序<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Master 启动后先 fork Agent 进程</span><br><span class=\"line\">Agent 初始化成功后，通过 IPC 通道通知 Master</span><br><span class=\"line\">Master 再 fork 多个 App Worker</span><br><span class=\"line\">App Worker 初始化成功，通知 Master</span><br><span class=\"line\">所有的进程初始化成功后，Master 通知 Agent 和 Worker 应用启动成功</span><br></pre></td></tr></table></figure></li>\n</ol>\n"},{"title":"overview","date":"2021-12-13T09:38:48.000Z","_content":"1. watchEffect 不能检测深层的变化，因此reactive 中变化无效，如果需要则 toRefs 转换\n1. V2 $attrs   1. custom events go into a @listerner bucket  2.不能绑定class \n1. Npm ls 查看依赖\n1. 可以看到结果reactive是递归会将每一层包装成Proxy对象的，深度监听每一层的property\n1. effectScope有一个可选参数为boolean，当传入true时表示阻断与父级的联系，阻断后这个scope对象将不会与父级关联，成为独立的scope。父级的stop也不会影响到它。 \n1. Last-Modified,Etag,Expires 三个同时使用时。先判断 Expire ，然后发送 Http 请求，服务器先判断 last-modified ，再判断 Etag ，必须都没有过期，才能返回 304 响应\n1. klona  fast utility to \"deep clone\" Objects, Arrays, Dates, RegExps, and more!\n1. Grep string starting with (e.g. 'S’)    grep -o 'S.*’\n1. ~: 如果写入的是 〜0.13.0，则当运行 npm update 时，会更新到补丁版本：即 0.13.1 可以，但 0.14.0 不可以。\n1. >: 接受高于指定版本的任何版本。\n1. ^: 只会执行不更改最左边非零数字的更新。 如果写入的是 ^0.13.0，则当运行 npm update 时，可以更新到 0.13.1、0.13.2 等，但不能更新到 0.14.0 或更高版本。 如果写入的是 ^1.13.0，则当运行 npm update 时，可以更新到 1.13.1、1.14.0 等，但不能更新到 2.0.0 或更高版本。\n2. firefox 子元素不缩小需要设置  You need to add min‑width:0\n3. flex 布局中子级超过了父级的宽度，需要设置 width:0 ,完全由flex 分配宽度。\n4. POSIX stands for Portable Operating System Interface.\n5.  @supports CSS at-rule 相当于功能选择器\n   ```\n   @supports (display: flex) {\n  body {\n    display: flex;\n    min-height: 100vh;\n  }\n}\n   ```\n2. https://github.com/cuixiaorui/mini-vue  vue3 source code \n3. react 被 startTransition 回调包裹的 setState 触发的渲染 被标记为不紧急渲染，这些渲染可能被其他紧急渲染所抢占。\n4. https://hyper.is/ electron console\n5. https://cmder.net/ windows 端的console 模拟器\n6. Access-Control-Request-Private-Network: true 在所有私有网络预检请求上设置\n   Access-Control-Allow-Private-Network: true 必须在所有私有网络预检响应上设置\n7. 使用 Fragments，我们不需要在DOM中添加额外的节点。我们只需要用 React.Fragment 或才简写 <> 来包裹内容就行了\n8. vite 虚拟模块  虚拟模块是一种很实用的模式，使你可以对使用 ESM 语法的源文件传入一些编译时信息。\n9.  glob Match files using the patterns the shell uses, like stars and stuff.\n10. click.self \n我们知道在自定义组件上，只能监听自定义事件，一些原生事件（比如click）是没有办法直接触发的，但是使用.native修饰符可以帮我们办到这点\n1. offset-path  定义动画运行路径\n1. Tauri 是一个为所有主流桌面平台构建小型、快速二进制文件的框架。开发人员可以集成任何编译成 HTML、 JS 和 CSS 的前端框架来构建他们的用户界面。应用程序的后端是一个 Rust 二进制文件，具有前端可以与之交互的 API。\n1.  gitsecreat 使用： https://www.mikesay.com/2020/12/16/git-encrypt-file-in-repository/#git-secret%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8\n1. svg2pdf.js 图片转pdf\n1. stream 的另外一个模式: objectMode。它是一种对象模式，我们把一件事情、或一个文件、或一个操作，抽象成一个对象。\n   ```\n   const Readable = require('stream').Readable\n\n   const readable = Readable({ objectMode: true })\n\n    readable.push('a')\n    readable.push('b')\n    readable.push({})\n    readable.push(null)\n\n    readable.on('data', data => console.log(data))\n\n   ```\n2. git config --global push.followTags true\n3. Markraw 标记不会被reactive\n4. watcheffect onInvalidate 在重新运行或者停止的时候执行\n5. composedPath() 是 Event 接口的一个方法，当对象数组调用该侦听器时返回事件路径。\n6. customref  track and trigger  \n7. vueuse useMemoize 对结果加cache\n8. elementFromPoint 根据point 获取element\n9.  Change-case Transform a string between camelCase, PascalCase, Capital Case, snake_case, param-case, CONSTANT_CASE and others.\n10. p-retry It does exponential backoff and supports custom retry strategies for failed operations.\n11. MutationObserver 观察dom 变化\n12. requestFullscreen\n13. passive: Boolean，设置为true时，表示 listener 永远不会调用 preventDefault()。如果 listener 仍然调用了这个函数，客户端将会忽略它并抛出一个控制台警告\n14. shallowReacive  shallowRef  shallowRef生成非递归响应数据，只监听第一层数据的变化\n15. 推荐在大部分时候用 watch 显式的指定依赖以避免不必要的重复触发，也避免在后续代码修改或重构时不小心引入新的依赖。watchEffect 适用于一些逻辑相对简单，依赖源和逻辑强相关的场景（或者懒惰的场景 ）。\n16. Object.fromEntries\n17. URL.revokeObjectURL() 静态方法用来释放一个之前已经存在的、通过调用 URL.createObjectURL() 创建的 URL 对象。\n18. querySelector  返回第一个匹配元素\n19. Array.prototype.at()接收一个正整数或者负整数作为参数，表示获取指定位置的成员\n20. IFC全称：Inline Formatting Context，名为行级格式化上下文。    触发：块级元素中仅包含内联级别元素\n21. The Notification interface of the Notifications API is used to configure and display desktop notifications to the user.\n22. TinyMCE 富文本编辑器\n23. Window.innerHeight  浏览器窗口的视口（viewport）高度（以像素为单位）；如果有水平滚动条，也包括滚动条高度。\n24. vuedraggable 处理拖动数据\n25. path-to-regexp   Turn a path string such as /user/:name into a regular expression. The compile function will return a function for transforming parameters into a valid path:\n26. vue router 重新render,redirect+fullpath.通过添加一个中转页实现。\n27. import { storeToRefs } from \"pinia”;\n28. html5 input number\n ```\n.no-arrow::-webkit-outer-spin-button,\n.no-arrow::-webkit-inner-spin-button {\n  -webkit-appearance: none;\n}\n ``` \n2. vue3 类型 MayBeRef\n3. 暂停watch后更新，\n```\nignoreUpdates(() => {\n  source.value = 'ignored'\n})\n```\n\n1. dsp 读取json,csv,xlxs 数据\n1. limu 创建imutable 对象\n2. controlledRef set peek,控制数据的更新\n ```\n const num = controlledRef(0, {\n  onBeforeChange(value, oldValue) {\n    // disallow changes larger then ±5 in one operation\n    if (Math.abs(value - oldValue) > 5)\n      return false // returning `false` to dismiss the change\n  },\n})\n ```\n\n1. flush: post 推迟副作用的初始运行，直到组件的首次渲染完成。\n   watch 通过更改设置 flush: 'sync'，我们可以为每个更改都强制触发侦听器，尽管这通常是不推荐的\n   ```\n\n- `'pre'`: buffers invalidated effects in the same 'tick' and flushes them before rendering\n- `'post'`: async like 'pre' but fires after component updates so you can access the updated DOM\n- `'sync'`: forces the effect to always trigger synchronously\n\n { flush: 'post' }\n)\n\n   ```\n1. transx vue 动画组件   一个小巧玲珑的 vue 组件切换动画库\n2. ts-morph 修改ts 代码，封装后的ts compiler api\n3. esno 执行ts\n4. https://mermaid-js.github.io/mermaid/#/     mermaid 及其方便的画图工具\n5. vue-parallaxy Is a compontent for fast 60fps parallax scroll effects in vue 2. 实现滚动的视差效果。\n6. useWatermark,Layzcontainer. context menu  vue-vben-admin 中\n7. localForage is a fast and simple storage library for JavaScript。Wraps IndexedDB, WebSQL, or localStorage using a simple but powerful API.\n8.  markRaw 标记对下不会被reactive\n9.  indexeddb-fs is a module that allows you to store data in the browser using an API similar to that of Node's fs module.\n10. 临时安全令牌（Security Token Service，STS）\n11. *** 获取文本px宽度* @param font{String}: 字体样式**\n\n```\nString.prototype.pxWidth = function(font) {\n  // re-use canvas object for better performance\n  var canvas = String.prototype.pxWidth.canvas || (String.prototype.pxWidth.canvas = document.createElement(\"canvas\")),\n      context = canvas.getContext(\"2d\"); 3\n\n  font && (context.font = font);\n  var metrics = context.measureText(this);\n\n  return metrics.width;\n}\n```\n\n1. 先保存各个实例的values信息， helm get values [release] > xxx.yaml\n\n\n1. \nHTTP协议中用头部字段Accept-Encoding 和 Content-Encoding对「采用何种编码格式传输正文」进行了协定，请求头的Accept-Encoding会列出客户端支持的编码格式。当响应头的 Content-Encoding指定了gzip时，浏览器则会进行对应解压\n\n1. Transfer-Encoding，是一个 HTTP 头部字段，字面意思是「传输编码」。实际上，HTTP 协议中还有另外一个头部与编码有关：Content-Encoding（内容编码）。Content-Encoding 通常用于对实体内容进行压缩编码，目的是优化传输，\n```\nTransfer-Encoding: chunked\nTransfer-Encoding: compress\nTransfer-Encoding: deflate\nTransfer-Encoding: gzip\nTransfer-Encoding: identity\n```\n\n\n2. 逐跳消息头  这类消息头仅对单次传输连接有意义，不能通过代理或缓存进行重新转发\n\n1. git merge --squash develop\n2. mime  https://github.com/sindresorhus/file-type  根据文件内容判断类型\n\n1. 语义化版本控制(SemVer)\n   先简单了解下什么是语义化的版本控制，其是由GitHub发起的一份用于规范版本号递增的规则，\n\n1.  deeplinks.js allows people to easily link directly to any text selection on your website.\n2.  Vue DevUI 开源的UI\n3. standard-version\nstandard-version 会根据提交的信息类型来自动更改对应的版本号,如下:\n```\nfeat: 次版本(minor)+1\nfix: 修订号(patch) +1\nBREAK CHANGE: 主板号(marjor) +1\n```\n1. outline 能告诉用户那一个可以激发事件的html元素获取了焦点，对钟爱键盘操作的用户尤其有意义。一个清晰悦目的outline设计能提高使用表单的用户体验。\n2. CSS属性 columns 用来设置元素的列宽和列数。\n重点，设置了display: contents的元素本身不会被渲染，但是其子元素能够正常被渲染。\n3. 为了使我们的盒子居中，通过align-items属性，可以将交叉轴上的item对齐，此时使用的是垂直方向的块轴。而使用justify-content则可以对齐主轴上的项目，主轴是水平方向的。\nalign conent  用来控制多行布局   控制“多条主轴”的 flex 项目在交叉轴的对齐。\n\n1. CSS 中的 place-items 是一个简写属性 ，它允许你在相关的布局（如 Grid 或 Flexbox）中可以同时沿着块级和内联方向对齐元素 (例如：align-items 和 justify-items 属性) 。如果未提供第二个值，则第一个值作为第二个值的默认值\n\n1. filter CSS属性将模糊或颜色偏移等图形效果应用于元素。滤镜通常用于调整图像，背景和边框的渲染。\n\n1. monaco 自定义language\n```\nregister monaco.languages.register({ id: 'mySpecialLanguage' });\nsetMonarchTokensProvider base language 里面有3 \ndefineTheme  设置样式\nmonaco.editor.defineTheme('myCoolTheme', {\n                    colors: {},\n                    base: 'vs',\n                    inherit: false,\n                    rules: [\n                        { token: 'custom-info', foreground: '808080' },\n                        { token: 'custom-error', foreground: 'ff0000', fontStyle: 'bold' },\n                        { token: 'custom-notice', foreground: 'FFA500' },\n                        { token: 'custom-date', foreground: '008800' }\n                    ]\n                });\nregisterCompletionItemProvider  智能提示，遇到对应的关键词\n```\n\n1. Monarch  用来实现代码高亮   https://juejin.cn/post/6844903736867831822\n\nhttps://microsoft.github.io/monaco-editor/monarch.html\n\n1. xe-utils 提供工具类\n1. Mitt  Tiny (~200b) functional event emitter / pubsub.\n1. element-resize-detector  \n1. memoize-one 记录最近的返回结果 \n1. 钱其实是“保健因子”，而不是“激励因子”，是多了没用、少了不行的东西\n2. 可以看到整个医改的核心就是放供给、促竞争和扶创新的过程\n3. 破船能过河\n4. Comlink Comlink makes WebWorkers enjoyable. 多线程\n5.  \n`Rails-style`: 按照文件的类型划分为不同的目录\n\n`Domain-style`: 按照一个功能特性或业务创建单独的目录\n\n`Ducks-style`: 优点类似于Domain-style，不过更彻底, 它通常将相关联的元素定义在一个文件下\n\n1. \n    强约定，体现团队的规范。首先它应该避免团队成员去关心或更改构建的配置细节，暴露最小化的配置接口。 另外构建工具不仅仅是构建，通常它还会集成代码检查、测试等功能。\n\n    方便升级。尤其是团队需要维护多个项目场景, 这一点很有意义\n\n2. BEM\n```\n元素（Element），即 price 、text ，代表从属于某个块，是这个块的子元素，跟在块后面，以双下划线为间隔，使用 .btn__price 、.btn__text 表示\n\n修饰符（Modifier），即 orange 、big ，用于修改块的状态，为块添加特定的主题或样式，跟在块后面，以双连字符为间隔，使用 .btn--orange 、.btn--big 表示\n\n```   \n1.  npm-run-all\n```\nBefore: npm run clean && npm run build:css && npm run build:js && npm run build:html\nAfter: npm-run-all clean build:*\n```\n\n1. display:flow-root可以让元素块状化，同时包含格式化上下文BFC，可以用来清除浮动，去除margin合并，实现两栏自适应布局等。\n\n1. stroke-dash 是一个定义虚线和间距图形的图像工具类, 被用于轮廓描边;\n\n1. npx degit\n   \n1.  有一些环境变量，比如HOME、PATH、SHELL、UID、USER等，在用户登录之前就已经被/bin/login程序设置好了。通常环境变量被定义并保存在用户家目录下的．bash_profile文件或全局的配置文件/etc/profile中\n\n1. env命令只显示全局变量；declare命令输出所有的变量、函数、整数和已经导出的变量\n\n1. http upgrade 通常来说这一机制总是由客户端发起的 （不过也有例外，比如说可以由服务端发起升级到传输层安全协议（TLS））， 服务端可以选择是否要升级到新协议。借助这一技术，连接可以以常用的协议启动（如HTTP/1.1），随后再升级到HTTP2甚至是WebSockets.\n\n1. 因为 CommonJS 在运行时进行加载方式的动态解析，在运行时阶段才能确定的导入导出关系，因此无法进行静态编译优化和类型检查。​\n\n1. JSZip  JSZip is a javascript library for creating, reading and editing .zip files, with a lovely and simple AP\n   \n2. spy-debugger  一站式页面调试、抓包工具。远程调试任何手机浏览器页面，任何手机移动端webview（如：微信，HybridApp等）。支持HTTP/HTTPS，无需USB连接设备\n   \n3. viteshot 基于vite 的快照\n\n4. useScrollLock","source":"_posts/overview.md","raw":"---\ntitle: overview\ndate: 2021-12-13 17:38:48\ntags: overview\n---\n1. watchEffect 不能检测深层的变化，因此reactive 中变化无效，如果需要则 toRefs 转换\n1. V2 $attrs   1. custom events go into a @listerner bucket  2.不能绑定class \n1. Npm ls 查看依赖\n1. 可以看到结果reactive是递归会将每一层包装成Proxy对象的，深度监听每一层的property\n1. effectScope有一个可选参数为boolean，当传入true时表示阻断与父级的联系，阻断后这个scope对象将不会与父级关联，成为独立的scope。父级的stop也不会影响到它。 \n1. Last-Modified,Etag,Expires 三个同时使用时。先判断 Expire ，然后发送 Http 请求，服务器先判断 last-modified ，再判断 Etag ，必须都没有过期，才能返回 304 响应\n1. klona  fast utility to \"deep clone\" Objects, Arrays, Dates, RegExps, and more!\n1. Grep string starting with (e.g. 'S’)    grep -o 'S.*’\n1. ~: 如果写入的是 〜0.13.0，则当运行 npm update 时，会更新到补丁版本：即 0.13.1 可以，但 0.14.0 不可以。\n1. >: 接受高于指定版本的任何版本。\n1. ^: 只会执行不更改最左边非零数字的更新。 如果写入的是 ^0.13.0，则当运行 npm update 时，可以更新到 0.13.1、0.13.2 等，但不能更新到 0.14.0 或更高版本。 如果写入的是 ^1.13.0，则当运行 npm update 时，可以更新到 1.13.1、1.14.0 等，但不能更新到 2.0.0 或更高版本。\n2. firefox 子元素不缩小需要设置  You need to add min‑width:0\n3. flex 布局中子级超过了父级的宽度，需要设置 width:0 ,完全由flex 分配宽度。\n4. POSIX stands for Portable Operating System Interface.\n5.  @supports CSS at-rule 相当于功能选择器\n   ```\n   @supports (display: flex) {\n  body {\n    display: flex;\n    min-height: 100vh;\n  }\n}\n   ```\n2. https://github.com/cuixiaorui/mini-vue  vue3 source code \n3. react 被 startTransition 回调包裹的 setState 触发的渲染 被标记为不紧急渲染，这些渲染可能被其他紧急渲染所抢占。\n4. https://hyper.is/ electron console\n5. https://cmder.net/ windows 端的console 模拟器\n6. Access-Control-Request-Private-Network: true 在所有私有网络预检请求上设置\n   Access-Control-Allow-Private-Network: true 必须在所有私有网络预检响应上设置\n7. 使用 Fragments，我们不需要在DOM中添加额外的节点。我们只需要用 React.Fragment 或才简写 <> 来包裹内容就行了\n8. vite 虚拟模块  虚拟模块是一种很实用的模式，使你可以对使用 ESM 语法的源文件传入一些编译时信息。\n9.  glob Match files using the patterns the shell uses, like stars and stuff.\n10. click.self \n我们知道在自定义组件上，只能监听自定义事件，一些原生事件（比如click）是没有办法直接触发的，但是使用.native修饰符可以帮我们办到这点\n1. offset-path  定义动画运行路径\n1. Tauri 是一个为所有主流桌面平台构建小型、快速二进制文件的框架。开发人员可以集成任何编译成 HTML、 JS 和 CSS 的前端框架来构建他们的用户界面。应用程序的后端是一个 Rust 二进制文件，具有前端可以与之交互的 API。\n1.  gitsecreat 使用： https://www.mikesay.com/2020/12/16/git-encrypt-file-in-repository/#git-secret%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8\n1. svg2pdf.js 图片转pdf\n1. stream 的另外一个模式: objectMode。它是一种对象模式，我们把一件事情、或一个文件、或一个操作，抽象成一个对象。\n   ```\n   const Readable = require('stream').Readable\n\n   const readable = Readable({ objectMode: true })\n\n    readable.push('a')\n    readable.push('b')\n    readable.push({})\n    readable.push(null)\n\n    readable.on('data', data => console.log(data))\n\n   ```\n2. git config --global push.followTags true\n3. Markraw 标记不会被reactive\n4. watcheffect onInvalidate 在重新运行或者停止的时候执行\n5. composedPath() 是 Event 接口的一个方法，当对象数组调用该侦听器时返回事件路径。\n6. customref  track and trigger  \n7. vueuse useMemoize 对结果加cache\n8. elementFromPoint 根据point 获取element\n9.  Change-case Transform a string between camelCase, PascalCase, Capital Case, snake_case, param-case, CONSTANT_CASE and others.\n10. p-retry It does exponential backoff and supports custom retry strategies for failed operations.\n11. MutationObserver 观察dom 变化\n12. requestFullscreen\n13. passive: Boolean，设置为true时，表示 listener 永远不会调用 preventDefault()。如果 listener 仍然调用了这个函数，客户端将会忽略它并抛出一个控制台警告\n14. shallowReacive  shallowRef  shallowRef生成非递归响应数据，只监听第一层数据的变化\n15. 推荐在大部分时候用 watch 显式的指定依赖以避免不必要的重复触发，也避免在后续代码修改或重构时不小心引入新的依赖。watchEffect 适用于一些逻辑相对简单，依赖源和逻辑强相关的场景（或者懒惰的场景 ）。\n16. Object.fromEntries\n17. URL.revokeObjectURL() 静态方法用来释放一个之前已经存在的、通过调用 URL.createObjectURL() 创建的 URL 对象。\n18. querySelector  返回第一个匹配元素\n19. Array.prototype.at()接收一个正整数或者负整数作为参数，表示获取指定位置的成员\n20. IFC全称：Inline Formatting Context，名为行级格式化上下文。    触发：块级元素中仅包含内联级别元素\n21. The Notification interface of the Notifications API is used to configure and display desktop notifications to the user.\n22. TinyMCE 富文本编辑器\n23. Window.innerHeight  浏览器窗口的视口（viewport）高度（以像素为单位）；如果有水平滚动条，也包括滚动条高度。\n24. vuedraggable 处理拖动数据\n25. path-to-regexp   Turn a path string such as /user/:name into a regular expression. The compile function will return a function for transforming parameters into a valid path:\n26. vue router 重新render,redirect+fullpath.通过添加一个中转页实现。\n27. import { storeToRefs } from \"pinia”;\n28. html5 input number\n ```\n.no-arrow::-webkit-outer-spin-button,\n.no-arrow::-webkit-inner-spin-button {\n  -webkit-appearance: none;\n}\n ``` \n2. vue3 类型 MayBeRef\n3. 暂停watch后更新，\n```\nignoreUpdates(() => {\n  source.value = 'ignored'\n})\n```\n\n1. dsp 读取json,csv,xlxs 数据\n1. limu 创建imutable 对象\n2. controlledRef set peek,控制数据的更新\n ```\n const num = controlledRef(0, {\n  onBeforeChange(value, oldValue) {\n    // disallow changes larger then ±5 in one operation\n    if (Math.abs(value - oldValue) > 5)\n      return false // returning `false` to dismiss the change\n  },\n})\n ```\n\n1. flush: post 推迟副作用的初始运行，直到组件的首次渲染完成。\n   watch 通过更改设置 flush: 'sync'，我们可以为每个更改都强制触发侦听器，尽管这通常是不推荐的\n   ```\n\n- `'pre'`: buffers invalidated effects in the same 'tick' and flushes them before rendering\n- `'post'`: async like 'pre' but fires after component updates so you can access the updated DOM\n- `'sync'`: forces the effect to always trigger synchronously\n\n { flush: 'post' }\n)\n\n   ```\n1. transx vue 动画组件   一个小巧玲珑的 vue 组件切换动画库\n2. ts-morph 修改ts 代码，封装后的ts compiler api\n3. esno 执行ts\n4. https://mermaid-js.github.io/mermaid/#/     mermaid 及其方便的画图工具\n5. vue-parallaxy Is a compontent for fast 60fps parallax scroll effects in vue 2. 实现滚动的视差效果。\n6. useWatermark,Layzcontainer. context menu  vue-vben-admin 中\n7. localForage is a fast and simple storage library for JavaScript。Wraps IndexedDB, WebSQL, or localStorage using a simple but powerful API.\n8.  markRaw 标记对下不会被reactive\n9.  indexeddb-fs is a module that allows you to store data in the browser using an API similar to that of Node's fs module.\n10. 临时安全令牌（Security Token Service，STS）\n11. *** 获取文本px宽度* @param font{String}: 字体样式**\n\n```\nString.prototype.pxWidth = function(font) {\n  // re-use canvas object for better performance\n  var canvas = String.prototype.pxWidth.canvas || (String.prototype.pxWidth.canvas = document.createElement(\"canvas\")),\n      context = canvas.getContext(\"2d\"); 3\n\n  font && (context.font = font);\n  var metrics = context.measureText(this);\n\n  return metrics.width;\n}\n```\n\n1. 先保存各个实例的values信息， helm get values [release] > xxx.yaml\n\n\n1. \nHTTP协议中用头部字段Accept-Encoding 和 Content-Encoding对「采用何种编码格式传输正文」进行了协定，请求头的Accept-Encoding会列出客户端支持的编码格式。当响应头的 Content-Encoding指定了gzip时，浏览器则会进行对应解压\n\n1. Transfer-Encoding，是一个 HTTP 头部字段，字面意思是「传输编码」。实际上，HTTP 协议中还有另外一个头部与编码有关：Content-Encoding（内容编码）。Content-Encoding 通常用于对实体内容进行压缩编码，目的是优化传输，\n```\nTransfer-Encoding: chunked\nTransfer-Encoding: compress\nTransfer-Encoding: deflate\nTransfer-Encoding: gzip\nTransfer-Encoding: identity\n```\n\n\n2. 逐跳消息头  这类消息头仅对单次传输连接有意义，不能通过代理或缓存进行重新转发\n\n1. git merge --squash develop\n2. mime  https://github.com/sindresorhus/file-type  根据文件内容判断类型\n\n1. 语义化版本控制(SemVer)\n   先简单了解下什么是语义化的版本控制，其是由GitHub发起的一份用于规范版本号递增的规则，\n\n1.  deeplinks.js allows people to easily link directly to any text selection on your website.\n2.  Vue DevUI 开源的UI\n3. standard-version\nstandard-version 会根据提交的信息类型来自动更改对应的版本号,如下:\n```\nfeat: 次版本(minor)+1\nfix: 修订号(patch) +1\nBREAK CHANGE: 主板号(marjor) +1\n```\n1. outline 能告诉用户那一个可以激发事件的html元素获取了焦点，对钟爱键盘操作的用户尤其有意义。一个清晰悦目的outline设计能提高使用表单的用户体验。\n2. CSS属性 columns 用来设置元素的列宽和列数。\n重点，设置了display: contents的元素本身不会被渲染，但是其子元素能够正常被渲染。\n3. 为了使我们的盒子居中，通过align-items属性，可以将交叉轴上的item对齐，此时使用的是垂直方向的块轴。而使用justify-content则可以对齐主轴上的项目，主轴是水平方向的。\nalign conent  用来控制多行布局   控制“多条主轴”的 flex 项目在交叉轴的对齐。\n\n1. CSS 中的 place-items 是一个简写属性 ，它允许你在相关的布局（如 Grid 或 Flexbox）中可以同时沿着块级和内联方向对齐元素 (例如：align-items 和 justify-items 属性) 。如果未提供第二个值，则第一个值作为第二个值的默认值\n\n1. filter CSS属性将模糊或颜色偏移等图形效果应用于元素。滤镜通常用于调整图像，背景和边框的渲染。\n\n1. monaco 自定义language\n```\nregister monaco.languages.register({ id: 'mySpecialLanguage' });\nsetMonarchTokensProvider base language 里面有3 \ndefineTheme  设置样式\nmonaco.editor.defineTheme('myCoolTheme', {\n                    colors: {},\n                    base: 'vs',\n                    inherit: false,\n                    rules: [\n                        { token: 'custom-info', foreground: '808080' },\n                        { token: 'custom-error', foreground: 'ff0000', fontStyle: 'bold' },\n                        { token: 'custom-notice', foreground: 'FFA500' },\n                        { token: 'custom-date', foreground: '008800' }\n                    ]\n                });\nregisterCompletionItemProvider  智能提示，遇到对应的关键词\n```\n\n1. Monarch  用来实现代码高亮   https://juejin.cn/post/6844903736867831822\n\nhttps://microsoft.github.io/monaco-editor/monarch.html\n\n1. xe-utils 提供工具类\n1. Mitt  Tiny (~200b) functional event emitter / pubsub.\n1. element-resize-detector  \n1. memoize-one 记录最近的返回结果 \n1. 钱其实是“保健因子”，而不是“激励因子”，是多了没用、少了不行的东西\n2. 可以看到整个医改的核心就是放供给、促竞争和扶创新的过程\n3. 破船能过河\n4. Comlink Comlink makes WebWorkers enjoyable. 多线程\n5.  \n`Rails-style`: 按照文件的类型划分为不同的目录\n\n`Domain-style`: 按照一个功能特性或业务创建单独的目录\n\n`Ducks-style`: 优点类似于Domain-style，不过更彻底, 它通常将相关联的元素定义在一个文件下\n\n1. \n    强约定，体现团队的规范。首先它应该避免团队成员去关心或更改构建的配置细节，暴露最小化的配置接口。 另外构建工具不仅仅是构建，通常它还会集成代码检查、测试等功能。\n\n    方便升级。尤其是团队需要维护多个项目场景, 这一点很有意义\n\n2. BEM\n```\n元素（Element），即 price 、text ，代表从属于某个块，是这个块的子元素，跟在块后面，以双下划线为间隔，使用 .btn__price 、.btn__text 表示\n\n修饰符（Modifier），即 orange 、big ，用于修改块的状态，为块添加特定的主题或样式，跟在块后面，以双连字符为间隔，使用 .btn--orange 、.btn--big 表示\n\n```   \n1.  npm-run-all\n```\nBefore: npm run clean && npm run build:css && npm run build:js && npm run build:html\nAfter: npm-run-all clean build:*\n```\n\n1. display:flow-root可以让元素块状化，同时包含格式化上下文BFC，可以用来清除浮动，去除margin合并，实现两栏自适应布局等。\n\n1. stroke-dash 是一个定义虚线和间距图形的图像工具类, 被用于轮廓描边;\n\n1. npx degit\n   \n1.  有一些环境变量，比如HOME、PATH、SHELL、UID、USER等，在用户登录之前就已经被/bin/login程序设置好了。通常环境变量被定义并保存在用户家目录下的．bash_profile文件或全局的配置文件/etc/profile中\n\n1. env命令只显示全局变量；declare命令输出所有的变量、函数、整数和已经导出的变量\n\n1. http upgrade 通常来说这一机制总是由客户端发起的 （不过也有例外，比如说可以由服务端发起升级到传输层安全协议（TLS））， 服务端可以选择是否要升级到新协议。借助这一技术，连接可以以常用的协议启动（如HTTP/1.1），随后再升级到HTTP2甚至是WebSockets.\n\n1. 因为 CommonJS 在运行时进行加载方式的动态解析，在运行时阶段才能确定的导入导出关系，因此无法进行静态编译优化和类型检查。​\n\n1. JSZip  JSZip is a javascript library for creating, reading and editing .zip files, with a lovely and simple AP\n   \n2. spy-debugger  一站式页面调试、抓包工具。远程调试任何手机浏览器页面，任何手机移动端webview（如：微信，HybridApp等）。支持HTTP/HTTPS，无需USB连接设备\n   \n3. viteshot 基于vite 的快照\n\n4. useScrollLock","slug":"overview","published":1,"updated":"2022-09-13T02:38:30.312Z","_id":"ckzf5se02001fyy8kjwqmoexv","comments":1,"layout":"post","photos":[],"link":"","content":"<ol>\n<li><p>watchEffect 不能检测深层的变化，因此reactive 中变化无效，如果需要则 toRefs 转换</p>\n</li>\n<li><p>V2 $attrs   1. custom events go into a @listerner bucket  2.不能绑定class </p>\n</li>\n<li><p>Npm ls 查看依赖</p>\n</li>\n<li><p>可以看到结果reactive是递归会将每一层包装成Proxy对象的，深度监听每一层的property</p>\n</li>\n<li><p>effectScope有一个可选参数为boolean，当传入true时表示阻断与父级的联系，阻断后这个scope对象将不会与父级关联，成为独立的scope。父级的stop也不会影响到它。 </p>\n</li>\n<li><p>Last-Modified,Etag,Expires 三个同时使用时。先判断 Expire ，然后发送 Http 请求，服务器先判断 last-modified ，再判断 Etag ，必须都没有过期，才能返回 304 响应</p>\n</li>\n<li><p>klona  fast utility to “deep clone” Objects, Arrays, Dates, RegExps, and more!</p>\n</li>\n<li><p>Grep string starting with (e.g. ‘S’)    grep -o ‘S.*’</p>\n</li>\n<li><p>~: 如果写入的是 〜0.13.0，则当运行 npm update 时，会更新到补丁版本：即 0.13.1 可以，但 0.14.0 不可以。</p>\n</li>\n<li><blockquote>\n<p>: 接受高于指定版本的任何版本。</p>\n</blockquote>\n</li>\n<li><p>^: 只会执行不更改最左边非零数字的更新。 如果写入的是 ^0.13.0，则当运行 npm update 时，可以更新到 0.13.1、0.13.2 等，但不能更新到 0.14.0 或更高版本。 如果写入的是 ^1.13.0，则当运行 npm update 时，可以更新到 1.13.1、1.14.0 等，但不能更新到 2.0.0 或更高版本。</p>\n</li>\n<li><p>firefox 子元素不缩小需要设置  You need to add min‑width:0</p>\n</li>\n<li><p>flex 布局中子级超过了父级的宽度，需要设置 width:0 ,完全由flex 分配宽度。</p>\n</li>\n<li><p>POSIX stands for Portable Operating System Interface.</p>\n</li>\n<li><p>@supports CSS at-rule 相当于功能选择器</p>\n   <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   @supports (display: flex) &#123;</span><br><span class=\"line\">  body &#123;</span><br><span class=\"line\">    display: flex;</span><br><span class=\"line\">    min-height: 100vh;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p><a href=\"https://github.com/cuixiaorui/mini-vue\">https://github.com/cuixiaorui/mini-vue</a>  vue3 source code </p>\n</li>\n<li><p>react 被 startTransition 回调包裹的 setState 触发的渲染 被标记为不紧急渲染，这些渲染可能被其他紧急渲染所抢占。</p>\n</li>\n<li><p><a href=\"https://hyper.is/\">https://hyper.is/</a> electron console</p>\n</li>\n<li><p><a href=\"https://cmder.net/\">https://cmder.net/</a> windows 端的console 模拟器</p>\n</li>\n<li><p>Access-Control-Request-Private-Network: true 在所有私有网络预检请求上设置<br>Access-Control-Allow-Private-Network: true 必须在所有私有网络预检响应上设置</p>\n</li>\n<li><p>使用 Fragments，我们不需要在DOM中添加额外的节点。我们只需要用 React.Fragment 或才简写 &lt;&gt; 来包裹内容就行了</p>\n</li>\n<li><p>vite 虚拟模块  虚拟模块是一种很实用的模式，使你可以对使用 ESM 语法的源文件传入一些编译时信息。</p>\n</li>\n<li><p>glob Match files using the patterns the shell uses, like stars and stuff.</p>\n</li>\n<li><p>click.self<br>我们知道在自定义组件上，只能监听自定义事件，一些原生事件（比如click）是没有办法直接触发的，但是使用.native修饰符可以帮我们办到这点</p>\n</li>\n<li><p>offset-path  定义动画运行路径</p>\n</li>\n<li><p>Tauri 是一个为所有主流桌面平台构建小型、快速二进制文件的框架。开发人员可以集成任何编译成 HTML、 JS 和 CSS 的前端框架来构建他们的用户界面。应用程序的后端是一个 Rust 二进制文件，具有前端可以与之交互的 API。</p>\n</li>\n<li><p>gitsecreat 使用： <a href=\"https://www.mikesay.com/2020/12/16/git-encrypt-file-in-repository/#git-secret%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8\">https://www.mikesay.com/2020/12/16/git-encrypt-file-in-repository/#git-secret%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8</a></p>\n</li>\n<li><p>svg2pdf.js 图片转pdf</p>\n</li>\n<li><p>stream 的另外一个模式: objectMode。它是一种对象模式，我们把一件事情、或一个文件、或一个操作，抽象成一个对象。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const Readable = require(&#x27;stream&#x27;).Readable</span><br><span class=\"line\"></span><br><span class=\"line\">const readable = Readable(&#123; objectMode: true &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"> readable.push(&#x27;a&#x27;)</span><br><span class=\"line\"> readable.push(&#x27;b&#x27;)</span><br><span class=\"line\"> readable.push(&#123;&#125;)</span><br><span class=\"line\"> readable.push(null)</span><br><span class=\"line\"></span><br><span class=\"line\"> readable.on(&#x27;data&#x27;, data =&gt; console.log(data))</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n<li><p>git config –global push.followTags true</p>\n</li>\n<li><p>Markraw 标记不会被reactive</p>\n</li>\n<li><p>watcheffect onInvalidate 在重新运行或者停止的时候执行</p>\n</li>\n<li><p>composedPath() 是 Event 接口的一个方法，当对象数组调用该侦听器时返回事件路径。</p>\n</li>\n<li><p>customref  track and trigger  </p>\n</li>\n<li><p>vueuse useMemoize 对结果加cache</p>\n</li>\n<li><p>elementFromPoint 根据point 获取element</p>\n</li>\n<li><p>Change-case Transform a string between camelCase, PascalCase, Capital Case, snake_case, param-case, CONSTANT_CASE and others.</p>\n</li>\n<li><p>p-retry It does exponential backoff and supports custom retry strategies for failed operations.</p>\n</li>\n<li><p>MutationObserver 观察dom 变化</p>\n</li>\n<li><p>requestFullscreen</p>\n</li>\n<li><p>passive: Boolean，设置为true时，表示 listener 永远不会调用 preventDefault()。如果 listener 仍然调用了这个函数，客户端将会忽略它并抛出一个控制台警告</p>\n</li>\n<li><p>shallowReacive  shallowRef  shallowRef生成非递归响应数据，只监听第一层数据的变化</p>\n</li>\n<li><p>推荐在大部分时候用 watch 显式的指定依赖以避免不必要的重复触发，也避免在后续代码修改或重构时不小心引入新的依赖。watchEffect 适用于一些逻辑相对简单，依赖源和逻辑强相关的场景（或者懒惰的场景 ）。</p>\n</li>\n<li><p>Object.fromEntries</p>\n</li>\n<li><p>URL.revokeObjectURL() 静态方法用来释放一个之前已经存在的、通过调用 URL.createObjectURL() 创建的 URL 对象。</p>\n</li>\n<li><p>querySelector  返回第一个匹配元素</p>\n</li>\n<li><p>Array.prototype.at()接收一个正整数或者负整数作为参数，表示获取指定位置的成员</p>\n</li>\n<li><p>IFC全称：Inline Formatting Context，名为行级格式化上下文。    触发：块级元素中仅包含内联级别元素</p>\n</li>\n<li><p>The Notification interface of the Notifications API is used to configure and display desktop notifications to the user.</p>\n</li>\n<li><p>TinyMCE 富文本编辑器</p>\n</li>\n<li><p>Window.innerHeight  浏览器窗口的视口（viewport）高度（以像素为单位）；如果有水平滚动条，也包括滚动条高度。</p>\n</li>\n<li><p>vuedraggable 处理拖动数据</p>\n</li>\n<li><p>path-to-regexp   Turn a path string such as &#x2F;user&#x2F;:name into a regular expression. The compile function will return a function for transforming parameters into a valid path:</p>\n</li>\n<li><p>vue router 重新render,redirect+fullpath.通过添加一个中转页实现。</p>\n</li>\n<li><p>import { storeToRefs } from “pinia”;</p>\n</li>\n<li><p>html5 input number</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.no-arrow::-webkit-outer-spin-button,</span><br><span class=\"line\">.no-arrow::-webkit-inner-spin-button &#123;</span><br><span class=\"line\">  -webkit-appearance: none;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>vue3 类型 MayBeRef</p>\n</li>\n<li><p>暂停watch后更新，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ignoreUpdates(() =&gt; &#123;</span><br><span class=\"line\">  source.value = &#x27;ignored&#x27;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>dsp 读取json,csv,xlxs 数据</p>\n</li>\n<li><p>limu 创建imutable 对象</p>\n</li>\n<li><p>controlledRef set peek,控制数据的更新</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> const num = controlledRef(0, &#123;</span><br><span class=\"line\">  onBeforeChange(value, oldValue) &#123;</span><br><span class=\"line\">    // disallow changes larger then ±5 in one operation</span><br><span class=\"line\">    if (Math.abs(value - oldValue) &gt; 5)</span><br><span class=\"line\">      return false // returning `false` to dismiss the change</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>flush: post 推迟副作用的初始运行，直到组件的首次渲染完成。<br>watch 通过更改设置 flush: ‘sync’，我们可以为每个更改都强制触发侦听器，尽管这通常是不推荐的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">- `&#x27;pre&#x27;`: buffers invalidated effects in the same &#x27;tick&#x27; and flushes them before rendering</span><br><span class=\"line\">- `&#x27;post&#x27;`: async like &#x27;pre&#x27; but fires after component updates so you can access the updated DOM</span><br><span class=\"line\">- `&#x27;sync&#x27;`: forces the effect to always trigger synchronously</span><br><span class=\"line\"></span><br><span class=\"line\"> &#123; flush: &#x27;post&#x27; &#125;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n<li><p>transx vue 动画组件   一个小巧玲珑的 vue 组件切换动画库</p>\n</li>\n<li><p>ts-morph 修改ts 代码，封装后的ts compiler api</p>\n</li>\n<li><p>esno 执行ts</p>\n</li>\n<li><p><a href=\"https://mermaid-js.github.io/mermaid/#/\">https://mermaid-js.github.io/mermaid/#/</a>     mermaid 及其方便的画图工具</p>\n</li>\n<li><p>vue-parallaxy Is a compontent for fast 60fps parallax scroll effects in vue 2. 实现滚动的视差效果。</p>\n</li>\n<li><p>useWatermark,Layzcontainer. context menu  vue-vben-admin 中</p>\n</li>\n<li><p>localForage is a fast and simple storage library for JavaScript。Wraps IndexedDB, WebSQL, or localStorage using a simple but powerful API.</p>\n</li>\n<li><p>markRaw 标记对下不会被reactive</p>\n</li>\n<li><p>indexeddb-fs is a module that allows you to store data in the browser using an API similar to that of Node’s fs module.</p>\n</li>\n<li><p>临时安全令牌（Security Token Service，STS）</p>\n</li>\n<li><p>*** 获取文本px宽度* @param font{String}: 字体样式**</p>\n</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String.prototype.pxWidth = function(font) &#123;</span><br><span class=\"line\">  // re-use canvas object for better performance</span><br><span class=\"line\">  var canvas = String.prototype.pxWidth.canvas || (String.prototype.pxWidth.canvas = document.createElement(&quot;canvas&quot;)),</span><br><span class=\"line\">      context = canvas.getContext(&quot;2d&quot;); 3</span><br><span class=\"line\"></span><br><span class=\"line\">  font &amp;&amp; (context.font = font);</span><br><span class=\"line\">  var metrics = context.measureText(this);</span><br><span class=\"line\"></span><br><span class=\"line\">  return metrics.width;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>先保存各个实例的values信息， helm get values [release] &gt; xxx.yaml</p>\n</li>\n<li><p>HTTP协议中用头部字段Accept-Encoding 和 Content-Encoding对「采用何种编码格式传输正文」进行了协定，请求头的Accept-Encoding会列出客户端支持的编码格式。当响应头的 Content-Encoding指定了gzip时，浏览器则会进行对应解压</p>\n</li>\n<li><p>Transfer-Encoding，是一个 HTTP 头部字段，字面意思是「传输编码」。实际上，HTTP 协议中还有另外一个头部与编码有关：Content-Encoding（内容编码）。Content-Encoding 通常用于对实体内容进行压缩编码，目的是优化传输，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Transfer-Encoding: chunked</span><br><span class=\"line\">Transfer-Encoding: compress</span><br><span class=\"line\">Transfer-Encoding: deflate</span><br><span class=\"line\">Transfer-Encoding: gzip</span><br><span class=\"line\">Transfer-Encoding: identity</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p>逐跳消息头  这类消息头仅对单次传输连接有意义，不能通过代理或缓存进行重新转发</p>\n</li>\n<li><p>git merge –squash develop</p>\n</li>\n<li><p>mime  <a href=\"https://github.com/sindresorhus/file-type\">https://github.com/sindresorhus/file-type</a>  根据文件内容判断类型</p>\n</li>\n<li><p>语义化版本控制(SemVer)<br>先简单了解下什么是语义化的版本控制，其是由GitHub发起的一份用于规范版本号递增的规则，</p>\n</li>\n<li><p>deeplinks.js allows people to easily link directly to any text selection on your website.</p>\n</li>\n<li><p>Vue DevUI 开源的UI</p>\n</li>\n<li><p>standard-version<br>standard-version 会根据提交的信息类型来自动更改对应的版本号,如下:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">feat: 次版本(minor)+1</span><br><span class=\"line\">fix: 修订号(patch) +1</span><br><span class=\"line\">BREAK CHANGE: 主板号(marjor) +1</span><br></pre></td></tr></table></figure></li>\n<li><p>outline 能告诉用户那一个可以激发事件的html元素获取了焦点，对钟爱键盘操作的用户尤其有意义。一个清晰悦目的outline设计能提高使用表单的用户体验。</p>\n</li>\n<li><p>CSS属性 columns 用来设置元素的列宽和列数。<br>重点，设置了display: contents的元素本身不会被渲染，但是其子元素能够正常被渲染。</p>\n</li>\n<li><p>为了使我们的盒子居中，通过align-items属性，可以将交叉轴上的item对齐，此时使用的是垂直方向的块轴。而使用justify-content则可以对齐主轴上的项目，主轴是水平方向的。<br>align conent  用来控制多行布局   控制“多条主轴”的 flex 项目在交叉轴的对齐。</p>\n</li>\n<li><p>CSS 中的 place-items 是一个简写属性 ，它允许你在相关的布局（如 Grid 或 Flexbox）中可以同时沿着块级和内联方向对齐元素 (例如：align-items 和 justify-items 属性) 。如果未提供第二个值，则第一个值作为第二个值的默认值</p>\n</li>\n<li><p>filter CSS属性将模糊或颜色偏移等图形效果应用于元素。滤镜通常用于调整图像，背景和边框的渲染。</p>\n</li>\n<li><p>monaco 自定义language</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">register monaco.languages.register(&#123; id: &#x27;mySpecialLanguage&#x27; &#125;);</span><br><span class=\"line\">setMonarchTokensProvider base language 里面有3 </span><br><span class=\"line\">defineTheme  设置样式</span><br><span class=\"line\">monaco.editor.defineTheme(&#x27;myCoolTheme&#x27;, &#123;</span><br><span class=\"line\">                    colors: &#123;&#125;,</span><br><span class=\"line\">                    base: &#x27;vs&#x27;,</span><br><span class=\"line\">                    inherit: false,</span><br><span class=\"line\">                    rules: [</span><br><span class=\"line\">                        &#123; token: &#x27;custom-info&#x27;, foreground: &#x27;808080&#x27; &#125;,</span><br><span class=\"line\">                        &#123; token: &#x27;custom-error&#x27;, foreground: &#x27;ff0000&#x27;, fontStyle: &#x27;bold&#x27; &#125;,</span><br><span class=\"line\">                        &#123; token: &#x27;custom-notice&#x27;, foreground: &#x27;FFA500&#x27; &#125;,</span><br><span class=\"line\">                        &#123; token: &#x27;custom-date&#x27;, foreground: &#x27;008800&#x27; &#125;</span><br><span class=\"line\">                    ]</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">registerCompletionItemProvider  智能提示，遇到对应的关键词</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Monarch  用来实现代码高亮   <a href=\"https://juejin.cn/post/6844903736867831822\">https://juejin.cn/post/6844903736867831822</a></p>\n</li>\n</ol>\n<p><a href=\"https://microsoft.github.io/monaco-editor/monarch.html\">https://microsoft.github.io/monaco-editor/monarch.html</a></p>\n<ol>\n<li>xe-utils 提供工具类</li>\n<li>Mitt  Tiny (~200b) functional event emitter &#x2F; pubsub.</li>\n<li>element-resize-detector  </li>\n<li>memoize-one 记录最近的返回结果 </li>\n<li>钱其实是“保健因子”，而不是“激励因子”，是多了没用、少了不行的东西</li>\n<li>可以看到整个医改的核心就是放供给、促竞争和扶创新的过程</li>\n<li>破船能过河</li>\n<li>Comlink Comlink makes WebWorkers enjoyable. 多线程</li>\n<li><code>Rails-style</code>: 按照文件的类型划分为不同的目录</li>\n</ol>\n<p><code>Domain-style</code>: 按照一个功能特性或业务创建单独的目录</p>\n<p><code>Ducks-style</code>: 优点类似于Domain-style，不过更彻底, 它通常将相关联的元素定义在一个文件下</p>\n<p>1.<br>    强约定，体现团队的规范。首先它应该避免团队成员去关心或更改构建的配置细节，暴露最小化的配置接口。 另外构建工具不仅仅是构建，通常它还会集成代码检查、测试等功能。</p>\n<pre><code>方便升级。尤其是团队需要维护多个项目场景, 这一点很有意义\n</code></pre>\n<ol start=\"2\">\n<li><p>BEM</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">元素（Element），即 price 、text ，代表从属于某个块，是这个块的子元素，跟在块后面，以双下划线为间隔，使用 .btn__price 、.btn__text 表示</span><br><span class=\"line\"></span><br><span class=\"line\">修饰符（Modifier），即 orange 、big ，用于修改块的状态，为块添加特定的主题或样式，跟在块后面，以双连字符为间隔，使用 .btn--orange 、.btn--big 表示</span><br><span class=\"line\"></span><br><span class=\"line\">```   </span><br><span class=\"line\">1.  npm-run-all</span><br></pre></td></tr></table></figure>\n<p>Before: npm run clean &amp;&amp; npm run build:css &amp;&amp; npm run build:js &amp;&amp; npm run build:html<br>After: npm-run-all clean build:*</p>\n<pre><code>\n</code></pre>\n</li>\n<li><p>display:flow-root可以让元素块状化，同时包含格式化上下文BFC，可以用来清除浮动，去除margin合并，实现两栏自适应布局等。</p>\n</li>\n<li><p>stroke-dash 是一个定义虚线和间距图形的图像工具类, 被用于轮廓描边;</p>\n</li>\n<li><p>npx degit</p>\n</li>\n<li><p>有一些环境变量，比如HOME、PATH、SHELL、UID、USER等，在用户登录之前就已经被&#x2F;bin&#x2F;login程序设置好了。通常环境变量被定义并保存在用户家目录下的．bash_profile文件或全局的配置文件&#x2F;etc&#x2F;profile中</p>\n</li>\n<li><p>env命令只显示全局变量；declare命令输出所有的变量、函数、整数和已经导出的变量</p>\n</li>\n<li><p>http upgrade 通常来说这一机制总是由客户端发起的 （不过也有例外，比如说可以由服务端发起升级到传输层安全协议（TLS））， 服务端可以选择是否要升级到新协议。借助这一技术，连接可以以常用的协议启动（如HTTP&#x2F;1.1），随后再升级到HTTP2甚至是WebSockets.</p>\n</li>\n<li><p>因为 CommonJS 在运行时进行加载方式的动态解析，在运行时阶段才能确定的导入导出关系，因此无法进行静态编译优化和类型检查。​</p>\n</li>\n<li><p>JSZip  JSZip is a javascript library for creating, reading and editing .zip files, with a lovely and simple AP</p>\n</li>\n<li><p>spy-debugger  一站式页面调试、抓包工具。远程调试任何手机浏览器页面，任何手机移动端webview（如：微信，HybridApp等）。支持HTTP&#x2F;HTTPS，无需USB连接设备</p>\n</li>\n<li><p>viteshot 基于vite 的快照</p>\n</li>\n<li><p>useScrollLock</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><p>watchEffect 不能检测深层的变化，因此reactive 中变化无效，如果需要则 toRefs 转换</p>\n</li>\n<li><p>V2 $attrs   1. custom events go into a @listerner bucket  2.不能绑定class </p>\n</li>\n<li><p>Npm ls 查看依赖</p>\n</li>\n<li><p>可以看到结果reactive是递归会将每一层包装成Proxy对象的，深度监听每一层的property</p>\n</li>\n<li><p>effectScope有一个可选参数为boolean，当传入true时表示阻断与父级的联系，阻断后这个scope对象将不会与父级关联，成为独立的scope。父级的stop也不会影响到它。 </p>\n</li>\n<li><p>Last-Modified,Etag,Expires 三个同时使用时。先判断 Expire ，然后发送 Http 请求，服务器先判断 last-modified ，再判断 Etag ，必须都没有过期，才能返回 304 响应</p>\n</li>\n<li><p>klona  fast utility to “deep clone” Objects, Arrays, Dates, RegExps, and more!</p>\n</li>\n<li><p>Grep string starting with (e.g. ‘S’)    grep -o ‘S.*’</p>\n</li>\n<li><p>~: 如果写入的是 〜0.13.0，则当运行 npm update 时，会更新到补丁版本：即 0.13.1 可以，但 0.14.0 不可以。</p>\n</li>\n<li><blockquote>\n<p>: 接受高于指定版本的任何版本。</p>\n</blockquote>\n</li>\n<li><p>^: 只会执行不更改最左边非零数字的更新。 如果写入的是 ^0.13.0，则当运行 npm update 时，可以更新到 0.13.1、0.13.2 等，但不能更新到 0.14.0 或更高版本。 如果写入的是 ^1.13.0，则当运行 npm update 时，可以更新到 1.13.1、1.14.0 等，但不能更新到 2.0.0 或更高版本。</p>\n</li>\n<li><p>firefox 子元素不缩小需要设置  You need to add min‑width:0</p>\n</li>\n<li><p>flex 布局中子级超过了父级的宽度，需要设置 width:0 ,完全由flex 分配宽度。</p>\n</li>\n<li><p>POSIX stands for Portable Operating System Interface.</p>\n</li>\n<li><p>@supports CSS at-rule 相当于功能选择器</p>\n   <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   @supports (display: flex) &#123;</span><br><span class=\"line\">  body &#123;</span><br><span class=\"line\">    display: flex;</span><br><span class=\"line\">    min-height: 100vh;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p><a href=\"https://github.com/cuixiaorui/mini-vue\">https://github.com/cuixiaorui/mini-vue</a>  vue3 source code </p>\n</li>\n<li><p>react 被 startTransition 回调包裹的 setState 触发的渲染 被标记为不紧急渲染，这些渲染可能被其他紧急渲染所抢占。</p>\n</li>\n<li><p><a href=\"https://hyper.is/\">https://hyper.is/</a> electron console</p>\n</li>\n<li><p><a href=\"https://cmder.net/\">https://cmder.net/</a> windows 端的console 模拟器</p>\n</li>\n<li><p>Access-Control-Request-Private-Network: true 在所有私有网络预检请求上设置<br>Access-Control-Allow-Private-Network: true 必须在所有私有网络预检响应上设置</p>\n</li>\n<li><p>使用 Fragments，我们不需要在DOM中添加额外的节点。我们只需要用 React.Fragment 或才简写 &lt;&gt; 来包裹内容就行了</p>\n</li>\n<li><p>vite 虚拟模块  虚拟模块是一种很实用的模式，使你可以对使用 ESM 语法的源文件传入一些编译时信息。</p>\n</li>\n<li><p>glob Match files using the patterns the shell uses, like stars and stuff.</p>\n</li>\n<li><p>click.self<br>我们知道在自定义组件上，只能监听自定义事件，一些原生事件（比如click）是没有办法直接触发的，但是使用.native修饰符可以帮我们办到这点</p>\n</li>\n<li><p>offset-path  定义动画运行路径</p>\n</li>\n<li><p>Tauri 是一个为所有主流桌面平台构建小型、快速二进制文件的框架。开发人员可以集成任何编译成 HTML、 JS 和 CSS 的前端框架来构建他们的用户界面。应用程序的后端是一个 Rust 二进制文件，具有前端可以与之交互的 API。</p>\n</li>\n<li><p>gitsecreat 使用： <a href=\"https://www.mikesay.com/2020/12/16/git-encrypt-file-in-repository/#git-secret%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8\">https://www.mikesay.com/2020/12/16/git-encrypt-file-in-repository/#git-secret%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8</a></p>\n</li>\n<li><p>svg2pdf.js 图片转pdf</p>\n</li>\n<li><p>stream 的另外一个模式: objectMode。它是一种对象模式，我们把一件事情、或一个文件、或一个操作，抽象成一个对象。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const Readable = require(&#x27;stream&#x27;).Readable</span><br><span class=\"line\"></span><br><span class=\"line\">const readable = Readable(&#123; objectMode: true &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"> readable.push(&#x27;a&#x27;)</span><br><span class=\"line\"> readable.push(&#x27;b&#x27;)</span><br><span class=\"line\"> readable.push(&#123;&#125;)</span><br><span class=\"line\"> readable.push(null)</span><br><span class=\"line\"></span><br><span class=\"line\"> readable.on(&#x27;data&#x27;, data =&gt; console.log(data))</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n<li><p>git config –global push.followTags true</p>\n</li>\n<li><p>Markraw 标记不会被reactive</p>\n</li>\n<li><p>watcheffect onInvalidate 在重新运行或者停止的时候执行</p>\n</li>\n<li><p>composedPath() 是 Event 接口的一个方法，当对象数组调用该侦听器时返回事件路径。</p>\n</li>\n<li><p>customref  track and trigger  </p>\n</li>\n<li><p>vueuse useMemoize 对结果加cache</p>\n</li>\n<li><p>elementFromPoint 根据point 获取element</p>\n</li>\n<li><p>Change-case Transform a string between camelCase, PascalCase, Capital Case, snake_case, param-case, CONSTANT_CASE and others.</p>\n</li>\n<li><p>p-retry It does exponential backoff and supports custom retry strategies for failed operations.</p>\n</li>\n<li><p>MutationObserver 观察dom 变化</p>\n</li>\n<li><p>requestFullscreen</p>\n</li>\n<li><p>passive: Boolean，设置为true时，表示 listener 永远不会调用 preventDefault()。如果 listener 仍然调用了这个函数，客户端将会忽略它并抛出一个控制台警告</p>\n</li>\n<li><p>shallowReacive  shallowRef  shallowRef生成非递归响应数据，只监听第一层数据的变化</p>\n</li>\n<li><p>推荐在大部分时候用 watch 显式的指定依赖以避免不必要的重复触发，也避免在后续代码修改或重构时不小心引入新的依赖。watchEffect 适用于一些逻辑相对简单，依赖源和逻辑强相关的场景（或者懒惰的场景 ）。</p>\n</li>\n<li><p>Object.fromEntries</p>\n</li>\n<li><p>URL.revokeObjectURL() 静态方法用来释放一个之前已经存在的、通过调用 URL.createObjectURL() 创建的 URL 对象。</p>\n</li>\n<li><p>querySelector  返回第一个匹配元素</p>\n</li>\n<li><p>Array.prototype.at()接收一个正整数或者负整数作为参数，表示获取指定位置的成员</p>\n</li>\n<li><p>IFC全称：Inline Formatting Context，名为行级格式化上下文。    触发：块级元素中仅包含内联级别元素</p>\n</li>\n<li><p>The Notification interface of the Notifications API is used to configure and display desktop notifications to the user.</p>\n</li>\n<li><p>TinyMCE 富文本编辑器</p>\n</li>\n<li><p>Window.innerHeight  浏览器窗口的视口（viewport）高度（以像素为单位）；如果有水平滚动条，也包括滚动条高度。</p>\n</li>\n<li><p>vuedraggable 处理拖动数据</p>\n</li>\n<li><p>path-to-regexp   Turn a path string such as &#x2F;user&#x2F;:name into a regular expression. The compile function will return a function for transforming parameters into a valid path:</p>\n</li>\n<li><p>vue router 重新render,redirect+fullpath.通过添加一个中转页实现。</p>\n</li>\n<li><p>import { storeToRefs } from “pinia”;</p>\n</li>\n<li><p>html5 input number</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.no-arrow::-webkit-outer-spin-button,</span><br><span class=\"line\">.no-arrow::-webkit-inner-spin-button &#123;</span><br><span class=\"line\">  -webkit-appearance: none;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>vue3 类型 MayBeRef</p>\n</li>\n<li><p>暂停watch后更新，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ignoreUpdates(() =&gt; &#123;</span><br><span class=\"line\">  source.value = &#x27;ignored&#x27;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>dsp 读取json,csv,xlxs 数据</p>\n</li>\n<li><p>limu 创建imutable 对象</p>\n</li>\n<li><p>controlledRef set peek,控制数据的更新</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> const num = controlledRef(0, &#123;</span><br><span class=\"line\">  onBeforeChange(value, oldValue) &#123;</span><br><span class=\"line\">    // disallow changes larger then ±5 in one operation</span><br><span class=\"line\">    if (Math.abs(value - oldValue) &gt; 5)</span><br><span class=\"line\">      return false // returning `false` to dismiss the change</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>flush: post 推迟副作用的初始运行，直到组件的首次渲染完成。<br>watch 通过更改设置 flush: ‘sync’，我们可以为每个更改都强制触发侦听器，尽管这通常是不推荐的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">- `&#x27;pre&#x27;`: buffers invalidated effects in the same &#x27;tick&#x27; and flushes them before rendering</span><br><span class=\"line\">- `&#x27;post&#x27;`: async like &#x27;pre&#x27; but fires after component updates so you can access the updated DOM</span><br><span class=\"line\">- `&#x27;sync&#x27;`: forces the effect to always trigger synchronously</span><br><span class=\"line\"></span><br><span class=\"line\"> &#123; flush: &#x27;post&#x27; &#125;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n<li><p>transx vue 动画组件   一个小巧玲珑的 vue 组件切换动画库</p>\n</li>\n<li><p>ts-morph 修改ts 代码，封装后的ts compiler api</p>\n</li>\n<li><p>esno 执行ts</p>\n</li>\n<li><p><a href=\"https://mermaid-js.github.io/mermaid/#/\">https://mermaid-js.github.io/mermaid/#/</a>     mermaid 及其方便的画图工具</p>\n</li>\n<li><p>vue-parallaxy Is a compontent for fast 60fps parallax scroll effects in vue 2. 实现滚动的视差效果。</p>\n</li>\n<li><p>useWatermark,Layzcontainer. context menu  vue-vben-admin 中</p>\n</li>\n<li><p>localForage is a fast and simple storage library for JavaScript。Wraps IndexedDB, WebSQL, or localStorage using a simple but powerful API.</p>\n</li>\n<li><p>markRaw 标记对下不会被reactive</p>\n</li>\n<li><p>indexeddb-fs is a module that allows you to store data in the browser using an API similar to that of Node’s fs module.</p>\n</li>\n<li><p>临时安全令牌（Security Token Service，STS）</p>\n</li>\n<li><p>*** 获取文本px宽度* @param font{String}: 字体样式**</p>\n</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String.prototype.pxWidth = function(font) &#123;</span><br><span class=\"line\">  // re-use canvas object for better performance</span><br><span class=\"line\">  var canvas = String.prototype.pxWidth.canvas || (String.prototype.pxWidth.canvas = document.createElement(&quot;canvas&quot;)),</span><br><span class=\"line\">      context = canvas.getContext(&quot;2d&quot;); 3</span><br><span class=\"line\"></span><br><span class=\"line\">  font &amp;&amp; (context.font = font);</span><br><span class=\"line\">  var metrics = context.measureText(this);</span><br><span class=\"line\"></span><br><span class=\"line\">  return metrics.width;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>先保存各个实例的values信息， helm get values [release] &gt; xxx.yaml</p>\n</li>\n<li><p>HTTP协议中用头部字段Accept-Encoding 和 Content-Encoding对「采用何种编码格式传输正文」进行了协定，请求头的Accept-Encoding会列出客户端支持的编码格式。当响应头的 Content-Encoding指定了gzip时，浏览器则会进行对应解压</p>\n</li>\n<li><p>Transfer-Encoding，是一个 HTTP 头部字段，字面意思是「传输编码」。实际上，HTTP 协议中还有另外一个头部与编码有关：Content-Encoding（内容编码）。Content-Encoding 通常用于对实体内容进行压缩编码，目的是优化传输，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Transfer-Encoding: chunked</span><br><span class=\"line\">Transfer-Encoding: compress</span><br><span class=\"line\">Transfer-Encoding: deflate</span><br><span class=\"line\">Transfer-Encoding: gzip</span><br><span class=\"line\">Transfer-Encoding: identity</span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p>逐跳消息头  这类消息头仅对单次传输连接有意义，不能通过代理或缓存进行重新转发</p>\n</li>\n<li><p>git merge –squash develop</p>\n</li>\n<li><p>mime  <a href=\"https://github.com/sindresorhus/file-type\">https://github.com/sindresorhus/file-type</a>  根据文件内容判断类型</p>\n</li>\n<li><p>语义化版本控制(SemVer)<br>先简单了解下什么是语义化的版本控制，其是由GitHub发起的一份用于规范版本号递增的规则，</p>\n</li>\n<li><p>deeplinks.js allows people to easily link directly to any text selection on your website.</p>\n</li>\n<li><p>Vue DevUI 开源的UI</p>\n</li>\n<li><p>standard-version<br>standard-version 会根据提交的信息类型来自动更改对应的版本号,如下:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">feat: 次版本(minor)+1</span><br><span class=\"line\">fix: 修订号(patch) +1</span><br><span class=\"line\">BREAK CHANGE: 主板号(marjor) +1</span><br></pre></td></tr></table></figure></li>\n<li><p>outline 能告诉用户那一个可以激发事件的html元素获取了焦点，对钟爱键盘操作的用户尤其有意义。一个清晰悦目的outline设计能提高使用表单的用户体验。</p>\n</li>\n<li><p>CSS属性 columns 用来设置元素的列宽和列数。<br>重点，设置了display: contents的元素本身不会被渲染，但是其子元素能够正常被渲染。</p>\n</li>\n<li><p>为了使我们的盒子居中，通过align-items属性，可以将交叉轴上的item对齐，此时使用的是垂直方向的块轴。而使用justify-content则可以对齐主轴上的项目，主轴是水平方向的。<br>align conent  用来控制多行布局   控制“多条主轴”的 flex 项目在交叉轴的对齐。</p>\n</li>\n<li><p>CSS 中的 place-items 是一个简写属性 ，它允许你在相关的布局（如 Grid 或 Flexbox）中可以同时沿着块级和内联方向对齐元素 (例如：align-items 和 justify-items 属性) 。如果未提供第二个值，则第一个值作为第二个值的默认值</p>\n</li>\n<li><p>filter CSS属性将模糊或颜色偏移等图形效果应用于元素。滤镜通常用于调整图像，背景和边框的渲染。</p>\n</li>\n<li><p>monaco 自定义language</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">register monaco.languages.register(&#123; id: &#x27;mySpecialLanguage&#x27; &#125;);</span><br><span class=\"line\">setMonarchTokensProvider base language 里面有3 </span><br><span class=\"line\">defineTheme  设置样式</span><br><span class=\"line\">monaco.editor.defineTheme(&#x27;myCoolTheme&#x27;, &#123;</span><br><span class=\"line\">                    colors: &#123;&#125;,</span><br><span class=\"line\">                    base: &#x27;vs&#x27;,</span><br><span class=\"line\">                    inherit: false,</span><br><span class=\"line\">                    rules: [</span><br><span class=\"line\">                        &#123; token: &#x27;custom-info&#x27;, foreground: &#x27;808080&#x27; &#125;,</span><br><span class=\"line\">                        &#123; token: &#x27;custom-error&#x27;, foreground: &#x27;ff0000&#x27;, fontStyle: &#x27;bold&#x27; &#125;,</span><br><span class=\"line\">                        &#123; token: &#x27;custom-notice&#x27;, foreground: &#x27;FFA500&#x27; &#125;,</span><br><span class=\"line\">                        &#123; token: &#x27;custom-date&#x27;, foreground: &#x27;008800&#x27; &#125;</span><br><span class=\"line\">                    ]</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">registerCompletionItemProvider  智能提示，遇到对应的关键词</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Monarch  用来实现代码高亮   <a href=\"https://juejin.cn/post/6844903736867831822\">https://juejin.cn/post/6844903736867831822</a></p>\n</li>\n</ol>\n<p><a href=\"https://microsoft.github.io/monaco-editor/monarch.html\">https://microsoft.github.io/monaco-editor/monarch.html</a></p>\n<ol>\n<li>xe-utils 提供工具类</li>\n<li>Mitt  Tiny (~200b) functional event emitter &#x2F; pubsub.</li>\n<li>element-resize-detector  </li>\n<li>memoize-one 记录最近的返回结果 </li>\n<li>钱其实是“保健因子”，而不是“激励因子”，是多了没用、少了不行的东西</li>\n<li>可以看到整个医改的核心就是放供给、促竞争和扶创新的过程</li>\n<li>破船能过河</li>\n<li>Comlink Comlink makes WebWorkers enjoyable. 多线程</li>\n<li><code>Rails-style</code>: 按照文件的类型划分为不同的目录</li>\n</ol>\n<p><code>Domain-style</code>: 按照一个功能特性或业务创建单独的目录</p>\n<p><code>Ducks-style</code>: 优点类似于Domain-style，不过更彻底, 它通常将相关联的元素定义在一个文件下</p>\n<p>1.<br>    强约定，体现团队的规范。首先它应该避免团队成员去关心或更改构建的配置细节，暴露最小化的配置接口。 另外构建工具不仅仅是构建，通常它还会集成代码检查、测试等功能。</p>\n<pre><code>方便升级。尤其是团队需要维护多个项目场景, 这一点很有意义\n</code></pre>\n<ol start=\"2\">\n<li><p>BEM</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">元素（Element），即 price 、text ，代表从属于某个块，是这个块的子元素，跟在块后面，以双下划线为间隔，使用 .btn__price 、.btn__text 表示</span><br><span class=\"line\"></span><br><span class=\"line\">修饰符（Modifier），即 orange 、big ，用于修改块的状态，为块添加特定的主题或样式，跟在块后面，以双连字符为间隔，使用 .btn--orange 、.btn--big 表示</span><br><span class=\"line\"></span><br><span class=\"line\">```   </span><br><span class=\"line\">1.  npm-run-all</span><br></pre></td></tr></table></figure>\n<p>Before: npm run clean &amp;&amp; npm run build:css &amp;&amp; npm run build:js &amp;&amp; npm run build:html<br>After: npm-run-all clean build:*</p>\n<pre><code>\n</code></pre>\n</li>\n<li><p>display:flow-root可以让元素块状化，同时包含格式化上下文BFC，可以用来清除浮动，去除margin合并，实现两栏自适应布局等。</p>\n</li>\n<li><p>stroke-dash 是一个定义虚线和间距图形的图像工具类, 被用于轮廓描边;</p>\n</li>\n<li><p>npx degit</p>\n</li>\n<li><p>有一些环境变量，比如HOME、PATH、SHELL、UID、USER等，在用户登录之前就已经被&#x2F;bin&#x2F;login程序设置好了。通常环境变量被定义并保存在用户家目录下的．bash_profile文件或全局的配置文件&#x2F;etc&#x2F;profile中</p>\n</li>\n<li><p>env命令只显示全局变量；declare命令输出所有的变量、函数、整数和已经导出的变量</p>\n</li>\n<li><p>http upgrade 通常来说这一机制总是由客户端发起的 （不过也有例外，比如说可以由服务端发起升级到传输层安全协议（TLS））， 服务端可以选择是否要升级到新协议。借助这一技术，连接可以以常用的协议启动（如HTTP&#x2F;1.1），随后再升级到HTTP2甚至是WebSockets.</p>\n</li>\n<li><p>因为 CommonJS 在运行时进行加载方式的动态解析，在运行时阶段才能确定的导入导出关系，因此无法进行静态编译优化和类型检查。​</p>\n</li>\n<li><p>JSZip  JSZip is a javascript library for creating, reading and editing .zip files, with a lovely and simple AP</p>\n</li>\n<li><p>spy-debugger  一站式页面调试、抓包工具。远程调试任何手机浏览器页面，任何手机移动端webview（如：微信，HybridApp等）。支持HTTP&#x2F;HTTPS，无需USB连接设备</p>\n</li>\n<li><p>viteshot 基于vite 的快照</p>\n</li>\n<li><p>useScrollLock</p>\n</li>\n</ol>\n"},{"title":"package","date":"2019-02-14T09:19:12.000Z","_content":"1. Vue-intro  新功能引导  \n1. zebra-editor-core  富文本编辑器\n1.  lucky sheet 在线的excel编辑\n1. generic-pool  资源池，可以reuse 和限制一些比较贵的资源比如数据库链接。\n1. Mind elixir 浏览器思维导图js module\n1.  cp-cli  copy 跨平台\n1.  markdown-it :  markdown parser\n1. web-storage-cache 对HTML5 localStorage 和sessionStorage 进行了扩展，添加了超时时间，序列化方法。可以直接存储json对象，同时可以非常简单的进行超时时间的设置。\n1. ImmortalDB 是在浏览器中存储持久键值数据的最佳方法。保存到 ImmortalDB 的数据被冗余地存储在 Cookies，IndexedDB 和 localStorage 中，并且如果其中的任何数据被删除或损坏，它们将不断进行自我修复。\n1. localForage 是一个快速简单的 JavaScript 存储库。 它通过使用类似于 localStorage 的简单 API 来使用异步存储（IndexedDB 或 WebSQL)），进而改善你的 Web 应用程序的离线体验。\n1. webworker-threads  node 多线程模块处理计算密集任务\n1. Textures.js  基于d3 生成纹理\n1. robotjs 控制键盘、鼠标、屏幕\n1. vue-count-to  的数字滚动组件，vue-count-to是一个无依赖，轻量级的vue组件，可以自行覆盖easingFn。你可以设置 startVal 和 endVal，它会自动判断计数或倒计时\n1. fullpagejs  通过调用本库可轻易创建全屏滚动网站(也称为单页网站)。 本库可创建全屏滚动网站，同时也可在网站中添加横向滚动条。\n1. Opn: A better node-open. Opens stuff like websites, files, executables. Cross-platform.\n2. Ora:进度条和文字。\n3. joi：数据验\n4. satisfies ：版本工具\n5. minimist：简单的参数处理\n6. read-pkg:规范化解析pkg\n7. inquirer:询问时可以给出选项\n8. Resovel:解析包的安装路径\n9. slash:Convert Windows backslash paths to slash paths: foo\\\\bar ➔ foo/bar\n1. klaw-sync:回遍历出所有文件，并返回文件路径和文件夹\n1. mime-types content-type 工具：1. 可以根据文件后缀获取 2. 根据content-type获取charset 3. 根据content-type 获取默认的文件名\n1. CodeMirror是一个运行在浏览器中的在线代码编辑器，支持100多种语言，高度可定制。\n1. @typescript-eslint/eslint-plugin.  eslint 检测typescript \n1. nanoid  A tiny, secure, URL-friendly, unique string ID generator for JavaScript.\n1. mm 对mudule 中的方法mock\n1. numerify  用来格式化数字 \n   \n1. utils-lite  前端提供debounce、thorttling、clone、cloneDeep 等方法\n1. is-type-of   node check 数据类型\n1. on-finished  Execute a callback when a HTTP request closes, finishes, or errors\n1. await-event  封装了promise \n\n```javascript\nvar PassThrough = require('stream').PassThrough\n \nvar stream = new PassThrough()\n// you attach it directly on an event emitter\nstream.await = require('await-event')\n \nco(function* () {\n  var chunk = yield stream.await('data')\n  var chunk = yield stream.await('data')\n  var chunk = yield stream.await('data')\n}).catch(noop)\n \nstream.write('some chunk’) \n```\n1. get-ready  NodeJS mixin to add one-time ready event\n2. ShellJS 是Unix shell命令在Node.js API上的可移植实现\n3. graceful-process   graceful exit process even parent exit on SIGKILL.\n4. semver.gte(process.version, '7.0.0’)  版本的比对 \n5. pkgfiles  自动再package中添加 npm publish 文件\n6. depd  标注方法deprecating \n7. http-errors   http错误  \n8. Global-tunnel  http请求的全局代理  \n9. humanize-ms  转义为ms  \n```\ntransform humanize time to ms  ms('1s') // 1000\nms(1000) // 1000\n```\n1. Exceljs 一个功能强大的excel 处理包\n1. ready-callback 所有注册的事件完成后，才执行ready中方法\n1. Get-ready  NodeJS mixin to add one-time ready event，ready 后执行相关方法\n1. xml2js  将xml 转换为json \n1. debug  调试状态输出  debug=*  debug=work:*   \n1. delegates  node模块中代理proto中属性的方法、setter和getter\n1. chokidar filewatch \n1. Puppeteer  headless browser\n1. cross-env Run scripts that set and use environment variables across platforms\n1. simplemde  markdown editor \n1. serialize-javascript  Serialize JavaScript to a superset of JSON that includes regular expressions and functions.\n1.route-cache  express router cache\n```javascript\nvar routeCache = require('route-cache');\n \n// cache route for 20 seconds\napp.get('/index', routeCache.cacheSeconds(20), function(req, res){\n  // do your dirty work here...\n  console.log('you will only see this every 20 seconds.');\n  res.send('this response will be cached');\n});\n```\n1. Ws server 端的websoket \n1. fastclick  解决浏览器点击的延迟\n1. Qs  A querystring parsing and stringifying library with some added security.\n1. lru-cache  A cache object that deletes the least-recently-used items.\n1. memory-fs  A simple in-memory filesystem. Holds data in a javascript object\n1. faker.js  generate massive amounts of fake data in the browser and node.js\n1. parseurl 等同node url parse，加了cache\n1. vue-lazy-component   Vue.js 2.x 组件级懒加载方案-Vue.js 2.x component level lazy loading solution\n1. async-validator  数据验证\n1. fast-safe-stringify    Safe and fast serialization alternative to JSON.stringify.\n1. node-notifier   Send cross platform native notifications using Node.js.\n1. dateformat   node 时间处理函数\n1. agentkeepalive  defaut is keepalive\n1. copy-to   copy an object's properties to another one, include propertiy, getter and setter.\n1. platform   A platform detection library that works on nearly all JavaScript platforms.\n\n1. svg-captcha 验证码  \n1. vue-virtual-scroller  加载大量数据\n1. FileSaver.js  保存大于 ram的文档\n1. vue-draggable-resizable  Vue2 Component for draggable and resizable elements.\n1. ScrollTrigger  根据滚动位置出发事件\n1. Vue Virtual Scroller   RecycleScroller 可以渲染列表中的可见项目。如果你不知道项目的大小，最好使用 DynamicScroller\n1. Vuetensils  没有样式的component,可定制自己样式\n1. v-calendar  日历插件\n1. vue-grid-layout 可以拖拽的布局控件\n1. Vue-content-loader  占位符控件\n1. Sinon   node 端监控方法执行、mock、spy\n1. figlet  控制台标题文字\n1. Cockatiel  是一个弹性和瞬态故障处理库，如重试，断路器，超时，隔板隔离和回退之类的策略。\n1. Signale  一个 Node 的日志格式库，自带16个级别，可以定制颜色和 Emoji。\n1. Wiki.js  构建wiki 文档管理 \n1. fast-xml-parser xml 和     json 转换\n1. js-cloudimage-360-view 360度查看\n1. crontab ui\n1. X-spreadsheet css 实现的sheet\n1. SitDown  [html to markdown](http://domchristie.github.io/turndown/)\n1. Wekan 一个开源的看板软件\n1. droppy  提供web界面的可本地部署的文件管理\n1. uplot 渲染大量数据，占用资源少\n1. https://github.com/jlongster/absurd-sql  sqllite 对indexdb的封装\n2. https://www.npmjs.com/package/zx   zx node shell 的脚本终极方案\n3.  vueuse vue hooks 比较全的\n1. splitpane 拖拽布局控件 https://antoniandre.github.io/splitpanes/\n2. chan  A golang like channel implementation for JavaScript that works well with co.\n3. pump  When using standard source.pipe(dest) source will not be destroyed if dest emits close or an error. You are also not able to provide a callback to tell when then pipe has finished.\n4. npx cloc path 用来统计代码行数\n5. acorn  A tiny, fast JavaScript parser written in JavaScript.\n6.  picocolors  The tiniest and the fastest library for terminal output formatting with ANSI colors.添加背景色的。\n7.  hash-sum  blazing fast unique hash generator\n8.  micromatch  Glob matching for javascript/node.js. A replacement and faster alternative to minimatch and multimatch.\n9.  xterm-addon-attach  An addon for xterm.js that enables attaching to a web socket. This addon requires xterm.js v4+.\n10. node-pty 虚拟的terminal forkpty(3) bindings for node.js. This allows you to fork processes with pseudoterminal file descriptors. It returns a terminal object which allows reads and writes.\n  asdf\n1. dom-to-image 一个可以将任意DOM节点转换为用JavaScript编写的矢量（SVG）或光栅（PNG或JPEG）图像的库\n ","source":"_posts/package.md","raw":"---\ntitle: package\ndate: 2019-02-14 17:19:12\ntags: useful package\n---\n1. Vue-intro  新功能引导  \n1. zebra-editor-core  富文本编辑器\n1.  lucky sheet 在线的excel编辑\n1. generic-pool  资源池，可以reuse 和限制一些比较贵的资源比如数据库链接。\n1. Mind elixir 浏览器思维导图js module\n1.  cp-cli  copy 跨平台\n1.  markdown-it :  markdown parser\n1. web-storage-cache 对HTML5 localStorage 和sessionStorage 进行了扩展，添加了超时时间，序列化方法。可以直接存储json对象，同时可以非常简单的进行超时时间的设置。\n1. ImmortalDB 是在浏览器中存储持久键值数据的最佳方法。保存到 ImmortalDB 的数据被冗余地存储在 Cookies，IndexedDB 和 localStorage 中，并且如果其中的任何数据被删除或损坏，它们将不断进行自我修复。\n1. localForage 是一个快速简单的 JavaScript 存储库。 它通过使用类似于 localStorage 的简单 API 来使用异步存储（IndexedDB 或 WebSQL)），进而改善你的 Web 应用程序的离线体验。\n1. webworker-threads  node 多线程模块处理计算密集任务\n1. Textures.js  基于d3 生成纹理\n1. robotjs 控制键盘、鼠标、屏幕\n1. vue-count-to  的数字滚动组件，vue-count-to是一个无依赖，轻量级的vue组件，可以自行覆盖easingFn。你可以设置 startVal 和 endVal，它会自动判断计数或倒计时\n1. fullpagejs  通过调用本库可轻易创建全屏滚动网站(也称为单页网站)。 本库可创建全屏滚动网站，同时也可在网站中添加横向滚动条。\n1. Opn: A better node-open. Opens stuff like websites, files, executables. Cross-platform.\n2. Ora:进度条和文字。\n3. joi：数据验\n4. satisfies ：版本工具\n5. minimist：简单的参数处理\n6. read-pkg:规范化解析pkg\n7. inquirer:询问时可以给出选项\n8. Resovel:解析包的安装路径\n9. slash:Convert Windows backslash paths to slash paths: foo\\\\bar ➔ foo/bar\n1. klaw-sync:回遍历出所有文件，并返回文件路径和文件夹\n1. mime-types content-type 工具：1. 可以根据文件后缀获取 2. 根据content-type获取charset 3. 根据content-type 获取默认的文件名\n1. CodeMirror是一个运行在浏览器中的在线代码编辑器，支持100多种语言，高度可定制。\n1. @typescript-eslint/eslint-plugin.  eslint 检测typescript \n1. nanoid  A tiny, secure, URL-friendly, unique string ID generator for JavaScript.\n1. mm 对mudule 中的方法mock\n1. numerify  用来格式化数字 \n   \n1. utils-lite  前端提供debounce、thorttling、clone、cloneDeep 等方法\n1. is-type-of   node check 数据类型\n1. on-finished  Execute a callback when a HTTP request closes, finishes, or errors\n1. await-event  封装了promise \n\n```javascript\nvar PassThrough = require('stream').PassThrough\n \nvar stream = new PassThrough()\n// you attach it directly on an event emitter\nstream.await = require('await-event')\n \nco(function* () {\n  var chunk = yield stream.await('data')\n  var chunk = yield stream.await('data')\n  var chunk = yield stream.await('data')\n}).catch(noop)\n \nstream.write('some chunk’) \n```\n1. get-ready  NodeJS mixin to add one-time ready event\n2. ShellJS 是Unix shell命令在Node.js API上的可移植实现\n3. graceful-process   graceful exit process even parent exit on SIGKILL.\n4. semver.gte(process.version, '7.0.0’)  版本的比对 \n5. pkgfiles  自动再package中添加 npm publish 文件\n6. depd  标注方法deprecating \n7. http-errors   http错误  \n8. Global-tunnel  http请求的全局代理  \n9. humanize-ms  转义为ms  \n```\ntransform humanize time to ms  ms('1s') // 1000\nms(1000) // 1000\n```\n1. Exceljs 一个功能强大的excel 处理包\n1. ready-callback 所有注册的事件完成后，才执行ready中方法\n1. Get-ready  NodeJS mixin to add one-time ready event，ready 后执行相关方法\n1. xml2js  将xml 转换为json \n1. debug  调试状态输出  debug=*  debug=work:*   \n1. delegates  node模块中代理proto中属性的方法、setter和getter\n1. chokidar filewatch \n1. Puppeteer  headless browser\n1. cross-env Run scripts that set and use environment variables across platforms\n1. simplemde  markdown editor \n1. serialize-javascript  Serialize JavaScript to a superset of JSON that includes regular expressions and functions.\n1.route-cache  express router cache\n```javascript\nvar routeCache = require('route-cache');\n \n// cache route for 20 seconds\napp.get('/index', routeCache.cacheSeconds(20), function(req, res){\n  // do your dirty work here...\n  console.log('you will only see this every 20 seconds.');\n  res.send('this response will be cached');\n});\n```\n1. Ws server 端的websoket \n1. fastclick  解决浏览器点击的延迟\n1. Qs  A querystring parsing and stringifying library with some added security.\n1. lru-cache  A cache object that deletes the least-recently-used items.\n1. memory-fs  A simple in-memory filesystem. Holds data in a javascript object\n1. faker.js  generate massive amounts of fake data in the browser and node.js\n1. parseurl 等同node url parse，加了cache\n1. vue-lazy-component   Vue.js 2.x 组件级懒加载方案-Vue.js 2.x component level lazy loading solution\n1. async-validator  数据验证\n1. fast-safe-stringify    Safe and fast serialization alternative to JSON.stringify.\n1. node-notifier   Send cross platform native notifications using Node.js.\n1. dateformat   node 时间处理函数\n1. agentkeepalive  defaut is keepalive\n1. copy-to   copy an object's properties to another one, include propertiy, getter and setter.\n1. platform   A platform detection library that works on nearly all JavaScript platforms.\n\n1. svg-captcha 验证码  \n1. vue-virtual-scroller  加载大量数据\n1. FileSaver.js  保存大于 ram的文档\n1. vue-draggable-resizable  Vue2 Component for draggable and resizable elements.\n1. ScrollTrigger  根据滚动位置出发事件\n1. Vue Virtual Scroller   RecycleScroller 可以渲染列表中的可见项目。如果你不知道项目的大小，最好使用 DynamicScroller\n1. Vuetensils  没有样式的component,可定制自己样式\n1. v-calendar  日历插件\n1. vue-grid-layout 可以拖拽的布局控件\n1. Vue-content-loader  占位符控件\n1. Sinon   node 端监控方法执行、mock、spy\n1. figlet  控制台标题文字\n1. Cockatiel  是一个弹性和瞬态故障处理库，如重试，断路器，超时，隔板隔离和回退之类的策略。\n1. Signale  一个 Node 的日志格式库，自带16个级别，可以定制颜色和 Emoji。\n1. Wiki.js  构建wiki 文档管理 \n1. fast-xml-parser xml 和     json 转换\n1. js-cloudimage-360-view 360度查看\n1. crontab ui\n1. X-spreadsheet css 实现的sheet\n1. SitDown  [html to markdown](http://domchristie.github.io/turndown/)\n1. Wekan 一个开源的看板软件\n1. droppy  提供web界面的可本地部署的文件管理\n1. uplot 渲染大量数据，占用资源少\n1. https://github.com/jlongster/absurd-sql  sqllite 对indexdb的封装\n2. https://www.npmjs.com/package/zx   zx node shell 的脚本终极方案\n3.  vueuse vue hooks 比较全的\n1. splitpane 拖拽布局控件 https://antoniandre.github.io/splitpanes/\n2. chan  A golang like channel implementation for JavaScript that works well with co.\n3. pump  When using standard source.pipe(dest) source will not be destroyed if dest emits close or an error. You are also not able to provide a callback to tell when then pipe has finished.\n4. npx cloc path 用来统计代码行数\n5. acorn  A tiny, fast JavaScript parser written in JavaScript.\n6.  picocolors  The tiniest and the fastest library for terminal output formatting with ANSI colors.添加背景色的。\n7.  hash-sum  blazing fast unique hash generator\n8.  micromatch  Glob matching for javascript/node.js. A replacement and faster alternative to minimatch and multimatch.\n9.  xterm-addon-attach  An addon for xterm.js that enables attaching to a web socket. This addon requires xterm.js v4+.\n10. node-pty 虚拟的terminal forkpty(3) bindings for node.js. This allows you to fork processes with pseudoterminal file descriptors. It returns a terminal object which allows reads and writes.\n  asdf\n1. dom-to-image 一个可以将任意DOM节点转换为用JavaScript编写的矢量（SVG）或光栅（PNG或JPEG）图像的库\n ","slug":"package","published":1,"updated":"2022-03-30T02:26:37.703Z","_id":"ckzf5se03001hyy8kowub1e2u","comments":1,"layout":"post","photos":[],"link":"","content":"<ol>\n<li><p>Vue-intro  新功能引导  </p>\n</li>\n<li><p>zebra-editor-core  富文本编辑器</p>\n</li>\n<li><p>lucky sheet 在线的excel编辑</p>\n</li>\n<li><p>generic-pool  资源池，可以reuse 和限制一些比较贵的资源比如数据库链接。</p>\n</li>\n<li><p>Mind elixir 浏览器思维导图js module</p>\n</li>\n<li><p>cp-cli  copy 跨平台</p>\n</li>\n<li><p>markdown-it :  markdown parser</p>\n</li>\n<li><p>web-storage-cache 对HTML5 localStorage 和sessionStorage 进行了扩展，添加了超时时间，序列化方法。可以直接存储json对象，同时可以非常简单的进行超时时间的设置。</p>\n</li>\n<li><p>ImmortalDB 是在浏览器中存储持久键值数据的最佳方法。保存到 ImmortalDB 的数据被冗余地存储在 Cookies，IndexedDB 和 localStorage 中，并且如果其中的任何数据被删除或损坏，它们将不断进行自我修复。</p>\n</li>\n<li><p>localForage 是一个快速简单的 JavaScript 存储库。 它通过使用类似于 localStorage 的简单 API 来使用异步存储（IndexedDB 或 WebSQL)），进而改善你的 Web 应用程序的离线体验。</p>\n</li>\n<li><p>webworker-threads  node 多线程模块处理计算密集任务</p>\n</li>\n<li><p>Textures.js  基于d3 生成纹理</p>\n</li>\n<li><p>robotjs 控制键盘、鼠标、屏幕</p>\n</li>\n<li><p>vue-count-to  的数字滚动组件，vue-count-to是一个无依赖，轻量级的vue组件，可以自行覆盖easingFn。你可以设置 startVal 和 endVal，它会自动判断计数或倒计时</p>\n</li>\n<li><p>fullpagejs  通过调用本库可轻易创建全屏滚动网站(也称为单页网站)。 本库可创建全屏滚动网站，同时也可在网站中添加横向滚动条。</p>\n</li>\n<li><p>Opn: A better node-open. Opens stuff like websites, files, executables. Cross-platform.</p>\n</li>\n<li><p>Ora:进度条和文字。</p>\n</li>\n<li><p>joi：数据验</p>\n</li>\n<li><p>satisfies ：版本工具</p>\n</li>\n<li><p>minimist：简单的参数处理</p>\n</li>\n<li><p>read-pkg:规范化解析pkg</p>\n</li>\n<li><p>inquirer:询问时可以给出选项</p>\n</li>\n<li><p>Resovel:解析包的安装路径</p>\n</li>\n<li><p>slash:Convert Windows backslash paths to slash paths: foo\\bar ➔ foo&#x2F;bar</p>\n</li>\n<li><p>klaw-sync:回遍历出所有文件，并返回文件路径和文件夹</p>\n</li>\n<li><p>mime-types content-type 工具：1. 可以根据文件后缀获取 2. 根据content-type获取charset 3. 根据content-type 获取默认的文件名</p>\n</li>\n<li><p>CodeMirror是一个运行在浏览器中的在线代码编辑器，支持100多种语言，高度可定制。</p>\n</li>\n<li><p>@typescript-eslint&#x2F;eslint-plugin.  eslint 检测typescript </p>\n</li>\n<li><p>nanoid  A tiny, secure, URL-friendly, unique string ID generator for JavaScript.</p>\n</li>\n<li><p>mm 对mudule 中的方法mock</p>\n</li>\n<li><p>numerify  用来格式化数字 </p>\n</li>\n<li><p>utils-lite  前端提供debounce、thorttling、clone、cloneDeep 等方法</p>\n</li>\n<li><p>is-type-of   node check 数据类型</p>\n</li>\n<li><p>on-finished  Execute a callback when a HTTP request closes, finishes, or errors</p>\n</li>\n<li><p>await-event  封装了promise</p>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"title class_\">PassThrough</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;stream&#x27;</span>).<span class=\"property\">PassThrough</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">var</span> stream = <span class=\"keyword\">new</span> <span class=\"title class_\">PassThrough</span>()</span><br><span class=\"line\"><span class=\"comment\">// you attach it directly on an event emitter</span></span><br><span class=\"line\">stream.<span class=\"property\">await</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;await-event&#x27;</span>)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"title function_\">co</span>(<span class=\"keyword\">function</span>* () &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> chunk = <span class=\"keyword\">yield</span> stream.<span class=\"title function_\">await</span>(<span class=\"string\">&#x27;data&#x27;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> chunk = <span class=\"keyword\">yield</span> stream.<span class=\"title function_\">await</span>(<span class=\"string\">&#x27;data&#x27;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> chunk = <span class=\"keyword\">yield</span> stream.<span class=\"title function_\">await</span>(<span class=\"string\">&#x27;data&#x27;</span>)</span><br><span class=\"line\">&#125;).<span class=\"title function_\">catch</span>(noop)</span><br><span class=\"line\"> </span><br><span class=\"line\">stream.<span class=\"title function_\">write</span>(<span class=\"string\">&#x27;some chunk’) </span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>get-ready  NodeJS mixin to add one-time ready event</li>\n<li>ShellJS 是Unix shell命令在Node.js API上的可移植实现</li>\n<li>graceful-process   graceful exit process even parent exit on SIGKILL.</li>\n<li>semver.gte(process.version, ‘7.0.0’)  版本的比对 </li>\n<li>pkgfiles  自动再package中添加 npm publish 文件</li>\n<li>depd  标注方法deprecating </li>\n<li>http-errors   http错误  </li>\n<li>Global-tunnel  http请求的全局代理  </li>\n<li>humanize-ms  转义为ms  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">transform humanize time to ms  ms(&#x27;1s&#x27;) // 1000</span><br><span class=\"line\">ms(1000) // 1000</span><br></pre></td></tr></table></figure></li>\n<li>Exceljs 一个功能强大的excel 处理包</li>\n<li>ready-callback 所有注册的事件完成后，才执行ready中方法</li>\n<li>Get-ready  NodeJS mixin to add one-time ready event，ready 后执行相关方法</li>\n<li>xml2js  将xml 转换为json </li>\n<li>debug  调试状态输出  debug&#x3D;*  debug&#x3D;work:*   </li>\n<li>delegates  node模块中代理proto中属性的方法、setter和getter</li>\n<li>chokidar filewatch </li>\n<li>Puppeteer  headless browser</li>\n<li>cross-env Run scripts that set and use environment variables across platforms</li>\n<li>simplemde  markdown editor </li>\n<li>serialize-javascript  Serialize JavaScript to a superset of JSON that includes regular expressions and functions.</li>\n</ol>\n<p>1.route-cache  express router cache</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> routeCache = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;route-cache&#x27;</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// cache route for 20 seconds</span></span><br><span class=\"line\">app.<span class=\"title function_\">get</span>(<span class=\"string\">&#x27;/index&#x27;</span>, routeCache.<span class=\"title function_\">cacheSeconds</span>(<span class=\"number\">20</span>), <span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>)&#123;</span><br><span class=\"line\">  <span class=\"comment\">// do your dirty work here...</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;you will only see this every 20 seconds.&#x27;</span>);</span><br><span class=\"line\">  res.<span class=\"title function_\">send</span>(<span class=\"string\">&#x27;this response will be cached&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p>Ws server 端的websoket </p>\n</li>\n<li><p>fastclick  解决浏览器点击的延迟</p>\n</li>\n<li><p>Qs  A querystring parsing and stringifying library with some added security.</p>\n</li>\n<li><p>lru-cache  A cache object that deletes the least-recently-used items.</p>\n</li>\n<li><p>memory-fs  A simple in-memory filesystem. Holds data in a javascript object</p>\n</li>\n<li><p>faker.js  generate massive amounts of fake data in the browser and node.js</p>\n</li>\n<li><p>parseurl 等同node url parse，加了cache</p>\n</li>\n<li><p>vue-lazy-component   Vue.js 2.x 组件级懒加载方案-Vue.js 2.x component level lazy loading solution</p>\n</li>\n<li><p>async-validator  数据验证</p>\n</li>\n<li><p>fast-safe-stringify    Safe and fast serialization alternative to JSON.stringify.</p>\n</li>\n<li><p>node-notifier   Send cross platform native notifications using Node.js.</p>\n</li>\n<li><p>dateformat   node 时间处理函数</p>\n</li>\n<li><p>agentkeepalive  defaut is keepalive</p>\n</li>\n<li><p>copy-to   copy an object’s properties to another one, include propertiy, getter and setter.</p>\n</li>\n<li><p>platform   A platform detection library that works on nearly all JavaScript platforms.</p>\n</li>\n<li><p>svg-captcha 验证码  </p>\n</li>\n<li><p>vue-virtual-scroller  加载大量数据</p>\n</li>\n<li><p>FileSaver.js  保存大于 ram的文档</p>\n</li>\n<li><p>vue-draggable-resizable  Vue2 Component for draggable and resizable elements.</p>\n</li>\n<li><p>ScrollTrigger  根据滚动位置出发事件</p>\n</li>\n<li><p>Vue Virtual Scroller   RecycleScroller 可以渲染列表中的可见项目。如果你不知道项目的大小，最好使用 DynamicScroller</p>\n</li>\n<li><p>Vuetensils  没有样式的component,可定制自己样式</p>\n</li>\n<li><p>v-calendar  日历插件</p>\n</li>\n<li><p>vue-grid-layout 可以拖拽的布局控件</p>\n</li>\n<li><p>Vue-content-loader  占位符控件</p>\n</li>\n<li><p>Sinon   node 端监控方法执行、mock、spy</p>\n</li>\n<li><p>figlet  控制台标题文字</p>\n</li>\n<li><p>Cockatiel  是一个弹性和瞬态故障处理库，如重试，断路器，超时，隔板隔离和回退之类的策略。</p>\n</li>\n<li><p>Signale  一个 Node 的日志格式库，自带16个级别，可以定制颜色和 Emoji。</p>\n</li>\n<li><p>Wiki.js  构建wiki 文档管理 </p>\n</li>\n<li><p>fast-xml-parser xml 和     json 转换</p>\n</li>\n<li><p>js-cloudimage-360-view 360度查看</p>\n</li>\n<li><p>crontab ui</p>\n</li>\n<li><p>X-spreadsheet css 实现的sheet</p>\n</li>\n<li><p>SitDown  <a href=\"http://domchristie.github.io/turndown/\">html to markdown</a></p>\n</li>\n<li><p>Wekan 一个开源的看板软件</p>\n</li>\n<li><p>droppy  提供web界面的可本地部署的文件管理</p>\n</li>\n<li><p>uplot 渲染大量数据，占用资源少</p>\n</li>\n<li><p><a href=\"https://github.com/jlongster/absurd-sql\">https://github.com/jlongster/absurd-sql</a>  sqllite 对indexdb的封装</p>\n</li>\n<li><p><a href=\"https://www.npmjs.com/package/zx\">https://www.npmjs.com/package/zx</a>   zx node shell 的脚本终极方案</p>\n</li>\n<li><p>vueuse vue hooks 比较全的</p>\n</li>\n<li><p>splitpane 拖拽布局控件 <a href=\"https://antoniandre.github.io/splitpanes/\">https://antoniandre.github.io/splitpanes/</a></p>\n</li>\n<li><p>chan  A golang like channel implementation for JavaScript that works well with co.</p>\n</li>\n<li><p>pump  When using standard source.pipe(dest) source will not be destroyed if dest emits close or an error. You are also not able to provide a callback to tell when then pipe has finished.</p>\n</li>\n<li><p>npx cloc path 用来统计代码行数</p>\n</li>\n<li><p>acorn  A tiny, fast JavaScript parser written in JavaScript.</p>\n</li>\n<li><p>picocolors  The tiniest and the fastest library for terminal output formatting with ANSI colors.添加背景色的。</p>\n</li>\n<li><p>hash-sum  blazing fast unique hash generator</p>\n</li>\n<li><p>micromatch  Glob matching for javascript&#x2F;node.js. A replacement and faster alternative to minimatch and multimatch.</p>\n</li>\n<li><p>xterm-addon-attach  An addon for xterm.js that enables attaching to a web socket. This addon requires xterm.js v4+.</p>\n</li>\n<li><p>node-pty 虚拟的terminal forkpty(3) bindings for node.js. This allows you to fork processes with pseudoterminal file descriptors. It returns a terminal object which allows reads and writes.<br>  asdf</p>\n</li>\n<li><p>dom-to-image 一个可以将任意DOM节点转换为用JavaScript编写的矢量（SVG）或光栅（PNG或JPEG）图像的库</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><p>Vue-intro  新功能引导  </p>\n</li>\n<li><p>zebra-editor-core  富文本编辑器</p>\n</li>\n<li><p>lucky sheet 在线的excel编辑</p>\n</li>\n<li><p>generic-pool  资源池，可以reuse 和限制一些比较贵的资源比如数据库链接。</p>\n</li>\n<li><p>Mind elixir 浏览器思维导图js module</p>\n</li>\n<li><p>cp-cli  copy 跨平台</p>\n</li>\n<li><p>markdown-it :  markdown parser</p>\n</li>\n<li><p>web-storage-cache 对HTML5 localStorage 和sessionStorage 进行了扩展，添加了超时时间，序列化方法。可以直接存储json对象，同时可以非常简单的进行超时时间的设置。</p>\n</li>\n<li><p>ImmortalDB 是在浏览器中存储持久键值数据的最佳方法。保存到 ImmortalDB 的数据被冗余地存储在 Cookies，IndexedDB 和 localStorage 中，并且如果其中的任何数据被删除或损坏，它们将不断进行自我修复。</p>\n</li>\n<li><p>localForage 是一个快速简单的 JavaScript 存储库。 它通过使用类似于 localStorage 的简单 API 来使用异步存储（IndexedDB 或 WebSQL)），进而改善你的 Web 应用程序的离线体验。</p>\n</li>\n<li><p>webworker-threads  node 多线程模块处理计算密集任务</p>\n</li>\n<li><p>Textures.js  基于d3 生成纹理</p>\n</li>\n<li><p>robotjs 控制键盘、鼠标、屏幕</p>\n</li>\n<li><p>vue-count-to  的数字滚动组件，vue-count-to是一个无依赖，轻量级的vue组件，可以自行覆盖easingFn。你可以设置 startVal 和 endVal，它会自动判断计数或倒计时</p>\n</li>\n<li><p>fullpagejs  通过调用本库可轻易创建全屏滚动网站(也称为单页网站)。 本库可创建全屏滚动网站，同时也可在网站中添加横向滚动条。</p>\n</li>\n<li><p>Opn: A better node-open. Opens stuff like websites, files, executables. Cross-platform.</p>\n</li>\n<li><p>Ora:进度条和文字。</p>\n</li>\n<li><p>joi：数据验</p>\n</li>\n<li><p>satisfies ：版本工具</p>\n</li>\n<li><p>minimist：简单的参数处理</p>\n</li>\n<li><p>read-pkg:规范化解析pkg</p>\n</li>\n<li><p>inquirer:询问时可以给出选项</p>\n</li>\n<li><p>Resovel:解析包的安装路径</p>\n</li>\n<li><p>slash:Convert Windows backslash paths to slash paths: foo\\bar ➔ foo&#x2F;bar</p>\n</li>\n<li><p>klaw-sync:回遍历出所有文件，并返回文件路径和文件夹</p>\n</li>\n<li><p>mime-types content-type 工具：1. 可以根据文件后缀获取 2. 根据content-type获取charset 3. 根据content-type 获取默认的文件名</p>\n</li>\n<li><p>CodeMirror是一个运行在浏览器中的在线代码编辑器，支持100多种语言，高度可定制。</p>\n</li>\n<li><p>@typescript-eslint&#x2F;eslint-plugin.  eslint 检测typescript </p>\n</li>\n<li><p>nanoid  A tiny, secure, URL-friendly, unique string ID generator for JavaScript.</p>\n</li>\n<li><p>mm 对mudule 中的方法mock</p>\n</li>\n<li><p>numerify  用来格式化数字 </p>\n</li>\n<li><p>utils-lite  前端提供debounce、thorttling、clone、cloneDeep 等方法</p>\n</li>\n<li><p>is-type-of   node check 数据类型</p>\n</li>\n<li><p>on-finished  Execute a callback when a HTTP request closes, finishes, or errors</p>\n</li>\n<li><p>await-event  封装了promise</p>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"title class_\">PassThrough</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;stream&#x27;</span>).<span class=\"property\">PassThrough</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">var</span> stream = <span class=\"keyword\">new</span> <span class=\"title class_\">PassThrough</span>()</span><br><span class=\"line\"><span class=\"comment\">// you attach it directly on an event emitter</span></span><br><span class=\"line\">stream.<span class=\"property\">await</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;await-event&#x27;</span>)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"title function_\">co</span>(<span class=\"keyword\">function</span>* () &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> chunk = <span class=\"keyword\">yield</span> stream.<span class=\"title function_\">await</span>(<span class=\"string\">&#x27;data&#x27;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> chunk = <span class=\"keyword\">yield</span> stream.<span class=\"title function_\">await</span>(<span class=\"string\">&#x27;data&#x27;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> chunk = <span class=\"keyword\">yield</span> stream.<span class=\"title function_\">await</span>(<span class=\"string\">&#x27;data&#x27;</span>)</span><br><span class=\"line\">&#125;).<span class=\"title function_\">catch</span>(noop)</span><br><span class=\"line\"> </span><br><span class=\"line\">stream.<span class=\"title function_\">write</span>(<span class=\"string\">&#x27;some chunk’) </span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>get-ready  NodeJS mixin to add one-time ready event</li>\n<li>ShellJS 是Unix shell命令在Node.js API上的可移植实现</li>\n<li>graceful-process   graceful exit process even parent exit on SIGKILL.</li>\n<li>semver.gte(process.version, ‘7.0.0’)  版本的比对 </li>\n<li>pkgfiles  自动再package中添加 npm publish 文件</li>\n<li>depd  标注方法deprecating </li>\n<li>http-errors   http错误  </li>\n<li>Global-tunnel  http请求的全局代理  </li>\n<li>humanize-ms  转义为ms  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">transform humanize time to ms  ms(&#x27;1s&#x27;) // 1000</span><br><span class=\"line\">ms(1000) // 1000</span><br></pre></td></tr></table></figure></li>\n<li>Exceljs 一个功能强大的excel 处理包</li>\n<li>ready-callback 所有注册的事件完成后，才执行ready中方法</li>\n<li>Get-ready  NodeJS mixin to add one-time ready event，ready 后执行相关方法</li>\n<li>xml2js  将xml 转换为json </li>\n<li>debug  调试状态输出  debug&#x3D;*  debug&#x3D;work:*   </li>\n<li>delegates  node模块中代理proto中属性的方法、setter和getter</li>\n<li>chokidar filewatch </li>\n<li>Puppeteer  headless browser</li>\n<li>cross-env Run scripts that set and use environment variables across platforms</li>\n<li>simplemde  markdown editor </li>\n<li>serialize-javascript  Serialize JavaScript to a superset of JSON that includes regular expressions and functions.</li>\n</ol>\n<p>1.route-cache  express router cache</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> routeCache = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;route-cache&#x27;</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// cache route for 20 seconds</span></span><br><span class=\"line\">app.<span class=\"title function_\">get</span>(<span class=\"string\">&#x27;/index&#x27;</span>, routeCache.<span class=\"title function_\">cacheSeconds</span>(<span class=\"number\">20</span>), <span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>)&#123;</span><br><span class=\"line\">  <span class=\"comment\">// do your dirty work here...</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;you will only see this every 20 seconds.&#x27;</span>);</span><br><span class=\"line\">  res.<span class=\"title function_\">send</span>(<span class=\"string\">&#x27;this response will be cached&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p>Ws server 端的websoket </p>\n</li>\n<li><p>fastclick  解决浏览器点击的延迟</p>\n</li>\n<li><p>Qs  A querystring parsing and stringifying library with some added security.</p>\n</li>\n<li><p>lru-cache  A cache object that deletes the least-recently-used items.</p>\n</li>\n<li><p>memory-fs  A simple in-memory filesystem. Holds data in a javascript object</p>\n</li>\n<li><p>faker.js  generate massive amounts of fake data in the browser and node.js</p>\n</li>\n<li><p>parseurl 等同node url parse，加了cache</p>\n</li>\n<li><p>vue-lazy-component   Vue.js 2.x 组件级懒加载方案-Vue.js 2.x component level lazy loading solution</p>\n</li>\n<li><p>async-validator  数据验证</p>\n</li>\n<li><p>fast-safe-stringify    Safe and fast serialization alternative to JSON.stringify.</p>\n</li>\n<li><p>node-notifier   Send cross platform native notifications using Node.js.</p>\n</li>\n<li><p>dateformat   node 时间处理函数</p>\n</li>\n<li><p>agentkeepalive  defaut is keepalive</p>\n</li>\n<li><p>copy-to   copy an object’s properties to another one, include propertiy, getter and setter.</p>\n</li>\n<li><p>platform   A platform detection library that works on nearly all JavaScript platforms.</p>\n</li>\n<li><p>svg-captcha 验证码  </p>\n</li>\n<li><p>vue-virtual-scroller  加载大量数据</p>\n</li>\n<li><p>FileSaver.js  保存大于 ram的文档</p>\n</li>\n<li><p>vue-draggable-resizable  Vue2 Component for draggable and resizable elements.</p>\n</li>\n<li><p>ScrollTrigger  根据滚动位置出发事件</p>\n</li>\n<li><p>Vue Virtual Scroller   RecycleScroller 可以渲染列表中的可见项目。如果你不知道项目的大小，最好使用 DynamicScroller</p>\n</li>\n<li><p>Vuetensils  没有样式的component,可定制自己样式</p>\n</li>\n<li><p>v-calendar  日历插件</p>\n</li>\n<li><p>vue-grid-layout 可以拖拽的布局控件</p>\n</li>\n<li><p>Vue-content-loader  占位符控件</p>\n</li>\n<li><p>Sinon   node 端监控方法执行、mock、spy</p>\n</li>\n<li><p>figlet  控制台标题文字</p>\n</li>\n<li><p>Cockatiel  是一个弹性和瞬态故障处理库，如重试，断路器，超时，隔板隔离和回退之类的策略。</p>\n</li>\n<li><p>Signale  一个 Node 的日志格式库，自带16个级别，可以定制颜色和 Emoji。</p>\n</li>\n<li><p>Wiki.js  构建wiki 文档管理 </p>\n</li>\n<li><p>fast-xml-parser xml 和     json 转换</p>\n</li>\n<li><p>js-cloudimage-360-view 360度查看</p>\n</li>\n<li><p>crontab ui</p>\n</li>\n<li><p>X-spreadsheet css 实现的sheet</p>\n</li>\n<li><p>SitDown  <a href=\"http://domchristie.github.io/turndown/\">html to markdown</a></p>\n</li>\n<li><p>Wekan 一个开源的看板软件</p>\n</li>\n<li><p>droppy  提供web界面的可本地部署的文件管理</p>\n</li>\n<li><p>uplot 渲染大量数据，占用资源少</p>\n</li>\n<li><p><a href=\"https://github.com/jlongster/absurd-sql\">https://github.com/jlongster/absurd-sql</a>  sqllite 对indexdb的封装</p>\n</li>\n<li><p><a href=\"https://www.npmjs.com/package/zx\">https://www.npmjs.com/package/zx</a>   zx node shell 的脚本终极方案</p>\n</li>\n<li><p>vueuse vue hooks 比较全的</p>\n</li>\n<li><p>splitpane 拖拽布局控件 <a href=\"https://antoniandre.github.io/splitpanes/\">https://antoniandre.github.io/splitpanes/</a></p>\n</li>\n<li><p>chan  A golang like channel implementation for JavaScript that works well with co.</p>\n</li>\n<li><p>pump  When using standard source.pipe(dest) source will not be destroyed if dest emits close or an error. You are also not able to provide a callback to tell when then pipe has finished.</p>\n</li>\n<li><p>npx cloc path 用来统计代码行数</p>\n</li>\n<li><p>acorn  A tiny, fast JavaScript parser written in JavaScript.</p>\n</li>\n<li><p>picocolors  The tiniest and the fastest library for terminal output formatting with ANSI colors.添加背景色的。</p>\n</li>\n<li><p>hash-sum  blazing fast unique hash generator</p>\n</li>\n<li><p>micromatch  Glob matching for javascript&#x2F;node.js. A replacement and faster alternative to minimatch and multimatch.</p>\n</li>\n<li><p>xterm-addon-attach  An addon for xterm.js that enables attaching to a web socket. This addon requires xterm.js v4+.</p>\n</li>\n<li><p>node-pty 虚拟的terminal forkpty(3) bindings for node.js. This allows you to fork processes with pseudoterminal file descriptors. It returns a terminal object which allows reads and writes.<br>  asdf</p>\n</li>\n<li><p>dom-to-image 一个可以将任意DOM节点转换为用JavaScript编写的矢量（SVG）或光栅（PNG或JPEG）图像的库</p>\n</li>\n</ol>\n"},{"title":"pattern","date":"2016-12-26T06:05:38.000Z","_content":"##  装饰模式\n\n```\n'use strict';\nclass Sale {\n  constructor(price) {\n    [this.decoratorsList, this.price] = [[], price];\n  }\n\n  decorate(decorator) {\n    if (!Sale[decorator]) throw new Error(`decorator not exist: ${decorator}`);\n    this.decoratorsList.push(Sale[decorator]);\n  }\n\n  getPrice() {\n    for (let decorator of this.decoratorsList) {\n      this.price = decorator(this.price);\n    }\n    return this.price.toFixed(2);\n  }\n\n  static quebec(price) {\n    return price + price * 7.5 / 100;\n  }\n\n  static fedtax(price) {\n    return price + price * 5 / 100;\n  }\n}\nmodule.exports=Sale;\n```\n\n## 工厂模式\n\n\n```\n \n'use strict';\nclass CarMaker {\n  constructor() {\n    this.doors = 0;\n  }\n\n  drive() {\n    console.log(`jaja, i have ${this.doors} doors`);\n  }\n\n  static factory(type) {\n    return new CarMaker[type]();\n  }\n}\n\nCarMaker.Compact = class Compact extends CarMaker {\n  constructor() {\n    super();\n    this.doors = 4;\n  }\n};\n\nmodule.exports=CarMaker;\n\n```\n\n## 策略模式 --自行脑补\n## 单例模式\n\n\n```\n'use strict';\nlet __instance = function () {\n  let instance;\n  return (newInstance) => {\n    if (newInstance) instance = newInstance;\n    return instance;\n  }\n}();\n\nclass Universe {\n  constructor() {\n    if (__instance()) return __instance();\n    __instance(this);\n  }\n}\nmodule.exports=Universe;\n\n```\n\n##订阅者模式\n\n\n```\n/**\n * Created by ryan on 2016/8/29.\n */\n'use strict';\nclass Event {\n  constructor() {\n    this.subscribers = new Map([['any', []]]);\n  }\n\n  on(fn, type = 'any') {\n    let subs = this.subscribers;\n    if (!subs.get(type)) return subs.set(type, [fn]);\n    subs.set(type, (subs.get(type).push(fn)));\n  }\n\n  emit(content, type = 'any') {\n    for (let fn of this.subscribers.get(type)) {\n      fn(content);\n    }\n  }\n}\n\nlet event = new Event();\n\nevent.on((content) => console.log(`get published content: ${content}`), 'myEvent');\nevent.emit('jaja', 'myEvent'); //get published content: jaja\n\n```\n","source":"_posts/pattern.md","raw":"---\ntitle: pattern\ndate: 2016-12-26 14:05:38\ntags: pattern\n---\n##  装饰模式\n\n```\n'use strict';\nclass Sale {\n  constructor(price) {\n    [this.decoratorsList, this.price] = [[], price];\n  }\n\n  decorate(decorator) {\n    if (!Sale[decorator]) throw new Error(`decorator not exist: ${decorator}`);\n    this.decoratorsList.push(Sale[decorator]);\n  }\n\n  getPrice() {\n    for (let decorator of this.decoratorsList) {\n      this.price = decorator(this.price);\n    }\n    return this.price.toFixed(2);\n  }\n\n  static quebec(price) {\n    return price + price * 7.5 / 100;\n  }\n\n  static fedtax(price) {\n    return price + price * 5 / 100;\n  }\n}\nmodule.exports=Sale;\n```\n\n## 工厂模式\n\n\n```\n \n'use strict';\nclass CarMaker {\n  constructor() {\n    this.doors = 0;\n  }\n\n  drive() {\n    console.log(`jaja, i have ${this.doors} doors`);\n  }\n\n  static factory(type) {\n    return new CarMaker[type]();\n  }\n}\n\nCarMaker.Compact = class Compact extends CarMaker {\n  constructor() {\n    super();\n    this.doors = 4;\n  }\n};\n\nmodule.exports=CarMaker;\n\n```\n\n## 策略模式 --自行脑补\n## 单例模式\n\n\n```\n'use strict';\nlet __instance = function () {\n  let instance;\n  return (newInstance) => {\n    if (newInstance) instance = newInstance;\n    return instance;\n  }\n}();\n\nclass Universe {\n  constructor() {\n    if (__instance()) return __instance();\n    __instance(this);\n  }\n}\nmodule.exports=Universe;\n\n```\n\n##订阅者模式\n\n\n```\n/**\n * Created by ryan on 2016/8/29.\n */\n'use strict';\nclass Event {\n  constructor() {\n    this.subscribers = new Map([['any', []]]);\n  }\n\n  on(fn, type = 'any') {\n    let subs = this.subscribers;\n    if (!subs.get(type)) return subs.set(type, [fn]);\n    subs.set(type, (subs.get(type).push(fn)));\n  }\n\n  emit(content, type = 'any') {\n    for (let fn of this.subscribers.get(type)) {\n      fn(content);\n    }\n  }\n}\n\nlet event = new Event();\n\nevent.on((content) => console.log(`get published content: ${content}`), 'myEvent');\nevent.emit('jaja', 'myEvent'); //get published content: jaja\n\n```\n","slug":"pattern","published":1,"updated":"2020-06-29T06:22:24.362Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckzf5se04001jyy8kch13339z","content":"<h2 id=\"装饰模式\"><a href=\"#装饰模式\" class=\"headerlink\" title=\"装饰模式\"></a>装饰模式</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;use strict&apos;;</span><br><span class=\"line\">class Sale &#123;</span><br><span class=\"line\">  constructor(price) &#123;</span><br><span class=\"line\">    [this.decoratorsList, this.price] = [[], price];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  decorate(decorator) &#123;</span><br><span class=\"line\">    if (!Sale[decorator]) throw new Error(`decorator not exist: $&#123;decorator&#125;`);</span><br><span class=\"line\">    this.decoratorsList.push(Sale[decorator]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  getPrice() &#123;</span><br><span class=\"line\">    for (let decorator of this.decoratorsList) &#123;</span><br><span class=\"line\">      this.price = decorator(this.price);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return this.price.toFixed(2);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  static quebec(price) &#123;</span><br><span class=\"line\">    return price + price * 7.5 / 100;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  static fedtax(price) &#123;</span><br><span class=\"line\">    return price + price * 5 / 100;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">module.exports=Sale;</span><br></pre></td></tr></table></figure>\n<h2 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> </span><br><span class=\"line\">&apos;use strict&apos;;</span><br><span class=\"line\">class CarMaker &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    this.doors = 0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  drive() &#123;</span><br><span class=\"line\">    console.log(`jaja, i have $&#123;this.doors&#125; doors`);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  static factory(type) &#123;</span><br><span class=\"line\">    return new CarMaker[type]();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">CarMaker.Compact = class Compact extends CarMaker &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    super();</span><br><span class=\"line\">    this.doors = 4;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports=CarMaker;</span><br></pre></td></tr></table></figure>\n<h2 id=\"策略模式-–自行脑补\"><a href=\"#策略模式-–自行脑补\" class=\"headerlink\" title=\"策略模式 –自行脑补\"></a>策略模式 –自行脑补</h2><h2 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;use strict&apos;;</span><br><span class=\"line\">let __instance = function () &#123;</span><br><span class=\"line\">  let instance;</span><br><span class=\"line\">  return (newInstance) =&gt; &#123;</span><br><span class=\"line\">    if (newInstance) instance = newInstance;</span><br><span class=\"line\">    return instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;();</span><br><span class=\"line\"></span><br><span class=\"line\">class Universe &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    if (__instance()) return __instance();</span><br><span class=\"line\">    __instance(this);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">module.exports=Universe;</span><br></pre></td></tr></table></figure>\n<p>##订阅者模式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Created by ryan on 2016/8/29.</span><br><span class=\"line\"> */</span><br><span class=\"line\">&apos;use strict&apos;;</span><br><span class=\"line\">class Event &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    this.subscribers = new Map([[&apos;any&apos;, []]]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  on(fn, type = &apos;any&apos;) &#123;</span><br><span class=\"line\">    let subs = this.subscribers;</span><br><span class=\"line\">    if (!subs.get(type)) return subs.set(type, [fn]);</span><br><span class=\"line\">    subs.set(type, (subs.get(type).push(fn)));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  emit(content, type = &apos;any&apos;) &#123;</span><br><span class=\"line\">    for (let fn of this.subscribers.get(type)) &#123;</span><br><span class=\"line\">      fn(content);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let event = new Event();</span><br><span class=\"line\"></span><br><span class=\"line\">event.on((content) =&gt; console.log(`get published content: $&#123;content&#125;`), &apos;myEvent&apos;);</span><br><span class=\"line\">event.emit(&apos;jaja&apos;, &apos;myEvent&apos;); //get published content: jaja</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"装饰模式\"><a href=\"#装饰模式\" class=\"headerlink\" title=\"装饰模式\"></a>装饰模式</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;use strict&apos;;</span><br><span class=\"line\">class Sale &#123;</span><br><span class=\"line\">  constructor(price) &#123;</span><br><span class=\"line\">    [this.decoratorsList, this.price] = [[], price];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  decorate(decorator) &#123;</span><br><span class=\"line\">    if (!Sale[decorator]) throw new Error(`decorator not exist: $&#123;decorator&#125;`);</span><br><span class=\"line\">    this.decoratorsList.push(Sale[decorator]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  getPrice() &#123;</span><br><span class=\"line\">    for (let decorator of this.decoratorsList) &#123;</span><br><span class=\"line\">      this.price = decorator(this.price);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return this.price.toFixed(2);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  static quebec(price) &#123;</span><br><span class=\"line\">    return price + price * 7.5 / 100;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  static fedtax(price) &#123;</span><br><span class=\"line\">    return price + price * 5 / 100;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">module.exports=Sale;</span><br></pre></td></tr></table></figure>\n<h2 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> </span><br><span class=\"line\">&apos;use strict&apos;;</span><br><span class=\"line\">class CarMaker &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    this.doors = 0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  drive() &#123;</span><br><span class=\"line\">    console.log(`jaja, i have $&#123;this.doors&#125; doors`);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  static factory(type) &#123;</span><br><span class=\"line\">    return new CarMaker[type]();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">CarMaker.Compact = class Compact extends CarMaker &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    super();</span><br><span class=\"line\">    this.doors = 4;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports=CarMaker;</span><br></pre></td></tr></table></figure>\n<h2 id=\"策略模式-–自行脑补\"><a href=\"#策略模式-–自行脑补\" class=\"headerlink\" title=\"策略模式 –自行脑补\"></a>策略模式 –自行脑补</h2><h2 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;use strict&apos;;</span><br><span class=\"line\">let __instance = function () &#123;</span><br><span class=\"line\">  let instance;</span><br><span class=\"line\">  return (newInstance) =&gt; &#123;</span><br><span class=\"line\">    if (newInstance) instance = newInstance;</span><br><span class=\"line\">    return instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;();</span><br><span class=\"line\"></span><br><span class=\"line\">class Universe &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    if (__instance()) return __instance();</span><br><span class=\"line\">    __instance(this);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">module.exports=Universe;</span><br></pre></td></tr></table></figure>\n<p>##订阅者模式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Created by ryan on 2016/8/29.</span><br><span class=\"line\"> */</span><br><span class=\"line\">&apos;use strict&apos;;</span><br><span class=\"line\">class Event &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    this.subscribers = new Map([[&apos;any&apos;, []]]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  on(fn, type = &apos;any&apos;) &#123;</span><br><span class=\"line\">    let subs = this.subscribers;</span><br><span class=\"line\">    if (!subs.get(type)) return subs.set(type, [fn]);</span><br><span class=\"line\">    subs.set(type, (subs.get(type).push(fn)));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  emit(content, type = &apos;any&apos;) &#123;</span><br><span class=\"line\">    for (let fn of this.subscribers.get(type)) &#123;</span><br><span class=\"line\">      fn(content);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let event = new Event();</span><br><span class=\"line\"></span><br><span class=\"line\">event.on((content) =&gt; console.log(`get published content: $&#123;content&#125;`), &apos;myEvent&apos;);</span><br><span class=\"line\">event.emit(&apos;jaja&apos;, &apos;myEvent&apos;); //get published content: jaja</span><br></pre></td></tr></table></figure>\n"},{"title":"manage","date":"2021-04-30T10:54:37.000Z","_content":"\n1. P8 提升技术能力的关键是什么呢？答案是技术深度和技术宽度齐头并进。而 P7 升 P8 的时候，在公司和业界的技术影响力恰恰是评委考察的一个重要方面。\n2. 为能够自主规划一些有利于晋升的工作。但是反过来说，Team Leader 也充满了挑战性，因为大部分人并没有系统地学习和练习过管理技能，所以在实际管理工作中很容易走极端。\n3. P8 来说，能不能拿到好的业务结果，这一点在考核中所占的比重要大得多，基本上和技术能力是平起平坐的地位。这就是 P7 很难晋升 P8 的第二个原因。\n4.  P8 需要负责指挥多个团队，提升自己管理技能的核心是学会抓住三个管理重点：搭建团队梯队，参与目标制定，关注技术演进。好的业务机会本身就非常稀缺，毕竟行业的风口并不是经常有的，业务上大的发展和突破也不是年年都有。而如果业务本身没有大的发展或者突破，相关的各种机会就会比较少\n5.  5W 指的是 5 个不同的英文单词：When（何时）、Where（何地）、Who（何人）、What（何事）、Why（何因），代表需求产生的背景和功能上线后的运行环境，类似于操作系统上下文（Context）的概念。\n6.  一类是核心人员流失，它导致很多重要工作无法开展，所以你需要提前培养核心人员的备份人员，搭建合理的团队梯度。\n7.  深度：理解vue、react 等源码、面向对象对象的学习，ts 设计模式，走技术专家的路线。在业务上也要懂，客户有啥需求，都能给出解决方案；在需求评审试，给出相应的意见。\n    广度：前端各种技术平台、electron、flutter ","source":"_posts/manage.md","raw":"---\ntitle: manage\ndate: 2021-04-30 18:54:37\ntags:\n---\n\n1. P8 提升技术能力的关键是什么呢？答案是技术深度和技术宽度齐头并进。而 P7 升 P8 的时候，在公司和业界的技术影响力恰恰是评委考察的一个重要方面。\n2. 为能够自主规划一些有利于晋升的工作。但是反过来说，Team Leader 也充满了挑战性，因为大部分人并没有系统地学习和练习过管理技能，所以在实际管理工作中很容易走极端。\n3. P8 来说，能不能拿到好的业务结果，这一点在考核中所占的比重要大得多，基本上和技术能力是平起平坐的地位。这就是 P7 很难晋升 P8 的第二个原因。\n4.  P8 需要负责指挥多个团队，提升自己管理技能的核心是学会抓住三个管理重点：搭建团队梯队，参与目标制定，关注技术演进。好的业务机会本身就非常稀缺，毕竟行业的风口并不是经常有的，业务上大的发展和突破也不是年年都有。而如果业务本身没有大的发展或者突破，相关的各种机会就会比较少\n5.  5W 指的是 5 个不同的英文单词：When（何时）、Where（何地）、Who（何人）、What（何事）、Why（何因），代表需求产生的背景和功能上线后的运行环境，类似于操作系统上下文（Context）的概念。\n6.  一类是核心人员流失，它导致很多重要工作无法开展，所以你需要提前培养核心人员的备份人员，搭建合理的团队梯度。\n7.  深度：理解vue、react 等源码、面向对象对象的学习，ts 设计模式，走技术专家的路线。在业务上也要懂，客户有啥需求，都能给出解决方案；在需求评审试，给出相应的意见。\n    广度：前端各种技术平台、electron、flutter ","slug":"manage","published":1,"updated":"2021-04-30T10:57:52.461Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckzf5se05001lyy8kncpfac8g","content":"<ol>\n<li>P8 提升技术能力的关键是什么呢？答案是技术深度和技术宽度齐头并进。而 P7 升 P8 的时候，在公司和业界的技术影响力恰恰是评委考察的一个重要方面。</li>\n<li>为能够自主规划一些有利于晋升的工作。但是反过来说，Team Leader 也充满了挑战性，因为大部分人并没有系统地学习和练习过管理技能，所以在实际管理工作中很容易走极端。</li>\n<li>P8 来说，能不能拿到好的业务结果，这一点在考核中所占的比重要大得多，基本上和技术能力是平起平坐的地位。这就是 P7 很难晋升 P8 的第二个原因。</li>\n<li>P8 需要负责指挥多个团队，提升自己管理技能的核心是学会抓住三个管理重点：搭建团队梯队，参与目标制定，关注技术演进。好的业务机会本身就非常稀缺，毕竟行业的风口并不是经常有的，业务上大的发展和突破也不是年年都有。而如果业务本身没有大的发展或者突破，相关的各种机会就会比较少</li>\n<li>5W 指的是 5 个不同的英文单词：When（何时）、Where（何地）、Who（何人）、What（何事）、Why（何因），代表需求产生的背景和功能上线后的运行环境，类似于操作系统上下文（Context）的概念。</li>\n<li>一类是核心人员流失，它导致很多重要工作无法开展，所以你需要提前培养核心人员的备份人员，搭建合理的团队梯度。</li>\n<li>深度：理解vue、react 等源码、面向对象对象的学习，ts 设计模式，走技术专家的路线。在业务上也要懂，客户有啥需求，都能给出解决方案；在需求评审试，给出相应的意见。<br>广度：前端各种技术平台、electron、flutter </li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>P8 提升技术能力的关键是什么呢？答案是技术深度和技术宽度齐头并进。而 P7 升 P8 的时候，在公司和业界的技术影响力恰恰是评委考察的一个重要方面。</li>\n<li>为能够自主规划一些有利于晋升的工作。但是反过来说，Team Leader 也充满了挑战性，因为大部分人并没有系统地学习和练习过管理技能，所以在实际管理工作中很容易走极端。</li>\n<li>P8 来说，能不能拿到好的业务结果，这一点在考核中所占的比重要大得多，基本上和技术能力是平起平坐的地位。这就是 P7 很难晋升 P8 的第二个原因。</li>\n<li>P8 需要负责指挥多个团队，提升自己管理技能的核心是学会抓住三个管理重点：搭建团队梯队，参与目标制定，关注技术演进。好的业务机会本身就非常稀缺，毕竟行业的风口并不是经常有的，业务上大的发展和突破也不是年年都有。而如果业务本身没有大的发展或者突破，相关的各种机会就会比较少</li>\n<li>5W 指的是 5 个不同的英文单词：When（何时）、Where（何地）、Who（何人）、What（何事）、Why（何因），代表需求产生的背景和功能上线后的运行环境，类似于操作系统上下文（Context）的概念。</li>\n<li>一类是核心人员流失，它导致很多重要工作无法开展，所以你需要提前培养核心人员的备份人员，搭建合理的团队梯度。</li>\n<li>深度：理解vue、react 等源码、面向对象对象的学习，ts 设计模式，走技术专家的路线。在业务上也要懂，客户有啥需求，都能给出解决方案；在需求评审试，给出相应的意见。<br>广度：前端各种技术平台、electron、flutter </li>\n</ol>\n"},{"title":"pm2","date":"2016-12-29T09:53:39.000Z","_content":"### pm2 start 启动文件的设置\n\n1. 通过 pm2 ecosystem 生成文件\n2. 在配置文件中配置，主要参数如下：\n　　\n```\nmin_uptime：最小运行时间，这里设置的是60s即如果应用程序在60s内退出，pm2会认为程序异常退出，此时触发重启max_restarts设置数量\n\nexec_mode：应用程序启动模式，这里设置的是cluster_mode（集群），默认是fork\nerror_file：自定义应用程序的错误日志文件\nout_file：自定义应用程序日志文件\npid_file：自定义应用程序的pid文件\nwatch：是否启用监控模式，默认是false。如果设置成true，当应用程序变动时，pm2会自动重载。这里也可以设置你要监控的文件\n\nexec_interpreter：应用程序的脚本类型，这里使用的shell，默认是nodejs\ndefaults to “node”. can be “python”, “ruby”, “bash” or whatever interpreter you wish to use. “none” will execute your app as a binary executable\n\n当使用babel的时候： exec_interpreter:\"babel-node\"\n \nmax_memory_restart  超出这个内存后会重新启动\n\n```\n\n3. 可以设置watch 的目录\n   \n```\n{\n  \"name\"        : \"fis-receiver\",  // 应用名称\n  \"script\"      : \"./bin/www\",  // 实际启动脚本\n  \"cwd\"         : \"./\",  // 当前工作路径\n  \"watch\": [  // 监控变化的目录，一旦变化，自动重启\n    \"bin\",\n    \"routers\"\n  ],\n  \"ignore_watch\" : [  // 从监控目录中排除\n    \"node_modules\", \n    \"logs\",\n    \"public\"\n  ],\n  \"watch_options\": {\n    \"followSymlinks\": false\n  },\n  \"error_file\" : \"./logs/app-err.log\",  // 错误日志路径\n  \"out_file\"   : \"./logs/app-out.log\",  // 普通日志路径\n  \"env\": {\n      \"NODE_ENV\": \"production\"  // 环境参数，当前指定为生产环境\n  }\n}\n```\n\n","source":"_posts/pm2.md","raw":"---\ntitle: pm2\ndate: 2016-12-29 17:53:39\ntags: pm2 \n---\n### pm2 start 启动文件的设置\n\n1. 通过 pm2 ecosystem 生成文件\n2. 在配置文件中配置，主要参数如下：\n　　\n```\nmin_uptime：最小运行时间，这里设置的是60s即如果应用程序在60s内退出，pm2会认为程序异常退出，此时触发重启max_restarts设置数量\n\nexec_mode：应用程序启动模式，这里设置的是cluster_mode（集群），默认是fork\nerror_file：自定义应用程序的错误日志文件\nout_file：自定义应用程序日志文件\npid_file：自定义应用程序的pid文件\nwatch：是否启用监控模式，默认是false。如果设置成true，当应用程序变动时，pm2会自动重载。这里也可以设置你要监控的文件\n\nexec_interpreter：应用程序的脚本类型，这里使用的shell，默认是nodejs\ndefaults to “node”. can be “python”, “ruby”, “bash” or whatever interpreter you wish to use. “none” will execute your app as a binary executable\n\n当使用babel的时候： exec_interpreter:\"babel-node\"\n \nmax_memory_restart  超出这个内存后会重新启动\n\n```\n\n3. 可以设置watch 的目录\n   \n```\n{\n  \"name\"        : \"fis-receiver\",  // 应用名称\n  \"script\"      : \"./bin/www\",  // 实际启动脚本\n  \"cwd\"         : \"./\",  // 当前工作路径\n  \"watch\": [  // 监控变化的目录，一旦变化，自动重启\n    \"bin\",\n    \"routers\"\n  ],\n  \"ignore_watch\" : [  // 从监控目录中排除\n    \"node_modules\", \n    \"logs\",\n    \"public\"\n  ],\n  \"watch_options\": {\n    \"followSymlinks\": false\n  },\n  \"error_file\" : \"./logs/app-err.log\",  // 错误日志路径\n  \"out_file\"   : \"./logs/app-out.log\",  // 普通日志路径\n  \"env\": {\n      \"NODE_ENV\": \"production\"  // 环境参数，当前指定为生产环境\n  }\n}\n```\n\n","slug":"pm2","published":1,"updated":"2020-06-29T06:22:24.362Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckzf5se05001nyy8k5e3tjozz","content":"<h3 id=\"pm2-start-启动文件的设置\"><a href=\"#pm2-start-启动文件的设置\" class=\"headerlink\" title=\"pm2 start 启动文件的设置\"></a>pm2 start 启动文件的设置</h3><ol>\n<li>通过 pm2 ecosystem 生成文件</li>\n<li><p>在配置文件中配置，主要参数如下：\n　　</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">min_uptime：最小运行时间，这里设置的是60s即如果应用程序在60s内退出，pm2会认为程序异常退出，此时触发重启max_restarts设置数量</span><br><span class=\"line\"></span><br><span class=\"line\">exec_mode：应用程序启动模式，这里设置的是cluster_mode（集群），默认是fork</span><br><span class=\"line\">error_file：自定义应用程序的错误日志文件</span><br><span class=\"line\">out_file：自定义应用程序日志文件</span><br><span class=\"line\">pid_file：自定义应用程序的pid文件</span><br><span class=\"line\">watch：是否启用监控模式，默认是false。如果设置成true，当应用程序变动时，pm2会自动重载。这里也可以设置你要监控的文件</span><br><span class=\"line\"></span><br><span class=\"line\">exec_interpreter：应用程序的脚本类型，这里使用的shell，默认是nodejs</span><br><span class=\"line\">defaults to “node”. can be “python”, “ruby”, “bash” or whatever interpreter you wish to use. “none” will execute your app as a binary executable</span><br><span class=\"line\"></span><br><span class=\"line\">当使用babel的时候： exec_interpreter:&quot;babel-node&quot;</span><br><span class=\"line\"> </span><br><span class=\"line\">max_memory_restart  超出这个内存后会重新启动</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>可以设置watch 的目录</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;name&quot;        : &quot;fis-receiver&quot;,  // 应用名称</span><br><span class=\"line\">  &quot;script&quot;      : &quot;./bin/www&quot;,  // 实际启动脚本</span><br><span class=\"line\">  &quot;cwd&quot;         : &quot;./&quot;,  // 当前工作路径</span><br><span class=\"line\">  &quot;watch&quot;: [  // 监控变化的目录，一旦变化，自动重启</span><br><span class=\"line\">    &quot;bin&quot;,</span><br><span class=\"line\">    &quot;routers&quot;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  &quot;ignore_watch&quot; : [  // 从监控目录中排除</span><br><span class=\"line\">    &quot;node_modules&quot;, </span><br><span class=\"line\">    &quot;logs&quot;,</span><br><span class=\"line\">    &quot;public&quot;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  &quot;watch_options&quot;: &#123;</span><br><span class=\"line\">    &quot;followSymlinks&quot;: false</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;error_file&quot; : &quot;./logs/app-err.log&quot;,  // 错误日志路径</span><br><span class=\"line\">  &quot;out_file&quot;   : &quot;./logs/app-out.log&quot;,  // 普通日志路径</span><br><span class=\"line\">  &quot;env&quot;: &#123;</span><br><span class=\"line\">      &quot;NODE_ENV&quot;: &quot;production&quot;  // 环境参数，当前指定为生产环境</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"pm2-start-启动文件的设置\"><a href=\"#pm2-start-启动文件的设置\" class=\"headerlink\" title=\"pm2 start 启动文件的设置\"></a>pm2 start 启动文件的设置</h3><ol>\n<li>通过 pm2 ecosystem 生成文件</li>\n<li><p>在配置文件中配置，主要参数如下：\n　　</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">min_uptime：最小运行时间，这里设置的是60s即如果应用程序在60s内退出，pm2会认为程序异常退出，此时触发重启max_restarts设置数量</span><br><span class=\"line\"></span><br><span class=\"line\">exec_mode：应用程序启动模式，这里设置的是cluster_mode（集群），默认是fork</span><br><span class=\"line\">error_file：自定义应用程序的错误日志文件</span><br><span class=\"line\">out_file：自定义应用程序日志文件</span><br><span class=\"line\">pid_file：自定义应用程序的pid文件</span><br><span class=\"line\">watch：是否启用监控模式，默认是false。如果设置成true，当应用程序变动时，pm2会自动重载。这里也可以设置你要监控的文件</span><br><span class=\"line\"></span><br><span class=\"line\">exec_interpreter：应用程序的脚本类型，这里使用的shell，默认是nodejs</span><br><span class=\"line\">defaults to “node”. can be “python”, “ruby”, “bash” or whatever interpreter you wish to use. “none” will execute your app as a binary executable</span><br><span class=\"line\"></span><br><span class=\"line\">当使用babel的时候： exec_interpreter:&quot;babel-node&quot;</span><br><span class=\"line\"> </span><br><span class=\"line\">max_memory_restart  超出这个内存后会重新启动</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>可以设置watch 的目录</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;name&quot;        : &quot;fis-receiver&quot;,  // 应用名称</span><br><span class=\"line\">  &quot;script&quot;      : &quot;./bin/www&quot;,  // 实际启动脚本</span><br><span class=\"line\">  &quot;cwd&quot;         : &quot;./&quot;,  // 当前工作路径</span><br><span class=\"line\">  &quot;watch&quot;: [  // 监控变化的目录，一旦变化，自动重启</span><br><span class=\"line\">    &quot;bin&quot;,</span><br><span class=\"line\">    &quot;routers&quot;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  &quot;ignore_watch&quot; : [  // 从监控目录中排除</span><br><span class=\"line\">    &quot;node_modules&quot;, </span><br><span class=\"line\">    &quot;logs&quot;,</span><br><span class=\"line\">    &quot;public&quot;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  &quot;watch_options&quot;: &#123;</span><br><span class=\"line\">    &quot;followSymlinks&quot;: false</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;error_file&quot; : &quot;./logs/app-err.log&quot;,  // 错误日志路径</span><br><span class=\"line\">  &quot;out_file&quot;   : &quot;./logs/app-out.log&quot;,  // 普通日志路径</span><br><span class=\"line\">  &quot;env&quot;: &#123;</span><br><span class=\"line\">      &quot;NODE_ENV&quot;: &quot;production&quot;  // 环境参数，当前指定为生产环境</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"postgre","date":"2017-02-21T03:18:37.000Z","_content":"\n```\ndb.many(query, values); // expects one or more rows\ndb.one(query, values); // expects a single row\ndb.none(query, values); // expects no rows\ndb.any(query, values); // expects anything, same as `manyOrNone`\ndb.oneOrNone(query, values); // expects 1 or 0 rows\ndb.manyOrNone(query, values); // expects anything, same as `any`\n```\n\nThe library supports named parameters in query formatting, with the syntax of $*propName*, where * is any of the following open-close pairs: {}, (), <>, [], //\n\n\n```\ndb.query('SELECT * FROM users WHERE name=${name} AND active=$/active/', {\n    name: 'John',\n    active: true\n});\n```\n\nthis 的用法：\n```\nvar doc = {\n    id: 123,\n    body: \"some text\"\n};\n\ndb.none(\"INSERT INTO documents(id, doc) VALUES(${id}, ${this})\", doc)\n    .then(function () {\n        // success;\n    })\n    .catch(function (error) {\n        // error;\n    });\n```\n\nwhich will execute:\n\nINSERT INTO documents(id, doc) VALUES(123, '{\"id\":123,\"body\":\"some text\"}')\n\n\n执行函数\n\nAnd when you are not expecting any return results, call db.proc instead. Both methods return a Promise object, but db.proc doesn't take a qrm parameter, always assuming it is one|none.\n```\ndb.func('findAudit', [123, new Date()])\n    .then(function (data) {\n        console.log(data); // printing the data returned \n    })\n    .catch(function (error) {\n        console.log(error); // printing the error \n    });\ndb.proc();\n```\n\n公用一个连接：\n\n```\ndb.task(function (t) {\n    // `t` and `this` here are the same;\n    // execute a chain of queries;\n})\n    .then(function (data) {\n        // success;\n    })\n    .catch(function (error) {\n        // failed;    \n    });\n```\n\n事物：其中可以嵌套事物\n\n```\ndb.tx(function (t) {\n    // t = this;\n    return t.batch([\n        t.one(\"insert into users(name) values($1) returning id\", \"John\"),\n        t.one(\"insert into events(code) values($1) returning id\", 123)\n    ]);\n})\n    .spread(function (user, event) {\n        // print new user id + new event id;\n        console.log(\"DATA:\", user.id, event.id);\n    })\n    .catch(function (error) {\n        console.log(\"ERROR:\", error); // print the error;\n    })\n    .finally(function () {\n    \n\n        pgp.end(); // for immediate app exit, closing the connection pool.   关闭连接池，是的一般不需要\n        \n        If, however you normally exit your application by killing the NodeJS process, then you don't need to use it.\n\n        \n    });\n```\n\n设置隔离级别：\n\n```\nvar TransactionMode = pgp.txMode.TransactionMode;\nvar isolationLevel = pgp.txMode.isolationLevel;\n\n// Create a reusable transaction mode (serializable + read-only + deferrable):\nvar tmSRD = new TransactionMode({\n    tiLevel: isolationLevel.serializable,\n    readOnly: true,\n    deferrable: true\n});\n\nfunction myTransaction() {\n    return this.query('SELECT * FROM table');\n}\n\nmyTransaction.txMode = tmSRD; // assign transaction mode;\n\ndb.tx(myTransaction)\n    .then(function(){\n        // success;\n    });\n```\n重置promise：\n\n```\nvar promise = require('bluebird');\nvar options = {\n    promiseLib: promise\n};\nvar pgp = require('pg-promise')(options);\n```\n\n","source":"_posts/postgre.md","raw":"---\ntitle: postgre\ndate: 2017-02-21 11:18:37\ntags: postgre\n---\n\n```\ndb.many(query, values); // expects one or more rows\ndb.one(query, values); // expects a single row\ndb.none(query, values); // expects no rows\ndb.any(query, values); // expects anything, same as `manyOrNone`\ndb.oneOrNone(query, values); // expects 1 or 0 rows\ndb.manyOrNone(query, values); // expects anything, same as `any`\n```\n\nThe library supports named parameters in query formatting, with the syntax of $*propName*, where * is any of the following open-close pairs: {}, (), <>, [], //\n\n\n```\ndb.query('SELECT * FROM users WHERE name=${name} AND active=$/active/', {\n    name: 'John',\n    active: true\n});\n```\n\nthis 的用法：\n```\nvar doc = {\n    id: 123,\n    body: \"some text\"\n};\n\ndb.none(\"INSERT INTO documents(id, doc) VALUES(${id}, ${this})\", doc)\n    .then(function () {\n        // success;\n    })\n    .catch(function (error) {\n        // error;\n    });\n```\n\nwhich will execute:\n\nINSERT INTO documents(id, doc) VALUES(123, '{\"id\":123,\"body\":\"some text\"}')\n\n\n执行函数\n\nAnd when you are not expecting any return results, call db.proc instead. Both methods return a Promise object, but db.proc doesn't take a qrm parameter, always assuming it is one|none.\n```\ndb.func('findAudit', [123, new Date()])\n    .then(function (data) {\n        console.log(data); // printing the data returned \n    })\n    .catch(function (error) {\n        console.log(error); // printing the error \n    });\ndb.proc();\n```\n\n公用一个连接：\n\n```\ndb.task(function (t) {\n    // `t` and `this` here are the same;\n    // execute a chain of queries;\n})\n    .then(function (data) {\n        // success;\n    })\n    .catch(function (error) {\n        // failed;    \n    });\n```\n\n事物：其中可以嵌套事物\n\n```\ndb.tx(function (t) {\n    // t = this;\n    return t.batch([\n        t.one(\"insert into users(name) values($1) returning id\", \"John\"),\n        t.one(\"insert into events(code) values($1) returning id\", 123)\n    ]);\n})\n    .spread(function (user, event) {\n        // print new user id + new event id;\n        console.log(\"DATA:\", user.id, event.id);\n    })\n    .catch(function (error) {\n        console.log(\"ERROR:\", error); // print the error;\n    })\n    .finally(function () {\n    \n\n        pgp.end(); // for immediate app exit, closing the connection pool.   关闭连接池，是的一般不需要\n        \n        If, however you normally exit your application by killing the NodeJS process, then you don't need to use it.\n\n        \n    });\n```\n\n设置隔离级别：\n\n```\nvar TransactionMode = pgp.txMode.TransactionMode;\nvar isolationLevel = pgp.txMode.isolationLevel;\n\n// Create a reusable transaction mode (serializable + read-only + deferrable):\nvar tmSRD = new TransactionMode({\n    tiLevel: isolationLevel.serializable,\n    readOnly: true,\n    deferrable: true\n});\n\nfunction myTransaction() {\n    return this.query('SELECT * FROM table');\n}\n\nmyTransaction.txMode = tmSRD; // assign transaction mode;\n\ndb.tx(myTransaction)\n    .then(function(){\n        // success;\n    });\n```\n重置promise：\n\n```\nvar promise = require('bluebird');\nvar options = {\n    promiseLib: promise\n};\nvar pgp = require('pg-promise')(options);\n```\n\n","slug":"postgre","published":1,"updated":"2020-06-29T06:22:24.362Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckzf5se06001pyy8k6hle2lny","content":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.many(query, values); // expects one or more rows</span><br><span class=\"line\">db.one(query, values); // expects a single row</span><br><span class=\"line\">db.none(query, values); // expects no rows</span><br><span class=\"line\">db.any(query, values); // expects anything, same as `manyOrNone`</span><br><span class=\"line\">db.oneOrNone(query, values); // expects 1 or 0 rows</span><br><span class=\"line\">db.manyOrNone(query, values); // expects anything, same as `any`</span><br></pre></td></tr></table></figure>\n<p>The library supports named parameters in query formatting, with the syntax of $<em>propName</em>, where * is any of the following open-close pairs: {}, (), &lt;&gt;, [], //</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.query(&apos;SELECT * FROM users WHERE name=$&#123;name&#125; AND active=$/active/&apos;, &#123;</span><br><span class=\"line\">    name: &apos;John&apos;,</span><br><span class=\"line\">    active: true</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>this 的用法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var doc = &#123;</span><br><span class=\"line\">    id: 123,</span><br><span class=\"line\">    body: &quot;some text&quot;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">db.none(&quot;INSERT INTO documents(id, doc) VALUES($&#123;id&#125;, $&#123;this&#125;)&quot;, doc)</span><br><span class=\"line\">    .then(function () &#123;</span><br><span class=\"line\">        // success;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .catch(function (error) &#123;</span><br><span class=\"line\">        // error;</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>which will execute:</p>\n<p>INSERT INTO documents(id, doc) VALUES(123, ‘{“id”:123,”body”:”some text”}’)</p>\n<p>执行函数</p>\n<p>And when you are not expecting any return results, call db.proc instead. Both methods return a Promise object, but db.proc doesn’t take a qrm parameter, always assuming it is one|none.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.func(&apos;findAudit&apos;, [123, new Date()])</span><br><span class=\"line\">    .then(function (data) &#123;</span><br><span class=\"line\">        console.log(data); // printing the data returned </span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .catch(function (error) &#123;</span><br><span class=\"line\">        console.log(error); // printing the error </span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">db.proc();</span><br></pre></td></tr></table></figure></p>\n<p>公用一个连接：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.task(function (t) &#123;</span><br><span class=\"line\">    // `t` and `this` here are the same;</span><br><span class=\"line\">    // execute a chain of queries;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">    .then(function (data) &#123;</span><br><span class=\"line\">        // success;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .catch(function (error) &#123;</span><br><span class=\"line\">        // failed;    </span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>事物：其中可以嵌套事物</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.tx(function (t) &#123;</span><br><span class=\"line\">    // t = this;</span><br><span class=\"line\">    return t.batch([</span><br><span class=\"line\">        t.one(&quot;insert into users(name) values($1) returning id&quot;, &quot;John&quot;),</span><br><span class=\"line\">        t.one(&quot;insert into events(code) values($1) returning id&quot;, 123)</span><br><span class=\"line\">    ]);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">    .spread(function (user, event) &#123;</span><br><span class=\"line\">        // print new user id + new event id;</span><br><span class=\"line\">        console.log(&quot;DATA:&quot;, user.id, event.id);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .catch(function (error) &#123;</span><br><span class=\"line\">        console.log(&quot;ERROR:&quot;, error); // print the error;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .finally(function () &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">        pgp.end(); // for immediate app exit, closing the connection pool.   关闭连接池，是的一般不需要</span><br><span class=\"line\">        </span><br><span class=\"line\">        If, however you normally exit your application by killing the NodeJS process, then you don&apos;t need to use it.</span><br><span class=\"line\"></span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>设置隔离级别：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var TransactionMode = pgp.txMode.TransactionMode;</span><br><span class=\"line\">var isolationLevel = pgp.txMode.isolationLevel;</span><br><span class=\"line\"></span><br><span class=\"line\">// Create a reusable transaction mode (serializable + read-only + deferrable):</span><br><span class=\"line\">var tmSRD = new TransactionMode(&#123;</span><br><span class=\"line\">    tiLevel: isolationLevel.serializable,</span><br><span class=\"line\">    readOnly: true,</span><br><span class=\"line\">    deferrable: true</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">function myTransaction() &#123;</span><br><span class=\"line\">    return this.query(&apos;SELECT * FROM table&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">myTransaction.txMode = tmSRD; // assign transaction mode;</span><br><span class=\"line\"></span><br><span class=\"line\">db.tx(myTransaction)</span><br><span class=\"line\">    .then(function()&#123;</span><br><span class=\"line\">        // success;</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>重置promise：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var promise = require(&apos;bluebird&apos;);</span><br><span class=\"line\">var options = &#123;</span><br><span class=\"line\">    promiseLib: promise</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var pgp = require(&apos;pg-promise&apos;)(options);</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.many(query, values); // expects one or more rows</span><br><span class=\"line\">db.one(query, values); // expects a single row</span><br><span class=\"line\">db.none(query, values); // expects no rows</span><br><span class=\"line\">db.any(query, values); // expects anything, same as `manyOrNone`</span><br><span class=\"line\">db.oneOrNone(query, values); // expects 1 or 0 rows</span><br><span class=\"line\">db.manyOrNone(query, values); // expects anything, same as `any`</span><br></pre></td></tr></table></figure>\n<p>The library supports named parameters in query formatting, with the syntax of $<em>propName</em>, where * is any of the following open-close pairs: {}, (), &lt;&gt;, [], //</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.query(&apos;SELECT * FROM users WHERE name=$&#123;name&#125; AND active=$/active/&apos;, &#123;</span><br><span class=\"line\">    name: &apos;John&apos;,</span><br><span class=\"line\">    active: true</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>this 的用法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var doc = &#123;</span><br><span class=\"line\">    id: 123,</span><br><span class=\"line\">    body: &quot;some text&quot;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">db.none(&quot;INSERT INTO documents(id, doc) VALUES($&#123;id&#125;, $&#123;this&#125;)&quot;, doc)</span><br><span class=\"line\">    .then(function () &#123;</span><br><span class=\"line\">        // success;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .catch(function (error) &#123;</span><br><span class=\"line\">        // error;</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>which will execute:</p>\n<p>INSERT INTO documents(id, doc) VALUES(123, ‘{“id”:123,”body”:”some text”}’)</p>\n<p>执行函数</p>\n<p>And when you are not expecting any return results, call db.proc instead. Both methods return a Promise object, but db.proc doesn’t take a qrm parameter, always assuming it is one|none.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.func(&apos;findAudit&apos;, [123, new Date()])</span><br><span class=\"line\">    .then(function (data) &#123;</span><br><span class=\"line\">        console.log(data); // printing the data returned </span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .catch(function (error) &#123;</span><br><span class=\"line\">        console.log(error); // printing the error </span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">db.proc();</span><br></pre></td></tr></table></figure></p>\n<p>公用一个连接：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.task(function (t) &#123;</span><br><span class=\"line\">    // `t` and `this` here are the same;</span><br><span class=\"line\">    // execute a chain of queries;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">    .then(function (data) &#123;</span><br><span class=\"line\">        // success;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .catch(function (error) &#123;</span><br><span class=\"line\">        // failed;    </span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>事物：其中可以嵌套事物</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.tx(function (t) &#123;</span><br><span class=\"line\">    // t = this;</span><br><span class=\"line\">    return t.batch([</span><br><span class=\"line\">        t.one(&quot;insert into users(name) values($1) returning id&quot;, &quot;John&quot;),</span><br><span class=\"line\">        t.one(&quot;insert into events(code) values($1) returning id&quot;, 123)</span><br><span class=\"line\">    ]);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">    .spread(function (user, event) &#123;</span><br><span class=\"line\">        // print new user id + new event id;</span><br><span class=\"line\">        console.log(&quot;DATA:&quot;, user.id, event.id);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .catch(function (error) &#123;</span><br><span class=\"line\">        console.log(&quot;ERROR:&quot;, error); // print the error;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .finally(function () &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">        pgp.end(); // for immediate app exit, closing the connection pool.   关闭连接池，是的一般不需要</span><br><span class=\"line\">        </span><br><span class=\"line\">        If, however you normally exit your application by killing the NodeJS process, then you don&apos;t need to use it.</span><br><span class=\"line\"></span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>设置隔离级别：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var TransactionMode = pgp.txMode.TransactionMode;</span><br><span class=\"line\">var isolationLevel = pgp.txMode.isolationLevel;</span><br><span class=\"line\"></span><br><span class=\"line\">// Create a reusable transaction mode (serializable + read-only + deferrable):</span><br><span class=\"line\">var tmSRD = new TransactionMode(&#123;</span><br><span class=\"line\">    tiLevel: isolationLevel.serializable,</span><br><span class=\"line\">    readOnly: true,</span><br><span class=\"line\">    deferrable: true</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">function myTransaction() &#123;</span><br><span class=\"line\">    return this.query(&apos;SELECT * FROM table&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">myTransaction.txMode = tmSRD; // assign transaction mode;</span><br><span class=\"line\"></span><br><span class=\"line\">db.tx(myTransaction)</span><br><span class=\"line\">    .then(function()&#123;</span><br><span class=\"line\">        // success;</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>重置promise：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var promise = require(&apos;bluebird&apos;);</span><br><span class=\"line\">var options = &#123;</span><br><span class=\"line\">    promiseLib: promise</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var pgp = require(&apos;pg-promise&apos;)(options);</span><br></pre></td></tr></table></figure>\n"},{"title":"security","date":"2019-12-09T10:11:18.000Z","_content":"\n\n### xss\n\nXSS 的原理是恶意攻击者往 Web 页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中 Web 里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。\n\n1. 反射型 XSS \n\n一般是通过给别人发送带有恶意脚本代码参数的 URL，当 URL 地址被打开时，特有的恶意代码参数被 HTML 解析、执行。\n不过一些浏览器如Chrome其内置了一些XSS过滤器，可以防止大部分反射型XSS攻击。\n\n反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等\n\n非持久型 XSS 漏洞攻击有以下几点特征：\n\n即时性，不经过服务器存储，直接通过 HTTP 的 GET 和 POST 请求就能完成一次攻击，拿到用户隐私数据。\n攻击者需要诱骗点击,必须要通过用户点击链接才能发起\n反馈率低，所以较难发现和响应修复\n盗取用户敏感保密信息\n\n2. 存储型 XSS\n\n持久型 XSS 漏洞，一般存在于 Form 表单提交等交互功能，如文章留言，提交文本信息等，黑客利用的 XSS 漏洞，将内容经正常功能提交进入数据库持久保存，当前端页面获得后端从数据库中读出的注入代码时，恰好将其渲染执行。\n\n这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。\n\n持久型 XSS 有以下几个特点：\n\n持久性，植入在数据库中\n盗取用户敏感私密信息\n危害面广\n\n3.DOM xss\n\n它不需要服务器解析响应的直接参与，触发XSS靠的是浏览器端的DOM解析，可以认为完全是客户端的事情。  解决方案通过csp: sript-src 的nonce值处理。\n\n4.jsonp 服务端做处理\n\n防御措施：1. httponly 2. csp 3.转义字符---现在的后端模板引擎都实现了转义 \n\n增加攻击难度，降低攻击后果\n\n\nhttps://xss-game.appspot.com/level1\n\n如果用 Vue/React 技术栈，并且不使用 v-html/dangerouslySetInnerHTML 功能，就在前端 render 阶段避免 innerHTML、outerHTML 的 XSS 隐患。\n\n### csrf\n\nCSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。\n\n\nCSRF的特点\n攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。\n攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。\n整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。\n跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。\n\n针对已上特点：同源检测 \n\n1. 同源检测 \n\n在HTTP协议中，每一个异步请求都会携带两个Header，用于标记来源域名：\n\n+ Origin Header\n+ Referer Header\n  这两个Header在浏览器发起请求时，大多数情况会自动带上，并且不能由前端自定义内容。 服务器可以通过解析这两个Header中的域名，确定请求的来源域\n\n但是Origin在以下两种情况下并不存在：\n + IE11同源策略： IE 11 不会在跨站CORS请求上添加Origin标头，Referer头将仍然是唯一的标识。最根本原因是因为IE 11对同源的定义和其他浏览器有不同，有两个主要的区别，可以参考MDN Same-origin_policy#IE_Exceptions\n\n+ 302重定向： 在302重定向之后Origin不包含在重定向的请求中，因为Origin可能会被认为是其他来源的敏感信息。对于302重定向的情况来说都是定向到新的服务器上的URL，因此浏览器不想将Origin泄漏到新的服务器上。\n\n#### 使用Referer Header确定来源域名\n\n根据HTTP协议，在HTTP头中有一个字段叫Referer，记录了该HTTP请求的来源地址。 对于Ajax请求，图片和script等资源请求，Referer为发起请求的页面地址。对于页面跳转，Referer为打开页面历史记录的前一个页面地址。因此我们使用Referer中链接的Origin部分可以得知请求的来源域名。\n\n通过refer 检测，可以定义不同的refer policy \n攻击者可以在自己的请求中隐藏Referer。 \nCSRF大多数情况下来自第三方域名，但并不能排除本域发起。如果攻击者有权限在本域发布评论（含链接、图片等，统称UGC），那么它可以直接在本域发起攻击，这种情况下同源策略无法达到防护的作用。\n\n综上所述：同源验证是一个相对简单的防范方法，能够防范绝大多数的CSRF攻击。但这并不是万无一失的，对于安全性要求较高，或者有较多用户输入内容的网站，我们就要对关键的接口做额外的防护措施。\n\n#### CSRF Token\nCSRF攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了用户自己的请求。那么我们可以要求所有的用户请求都携带一个CSRF攻击者无法获取到的Token。服务器通过校验请求是否携带正确的Token，来把正常的请求和攻击的请求区分开，也可以防范CSRF的攻击。\n\nToken是一个比较有效的CSRF防护方法，只要页面没有XSS漏洞泄露Token，那么接口的CSRF攻击就无法成功。\n\n验证码和密码其实也可以起到CSRF Token的作用哦，而且更安全。\n\n#### 双重Cookie验证\n\n利用CSRF攻击不能获取到用户Cookie的特点，我们可以要求Ajax和表单请求携带一个Cookie中的值。\n\n此方法相对于CSRF Token就简单了许多。可以直接通过前后端拦截的的方法自动化实现。后端校验也更加方便，只需进行请求中字段的对比，而不需要再进行查询和存储Token。\n\n当然，此方法并没有大规模应用，其在大型网站上的安全性还是没有CSRF Token高，原因我们举例进行说明。\n\n1. 用双重Cookie防御CSRF的优点：\n\n无需使用Session，适用面更广，易于实施。\nToken储存于客户端中，不会给服务器带来压力。\n相对于Token，实施成本更低，可以在前后端统一拦截校验，而不需要一个个接口和页面添加。\n\n2. 缺点：\n\n无法使用httponly，这样造成了cookie的安全风险。\n难以做到子域名的隔离。\n为了确保Cookie传输安全，采用这种防御方式的最好确保用整站HTTPS的方式，如果还没切HTTPS的使用这种方式也会有风险。\n\nSamesite Cookie属性\n\n####Samesite Cookie属性\n\n防止CSRF攻击的办法已经有上面的预防措施。为了从源头上解决这个问题，Google起草了一份草案来改进HTTP协议，那就是为Set-Cookie响应头新增Samesite属性，它用来标明这个 Cookie是个“同站 Cookie”，同站Cookie只能作为第一方Cookie，不能作为第三方Cookie，Samesite 有两个属性值，分别是 Strict 和 Lax，下面分别讲解：\n\nSamesite=Strict\n这种称为严格模式，表明这个 Cookie 在任何情况下都不可能作为第三方 Cookie，绝无例外。比如说 b.com 设置了如下 Cookie：\n\nSamesite=Lax 打开链接或者页面跳转时可带Cookie\n\n1. 另外一个问题是Samesite的兼容性不是很好，现阶段除了从新版Chrome和Firefox支持以外，Safari以及iOS Safari都还不支持，现阶段看来暂时还不能普及。\n2. SamesiteCookie目前有一个致命的缺陷：不支持子域。例如，种在topic.a.com下的Cookie，并不能使用a.com下种植的SamesiteCookie。这就导致了当我们网站有多个子域名时，不能使用SamesiteCookie在主域名存储用户登录信息。每个子域名都需要用户重新登录一次。\n\n\n1. 点击劫持\n1. url 跳转漏洞(url 钓鱼)\n1. 图片钓鱼\n1. iframe 钓鱼\n1. os 命令注入\n\n\nstrict-transport-security HTTP Strict Transport Security（通常简称为HSTS）是一个安全功能，它告诉浏览器只能通过HTTPS访问当前资源，而不是HTTP\n\n1. post 请求，用户访问该网页后激发 2. 链接类 用户点击后激发\n\n利用的form 表单、URL 跳转\n\n\nwaf:\n1. Web攻击防护：帮助您防护SQL注入、XSS跨站攻击等常见的Web攻击。\n1. CC攻击防护：帮助您防护针对页面请求的CC攻击。\n1. 恶意IP惩罚：帮助您自动封禁在短时间内进行多次Web攻击的客户端IP。\n1. 地理IP封禁：帮助您一键封禁来自指定国内省份或海外地区的IP的访问请求。\n\n\n1. XST 的全称是 Cross-Site Tracing，客户端发 TRACE 请求至服务器，如果服务器按照标准实现了 TRACE 响应，则在 response body 里会返回此次请求的完整头信息。通过这种方式，客户端可以获取某些敏感的头字段，例如 httpOnly 的 Cookie。","source":"_posts/security-1.md","raw":"---\ntitle: security\ndate: 2019-12-09 18:11:18\ntags: web 安全\n---\n\n\n### xss\n\nXSS 的原理是恶意攻击者往 Web 页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中 Web 里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。\n\n1. 反射型 XSS \n\n一般是通过给别人发送带有恶意脚本代码参数的 URL，当 URL 地址被打开时，特有的恶意代码参数被 HTML 解析、执行。\n不过一些浏览器如Chrome其内置了一些XSS过滤器，可以防止大部分反射型XSS攻击。\n\n反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等\n\n非持久型 XSS 漏洞攻击有以下几点特征：\n\n即时性，不经过服务器存储，直接通过 HTTP 的 GET 和 POST 请求就能完成一次攻击，拿到用户隐私数据。\n攻击者需要诱骗点击,必须要通过用户点击链接才能发起\n反馈率低，所以较难发现和响应修复\n盗取用户敏感保密信息\n\n2. 存储型 XSS\n\n持久型 XSS 漏洞，一般存在于 Form 表单提交等交互功能，如文章留言，提交文本信息等，黑客利用的 XSS 漏洞，将内容经正常功能提交进入数据库持久保存，当前端页面获得后端从数据库中读出的注入代码时，恰好将其渲染执行。\n\n这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。\n\n持久型 XSS 有以下几个特点：\n\n持久性，植入在数据库中\n盗取用户敏感私密信息\n危害面广\n\n3.DOM xss\n\n它不需要服务器解析响应的直接参与，触发XSS靠的是浏览器端的DOM解析，可以认为完全是客户端的事情。  解决方案通过csp: sript-src 的nonce值处理。\n\n4.jsonp 服务端做处理\n\n防御措施：1. httponly 2. csp 3.转义字符---现在的后端模板引擎都实现了转义 \n\n增加攻击难度，降低攻击后果\n\n\nhttps://xss-game.appspot.com/level1\n\n如果用 Vue/React 技术栈，并且不使用 v-html/dangerouslySetInnerHTML 功能，就在前端 render 阶段避免 innerHTML、outerHTML 的 XSS 隐患。\n\n### csrf\n\nCSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。\n\n\nCSRF的特点\n攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。\n攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。\n整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。\n跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。\n\n针对已上特点：同源检测 \n\n1. 同源检测 \n\n在HTTP协议中，每一个异步请求都会携带两个Header，用于标记来源域名：\n\n+ Origin Header\n+ Referer Header\n  这两个Header在浏览器发起请求时，大多数情况会自动带上，并且不能由前端自定义内容。 服务器可以通过解析这两个Header中的域名，确定请求的来源域\n\n但是Origin在以下两种情况下并不存在：\n + IE11同源策略： IE 11 不会在跨站CORS请求上添加Origin标头，Referer头将仍然是唯一的标识。最根本原因是因为IE 11对同源的定义和其他浏览器有不同，有两个主要的区别，可以参考MDN Same-origin_policy#IE_Exceptions\n\n+ 302重定向： 在302重定向之后Origin不包含在重定向的请求中，因为Origin可能会被认为是其他来源的敏感信息。对于302重定向的情况来说都是定向到新的服务器上的URL，因此浏览器不想将Origin泄漏到新的服务器上。\n\n#### 使用Referer Header确定来源域名\n\n根据HTTP协议，在HTTP头中有一个字段叫Referer，记录了该HTTP请求的来源地址。 对于Ajax请求，图片和script等资源请求，Referer为发起请求的页面地址。对于页面跳转，Referer为打开页面历史记录的前一个页面地址。因此我们使用Referer中链接的Origin部分可以得知请求的来源域名。\n\n通过refer 检测，可以定义不同的refer policy \n攻击者可以在自己的请求中隐藏Referer。 \nCSRF大多数情况下来自第三方域名，但并不能排除本域发起。如果攻击者有权限在本域发布评论（含链接、图片等，统称UGC），那么它可以直接在本域发起攻击，这种情况下同源策略无法达到防护的作用。\n\n综上所述：同源验证是一个相对简单的防范方法，能够防范绝大多数的CSRF攻击。但这并不是万无一失的，对于安全性要求较高，或者有较多用户输入内容的网站，我们就要对关键的接口做额外的防护措施。\n\n#### CSRF Token\nCSRF攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了用户自己的请求。那么我们可以要求所有的用户请求都携带一个CSRF攻击者无法获取到的Token。服务器通过校验请求是否携带正确的Token，来把正常的请求和攻击的请求区分开，也可以防范CSRF的攻击。\n\nToken是一个比较有效的CSRF防护方法，只要页面没有XSS漏洞泄露Token，那么接口的CSRF攻击就无法成功。\n\n验证码和密码其实也可以起到CSRF Token的作用哦，而且更安全。\n\n#### 双重Cookie验证\n\n利用CSRF攻击不能获取到用户Cookie的特点，我们可以要求Ajax和表单请求携带一个Cookie中的值。\n\n此方法相对于CSRF Token就简单了许多。可以直接通过前后端拦截的的方法自动化实现。后端校验也更加方便，只需进行请求中字段的对比，而不需要再进行查询和存储Token。\n\n当然，此方法并没有大规模应用，其在大型网站上的安全性还是没有CSRF Token高，原因我们举例进行说明。\n\n1. 用双重Cookie防御CSRF的优点：\n\n无需使用Session，适用面更广，易于实施。\nToken储存于客户端中，不会给服务器带来压力。\n相对于Token，实施成本更低，可以在前后端统一拦截校验，而不需要一个个接口和页面添加。\n\n2. 缺点：\n\n无法使用httponly，这样造成了cookie的安全风险。\n难以做到子域名的隔离。\n为了确保Cookie传输安全，采用这种防御方式的最好确保用整站HTTPS的方式，如果还没切HTTPS的使用这种方式也会有风险。\n\nSamesite Cookie属性\n\n####Samesite Cookie属性\n\n防止CSRF攻击的办法已经有上面的预防措施。为了从源头上解决这个问题，Google起草了一份草案来改进HTTP协议，那就是为Set-Cookie响应头新增Samesite属性，它用来标明这个 Cookie是个“同站 Cookie”，同站Cookie只能作为第一方Cookie，不能作为第三方Cookie，Samesite 有两个属性值，分别是 Strict 和 Lax，下面分别讲解：\n\nSamesite=Strict\n这种称为严格模式，表明这个 Cookie 在任何情况下都不可能作为第三方 Cookie，绝无例外。比如说 b.com 设置了如下 Cookie：\n\nSamesite=Lax 打开链接或者页面跳转时可带Cookie\n\n1. 另外一个问题是Samesite的兼容性不是很好，现阶段除了从新版Chrome和Firefox支持以外，Safari以及iOS Safari都还不支持，现阶段看来暂时还不能普及。\n2. SamesiteCookie目前有一个致命的缺陷：不支持子域。例如，种在topic.a.com下的Cookie，并不能使用a.com下种植的SamesiteCookie。这就导致了当我们网站有多个子域名时，不能使用SamesiteCookie在主域名存储用户登录信息。每个子域名都需要用户重新登录一次。\n\n\n1. 点击劫持\n1. url 跳转漏洞(url 钓鱼)\n1. 图片钓鱼\n1. iframe 钓鱼\n1. os 命令注入\n\n\nstrict-transport-security HTTP Strict Transport Security（通常简称为HSTS）是一个安全功能，它告诉浏览器只能通过HTTPS访问当前资源，而不是HTTP\n\n1. post 请求，用户访问该网页后激发 2. 链接类 用户点击后激发\n\n利用的form 表单、URL 跳转\n\n\nwaf:\n1. Web攻击防护：帮助您防护SQL注入、XSS跨站攻击等常见的Web攻击。\n1. CC攻击防护：帮助您防护针对页面请求的CC攻击。\n1. 恶意IP惩罚：帮助您自动封禁在短时间内进行多次Web攻击的客户端IP。\n1. 地理IP封禁：帮助您一键封禁来自指定国内省份或海外地区的IP的访问请求。\n\n\n1. XST 的全称是 Cross-Site Tracing，客户端发 TRACE 请求至服务器，如果服务器按照标准实现了 TRACE 响应，则在 response body 里会返回此次请求的完整头信息。通过这种方式，客户端可以获取某些敏感的头字段，例如 httpOnly 的 Cookie。","slug":"security-1","published":1,"updated":"2020-06-29T06:22:24.362Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckzf5se07001qyy8ktj7eu1yc","content":"<h3 id=\"xss\"><a href=\"#xss\" class=\"headerlink\" title=\"xss\"></a>xss</h3><p>XSS 的原理是恶意攻击者往 Web 页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中 Web 里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。</p>\n<ol>\n<li>反射型 XSS </li>\n</ol>\n<p>一般是通过给别人发送带有恶意脚本代码参数的 URL，当 URL 地址被打开时，特有的恶意代码参数被 HTML 解析、执行。<br>不过一些浏览器如Chrome其内置了一些XSS过滤器，可以防止大部分反射型XSS攻击。</p>\n<p>反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等</p>\n<p>非持久型 XSS 漏洞攻击有以下几点特征：</p>\n<p>即时性，不经过服务器存储，直接通过 HTTP 的 GET 和 POST 请求就能完成一次攻击，拿到用户隐私数据。<br>攻击者需要诱骗点击,必须要通过用户点击链接才能发起<br>反馈率低，所以较难发现和响应修复<br>盗取用户敏感保密信息</p>\n<ol start=\"2\">\n<li>存储型 XSS</li>\n</ol>\n<p>持久型 XSS 漏洞，一般存在于 Form 表单提交等交互功能，如文章留言，提交文本信息等，黑客利用的 XSS 漏洞，将内容经正常功能提交进入数据库持久保存，当前端页面获得后端从数据库中读出的注入代码时，恰好将其渲染执行。</p>\n<p>这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。</p>\n<p>持久型 XSS 有以下几个特点：</p>\n<p>持久性，植入在数据库中<br>盗取用户敏感私密信息<br>危害面广</p>\n<p>3.DOM xss</p>\n<p>它不需要服务器解析响应的直接参与，触发XSS靠的是浏览器端的DOM解析，可以认为完全是客户端的事情。  解决方案通过csp: sript-src 的nonce值处理。</p>\n<p>4.jsonp 服务端做处理</p>\n<p>防御措施：1. httponly 2. csp 3.转义字符—现在的后端模板引擎都实现了转义 </p>\n<p>增加攻击难度，降低攻击后果</p>\n<p><a href=\"https://xss-game.appspot.com/level1\" target=\"_blank\" rel=\"noopener\">https://xss-game.appspot.com/level1</a></p>\n<p>如果用 Vue/React 技术栈，并且不使用 v-html/dangerouslySetInnerHTML 功能，就在前端 render 阶段避免 innerHTML、outerHTML 的 XSS 隐患。</p>\n<h3 id=\"csrf\"><a href=\"#csrf\" class=\"headerlink\" title=\"csrf\"></a>csrf</h3><p>CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</p>\n<p>CSRF的特点<br>攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。<br>攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。<br>整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。<br>跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。</p>\n<p>针对已上特点：同源检测 </p>\n<ol>\n<li>同源检测 </li>\n</ol>\n<p>在HTTP协议中，每一个异步请求都会携带两个Header，用于标记来源域名：</p>\n<ul>\n<li>Origin Header</li>\n<li>Referer Header<br>这两个Header在浏览器发起请求时，大多数情况会自动带上，并且不能由前端自定义内容。 服务器可以通过解析这两个Header中的域名，确定请求的来源域</li>\n</ul>\n<p>但是Origin在以下两种情况下并不存在：</p>\n<ul>\n<li>IE11同源策略： IE 11 不会在跨站CORS请求上添加Origin标头，Referer头将仍然是唯一的标识。最根本原因是因为IE 11对同源的定义和其他浏览器有不同，有两个主要的区别，可以参考MDN Same-origin_policy#IE_Exceptions</li>\n</ul>\n<ul>\n<li>302重定向： 在302重定向之后Origin不包含在重定向的请求中，因为Origin可能会被认为是其他来源的敏感信息。对于302重定向的情况来说都是定向到新的服务器上的URL，因此浏览器不想将Origin泄漏到新的服务器上。</li>\n</ul>\n<h4 id=\"使用Referer-Header确定来源域名\"><a href=\"#使用Referer-Header确定来源域名\" class=\"headerlink\" title=\"使用Referer Header确定来源域名\"></a>使用Referer Header确定来源域名</h4><p>根据HTTP协议，在HTTP头中有一个字段叫Referer，记录了该HTTP请求的来源地址。 对于Ajax请求，图片和script等资源请求，Referer为发起请求的页面地址。对于页面跳转，Referer为打开页面历史记录的前一个页面地址。因此我们使用Referer中链接的Origin部分可以得知请求的来源域名。</p>\n<p>通过refer 检测，可以定义不同的refer policy<br>攻击者可以在自己的请求中隐藏Referer。<br>CSRF大多数情况下来自第三方域名，但并不能排除本域发起。如果攻击者有权限在本域发布评论（含链接、图片等，统称UGC），那么它可以直接在本域发起攻击，这种情况下同源策略无法达到防护的作用。</p>\n<p>综上所述：同源验证是一个相对简单的防范方法，能够防范绝大多数的CSRF攻击。但这并不是万无一失的，对于安全性要求较高，或者有较多用户输入内容的网站，我们就要对关键的接口做额外的防护措施。</p>\n<h4 id=\"CSRF-Token\"><a href=\"#CSRF-Token\" class=\"headerlink\" title=\"CSRF Token\"></a>CSRF Token</h4><p>CSRF攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了用户自己的请求。那么我们可以要求所有的用户请求都携带一个CSRF攻击者无法获取到的Token。服务器通过校验请求是否携带正确的Token，来把正常的请求和攻击的请求区分开，也可以防范CSRF的攻击。</p>\n<p>Token是一个比较有效的CSRF防护方法，只要页面没有XSS漏洞泄露Token，那么接口的CSRF攻击就无法成功。</p>\n<p>验证码和密码其实也可以起到CSRF Token的作用哦，而且更安全。</p>\n<h4 id=\"双重Cookie验证\"><a href=\"#双重Cookie验证\" class=\"headerlink\" title=\"双重Cookie验证\"></a>双重Cookie验证</h4><p>利用CSRF攻击不能获取到用户Cookie的特点，我们可以要求Ajax和表单请求携带一个Cookie中的值。</p>\n<p>此方法相对于CSRF Token就简单了许多。可以直接通过前后端拦截的的方法自动化实现。后端校验也更加方便，只需进行请求中字段的对比，而不需要再进行查询和存储Token。</p>\n<p>当然，此方法并没有大规模应用，其在大型网站上的安全性还是没有CSRF Token高，原因我们举例进行说明。</p>\n<ol>\n<li>用双重Cookie防御CSRF的优点：</li>\n</ol>\n<p>无需使用Session，适用面更广，易于实施。<br>Token储存于客户端中，不会给服务器带来压力。<br>相对于Token，实施成本更低，可以在前后端统一拦截校验，而不需要一个个接口和页面添加。</p>\n<ol start=\"2\">\n<li>缺点：</li>\n</ol>\n<p>无法使用httponly，这样造成了cookie的安全风险。<br>难以做到子域名的隔离。<br>为了确保Cookie传输安全，采用这种防御方式的最好确保用整站HTTPS的方式，如果还没切HTTPS的使用这种方式也会有风险。</p>\n<p>Samesite Cookie属性</p>\n<p>####Samesite Cookie属性</p>\n<p>防止CSRF攻击的办法已经有上面的预防措施。为了从源头上解决这个问题，Google起草了一份草案来改进HTTP协议，那就是为Set-Cookie响应头新增Samesite属性，它用来标明这个 Cookie是个“同站 Cookie”，同站Cookie只能作为第一方Cookie，不能作为第三方Cookie，Samesite 有两个属性值，分别是 Strict 和 Lax，下面分别讲解：</p>\n<p>Samesite=Strict<br>这种称为严格模式，表明这个 Cookie 在任何情况下都不可能作为第三方 Cookie，绝无例外。比如说 b.com 设置了如下 Cookie：</p>\n<p>Samesite=Lax 打开链接或者页面跳转时可带Cookie</p>\n<ol>\n<li>另外一个问题是Samesite的兼容性不是很好，现阶段除了从新版Chrome和Firefox支持以外，Safari以及iOS Safari都还不支持，现阶段看来暂时还不能普及。</li>\n<li>SamesiteCookie目前有一个致命的缺陷：不支持子域。例如，种在topic.a.com下的Cookie，并不能使用a.com下种植的SamesiteCookie。这就导致了当我们网站有多个子域名时，不能使用SamesiteCookie在主域名存储用户登录信息。每个子域名都需要用户重新登录一次。</li>\n</ol>\n<ol>\n<li>点击劫持</li>\n<li>url 跳转漏洞(url 钓鱼)</li>\n<li>图片钓鱼</li>\n<li>iframe 钓鱼</li>\n<li>os 命令注入</li>\n</ol>\n<p>strict-transport-security HTTP Strict Transport Security（通常简称为HSTS）是一个安全功能，它告诉浏览器只能通过HTTPS访问当前资源，而不是HTTP</p>\n<ol>\n<li>post 请求，用户访问该网页后激发 2. 链接类 用户点击后激发</li>\n</ol>\n<p>利用的form 表单、URL 跳转</p>\n<p>waf:</p>\n<ol>\n<li>Web攻击防护：帮助您防护SQL注入、XSS跨站攻击等常见的Web攻击。</li>\n<li>CC攻击防护：帮助您防护针对页面请求的CC攻击。</li>\n<li>恶意IP惩罚：帮助您自动封禁在短时间内进行多次Web攻击的客户端IP。</li>\n<li>地理IP封禁：帮助您一键封禁来自指定国内省份或海外地区的IP的访问请求。</li>\n</ol>\n<ol>\n<li>XST 的全称是 Cross-Site Tracing，客户端发 TRACE 请求至服务器，如果服务器按照标准实现了 TRACE 响应，则在 response body 里会返回此次请求的完整头信息。通过这种方式，客户端可以获取某些敏感的头字段，例如 httpOnly 的 Cookie。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"xss\"><a href=\"#xss\" class=\"headerlink\" title=\"xss\"></a>xss</h3><p>XSS 的原理是恶意攻击者往 Web 页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中 Web 里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。</p>\n<ol>\n<li>反射型 XSS </li>\n</ol>\n<p>一般是通过给别人发送带有恶意脚本代码参数的 URL，当 URL 地址被打开时，特有的恶意代码参数被 HTML 解析、执行。<br>不过一些浏览器如Chrome其内置了一些XSS过滤器，可以防止大部分反射型XSS攻击。</p>\n<p>反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等</p>\n<p>非持久型 XSS 漏洞攻击有以下几点特征：</p>\n<p>即时性，不经过服务器存储，直接通过 HTTP 的 GET 和 POST 请求就能完成一次攻击，拿到用户隐私数据。<br>攻击者需要诱骗点击,必须要通过用户点击链接才能发起<br>反馈率低，所以较难发现和响应修复<br>盗取用户敏感保密信息</p>\n<ol start=\"2\">\n<li>存储型 XSS</li>\n</ol>\n<p>持久型 XSS 漏洞，一般存在于 Form 表单提交等交互功能，如文章留言，提交文本信息等，黑客利用的 XSS 漏洞，将内容经正常功能提交进入数据库持久保存，当前端页面获得后端从数据库中读出的注入代码时，恰好将其渲染执行。</p>\n<p>这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。</p>\n<p>持久型 XSS 有以下几个特点：</p>\n<p>持久性，植入在数据库中<br>盗取用户敏感私密信息<br>危害面广</p>\n<p>3.DOM xss</p>\n<p>它不需要服务器解析响应的直接参与，触发XSS靠的是浏览器端的DOM解析，可以认为完全是客户端的事情。  解决方案通过csp: sript-src 的nonce值处理。</p>\n<p>4.jsonp 服务端做处理</p>\n<p>防御措施：1. httponly 2. csp 3.转义字符—现在的后端模板引擎都实现了转义 </p>\n<p>增加攻击难度，降低攻击后果</p>\n<p><a href=\"https://xss-game.appspot.com/level1\" target=\"_blank\" rel=\"noopener\">https://xss-game.appspot.com/level1</a></p>\n<p>如果用 Vue/React 技术栈，并且不使用 v-html/dangerouslySetInnerHTML 功能，就在前端 render 阶段避免 innerHTML、outerHTML 的 XSS 隐患。</p>\n<h3 id=\"csrf\"><a href=\"#csrf\" class=\"headerlink\" title=\"csrf\"></a>csrf</h3><p>CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</p>\n<p>CSRF的特点<br>攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。<br>攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。<br>整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。<br>跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。</p>\n<p>针对已上特点：同源检测 </p>\n<ol>\n<li>同源检测 </li>\n</ol>\n<p>在HTTP协议中，每一个异步请求都会携带两个Header，用于标记来源域名：</p>\n<ul>\n<li>Origin Header</li>\n<li>Referer Header<br>这两个Header在浏览器发起请求时，大多数情况会自动带上，并且不能由前端自定义内容。 服务器可以通过解析这两个Header中的域名，确定请求的来源域</li>\n</ul>\n<p>但是Origin在以下两种情况下并不存在：</p>\n<ul>\n<li>IE11同源策略： IE 11 不会在跨站CORS请求上添加Origin标头，Referer头将仍然是唯一的标识。最根本原因是因为IE 11对同源的定义和其他浏览器有不同，有两个主要的区别，可以参考MDN Same-origin_policy#IE_Exceptions</li>\n</ul>\n<ul>\n<li>302重定向： 在302重定向之后Origin不包含在重定向的请求中，因为Origin可能会被认为是其他来源的敏感信息。对于302重定向的情况来说都是定向到新的服务器上的URL，因此浏览器不想将Origin泄漏到新的服务器上。</li>\n</ul>\n<h4 id=\"使用Referer-Header确定来源域名\"><a href=\"#使用Referer-Header确定来源域名\" class=\"headerlink\" title=\"使用Referer Header确定来源域名\"></a>使用Referer Header确定来源域名</h4><p>根据HTTP协议，在HTTP头中有一个字段叫Referer，记录了该HTTP请求的来源地址。 对于Ajax请求，图片和script等资源请求，Referer为发起请求的页面地址。对于页面跳转，Referer为打开页面历史记录的前一个页面地址。因此我们使用Referer中链接的Origin部分可以得知请求的来源域名。</p>\n<p>通过refer 检测，可以定义不同的refer policy<br>攻击者可以在自己的请求中隐藏Referer。<br>CSRF大多数情况下来自第三方域名，但并不能排除本域发起。如果攻击者有权限在本域发布评论（含链接、图片等，统称UGC），那么它可以直接在本域发起攻击，这种情况下同源策略无法达到防护的作用。</p>\n<p>综上所述：同源验证是一个相对简单的防范方法，能够防范绝大多数的CSRF攻击。但这并不是万无一失的，对于安全性要求较高，或者有较多用户输入内容的网站，我们就要对关键的接口做额外的防护措施。</p>\n<h4 id=\"CSRF-Token\"><a href=\"#CSRF-Token\" class=\"headerlink\" title=\"CSRF Token\"></a>CSRF Token</h4><p>CSRF攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了用户自己的请求。那么我们可以要求所有的用户请求都携带一个CSRF攻击者无法获取到的Token。服务器通过校验请求是否携带正确的Token，来把正常的请求和攻击的请求区分开，也可以防范CSRF的攻击。</p>\n<p>Token是一个比较有效的CSRF防护方法，只要页面没有XSS漏洞泄露Token，那么接口的CSRF攻击就无法成功。</p>\n<p>验证码和密码其实也可以起到CSRF Token的作用哦，而且更安全。</p>\n<h4 id=\"双重Cookie验证\"><a href=\"#双重Cookie验证\" class=\"headerlink\" title=\"双重Cookie验证\"></a>双重Cookie验证</h4><p>利用CSRF攻击不能获取到用户Cookie的特点，我们可以要求Ajax和表单请求携带一个Cookie中的值。</p>\n<p>此方法相对于CSRF Token就简单了许多。可以直接通过前后端拦截的的方法自动化实现。后端校验也更加方便，只需进行请求中字段的对比，而不需要再进行查询和存储Token。</p>\n<p>当然，此方法并没有大规模应用，其在大型网站上的安全性还是没有CSRF Token高，原因我们举例进行说明。</p>\n<ol>\n<li>用双重Cookie防御CSRF的优点：</li>\n</ol>\n<p>无需使用Session，适用面更广，易于实施。<br>Token储存于客户端中，不会给服务器带来压力。<br>相对于Token，实施成本更低，可以在前后端统一拦截校验，而不需要一个个接口和页面添加。</p>\n<ol start=\"2\">\n<li>缺点：</li>\n</ol>\n<p>无法使用httponly，这样造成了cookie的安全风险。<br>难以做到子域名的隔离。<br>为了确保Cookie传输安全，采用这种防御方式的最好确保用整站HTTPS的方式，如果还没切HTTPS的使用这种方式也会有风险。</p>\n<p>Samesite Cookie属性</p>\n<p>####Samesite Cookie属性</p>\n<p>防止CSRF攻击的办法已经有上面的预防措施。为了从源头上解决这个问题，Google起草了一份草案来改进HTTP协议，那就是为Set-Cookie响应头新增Samesite属性，它用来标明这个 Cookie是个“同站 Cookie”，同站Cookie只能作为第一方Cookie，不能作为第三方Cookie，Samesite 有两个属性值，分别是 Strict 和 Lax，下面分别讲解：</p>\n<p>Samesite=Strict<br>这种称为严格模式，表明这个 Cookie 在任何情况下都不可能作为第三方 Cookie，绝无例外。比如说 b.com 设置了如下 Cookie：</p>\n<p>Samesite=Lax 打开链接或者页面跳转时可带Cookie</p>\n<ol>\n<li>另外一个问题是Samesite的兼容性不是很好，现阶段除了从新版Chrome和Firefox支持以外，Safari以及iOS Safari都还不支持，现阶段看来暂时还不能普及。</li>\n<li>SamesiteCookie目前有一个致命的缺陷：不支持子域。例如，种在topic.a.com下的Cookie，并不能使用a.com下种植的SamesiteCookie。这就导致了当我们网站有多个子域名时，不能使用SamesiteCookie在主域名存储用户登录信息。每个子域名都需要用户重新登录一次。</li>\n</ol>\n<ol>\n<li>点击劫持</li>\n<li>url 跳转漏洞(url 钓鱼)</li>\n<li>图片钓鱼</li>\n<li>iframe 钓鱼</li>\n<li>os 命令注入</li>\n</ol>\n<p>strict-transport-security HTTP Strict Transport Security（通常简称为HSTS）是一个安全功能，它告诉浏览器只能通过HTTPS访问当前资源，而不是HTTP</p>\n<ol>\n<li>post 请求，用户访问该网页后激发 2. 链接类 用户点击后激发</li>\n</ol>\n<p>利用的form 表单、URL 跳转</p>\n<p>waf:</p>\n<ol>\n<li>Web攻击防护：帮助您防护SQL注入、XSS跨站攻击等常见的Web攻击。</li>\n<li>CC攻击防护：帮助您防护针对页面请求的CC攻击。</li>\n<li>恶意IP惩罚：帮助您自动封禁在短时间内进行多次Web攻击的客户端IP。</li>\n<li>地理IP封禁：帮助您一键封禁来自指定国内省份或海外地区的IP的访问请求。</li>\n</ol>\n<ol>\n<li>XST 的全称是 Cross-Site Tracing，客户端发 TRACE 请求至服务器，如果服务器按照标准实现了 TRACE 响应，则在 response body 里会返回此次请求的完整头信息。通过这种方式，客户端可以获取某些敏感的头字段，例如 httpOnly 的 Cookie。</li>\n</ol>\n"},{"title":"regex","date":"2019-06-24T05:56:32.000Z","_content":"\n### s修饰符使得 . 能够匹配任何字符\n \n/foo.bar/s.test('foo\\nbar')\n\n### ? 非贪婪模式\n\n? 非贪婪模式，只匹配最少的数据。 对 \"123abc\" 应用 /\\d+/ 将会返回 \"123\"，如果使用 /\\d+?/,那么就只会匹配到 \"1”。\n\n### 先行断言\n\nx(?=y)  匹配'x'仅仅当'x'后面跟着'y'.这种叫做先行断言。例如，/Jack(?=Sprat)/会匹配到'Jack'仅仅当它后面跟着'Sprat'。/Jack(?=Sprat|Frost)/匹配‘Jack’仅仅当它后面跟着'Sprat'或者是‘Frost’。但是‘Sprat’和‘Frost’都不是匹配结果的一部分。\n\n### 后行断言 \n\n(?<=y)x  匹配'x'仅仅当'x'前面是'y'.这种叫做后行断言。\n\n类似，匹配前面字符不为$\n  (?<!\\$)browser\n### 正向否定查找\n\nx(?!y)   匹配'x'仅仅当'x'后面不跟着'y',这个叫做正向否定查找。/\\d+(?!\\.)/匹配一个数字仅仅当这个数字后面没有跟小数点的时候。正则表达式/\\d+(?!\\.)/.exec(\"3.141\")匹配‘141’而不是‘3.141’\n\n### 边界 \n\\b 匹配一个词的边界。  \n\\B 匹配一个非单词边界\n\n### w\n\\w 匹配一个单字字符（字母、数字或者下划线）。\n等价于[A-Za-z0-9_]。\n\n例如, /\\w/ 匹配 \"apple,\" 中的 'a'，\"$5.28,\"中的 '5' 和 \"3D.\" 中的 '3’。\n\n\\W 匹配一个非单字字符。\n\n等价于[^A-Za-z0-9_]。\n\n例如, /\\W/ 或者 /[^A-Za-z0-9_]/ 匹配 \"50%.\" 中的 '%’。\n\n### 子字符串匹配\n```\nvar re = /(\\w+)\\s(\\w+)/;\nvar str = \"John Smith\";\nvar newstr = str.replace(re, \"$2, $1\");\nconsole.log(newstr);\n```\n\n#### 非捕获组\n\n?: 用非捕获组 提升匹配效率。\n\ny修饰符的一个应用，是从字符串提取 token（词元），y修饰符确保了匹配之间不会有漏掉的字符。可以修改regex的 lastIndex 。\n\n### 具名匹配\n\n```\nconst RE_DATE = /(\\d{4})-(\\d{2})-(\\d{2})/;\n\n\n\nconst matchObj = RE_DATE.exec('1999-12-31');\n\nconst year = matchObj[1]; // 1999\n\nconst month = matchObj[2]; // 12\n\nconst day = matchObj[3]; // 31\n\nReplace 函数形式：\n\n'2015-01-02'.replace(re, (\n\n   matched, // 整个匹配结果 2015-01-02\n\n   capture1, // 第一个组匹配 2015\n\n   capture2, // 第二个组匹配 01\n\n   capture3, // 第三个组匹配 02\n\n   position, // 匹配开始的位置 0\n\n   S, // 原字符串 2015-01-02\n\n   groups // 具名组构成的一个对象 {year, month, day}\n\n ) => {\n\n let {day, month, year} = groups;\n\n return `${day}/${month}/${year}`;\n\n});\n```\n\n```javascript\n// 可以直接赋值\nlet {groups: {one, two}} = /^(?<one>.*):(?<two>.*)$/u.exec('foo:bar');\none  // foo\ntwo  // bar\n\n// 直接replace\nlet re = /(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/u;\n\n'2015-01-02'.replace(re, '$<day>/$<month>/$<year>')\n```\n\n### 使用引用(具名)\n\n使用引用：const RE_TWICE = /^(?<word>[a-z]+)!\\k<word>$/;\n\nRE_TWICE.test('abc!abc') // true\nRE_TWICE.test('abc!ab') // false\n\n### 捕获组的使用\nRegex 中捕获组的使用：\n对于普通捕获组和命名捕获组的引用，语法如下：\n普通捕获组反向引用：\\k<number>，通常简写为\\number\n\n命名捕获组反向引用：\\k<name>或者\\k'name'\n\n### 匹配字符和非字符\n\\b matches the empty string at the beginning or end of a word. \n\n\\B matches the empty string not at the beginning or end of a word. \n\n","source":"_posts/regex.md","raw":"---\ntitle: regex\ndate: 2019-06-24 13:56:32\ntags: regex\n---\n\n### s修饰符使得 . 能够匹配任何字符\n \n/foo.bar/s.test('foo\\nbar')\n\n### ? 非贪婪模式\n\n? 非贪婪模式，只匹配最少的数据。 对 \"123abc\" 应用 /\\d+/ 将会返回 \"123\"，如果使用 /\\d+?/,那么就只会匹配到 \"1”。\n\n### 先行断言\n\nx(?=y)  匹配'x'仅仅当'x'后面跟着'y'.这种叫做先行断言。例如，/Jack(?=Sprat)/会匹配到'Jack'仅仅当它后面跟着'Sprat'。/Jack(?=Sprat|Frost)/匹配‘Jack’仅仅当它后面跟着'Sprat'或者是‘Frost’。但是‘Sprat’和‘Frost’都不是匹配结果的一部分。\n\n### 后行断言 \n\n(?<=y)x  匹配'x'仅仅当'x'前面是'y'.这种叫做后行断言。\n\n类似，匹配前面字符不为$\n  (?<!\\$)browser\n### 正向否定查找\n\nx(?!y)   匹配'x'仅仅当'x'后面不跟着'y',这个叫做正向否定查找。/\\d+(?!\\.)/匹配一个数字仅仅当这个数字后面没有跟小数点的时候。正则表达式/\\d+(?!\\.)/.exec(\"3.141\")匹配‘141’而不是‘3.141’\n\n### 边界 \n\\b 匹配一个词的边界。  \n\\B 匹配一个非单词边界\n\n### w\n\\w 匹配一个单字字符（字母、数字或者下划线）。\n等价于[A-Za-z0-9_]。\n\n例如, /\\w/ 匹配 \"apple,\" 中的 'a'，\"$5.28,\"中的 '5' 和 \"3D.\" 中的 '3’。\n\n\\W 匹配一个非单字字符。\n\n等价于[^A-Za-z0-9_]。\n\n例如, /\\W/ 或者 /[^A-Za-z0-9_]/ 匹配 \"50%.\" 中的 '%’。\n\n### 子字符串匹配\n```\nvar re = /(\\w+)\\s(\\w+)/;\nvar str = \"John Smith\";\nvar newstr = str.replace(re, \"$2, $1\");\nconsole.log(newstr);\n```\n\n#### 非捕获组\n\n?: 用非捕获组 提升匹配效率。\n\ny修饰符的一个应用，是从字符串提取 token（词元），y修饰符确保了匹配之间不会有漏掉的字符。可以修改regex的 lastIndex 。\n\n### 具名匹配\n\n```\nconst RE_DATE = /(\\d{4})-(\\d{2})-(\\d{2})/;\n\n\n\nconst matchObj = RE_DATE.exec('1999-12-31');\n\nconst year = matchObj[1]; // 1999\n\nconst month = matchObj[2]; // 12\n\nconst day = matchObj[3]; // 31\n\nReplace 函数形式：\n\n'2015-01-02'.replace(re, (\n\n   matched, // 整个匹配结果 2015-01-02\n\n   capture1, // 第一个组匹配 2015\n\n   capture2, // 第二个组匹配 01\n\n   capture3, // 第三个组匹配 02\n\n   position, // 匹配开始的位置 0\n\n   S, // 原字符串 2015-01-02\n\n   groups // 具名组构成的一个对象 {year, month, day}\n\n ) => {\n\n let {day, month, year} = groups;\n\n return `${day}/${month}/${year}`;\n\n});\n```\n\n```javascript\n// 可以直接赋值\nlet {groups: {one, two}} = /^(?<one>.*):(?<two>.*)$/u.exec('foo:bar');\none  // foo\ntwo  // bar\n\n// 直接replace\nlet re = /(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/u;\n\n'2015-01-02'.replace(re, '$<day>/$<month>/$<year>')\n```\n\n### 使用引用(具名)\n\n使用引用：const RE_TWICE = /^(?<word>[a-z]+)!\\k<word>$/;\n\nRE_TWICE.test('abc!abc') // true\nRE_TWICE.test('abc!ab') // false\n\n### 捕获组的使用\nRegex 中捕获组的使用：\n对于普通捕获组和命名捕获组的引用，语法如下：\n普通捕获组反向引用：\\k<number>，通常简写为\\number\n\n命名捕获组反向引用：\\k<name>或者\\k'name'\n\n### 匹配字符和非字符\n\\b matches the empty string at the beginning or end of a word. \n\n\\B matches the empty string not at the beginning or end of a word. \n\n","slug":"regex","published":1,"updated":"2021-12-23T06:37:40.458Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckzf5se08001tyy8kyris7kj2","content":"<h3 id=\"s修饰符使得-能够匹配任何字符\"><a href=\"#s修饰符使得-能够匹配任何字符\" class=\"headerlink\" title=\"s修饰符使得 . 能够匹配任何字符\"></a>s修饰符使得 . 能够匹配任何字符</h3><p>/foo.bar/s.test(‘foo\\nbar’)</p>\n<h3 id=\"非贪婪模式\"><a href=\"#非贪婪模式\" class=\"headerlink\" title=\"? 非贪婪模式\"></a>? 非贪婪模式</h3><p>? 非贪婪模式，只匹配最少的数据。 对 “123abc” 应用 /\\d+/ 将会返回 “123”，如果使用 /\\d+?/,那么就只会匹配到 “1”。</p>\n<h3 id=\"先行断言\"><a href=\"#先行断言\" class=\"headerlink\" title=\"先行断言\"></a>先行断言</h3><p>x(?=y)  匹配’x’仅仅当’x’后面跟着’y’.这种叫做先行断言。例如，/Jack(?=Sprat)/会匹配到’Jack’仅仅当它后面跟着’Sprat’。/Jack(?=Sprat|Frost)/匹配‘Jack’仅仅当它后面跟着’Sprat’或者是‘Frost’。但是‘Sprat’和‘Frost’都不是匹配结果的一部分。</p>\n<h3 id=\"后行断言\"><a href=\"#后行断言\" class=\"headerlink\" title=\"后行断言\"></a>后行断言</h3><p>(?&lt;=y)x  匹配’x’仅仅当’x’前面是’y’.这种叫做后行断言。</p>\n<p>类似，匹配前面字符不为$<br>  (?&lt;!\\$)browser</p>\n<h3 id=\"正向否定查找\"><a href=\"#正向否定查找\" class=\"headerlink\" title=\"正向否定查找\"></a>正向否定查找</h3><p>x(?!y)   匹配’x’仅仅当’x’后面不跟着’y’,这个叫做正向否定查找。/\\d+(?!.)/匹配一个数字仅仅当这个数字后面没有跟小数点的时候。正则表达式/\\d+(?!.)/.exec(“3.141”)匹配‘141’而不是‘3.141’</p>\n<h3 id=\"边界\"><a href=\"#边界\" class=\"headerlink\" title=\"边界\"></a>边界</h3><p>\\b 匹配一个词的边界。<br>\\B 匹配一个非单词边界</p>\n<h3 id=\"w\"><a href=\"#w\" class=\"headerlink\" title=\"w\"></a>w</h3><p>\\w 匹配一个单字字符（字母、数字或者下划线）。<br>等价于[A-Za-z0-9_]。</p>\n<p>例如, /\\w/ 匹配 “apple,” 中的 ‘a’，”$5.28,”中的 ‘5’ 和 “3D.” 中的 ‘3’。</p>\n<p>\\W 匹配一个非单字字符。</p>\n<p>等价于[^A-Za-z0-9_]。</p>\n<p>例如, /\\W/ 或者 /[^A-Za-z0-9_]/ 匹配 “50%.” 中的 ‘%’。</p>\n<h3 id=\"子字符串匹配\"><a href=\"#子字符串匹配\" class=\"headerlink\" title=\"子字符串匹配\"></a>子字符串匹配</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var re = /(\\w+)\\s(\\w+)/;</span><br><span class=\"line\">var str = &quot;John Smith&quot;;</span><br><span class=\"line\">var newstr = str.replace(re, &quot;$2, $1&quot;);</span><br><span class=\"line\">console.log(newstr);</span><br></pre></td></tr></table></figure>\n<h4 id=\"非捕获组\"><a href=\"#非捕获组\" class=\"headerlink\" title=\"非捕获组\"></a>非捕获组</h4><p>?: 用非捕获组 提升匹配效率。</p>\n<p>y修饰符的一个应用，是从字符串提取 token（词元），y修饰符确保了匹配之间不会有漏掉的字符。可以修改regex的 lastIndex 。</p>\n<h3 id=\"具名匹配\"><a href=\"#具名匹配\" class=\"headerlink\" title=\"具名匹配\"></a>具名匹配</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const RE_DATE = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">const matchObj = RE_DATE.exec(&apos;1999-12-31&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">const year = matchObj[1]; // 1999</span><br><span class=\"line\"></span><br><span class=\"line\">const month = matchObj[2]; // 12</span><br><span class=\"line\"></span><br><span class=\"line\">const day = matchObj[3]; // 31</span><br><span class=\"line\"></span><br><span class=\"line\">Replace 函数形式：</span><br><span class=\"line\"></span><br><span class=\"line\">&apos;2015-01-02&apos;.replace(re, (</span><br><span class=\"line\"></span><br><span class=\"line\">   matched, // 整个匹配结果 2015-01-02</span><br><span class=\"line\"></span><br><span class=\"line\">   capture1, // 第一个组匹配 2015</span><br><span class=\"line\"></span><br><span class=\"line\">   capture2, // 第二个组匹配 01</span><br><span class=\"line\"></span><br><span class=\"line\">   capture3, // 第三个组匹配 02</span><br><span class=\"line\"></span><br><span class=\"line\">   position, // 匹配开始的位置 0</span><br><span class=\"line\"></span><br><span class=\"line\">   S, // 原字符串 2015-01-02</span><br><span class=\"line\"></span><br><span class=\"line\">   groups // 具名组构成的一个对象 &#123;year, month, day&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> ) =&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> let &#123;day, month, year&#125; = groups;</span><br><span class=\"line\"></span><br><span class=\"line\"> return `$&#123;day&#125;/$&#123;month&#125;/$&#123;year&#125;`;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 可以直接赋值</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123;<span class=\"attr\">groups</span>: &#123;one, two&#125;&#125; = <span class=\"regexp\">/^(?&lt;one&gt;.*):(?&lt;two&gt;.*)$/u</span>.exec(<span class=\"string\">'foo:bar'</span>);</span><br><span class=\"line\">one  <span class=\"comment\">// foo</span></span><br><span class=\"line\">two  <span class=\"comment\">// bar</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 直接replace</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> re = <span class=\"regexp\">/(?&lt;year&gt;\\d&#123;4&#125;)-(?&lt;month&gt;\\d&#123;2&#125;)-(?&lt;day&gt;\\d&#123;2&#125;)/u</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">'2015-01-02'</span>.replace(re, <span class=\"string\">'$&lt;day&gt;/$&lt;month&gt;/$&lt;year&gt;'</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用引用-具名\"><a href=\"#使用引用-具名\" class=\"headerlink\" title=\"使用引用(具名)\"></a>使用引用(具名)</h3><p>使用引用：const RE_TWICE = /^(?<word>[a-z]+)!\\k<word>$/;</word></word></p>\n<p>RE_TWICE.test(‘abc!abc’) // true<br>RE_TWICE.test(‘abc!ab’) // false</p>\n<h3 id=\"捕获组的使用\"><a href=\"#捕获组的使用\" class=\"headerlink\" title=\"捕获组的使用\"></a>捕获组的使用</h3><p>Regex 中捕获组的使用：<br>对于普通捕获组和命名捕获组的引用，语法如下：<br>普通捕获组反向引用：\\k<number>，通常简写为\\number</number></p>\n<p>命名捕获组反向引用：\\k<name>或者\\k’name’</name></p>\n<h3 id=\"匹配字符和非字符\"><a href=\"#匹配字符和非字符\" class=\"headerlink\" title=\"匹配字符和非字符\"></a>匹配字符和非字符</h3><p>\\b matches the empty string at the beginning or end of a word. </p>\n<p>\\B matches the empty string not at the beginning or end of a word. </p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"s修饰符使得-能够匹配任何字符\"><a href=\"#s修饰符使得-能够匹配任何字符\" class=\"headerlink\" title=\"s修饰符使得 . 能够匹配任何字符\"></a>s修饰符使得 . 能够匹配任何字符</h3><p>/foo.bar/s.test(‘foo\\nbar’)</p>\n<h3 id=\"非贪婪模式\"><a href=\"#非贪婪模式\" class=\"headerlink\" title=\"? 非贪婪模式\"></a>? 非贪婪模式</h3><p>? 非贪婪模式，只匹配最少的数据。 对 “123abc” 应用 /\\d+/ 将会返回 “123”，如果使用 /\\d+?/,那么就只会匹配到 “1”。</p>\n<h3 id=\"先行断言\"><a href=\"#先行断言\" class=\"headerlink\" title=\"先行断言\"></a>先行断言</h3><p>x(?=y)  匹配’x’仅仅当’x’后面跟着’y’.这种叫做先行断言。例如，/Jack(?=Sprat)/会匹配到’Jack’仅仅当它后面跟着’Sprat’。/Jack(?=Sprat|Frost)/匹配‘Jack’仅仅当它后面跟着’Sprat’或者是‘Frost’。但是‘Sprat’和‘Frost’都不是匹配结果的一部分。</p>\n<h3 id=\"后行断言\"><a href=\"#后行断言\" class=\"headerlink\" title=\"后行断言\"></a>后行断言</h3><p>(?&lt;=y)x  匹配’x’仅仅当’x’前面是’y’.这种叫做后行断言。</p>\n<p>类似，匹配前面字符不为$<br>  (?&lt;!\\$)browser</p>\n<h3 id=\"正向否定查找\"><a href=\"#正向否定查找\" class=\"headerlink\" title=\"正向否定查找\"></a>正向否定查找</h3><p>x(?!y)   匹配’x’仅仅当’x’后面不跟着’y’,这个叫做正向否定查找。/\\d+(?!.)/匹配一个数字仅仅当这个数字后面没有跟小数点的时候。正则表达式/\\d+(?!.)/.exec(“3.141”)匹配‘141’而不是‘3.141’</p>\n<h3 id=\"边界\"><a href=\"#边界\" class=\"headerlink\" title=\"边界\"></a>边界</h3><p>\\b 匹配一个词的边界。<br>\\B 匹配一个非单词边界</p>\n<h3 id=\"w\"><a href=\"#w\" class=\"headerlink\" title=\"w\"></a>w</h3><p>\\w 匹配一个单字字符（字母、数字或者下划线）。<br>等价于[A-Za-z0-9_]。</p>\n<p>例如, /\\w/ 匹配 “apple,” 中的 ‘a’，”$5.28,”中的 ‘5’ 和 “3D.” 中的 ‘3’。</p>\n<p>\\W 匹配一个非单字字符。</p>\n<p>等价于[^A-Za-z0-9_]。</p>\n<p>例如, /\\W/ 或者 /[^A-Za-z0-9_]/ 匹配 “50%.” 中的 ‘%’。</p>\n<h3 id=\"子字符串匹配\"><a href=\"#子字符串匹配\" class=\"headerlink\" title=\"子字符串匹配\"></a>子字符串匹配</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var re = /(\\w+)\\s(\\w+)/;</span><br><span class=\"line\">var str = &quot;John Smith&quot;;</span><br><span class=\"line\">var newstr = str.replace(re, &quot;$2, $1&quot;);</span><br><span class=\"line\">console.log(newstr);</span><br></pre></td></tr></table></figure>\n<h4 id=\"非捕获组\"><a href=\"#非捕获组\" class=\"headerlink\" title=\"非捕获组\"></a>非捕获组</h4><p>?: 用非捕获组 提升匹配效率。</p>\n<p>y修饰符的一个应用，是从字符串提取 token（词元），y修饰符确保了匹配之间不会有漏掉的字符。可以修改regex的 lastIndex 。</p>\n<h3 id=\"具名匹配\"><a href=\"#具名匹配\" class=\"headerlink\" title=\"具名匹配\"></a>具名匹配</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const RE_DATE = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">const matchObj = RE_DATE.exec(&apos;1999-12-31&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">const year = matchObj[1]; // 1999</span><br><span class=\"line\"></span><br><span class=\"line\">const month = matchObj[2]; // 12</span><br><span class=\"line\"></span><br><span class=\"line\">const day = matchObj[3]; // 31</span><br><span class=\"line\"></span><br><span class=\"line\">Replace 函数形式：</span><br><span class=\"line\"></span><br><span class=\"line\">&apos;2015-01-02&apos;.replace(re, (</span><br><span class=\"line\"></span><br><span class=\"line\">   matched, // 整个匹配结果 2015-01-02</span><br><span class=\"line\"></span><br><span class=\"line\">   capture1, // 第一个组匹配 2015</span><br><span class=\"line\"></span><br><span class=\"line\">   capture2, // 第二个组匹配 01</span><br><span class=\"line\"></span><br><span class=\"line\">   capture3, // 第三个组匹配 02</span><br><span class=\"line\"></span><br><span class=\"line\">   position, // 匹配开始的位置 0</span><br><span class=\"line\"></span><br><span class=\"line\">   S, // 原字符串 2015-01-02</span><br><span class=\"line\"></span><br><span class=\"line\">   groups // 具名组构成的一个对象 &#123;year, month, day&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> ) =&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> let &#123;day, month, year&#125; = groups;</span><br><span class=\"line\"></span><br><span class=\"line\"> return `$&#123;day&#125;/$&#123;month&#125;/$&#123;year&#125;`;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 可以直接赋值</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123;<span class=\"attr\">groups</span>: &#123;one, two&#125;&#125; = <span class=\"regexp\">/^(?&lt;one&gt;.*):(?&lt;two&gt;.*)$/u</span>.exec(<span class=\"string\">'foo:bar'</span>);</span><br><span class=\"line\">one  <span class=\"comment\">// foo</span></span><br><span class=\"line\">two  <span class=\"comment\">// bar</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 直接replace</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> re = <span class=\"regexp\">/(?&lt;year&gt;\\d&#123;4&#125;)-(?&lt;month&gt;\\d&#123;2&#125;)-(?&lt;day&gt;\\d&#123;2&#125;)/u</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">'2015-01-02'</span>.replace(re, <span class=\"string\">'$&lt;day&gt;/$&lt;month&gt;/$&lt;year&gt;'</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用引用-具名\"><a href=\"#使用引用-具名\" class=\"headerlink\" title=\"使用引用(具名)\"></a>使用引用(具名)</h3><p>使用引用：const RE_TWICE = /^(?<word>[a-z]+)!\\k<word>$/;</word></word></p>\n<p>RE_TWICE.test(‘abc!abc’) // true<br>RE_TWICE.test(‘abc!ab’) // false</p>\n<h3 id=\"捕获组的使用\"><a href=\"#捕获组的使用\" class=\"headerlink\" title=\"捕获组的使用\"></a>捕获组的使用</h3><p>Regex 中捕获组的使用：<br>对于普通捕获组和命名捕获组的引用，语法如下：<br>普通捕获组反向引用：\\k<number>，通常简写为\\number</number></p>\n<p>命名捕获组反向引用：\\k<name>或者\\k’name’</name></p>\n<h3 id=\"匹配字符和非字符\"><a href=\"#匹配字符和非字符\" class=\"headerlink\" title=\"匹配字符和非字符\"></a>匹配字符和非字符</h3><p>\\b matches the empty string at the beginning or end of a word. </p>\n<p>\\B matches the empty string not at the beginning or end of a word. </p>\n"},{"title":"stringencode","date":"2019-12-10T09:10:23.000Z","_content":"\nASCII、UTF-8\\16\nunicode GB2312 \n\n字符是语言中的概念，但是计算机只认识 0 和 1 这两个数字。因此要想让计算机存储、处理字符串，就必须把字符串用二进制表示出来。在 ASCII 码中，每个英文字母都有自己对应的数字。我们通常把 ASCII 码称为字符集，也就是字符的集合。了解 ASCII 码的同学应该都知道小写字母 a 可以用 97 来表示，97 也被称为字符 a 在 ASCII 字符集中的码位。\n\n可见把字符转换成码位的过程类似于加密(encrypt)，我们称之为编码(encode)，反则则类似于解密，我们称之为解码(decode)\n\n字符转换成码位的过程是编码，这个过程有无数种实现方式。比如 a -> 97、b -> 98 这种就是 ASCII 编码，因为 255 = 2 ^ 8，所以所有 ASCII 编码下的码位恰好都可以由一个字节表示。\n\n除了中国人之外，各个地区的人也都根据自己的语言拓展了相应的编码方式。这样unicode就出现了。\n\n缺点：过于庞大、\n\n中文的utf-8 大于GBk的两个字节\n\n因此，我们有了对 Unicode 字符再次编码的编码方式，常见的有 utf-8，utf-16 等。UTF 表示 Unicode Transfer Format，因此是针对 Unicode 字符集的一系列编码方式。utf-8 是一种变长编码，也就是说不同的 Unicode 字符在 utf-8 编码下的码位长度可能不同，如下表所示:\n\n |Unicode 编码(16进制) | utf-8 码位(二进制)|\n |----|----|\n |000000-00007F       |0xxxxxxx|\n |000080-0007FF|110xxxxx 10xxxxxx|\n |000800-00FFFF|1110xxxx 10xxxxxx 10xxxxxx|\n |010000-1FFFFF|11110xxx10xxxxxx10xxxxxx10xxxxxx|\n\n\n1. escape\n1. encodeURIComponent encodeURI\n\nencodeURI()不会对本身属于URI的特殊字符进行编码，例如冒号、正斜杠、问号和井字号；而encodeURIComponent()则会对它发现的任何非标准字符进行编码。\n使用encodeURI()编码后的结果是除了空格之外的其他字符都原封不动，只有空格被替换成了%20。而encodeURIComponent()方法则会使用对应的编码替换所有非字母数字字符。\n\nescape 在处理 0xff 之外字符的时候，是直接使用字符的 unicode 在前面加上一个 「%u」,举例说明。\n而encodeURI则是先进行 UTF-8，再在 UTF-8 的每个字节码前加上一个 「%」；\nencodeURI 是W3C 的标准，而 Escape 是非标准。\n\n\nJavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode 码点大于0xFFFF的字符），JavaScript 会认为它们是两个字符。\n","source":"_posts/stringencode.md","raw":"---\ntitle: stringencode\ndate: 2019-12-10 17:10:23\ntags: encode decode\n---\n\nASCII、UTF-8\\16\nunicode GB2312 \n\n字符是语言中的概念，但是计算机只认识 0 和 1 这两个数字。因此要想让计算机存储、处理字符串，就必须把字符串用二进制表示出来。在 ASCII 码中，每个英文字母都有自己对应的数字。我们通常把 ASCII 码称为字符集，也就是字符的集合。了解 ASCII 码的同学应该都知道小写字母 a 可以用 97 来表示，97 也被称为字符 a 在 ASCII 字符集中的码位。\n\n可见把字符转换成码位的过程类似于加密(encrypt)，我们称之为编码(encode)，反则则类似于解密，我们称之为解码(decode)\n\n字符转换成码位的过程是编码，这个过程有无数种实现方式。比如 a -> 97、b -> 98 这种就是 ASCII 编码，因为 255 = 2 ^ 8，所以所有 ASCII 编码下的码位恰好都可以由一个字节表示。\n\n除了中国人之外，各个地区的人也都根据自己的语言拓展了相应的编码方式。这样unicode就出现了。\n\n缺点：过于庞大、\n\n中文的utf-8 大于GBk的两个字节\n\n因此，我们有了对 Unicode 字符再次编码的编码方式，常见的有 utf-8，utf-16 等。UTF 表示 Unicode Transfer Format，因此是针对 Unicode 字符集的一系列编码方式。utf-8 是一种变长编码，也就是说不同的 Unicode 字符在 utf-8 编码下的码位长度可能不同，如下表所示:\n\n |Unicode 编码(16进制) | utf-8 码位(二进制)|\n |----|----|\n |000000-00007F       |0xxxxxxx|\n |000080-0007FF|110xxxxx 10xxxxxx|\n |000800-00FFFF|1110xxxx 10xxxxxx 10xxxxxx|\n |010000-1FFFFF|11110xxx10xxxxxx10xxxxxx10xxxxxx|\n\n\n1. escape\n1. encodeURIComponent encodeURI\n\nencodeURI()不会对本身属于URI的特殊字符进行编码，例如冒号、正斜杠、问号和井字号；而encodeURIComponent()则会对它发现的任何非标准字符进行编码。\n使用encodeURI()编码后的结果是除了空格之外的其他字符都原封不动，只有空格被替换成了%20。而encodeURIComponent()方法则会使用对应的编码替换所有非字母数字字符。\n\nescape 在处理 0xff 之外字符的时候，是直接使用字符的 unicode 在前面加上一个 「%u」,举例说明。\n而encodeURI则是先进行 UTF-8，再在 UTF-8 的每个字节码前加上一个 「%」；\nencodeURI 是W3C 的标准，而 Escape 是非标准。\n\n\nJavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode 码点大于0xFFFF的字符），JavaScript 会认为它们是两个字符。\n","slug":"stringencode","published":1,"updated":"2020-06-29T06:22:24.363Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckzf5se09001uyy8k3xjon3gt","content":"<p>ASCII、UTF-8\\16<br>unicode GB2312 </p>\n<p>字符是语言中的概念，但是计算机只认识 0 和 1 这两个数字。因此要想让计算机存储、处理字符串，就必须把字符串用二进制表示出来。在 ASCII 码中，每个英文字母都有自己对应的数字。我们通常把 ASCII 码称为字符集，也就是字符的集合。了解 ASCII 码的同学应该都知道小写字母 a 可以用 97 来表示，97 也被称为字符 a 在 ASCII 字符集中的码位。</p>\n<p>可见把字符转换成码位的过程类似于加密(encrypt)，我们称之为编码(encode)，反则则类似于解密，我们称之为解码(decode)</p>\n<p>字符转换成码位的过程是编码，这个过程有无数种实现方式。比如 a -&gt; 97、b -&gt; 98 这种就是 ASCII 编码，因为 255 = 2 ^ 8，所以所有 ASCII 编码下的码位恰好都可以由一个字节表示。</p>\n<p>除了中国人之外，各个地区的人也都根据自己的语言拓展了相应的编码方式。这样unicode就出现了。</p>\n<p>缺点：过于庞大、</p>\n<p>中文的utf-8 大于GBk的两个字节</p>\n<p>因此，我们有了对 Unicode 字符再次编码的编码方式，常见的有 utf-8，utf-16 等。UTF 表示 Unicode Transfer Format，因此是针对 Unicode 字符集的一系列编码方式。utf-8 是一种变长编码，也就是说不同的 Unicode 字符在 utf-8 编码下的码位长度可能不同，如下表所示:</p>\n<table>\n<thead>\n<tr>\n<th>Unicode 编码(16进制)</th>\n<th>utf-8 码位(二进制)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>000000-00007F</td>\n<td>0xxxxxxx</td>\n</tr>\n<tr>\n<td>000080-0007FF</td>\n<td>110xxxxx 10xxxxxx</td>\n</tr>\n<tr>\n<td>000800-00FFFF</td>\n<td>1110xxxx 10xxxxxx 10xxxxxx</td>\n</tr>\n<tr>\n<td>010000-1FFFFF</td>\n<td>11110xxx10xxxxxx10xxxxxx10xxxxxx</td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li>escape</li>\n<li>encodeURIComponent encodeURI</li>\n</ol>\n<p>encodeURI()不会对本身属于URI的特殊字符进行编码，例如冒号、正斜杠、问号和井字号；而encodeURIComponent()则会对它发现的任何非标准字符进行编码。<br>使用encodeURI()编码后的结果是除了空格之外的其他字符都原封不动，只有空格被替换成了%20。而encodeURIComponent()方法则会使用对应的编码替换所有非字母数字字符。</p>\n<p>escape 在处理 0xff 之外字符的时候，是直接使用字符的 unicode 在前面加上一个 「%u」,举例说明。<br>而encodeURI则是先进行 UTF-8，再在 UTF-8 的每个字节码前加上一个 「%」；<br>encodeURI 是W3C 的标准，而 Escape 是非标准。</p>\n<p>JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode 码点大于0xFFFF的字符），JavaScript 会认为它们是两个字符。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>ASCII、UTF-8\\16<br>unicode GB2312 </p>\n<p>字符是语言中的概念，但是计算机只认识 0 和 1 这两个数字。因此要想让计算机存储、处理字符串，就必须把字符串用二进制表示出来。在 ASCII 码中，每个英文字母都有自己对应的数字。我们通常把 ASCII 码称为字符集，也就是字符的集合。了解 ASCII 码的同学应该都知道小写字母 a 可以用 97 来表示，97 也被称为字符 a 在 ASCII 字符集中的码位。</p>\n<p>可见把字符转换成码位的过程类似于加密(encrypt)，我们称之为编码(encode)，反则则类似于解密，我们称之为解码(decode)</p>\n<p>字符转换成码位的过程是编码，这个过程有无数种实现方式。比如 a -&gt; 97、b -&gt; 98 这种就是 ASCII 编码，因为 255 = 2 ^ 8，所以所有 ASCII 编码下的码位恰好都可以由一个字节表示。</p>\n<p>除了中国人之外，各个地区的人也都根据自己的语言拓展了相应的编码方式。这样unicode就出现了。</p>\n<p>缺点：过于庞大、</p>\n<p>中文的utf-8 大于GBk的两个字节</p>\n<p>因此，我们有了对 Unicode 字符再次编码的编码方式，常见的有 utf-8，utf-16 等。UTF 表示 Unicode Transfer Format，因此是针对 Unicode 字符集的一系列编码方式。utf-8 是一种变长编码，也就是说不同的 Unicode 字符在 utf-8 编码下的码位长度可能不同，如下表所示:</p>\n<table>\n<thead>\n<tr>\n<th>Unicode 编码(16进制)</th>\n<th>utf-8 码位(二进制)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>000000-00007F</td>\n<td>0xxxxxxx</td>\n</tr>\n<tr>\n<td>000080-0007FF</td>\n<td>110xxxxx 10xxxxxx</td>\n</tr>\n<tr>\n<td>000800-00FFFF</td>\n<td>1110xxxx 10xxxxxx 10xxxxxx</td>\n</tr>\n<tr>\n<td>010000-1FFFFF</td>\n<td>11110xxx10xxxxxx10xxxxxx10xxxxxx</td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li>escape</li>\n<li>encodeURIComponent encodeURI</li>\n</ol>\n<p>encodeURI()不会对本身属于URI的特殊字符进行编码，例如冒号、正斜杠、问号和井字号；而encodeURIComponent()则会对它发现的任何非标准字符进行编码。<br>使用encodeURI()编码后的结果是除了空格之外的其他字符都原封不动，只有空格被替换成了%20。而encodeURIComponent()方法则会使用对应的编码替换所有非字母数字字符。</p>\n<p>escape 在处理 0xff 之外字符的时候，是直接使用字符的 unicode 在前面加上一个 「%u」,举例说明。<br>而encodeURI则是先进行 UTF-8，再在 UTF-8 的每个字节码前加上一个 「%」；<br>encodeURI 是W3C 的标准，而 Escape 是非标准。</p>\n<p>JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode 码点大于0xFFFF的字符），JavaScript 会认为它们是两个字符。</p>\n"},{"title":"security","date":"2019-04-25T08:49:58.000Z","_content":"\n```text\n参考： https://juejin.im/post/5bad9140e51d450e935c6d64#heading-9\n\nxss 攻击类型分为：反射、存储和dom \n\n在纯前端渲染中，我们会明确的告诉浏览器：下面要设置的内容是文本（.innerText），还是属性（.setAttribute），还是样式（.style）等等。浏览器不会被轻易的被欺骗，执行预期外的代码了.\n\n在很多内部、管理系统中，采用纯前端渲染是非常合适的。但对于性能要求高，或有 SEO 需求的页面，我们仍然要面对拼接 HTML 的问题。需要html 转义。\n\n利用模板引擎\n开启模板引擎自带的 HTML 转义功能。例如：\n在 ejs 中，尽量使用 <%= data %> 而不是 <%- data %>；\n在 doT.js 中，尽量使用 {{! data } 而不是 {{= data }；\n在 FreeMarker 中，确保引擎版本高于 2.3.24，并且选择正确的 freemarker.core.OutputFormat。\n避免内联事件\n尽量不要使用 onLoad=\"onload('{{data}}')\"、onClick=\"go('{{action}}')\" 这种拼接内联事件的写法。在 JavaScript 中通过 .addEventlistener() 事件绑定会更安全。\n避免拼接 HTML\n前端采用拼接 HTML 的方法比较危险，如果框架允许，使用 createElement、setAttribute 之类的方法实现。或者采用比较成熟的渲染框架，如 Vue/React 等。\n时刻保持警惕\n在插入位置为 DOM 属性、链接等位置时，要打起精神，严加防范。\n增加攻击难度，降低攻击后果\n通过 CSP、输入长度配置、接口安全措施等方法，增加攻击的难度，降低攻击的后果。\n主动检测和发现\n可使用 XSS 攻击字符串和自动扫描工具寻找潜在的 XSS 漏洞。\n\n```\n\n\n\n","source":"_posts/security.md","raw":"---\ntitle: security\ndate: 2019-04-25 16:49:58\ntags: 安全\n---\n\n```text\n参考： https://juejin.im/post/5bad9140e51d450e935c6d64#heading-9\n\nxss 攻击类型分为：反射、存储和dom \n\n在纯前端渲染中，我们会明确的告诉浏览器：下面要设置的内容是文本（.innerText），还是属性（.setAttribute），还是样式（.style）等等。浏览器不会被轻易的被欺骗，执行预期外的代码了.\n\n在很多内部、管理系统中，采用纯前端渲染是非常合适的。但对于性能要求高，或有 SEO 需求的页面，我们仍然要面对拼接 HTML 的问题。需要html 转义。\n\n利用模板引擎\n开启模板引擎自带的 HTML 转义功能。例如：\n在 ejs 中，尽量使用 <%= data %> 而不是 <%- data %>；\n在 doT.js 中，尽量使用 {{! data } 而不是 {{= data }；\n在 FreeMarker 中，确保引擎版本高于 2.3.24，并且选择正确的 freemarker.core.OutputFormat。\n避免内联事件\n尽量不要使用 onLoad=\"onload('{{data}}')\"、onClick=\"go('{{action}}')\" 这种拼接内联事件的写法。在 JavaScript 中通过 .addEventlistener() 事件绑定会更安全。\n避免拼接 HTML\n前端采用拼接 HTML 的方法比较危险，如果框架允许，使用 createElement、setAttribute 之类的方法实现。或者采用比较成熟的渲染框架，如 Vue/React 等。\n时刻保持警惕\n在插入位置为 DOM 属性、链接等位置时，要打起精神，严加防范。\n增加攻击难度，降低攻击后果\n通过 CSP、输入长度配置、接口安全措施等方法，增加攻击的难度，降低攻击的后果。\n主动检测和发现\n可使用 XSS 攻击字符串和自动扫描工具寻找潜在的 XSS 漏洞。\n\n```\n\n\n\n","slug":"security","published":1,"updated":"2020-08-20T01:59:23.888Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckzf5se0a001wyy8khyv2rcii","content":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">参考： https://juejin.im/post/5bad9140e51d450e935c6d64#heading-9</span><br><span class=\"line\"></span><br><span class=\"line\">xss 攻击类型分为：反射、存储和dom </span><br><span class=\"line\"></span><br><span class=\"line\">在纯前端渲染中，我们会明确的告诉浏览器：下面要设置的内容是文本（.innerText），还是属性（.setAttribute），还是样式（.style）等等。浏览器不会被轻易的被欺骗，执行预期外的代码了.</span><br><span class=\"line\"></span><br><span class=\"line\">在很多内部、管理系统中，采用纯前端渲染是非常合适的。但对于性能要求高，或有 SEO 需求的页面，我们仍然要面对拼接 HTML 的问题。需要html 转义。</span><br><span class=\"line\"></span><br><span class=\"line\">利用模板引擎</span><br><span class=\"line\">开启模板引擎自带的 HTML 转义功能。例如：</span><br><span class=\"line\">在 ejs 中，尽量使用 &lt;%= data %&gt; 而不是 &lt;%- data %&gt;；</span><br><span class=\"line\">在 doT.js 中，尽量使用 &#123;&#123;! data &#125; 而不是 &#123;&#123;= data &#125;；</span><br><span class=\"line\">在 FreeMarker 中，确保引擎版本高于 2.3.24，并且选择正确的 freemarker.core.OutputFormat。</span><br><span class=\"line\">避免内联事件</span><br><span class=\"line\">尽量不要使用 onLoad=&quot;onload(&apos;&#123;&#123;data&#125;&#125;&apos;)&quot;、onClick=&quot;go(&apos;&#123;&#123;action&#125;&#125;&apos;)&quot; 这种拼接内联事件的写法。在 JavaScript 中通过 .addEventlistener() 事件绑定会更安全。</span><br><span class=\"line\">避免拼接 HTML</span><br><span class=\"line\">前端采用拼接 HTML 的方法比较危险，如果框架允许，使用 createElement、setAttribute 之类的方法实现。或者采用比较成熟的渲染框架，如 Vue/React 等。</span><br><span class=\"line\">时刻保持警惕</span><br><span class=\"line\">在插入位置为 DOM 属性、链接等位置时，要打起精神，严加防范。</span><br><span class=\"line\">增加攻击难度，降低攻击后果</span><br><span class=\"line\">通过 CSP、输入长度配置、接口安全措施等方法，增加攻击的难度，降低攻击的后果。</span><br><span class=\"line\">主动检测和发现</span><br><span class=\"line\">可使用 XSS 攻击字符串和自动扫描工具寻找潜在的 XSS 漏洞。</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">参考： https://juejin.im/post/5bad9140e51d450e935c6d64#heading-9</span><br><span class=\"line\"></span><br><span class=\"line\">xss 攻击类型分为：反射、存储和dom </span><br><span class=\"line\"></span><br><span class=\"line\">在纯前端渲染中，我们会明确的告诉浏览器：下面要设置的内容是文本（.innerText），还是属性（.setAttribute），还是样式（.style）等等。浏览器不会被轻易的被欺骗，执行预期外的代码了.</span><br><span class=\"line\"></span><br><span class=\"line\">在很多内部、管理系统中，采用纯前端渲染是非常合适的。但对于性能要求高，或有 SEO 需求的页面，我们仍然要面对拼接 HTML 的问题。需要html 转义。</span><br><span class=\"line\"></span><br><span class=\"line\">利用模板引擎</span><br><span class=\"line\">开启模板引擎自带的 HTML 转义功能。例如：</span><br><span class=\"line\">在 ejs 中，尽量使用 &lt;%= data %&gt; 而不是 &lt;%- data %&gt;；</span><br><span class=\"line\">在 doT.js 中，尽量使用 &#123;&#123;! data &#125; 而不是 &#123;&#123;= data &#125;；</span><br><span class=\"line\">在 FreeMarker 中，确保引擎版本高于 2.3.24，并且选择正确的 freemarker.core.OutputFormat。</span><br><span class=\"line\">避免内联事件</span><br><span class=\"line\">尽量不要使用 onLoad=&quot;onload(&apos;&#123;&#123;data&#125;&#125;&apos;)&quot;、onClick=&quot;go(&apos;&#123;&#123;action&#125;&#125;&apos;)&quot; 这种拼接内联事件的写法。在 JavaScript 中通过 .addEventlistener() 事件绑定会更安全。</span><br><span class=\"line\">避免拼接 HTML</span><br><span class=\"line\">前端采用拼接 HTML 的方法比较危险，如果框架允许，使用 createElement、setAttribute 之类的方法实现。或者采用比较成熟的渲染框架，如 Vue/React 等。</span><br><span class=\"line\">时刻保持警惕</span><br><span class=\"line\">在插入位置为 DOM 属性、链接等位置时，要打起精神，严加防范。</span><br><span class=\"line\">增加攻击难度，降低攻击后果</span><br><span class=\"line\">通过 CSP、输入长度配置、接口安全措施等方法，增加攻击的难度，降低攻击的后果。</span><br><span class=\"line\">主动检测和发现</span><br><span class=\"line\">可使用 XSS 攻击字符串和自动扫描工具寻找潜在的 XSS 漏洞。</span><br></pre></td></tr></table></figure>\n"},{"title":"typescript","date":"2019-02-25T02:16:27.000Z","_content":"\n### 只读属性\n```\ninterface Point {\n    readonly x: number;\n    readonly y: number;\n}\n```\n\n###  接口继承  \n    支持多重继承, 比较有意思的事接口可以继承类\n\n### 枚举类型\n ```\n enum Color {Red, Green, Blue}\n let c: Color = Color.Green;\n```\n\n### any \n```angular2html\nlet notSure: any = 4;\nnotSure = \"maybe a string instead\";\nnotSure = false; // okay, definitely a boolean\n\n```\n### 类型断言 \nas 和 <>\n\n### 剩余参数 \n```angular2html\nfunction invokeLater(args: any[], callback: (...args: any[]) => void) {\n    /* ... Invoke callback with 'args' ... */\n}\n\n// Unsound - invokeLater \"might\" provide any number of arguments\ninvokeLater([1, 2], (x, y) => console.log(x + ', ' + y));\n\n```\n\n### 交叉类型 特色\nPerson & Serializable & Loggable同时是 Person 和 Serializable 和 Loggable。 就是说这个类型的对象同时拥有了这三种类型的成员。\n\n### 联合类型 \n 如果一个值的类型是 A | B，我们能够 确定的是它包含了 A 和 B中共有的成员。 -- 用来做代码检查的\n ```\ninterface Bird {\n    fly();\n    layEggs();\n}\n\ninterface Fish {\n    swim();\n    layEggs();\n}\n\nfunction getSmallPet(): Fish | Bird {\n    // ...\n}\n\nlet pet = getSmallPet();\npet.layEggs(); // okay\npet.swim();    // error\n\n需要类型转换：(<Fish>pet).swim()\n\n```\n \n###  谓词为 parameterName is Type这种形式\n```\nfunction isFish(pet: Fish | Bird): pet is Fish {\n    return (<Fish>pet).swim !== undefined;\n}\n```\n### 参数指定默认值 \n```angular2html\nfunction keepWholeObject(wholeObject: { a: string, b?: number }) {\n    let { a, b = 1001 } = wholeObject;\n}\nTypeScript编译器不允许展开泛型函数上的类型参数 。 这个特性会在TypeScript的未来版本中考虑实现。 ...\n\n\nfunction buildName(firstName: string, lastName: string = 'Cat') {\n    return firstName + ' ' + lastName;\n}\n\n```\n### 数组泛型   \nArray<number>  \n\nlet list: any[] = ['Xcat Liu', 25, { website: 'http://xcatliu.com' }];\n\n用接口表示数组：\n\ninterface NumberArray {\n    [index: number]: number;\n}\n\n### 声明语句 \ndeclare var jQuery: (string) => any;\n\n我们约定声明文件以 .d.ts 为后缀。\n### 元组 \n```angular2html\nlet xcatliu: [string, number];\nxcatliu[0] = 'Xcat Liu';\nxcatliu[1] = 25;\n```\n### 命名空间  来源于C# \nnamespace Validation {}\n\nimport 别名\n```angular2html\namespace Shapes {\n    export namespace Polygons {\n        export class Triangle { }\n        export class Square { }\n    }\n}\n\nimport polygons = Shapes.Polygons;\nlet sq = new polygons.Square();\n```\n### index \n```angular2html\ntype Index = 'a' | 'b' | 'c'\ntype FromIndex = { [k in Index]?: number }\n\nconst good: FromIndex = {b:1, c:2}\n\n// Error:\n// Type '{ b: number; c: number; d: number; }' is not assignable to type 'FromIndex'.\n// Object literal may only specify known properties, and 'd' does not exist in type 'FromIndex'.\nconst bad: FromIndex = {b:1, c:2, d:3};\n```\n### this 参数\n```angular2html\ninterface Card {\n    suit: string;\n    card: number;\n}\ninterface Deck {\n    suits: string[];\n    cards: number[];\n    createCardPicker(this: Deck): () => Card;\n}\nlet deck: Deck = {\n    suits: [\"hearts\", \"spades\", \"clubs\", \"diamonds\"],\n    cards: Array(52),\n    // NOTE: The function now explicitly specifies that its callee must be of type Deck\n    createCardPicker: function(this: Deck) {\n        return () => {\n            let pickedCard = Math.floor(Math.random() * 52);\n            let pickedSuit = Math.floor(pickedCard / 13);\n\n            return {suit: this.suits[pickedSuit], card: pickedCard % 13};\n        }\n    }\n}\n```\n\n","source":"_posts/typescript.md","raw":"---\ntitle: typescript\ndate: 2019-02-25 10:16:27\ntags: ts\n---\n\n### 只读属性\n```\ninterface Point {\n    readonly x: number;\n    readonly y: number;\n}\n```\n\n###  接口继承  \n    支持多重继承, 比较有意思的事接口可以继承类\n\n### 枚举类型\n ```\n enum Color {Red, Green, Blue}\n let c: Color = Color.Green;\n```\n\n### any \n```angular2html\nlet notSure: any = 4;\nnotSure = \"maybe a string instead\";\nnotSure = false; // okay, definitely a boolean\n\n```\n### 类型断言 \nas 和 <>\n\n### 剩余参数 \n```angular2html\nfunction invokeLater(args: any[], callback: (...args: any[]) => void) {\n    /* ... Invoke callback with 'args' ... */\n}\n\n// Unsound - invokeLater \"might\" provide any number of arguments\ninvokeLater([1, 2], (x, y) => console.log(x + ', ' + y));\n\n```\n\n### 交叉类型 特色\nPerson & Serializable & Loggable同时是 Person 和 Serializable 和 Loggable。 就是说这个类型的对象同时拥有了这三种类型的成员。\n\n### 联合类型 \n 如果一个值的类型是 A | B，我们能够 确定的是它包含了 A 和 B中共有的成员。 -- 用来做代码检查的\n ```\ninterface Bird {\n    fly();\n    layEggs();\n}\n\ninterface Fish {\n    swim();\n    layEggs();\n}\n\nfunction getSmallPet(): Fish | Bird {\n    // ...\n}\n\nlet pet = getSmallPet();\npet.layEggs(); // okay\npet.swim();    // error\n\n需要类型转换：(<Fish>pet).swim()\n\n```\n \n###  谓词为 parameterName is Type这种形式\n```\nfunction isFish(pet: Fish | Bird): pet is Fish {\n    return (<Fish>pet).swim !== undefined;\n}\n```\n### 参数指定默认值 \n```angular2html\nfunction keepWholeObject(wholeObject: { a: string, b?: number }) {\n    let { a, b = 1001 } = wholeObject;\n}\nTypeScript编译器不允许展开泛型函数上的类型参数 。 这个特性会在TypeScript的未来版本中考虑实现。 ...\n\n\nfunction buildName(firstName: string, lastName: string = 'Cat') {\n    return firstName + ' ' + lastName;\n}\n\n```\n### 数组泛型   \nArray<number>  \n\nlet list: any[] = ['Xcat Liu', 25, { website: 'http://xcatliu.com' }];\n\n用接口表示数组：\n\ninterface NumberArray {\n    [index: number]: number;\n}\n\n### 声明语句 \ndeclare var jQuery: (string) => any;\n\n我们约定声明文件以 .d.ts 为后缀。\n### 元组 \n```angular2html\nlet xcatliu: [string, number];\nxcatliu[0] = 'Xcat Liu';\nxcatliu[1] = 25;\n```\n### 命名空间  来源于C# \nnamespace Validation {}\n\nimport 别名\n```angular2html\namespace Shapes {\n    export namespace Polygons {\n        export class Triangle { }\n        export class Square { }\n    }\n}\n\nimport polygons = Shapes.Polygons;\nlet sq = new polygons.Square();\n```\n### index \n```angular2html\ntype Index = 'a' | 'b' | 'c'\ntype FromIndex = { [k in Index]?: number }\n\nconst good: FromIndex = {b:1, c:2}\n\n// Error:\n// Type '{ b: number; c: number; d: number; }' is not assignable to type 'FromIndex'.\n// Object literal may only specify known properties, and 'd' does not exist in type 'FromIndex'.\nconst bad: FromIndex = {b:1, c:2, d:3};\n```\n### this 参数\n```angular2html\ninterface Card {\n    suit: string;\n    card: number;\n}\ninterface Deck {\n    suits: string[];\n    cards: number[];\n    createCardPicker(this: Deck): () => Card;\n}\nlet deck: Deck = {\n    suits: [\"hearts\", \"spades\", \"clubs\", \"diamonds\"],\n    cards: Array(52),\n    // NOTE: The function now explicitly specifies that its callee must be of type Deck\n    createCardPicker: function(this: Deck) {\n        return () => {\n            let pickedCard = Math.floor(Math.random() * 52);\n            let pickedSuit = Math.floor(pickedCard / 13);\n\n            return {suit: this.suits[pickedSuit], card: pickedCard % 13};\n        }\n    }\n}\n```\n\n","slug":"typescript","published":1,"updated":"2020-06-29T06:22:24.363Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckzf5se0b001yyy8k12cc98uq","content":"<h3 id=\"只读属性\"><a href=\"#只读属性\" class=\"headerlink\" title=\"只读属性\"></a>只读属性</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface Point &#123;</span><br><span class=\"line\">    readonly x: number;</span><br><span class=\"line\">    readonly y: number;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"接口继承\"><a href=\"#接口继承\" class=\"headerlink\" title=\"接口继承\"></a>接口继承</h3><pre><code>支持多重继承, 比较有意思的事接口可以继承类\n</code></pre><h3 id=\"枚举类型\"><a href=\"#枚举类型\" class=\"headerlink\" title=\"枚举类型\"></a>枚举类型</h3> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum Color &#123;Red, Green, Blue&#125;</span><br><span class=\"line\">let c: Color = Color.Green;</span><br></pre></td></tr></table></figure>\n<h3 id=\"any\"><a href=\"#any\" class=\"headerlink\" title=\"any\"></a>any</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let notSure: any = 4;</span><br><span class=\"line\">notSure = &quot;maybe a string instead&quot;;</span><br><span class=\"line\">notSure = false; // okay, definitely a boolean</span><br></pre></td></tr></table></figure>\n<h3 id=\"类型断言\"><a href=\"#类型断言\" class=\"headerlink\" title=\"类型断言\"></a>类型断言</h3><p>as 和 &lt;&gt;</p>\n<h3 id=\"剩余参数\"><a href=\"#剩余参数\" class=\"headerlink\" title=\"剩余参数\"></a>剩余参数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function invokeLater(args: any[], callback: (...args: any[]) =&gt; void) &#123;</span><br><span class=\"line\">    /* ... Invoke callback with &apos;args&apos; ... */</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Unsound - invokeLater &quot;might&quot; provide any number of arguments</span><br><span class=\"line\">invokeLater([1, 2], (x, y) =&gt; console.log(x + &apos;, &apos; + y));</span><br></pre></td></tr></table></figure>\n<h3 id=\"交叉类型-特色\"><a href=\"#交叉类型-特色\" class=\"headerlink\" title=\"交叉类型 特色\"></a>交叉类型 特色</h3><p>Person &amp; Serializable &amp; Loggable同时是 Person 和 Serializable 和 Loggable。 就是说这个类型的对象同时拥有了这三种类型的成员。</p>\n<h3 id=\"联合类型\"><a href=\"#联合类型\" class=\"headerlink\" title=\"联合类型\"></a>联合类型</h3><p> 如果一个值的类型是 A | B，我们能够 确定的是它包含了 A 和 B中共有的成员。 – 用来做代码检查的<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface Bird &#123;</span><br><span class=\"line\">    fly();</span><br><span class=\"line\">    layEggs();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">interface Fish &#123;</span><br><span class=\"line\">    swim();</span><br><span class=\"line\">    layEggs();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function getSmallPet(): Fish | Bird &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let pet = getSmallPet();</span><br><span class=\"line\">pet.layEggs(); // okay</span><br><span class=\"line\">pet.swim();    // error</span><br><span class=\"line\"></span><br><span class=\"line\">需要类型转换：(&lt;Fish&gt;pet).swim()</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"谓词为-parameterName-is-Type这种形式\"><a href=\"#谓词为-parameterName-is-Type这种形式\" class=\"headerlink\" title=\"谓词为 parameterName is Type这种形式\"></a>谓词为 parameterName is Type这种形式</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function isFish(pet: Fish | Bird): pet is Fish &#123;</span><br><span class=\"line\">    return (&lt;Fish&gt;pet).swim !== undefined;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"参数指定默认值\"><a href=\"#参数指定默认值\" class=\"headerlink\" title=\"参数指定默认值\"></a>参数指定默认值</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function keepWholeObject(wholeObject: &#123; a: string, b?: number &#125;) &#123;</span><br><span class=\"line\">    let &#123; a, b = 1001 &#125; = wholeObject;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">TypeScript编译器不允许展开泛型函数上的类型参数 。 这个特性会在TypeScript的未来版本中考虑实现。 ...</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">function buildName(firstName: string, lastName: string = &apos;Cat&apos;) &#123;</span><br><span class=\"line\">    return firstName + &apos; &apos; + lastName;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"数组泛型\"><a href=\"#数组泛型\" class=\"headerlink\" title=\"数组泛型\"></a>数组泛型</h3><p>Array<number>  </number></p>\n<p>let list: any[] = [‘Xcat Liu’, 25, { website: ‘<a href=\"http://xcatliu.com&#39;\" target=\"_blank\" rel=\"noopener\">http://xcatliu.com&#39;</a> }];</p>\n<p>用接口表示数组：</p>\n<p>interface NumberArray {<br>    [index: number]: number;<br>}</p>\n<h3 id=\"声明语句\"><a href=\"#声明语句\" class=\"headerlink\" title=\"声明语句\"></a>声明语句</h3><p>declare var jQuery: (string) =&gt; any;</p>\n<p>我们约定声明文件以 .d.ts 为后缀。</p>\n<h3 id=\"元组\"><a href=\"#元组\" class=\"headerlink\" title=\"元组\"></a>元组</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let xcatliu: [string, number];</span><br><span class=\"line\">xcatliu[0] = &apos;Xcat Liu&apos;;</span><br><span class=\"line\">xcatliu[1] = 25;</span><br></pre></td></tr></table></figure>\n<h3 id=\"命名空间-来源于C\"><a href=\"#命名空间-来源于C\" class=\"headerlink\" title=\"命名空间  来源于C\"></a>命名空间  来源于C</h3><p>namespace Validation {}</p>\n<p>import 别名<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">amespace Shapes &#123;</span><br><span class=\"line\">    export namespace Polygons &#123;</span><br><span class=\"line\">        export class Triangle &#123; &#125;</span><br><span class=\"line\">        export class Square &#123; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">import polygons = Shapes.Polygons;</span><br><span class=\"line\">let sq = new polygons.Square();</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"index\"><a href=\"#index\" class=\"headerlink\" title=\"index\"></a>index</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Index = &apos;a&apos; | &apos;b&apos; | &apos;c&apos;</span><br><span class=\"line\">type FromIndex = &#123; [k in Index]?: number &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const good: FromIndex = &#123;b:1, c:2&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Error:</span><br><span class=\"line\">// Type &apos;&#123; b: number; c: number; d: number; &#125;&apos; is not assignable to type &apos;FromIndex&apos;.</span><br><span class=\"line\">// Object literal may only specify known properties, and &apos;d&apos; does not exist in type &apos;FromIndex&apos;.</span><br><span class=\"line\">const bad: FromIndex = &#123;b:1, c:2, d:3&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"this-参数\"><a href=\"#this-参数\" class=\"headerlink\" title=\"this 参数\"></a>this 参数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface Card &#123;</span><br><span class=\"line\">    suit: string;</span><br><span class=\"line\">    card: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">interface Deck &#123;</span><br><span class=\"line\">    suits: string[];</span><br><span class=\"line\">    cards: number[];</span><br><span class=\"line\">    createCardPicker(this: Deck): () =&gt; Card;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let deck: Deck = &#123;</span><br><span class=\"line\">    suits: [&quot;hearts&quot;, &quot;spades&quot;, &quot;clubs&quot;, &quot;diamonds&quot;],</span><br><span class=\"line\">    cards: Array(52),</span><br><span class=\"line\">    // NOTE: The function now explicitly specifies that its callee must be of type Deck</span><br><span class=\"line\">    createCardPicker: function(this: Deck) &#123;</span><br><span class=\"line\">        return () =&gt; &#123;</span><br><span class=\"line\">            let pickedCard = Math.floor(Math.random() * 52);</span><br><span class=\"line\">            let pickedSuit = Math.floor(pickedCard / 13);</span><br><span class=\"line\"></span><br><span class=\"line\">            return &#123;suit: this.suits[pickedSuit], card: pickedCard % 13&#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"只读属性\"><a href=\"#只读属性\" class=\"headerlink\" title=\"只读属性\"></a>只读属性</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface Point &#123;</span><br><span class=\"line\">    readonly x: number;</span><br><span class=\"line\">    readonly y: number;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"接口继承\"><a href=\"#接口继承\" class=\"headerlink\" title=\"接口继承\"></a>接口继承</h3><pre><code>支持多重继承, 比较有意思的事接口可以继承类\n</code></pre><h3 id=\"枚举类型\"><a href=\"#枚举类型\" class=\"headerlink\" title=\"枚举类型\"></a>枚举类型</h3> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum Color &#123;Red, Green, Blue&#125;</span><br><span class=\"line\">let c: Color = Color.Green;</span><br></pre></td></tr></table></figure>\n<h3 id=\"any\"><a href=\"#any\" class=\"headerlink\" title=\"any\"></a>any</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let notSure: any = 4;</span><br><span class=\"line\">notSure = &quot;maybe a string instead&quot;;</span><br><span class=\"line\">notSure = false; // okay, definitely a boolean</span><br></pre></td></tr></table></figure>\n<h3 id=\"类型断言\"><a href=\"#类型断言\" class=\"headerlink\" title=\"类型断言\"></a>类型断言</h3><p>as 和 &lt;&gt;</p>\n<h3 id=\"剩余参数\"><a href=\"#剩余参数\" class=\"headerlink\" title=\"剩余参数\"></a>剩余参数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function invokeLater(args: any[], callback: (...args: any[]) =&gt; void) &#123;</span><br><span class=\"line\">    /* ... Invoke callback with &apos;args&apos; ... */</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Unsound - invokeLater &quot;might&quot; provide any number of arguments</span><br><span class=\"line\">invokeLater([1, 2], (x, y) =&gt; console.log(x + &apos;, &apos; + y));</span><br></pre></td></tr></table></figure>\n<h3 id=\"交叉类型-特色\"><a href=\"#交叉类型-特色\" class=\"headerlink\" title=\"交叉类型 特色\"></a>交叉类型 特色</h3><p>Person &amp; Serializable &amp; Loggable同时是 Person 和 Serializable 和 Loggable。 就是说这个类型的对象同时拥有了这三种类型的成员。</p>\n<h3 id=\"联合类型\"><a href=\"#联合类型\" class=\"headerlink\" title=\"联合类型\"></a>联合类型</h3><p> 如果一个值的类型是 A | B，我们能够 确定的是它包含了 A 和 B中共有的成员。 – 用来做代码检查的<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface Bird &#123;</span><br><span class=\"line\">    fly();</span><br><span class=\"line\">    layEggs();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">interface Fish &#123;</span><br><span class=\"line\">    swim();</span><br><span class=\"line\">    layEggs();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function getSmallPet(): Fish | Bird &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let pet = getSmallPet();</span><br><span class=\"line\">pet.layEggs(); // okay</span><br><span class=\"line\">pet.swim();    // error</span><br><span class=\"line\"></span><br><span class=\"line\">需要类型转换：(&lt;Fish&gt;pet).swim()</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"谓词为-parameterName-is-Type这种形式\"><a href=\"#谓词为-parameterName-is-Type这种形式\" class=\"headerlink\" title=\"谓词为 parameterName is Type这种形式\"></a>谓词为 parameterName is Type这种形式</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function isFish(pet: Fish | Bird): pet is Fish &#123;</span><br><span class=\"line\">    return (&lt;Fish&gt;pet).swim !== undefined;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"参数指定默认值\"><a href=\"#参数指定默认值\" class=\"headerlink\" title=\"参数指定默认值\"></a>参数指定默认值</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function keepWholeObject(wholeObject: &#123; a: string, b?: number &#125;) &#123;</span><br><span class=\"line\">    let &#123; a, b = 1001 &#125; = wholeObject;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">TypeScript编译器不允许展开泛型函数上的类型参数 。 这个特性会在TypeScript的未来版本中考虑实现。 ...</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">function buildName(firstName: string, lastName: string = &apos;Cat&apos;) &#123;</span><br><span class=\"line\">    return firstName + &apos; &apos; + lastName;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"数组泛型\"><a href=\"#数组泛型\" class=\"headerlink\" title=\"数组泛型\"></a>数组泛型</h3><p>Array<number>  </number></p>\n<p>let list: any[] = [‘Xcat Liu’, 25, { website: ‘<a href=\"http://xcatliu.com&#39;\" target=\"_blank\" rel=\"noopener\">http://xcatliu.com&#39;</a> }];</p>\n<p>用接口表示数组：</p>\n<p>interface NumberArray {<br>    [index: number]: number;<br>}</p>\n<h3 id=\"声明语句\"><a href=\"#声明语句\" class=\"headerlink\" title=\"声明语句\"></a>声明语句</h3><p>declare var jQuery: (string) =&gt; any;</p>\n<p>我们约定声明文件以 .d.ts 为后缀。</p>\n<h3 id=\"元组\"><a href=\"#元组\" class=\"headerlink\" title=\"元组\"></a>元组</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let xcatliu: [string, number];</span><br><span class=\"line\">xcatliu[0] = &apos;Xcat Liu&apos;;</span><br><span class=\"line\">xcatliu[1] = 25;</span><br></pre></td></tr></table></figure>\n<h3 id=\"命名空间-来源于C\"><a href=\"#命名空间-来源于C\" class=\"headerlink\" title=\"命名空间  来源于C\"></a>命名空间  来源于C</h3><p>namespace Validation {}</p>\n<p>import 别名<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">amespace Shapes &#123;</span><br><span class=\"line\">    export namespace Polygons &#123;</span><br><span class=\"line\">        export class Triangle &#123; &#125;</span><br><span class=\"line\">        export class Square &#123; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">import polygons = Shapes.Polygons;</span><br><span class=\"line\">let sq = new polygons.Square();</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"index\"><a href=\"#index\" class=\"headerlink\" title=\"index\"></a>index</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Index = &apos;a&apos; | &apos;b&apos; | &apos;c&apos;</span><br><span class=\"line\">type FromIndex = &#123; [k in Index]?: number &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const good: FromIndex = &#123;b:1, c:2&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Error:</span><br><span class=\"line\">// Type &apos;&#123; b: number; c: number; d: number; &#125;&apos; is not assignable to type &apos;FromIndex&apos;.</span><br><span class=\"line\">// Object literal may only specify known properties, and &apos;d&apos; does not exist in type &apos;FromIndex&apos;.</span><br><span class=\"line\">const bad: FromIndex = &#123;b:1, c:2, d:3&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"this-参数\"><a href=\"#this-参数\" class=\"headerlink\" title=\"this 参数\"></a>this 参数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface Card &#123;</span><br><span class=\"line\">    suit: string;</span><br><span class=\"line\">    card: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">interface Deck &#123;</span><br><span class=\"line\">    suits: string[];</span><br><span class=\"line\">    cards: number[];</span><br><span class=\"line\">    createCardPicker(this: Deck): () =&gt; Card;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let deck: Deck = &#123;</span><br><span class=\"line\">    suits: [&quot;hearts&quot;, &quot;spades&quot;, &quot;clubs&quot;, &quot;diamonds&quot;],</span><br><span class=\"line\">    cards: Array(52),</span><br><span class=\"line\">    // NOTE: The function now explicitly specifies that its callee must be of type Deck</span><br><span class=\"line\">    createCardPicker: function(this: Deck) &#123;</span><br><span class=\"line\">        return () =&gt; &#123;</span><br><span class=\"line\">            let pickedCard = Math.floor(Math.random() * 52);</span><br><span class=\"line\">            let pickedSuit = Math.floor(pickedCard / 13);</span><br><span class=\"line\"></span><br><span class=\"line\">            return &#123;suit: this.suits[pickedSuit], card: pickedCard % 13&#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"vue","date":"2017-01-19T07:19:03.000Z","_content":"### js\n1. 这里对该vm注册一个Watcher实例，Watcher的getter为updateComponent函数，用于触发所有渲染所需要用到的数据的getter，进行依赖收集，就是在mounted的时候进行依赖收集。\n\n用户的自定义 watcher 要优先于渲染 watcher 执行；因为用户自定义 watcher 是在渲染 watcher 之前创建的。Vm._watcher.update()\n\n1. 对于渲染 watcher 而言，它在执行 this.get() 方法求值的时候，会执行 getter 方法： updateComponent = () => {\n   updateComponent = () => { vm._update(vm._render(), hydrating)\n1. vue diff 算法\n```text\n//相同的话进行patch\npatchVnode (oldVnode, vnode) {\n    const el = vnode.el = oldVnode.el\n    let i, oldCh = oldVnode.children, ch = vnode.children\n    if (oldVnode === vnode) return\n    if (oldVnode.text !== null && vnode.text !== null && oldVnode.text !== vnode.text) {\n        api.setTextContent(el, vnode.text)\n    }else {\n        updateEle(el, vnode, oldVnode)\n    \tif (oldCh && ch && oldCh !== ch) {\n            updateChildren(el, oldCh, ch)\n    \t}else if (ch){\n            createEle(vnode) //create el's children dom\n    \t}else if (oldCh){\n            api.removeChildren(el)\n    \t}\n    }\n}\n```\n1. 提高性能\n```text\n\n压缩代码\n提取页面公共资源 基础包cdn\\splitchunks\nTree shaking \nscope hoisting\n图片压缩 \n动态polyfill \n\n```\n1. 事件代理：1. 减少事件注册，节省内存。 2. 简化了dom更新时，上面的事件off与on 操作。focus，blur之类的，本身就没用冒泡的特性\n2. 函数式组件与普通组件的区别\n   \n   函数式组件需要在声明组件是指定functional\n   函数式组件不需要实例化，所以没有this,this通过render函数的第二个参数来代替\n   函数式组件没有生命周期钩子函数，不能使用计算属性，watch等等\n   函数式组件不能通过$emit对外暴露事件，调用事件只能通过context.listeners.click的方式调用外部传入的事件\n   因为函数式组件是没有实例化的，所以在外部通过ref去引用组件时，实际引用的是HTMLElement\n   函数式组件的props可以不用显示声明，所以没有在props里面声明的属性都会被自动隐式解析为prop,而普通组件所有未声明的属性都被解析到$attrs里面，并自动挂载到组件根元素上面(可以通过inheritAttrs属性禁止)\n\n3. 「适合引入自动化测试的场景：」\n\n公共库类的开发维护\n中长期项目的迭代/重构\n引用了不可控的第三方依赖\n\n1. Observer 是一个类，它的作用是给对象的属性添加 getter 和 setter，用于依赖收集和派发更新。Render 时通过getter 进行依赖收集。\n2. Dep 是一个 Class，它定义了一些属性和方法，这里需要特别注意的是它有一个静态属性 target，这是一个全局唯一 Watcher，这是一个非常巧妙的设计，\n因为在同一时间只能有一个全局的 Watcher 被计算，另外它的自身属性 subs 也是 Watcher 的数组。\n3. vue array 拦截\n```js\n /*取得原生数组的原型*/\nconst arrayProto = Array.prototype\n/*创建一个新的数组对象，修改该对象上的数组的七个方法，防止污染原生数组方法*/\nexport const arrayMethods = Object.create(arrayProto)\n```\n1. 首先通过 Vue.options = Object.create(null) 创建一个空对象，然后遍历 ASSET_TYPES: \n    Vue.options.components = {}\n    Vue.options.directives = {} \n    Vue.options.filters = {}\n \n3. vue 父子组件：\n加载渲染过程\n父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted\n父beforeUpdate->子beforeUpdate->子updated->父updated\n父组件更新过程\n父beforeUpdate->父updated\n销毁过程\n父beforeDestroy->子beforeDestroy->子destroyed->父destroyed\n\n1. for await...of循环，则是用于遍历异步的 Iterator 接口。\n```javascript\nfunction main(inputFilePath) {\n  const readStream = fs.createReadStream(\n    inputFilePath,\n    { encoding: 'utf8', highWaterMark: 1024 }\n  );\n  readStream.on('data', (chunk) => {\n    console.log('>>> '+chunk);\n  });\n  readStream.on('end', () => {\n    console.log('### DONE ###');\n  });\n}\n\n// 异步遍历器写法\nasync function main(inputFilePath) {\n  const readStream = fs.createReadStream(\n    inputFilePath,\n    { encoding: 'utf8', highWaterMark: 1024 }\n  );\n\n  for await (const chunk of readStream) {\n    console.log('>>> '+chunk);\n  }\n  console.log('### DONE ###');\n}\n```  \n1. Vm.$watch this._data.$$state 的值，/* 检测store中的_committing的值，如果是true代表不是通过mutation的方法修改的 */\n2. /* 这里new了一个Vue对象，运用Vue内部的响应式实现注册state以及computed*/\n    store._vm = new Vue({ data: {$$state: state }, computed })\n3. this.$on('hook:updated', () => {})\n \n1. Vue.config.optionMergeStrategies  \n1.  在Vue2.5之前，使用函数式组件只能通过JSX的方式，在之后，可以通过模板语法来生命函数式组件\n ```html\n <!--在template 上面添加 functional属性-->\n<template functional>\n  <img :src=\"avatar ? avatar : 'default-avatar.png'\" />\n</template>\n<!--根据上一节第六条，可以省略声明props-->\n ```\n\n1. Vue beforecreated:data vue 实例化、init events\n \n1.  作用域插槽 this.$scopedSlots.header({ text: this.headerText })\n   \n2. 全局的components ，通过vue 的options merge 到组件上。 最后通过 extend(Vue.options.components, builtInComponents) 把一些内置组件扩展到 Vue.options.components 上，\nVue 的内置组件目前有 <keep-alive>、<transition> 和 <transition-group> 组件，这也就是为什么我们在其它组件中使用 <keep-alive> 组件不需要注册的原因\n\n11. components，filters，directives\n   两个对象合并的时候，不会相互覆盖，而是 权重小的 被放到 权重大 的 的原型上\n13. 数组叠加   包括生命周期函数和watch\n14. 函数合并叠加   包括选项：data，provide，权重大的优先 \n1. 最主要最关键的原因是函数式组件不需要实例化，无状态，没有生命周期，所以渲染性能要好于普通组件\n   函数式组件结构比较简单，代码结构更清晰\n4. inject 用法：\n\n```javastript\n   inject: {\n   // 注入的属性名称 parentForm: {\n   // 通过 from 指定从哪个属性注入\n   from: 'customForm',\n    default: () => ({ size: 'default' }) } },\n```\n1. redirective  \n\n```text\nbinding：一个对象，包含以下 property：\nname：指令名，不包括 v- 前缀。\nvalue：指令的绑定值，例如：v-my-directive=\"1 + 1\" 中，绑定值为 2。\noldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。\nexpression：字符串形式的指令表达式。例如 v-my-directive=\"1 + 1\" 中，表达式为 \"1 + 1\"。\narg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 \"foo\"。\nmodifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。\n```\n\n1. Async validator\n ```javascript\n asyncValidator: (rule, value) => {\n        return new Promise((resolve, reject) => {\n          if (value < 18) {\n            reject(\"too young\");  // reject with error message\n          } else {\n            resolve();\n          }\n        });\n      }\n ```\n\n1.  ref用创建一个包装对象，只具备一个响应式属性value，如果将对象指定为ref的值，该对象将被reactive方法深度遍历。如果传入 ref 的是一个对象，将调用 reactive 方法进行深层响应转换。所以ref 可以解构\n1. history 模式：\n```text\n通过 history.pushState() 方法改变地址栏\n监听 popstate 事件\n根据当前路由地址找到对应组件重新渲染\n```\n\n1. `<input type=\"text\" v-on=\"{ input:onInput,focus:onFocus,blur:onBlur, }\">`   同样 v-bind \n1. keepalive mouted 只会执行一次，vnode上关联的component intance,在patch 阶段会转换为真实的dom.\n1.\n```javascript\n/*parse解析得到ast树*/\n  \n    const ast = parse(template.trim(), options)\n    /*\n      将AST树进行优化\n      优化的目标：生成模板AST树，检测不需要进行DOM改变的静态子树。\n      一旦检测到这些静态树，我们就能做以下这些事情：\n      1.把它们变成常数，这样我们就再也不需要每次重新渲染时创建新的节点了。\n      2.在patch的过程中直接跳过。\n   */\n    optimize(ast, options)\n```\n\n  optimize的主要作用是标记static静态节点，这是Vue在编译过程中的一处优化，后面当update更新界面时，会有一个patch的过程，diff算法会直接跳过静态节点，从而减少了比较的过程，优化了patch的性能。\n  \n1. Render\n// resolve template/el and convert to render function 。mounted 方法中\n在此方法中调用 vm._render 方法先生成虚拟 Node(render 函数返回的就是vnode)，最终调用 vm._update 更新 DOM。\n\nUpdate 调用的时机：1.首次渲染 2.数据更新 \n\n \n1. \n1. Vue 通过在内存中实现文档结构的虚拟表示来解决此问题，其中虚拟节点（VNode）表示 DOM 树中的节点。当需要操纵时，可以在虚拟 DOM的 内存中执行计算和操作，而不是在真实 DOM 上进行操纵。这自然会更快，并且允许虚拟 DOM 算法计算出最优化的方式来更新实际 DOM 结构。\n1. \nVue 不会对 provide 中的变量进行响应式处理。所以，要想 inject 接受的变量是响应式的，provide 提供的变量本身就需要是响应式的。单项数据流\n\ninheritAttrs: false, // 可以关闭自动挂载到组件根元素上的没有在props声明的属性\n1. 子组件不需要任何处理，只需要在父组件引用的时候通过@hook来监听即可，代码重写如下：<Child @hook:mounted=\"doSomething”/>\n1. 数据动态变化：\n   export const store = Vue.observable({ count: 0 });\n1. vue life cycle\n```\nparse阶段：使用正在表达式将template进行字符串解析，得到指令、class、style等数据，生成抽象语法树 AST。\noptimize阶段：寻找 AST 中的静态节点进行标记，为后面 VNode 的 patch 过程中对比做优化。被标记为 static 的节点在后面的 diff 算法中会被直接忽略，不做详细的比较。\n\ngenerate阶段：根据 AST 结构拼接生成 render 函数的字符串。\n```\n [life cycle](https://user-gold-cdn.xitu.io/2019/12/26/16f40a08cac6d3cb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n1. 每个逻辑关注点的代码现在都在复合函数中并置在一起。 这大大减少了在处理大型组件时需要不断“跳转”的情况。 组合函数也可以在编辑器中折叠，使组件更容易扫描:\n\n1. js 链接 defer 和 async\n1. keep-alive 的实现正是用到了 LRU 策略,将最近访问的组件 push 到 this.keys 最后面,this.keys[0]也就是最久没被访问的组件,当缓存实例超过 max 设置值,删除 this.keys[0]\n\n```text\ndefer 和 async 都是并行加载的，主要区别在于下载后何时执行。\n每一个 async 属性的脚本都在它下载结束之后立刻执行，所以就有可能出现脚本执行顺序被打乱的情况\n每一个 defer 属性的脚本会在 HTML 解析完成后, DOMContentLoaded 之前，按照 DOM 中的顺序执行（ie>=10）\ndefer 和 async 都只适用于外部脚本文件，对与内联的 script 标签是不起作用\n\n```\n1. preload 用 “as” 或者用 “type” 属性来表示他们请求资源的优先级（比如说 preload 使用 as=\"style\" 属性将获得最高的优先级）。没有 “as” 属性的将被看作异步请求，“Early”意味着在所有未被预加载的图片请求之前被请求（“late”意味着之后）\n \n \n \n2. Vue.config.errorHandler   \n3. v-pre  场景:vue 是响应式系统,但是有些静态的标签不需要多次编译,这样可以节省性能\n4. v-loader transformAssetUrls  \n在模板编译过程中，编译器可以将某些特性转换为 require 调用，例如 src 中的 URL。因此这些目标资源可以被 webpack 处理。例如 <img src=\"./foo.png\"> 会找到你文件系统中的 ./foo.png 并将其作为一个依赖包含在你的包里\n\n1. view router加key  场景:由于 Vue 会复用相同组件, 即 /page/1 => /page/2 或者 /page?id=1 => /page?id=2 这类链接跳转时, 将不在执行created, mounted之类的钩子\n\n1.![事件循环](https://github.com/ryansecret/blog/blob/master/source/asset/eventloop.jpg)\n1. 生命周期\n```text\nbeforeCreate阶段：vue实例的挂载元素el和数据对象data都是undefined，还没有初始化。\ncreated阶段：vue实例的数据对象data有了，可以访问里面的数据和方法，未挂载到DOM，el还没有\nbeforeMount阶段：vue实例的el和data都初始化了，但是挂载之前为虚拟的dom节点\nmounted阶段：vue实例挂载到真实DOM上，就可以通过DOM获取DOM节点\nbeforeUpdate阶段：响应式数据更新时调用，发生在虚拟DOM打补丁之前，适合在更新之前访问现有的DOM，比如手动移除已添加的事件监听器\nupdated阶段：虚拟DOM重新渲染和打补丁之后调用，组成新的DOM已经更新，避免在这个钩子函数中操作数据，防止死循环\nbeforeDestroy阶段：实例销毁前调用，实例还可以用，this能获取到实例，常用于销毁定时器，解绑事件\ndestroyed阶段：实例销毁后调用，调用后所有事件监听器会被移除，所有的子实例都会被销毁  \n```         \n1. __proto__ 属性，这是历史遗留的非标准的语法，但在现代浏览器中广泛实现。获得原型的更可靠方法是使用 Object.getPrototypeOf(new Object())；例如：\n ```javascript\nconst car = {}\nconst list = []\n \nconsole.log(Object.getPrototypeOf(car));\nconsole.log(Object.getPrototypeOf(list));\n```\n \n### 内部机制 \n\nvue-loader \n\ncompiler 目录包含 Vue.js 所有编译相关的代码。它包括把模板解析成 ast 语法树，ast 语法树优化，代码生成等功能。\n\n\n微任务的例子：micortask\n\nprocess.nextTick\npromise\nObject.observe\n\n宏任务的例子：\n\nsetTimeout\nsetInterval\nsetImmediate\nI/O\n\n需要注意的是node 和 浏览器的 event loop 是有区别的(需要注意的是node v12.0 之后和浏览器处理事一致的)：\n\n```text\n浏览器的事件循环：\n\n执行全局Script同步代码，这些同步代码有一些是同步语句，有一些是异步语句（比如setTimeout等）；\n全局Script代码执行完毕后，调用栈Stack会清空；\n从微队列microtask queue中取出位于队首的回调任务，放入调用栈Stack中执行，执行完后microtask queue长度减1；\n继续取出位于队首的任务，放入调用栈Stack中执行，以此类推，直到直到把microtask queue中的所有任务都执行完毕。注意，如果在执行microtask的过程中，又产生了microtask，那么会加入到队列的末尾，也会在这个周期被调用执行；\nmicrotask queue中的所有任务都执行完毕，此时microtask queue为空队列，调用栈Stack也为空；\n取出宏队列macrotask queue中位于队首的任务，放入Stack中执行；\n执行完毕后，调用栈Stack为空；\n重复第3-7个步骤；\n重复第3-7个步骤；\n……\n\nNodeJS中微队列主要有2个：\nNext Tick Queue：是放置process.nextTick(callback)的回调任务的\nOther Micro Queue：放置其他microtask，比如Promise等\n\n具体参见： https://segmentfault.com/a/1190000016278115\n\n```\n\n\n``` \ntimers 阶段：这个阶段执行timer（setTimeout、setInterval）的回调\nI/O callbacks 阶段：执行一些系统调用错误，比如网络通信的错误回调\nidle, prepare 阶段：仅node内部使用\npoll 阶段：获取新的I/O事件, 适当的条件下node将阻塞在这里\ncheck 阶段：执行 setImmediate() 的回调\nclose callbacks 阶段：执行 socket 的 close 事件回调\n\ntimers 是事件循环的第一个阶段，Node 会去检查有无已过期的timer，如果有则把它的回调压入timer的任务队列中等待执行，事实上，Node 并不能保证timer在预设时间到了就会立即执行，因为Node对timer的过期检查不一定靠谱，它会受机器上其它运行程序影响，或者那个时间点主线程不空闲。比如下面的代码，setTimeout() 和 setImmediate() 的执行顺序是不确定的。\n\npoll 阶段\npoll 阶段主要有2个功能：\n\n处理 poll 队列的事件\n当有已超时的 timer，执行它的回调函数\neven loop将同步执行poll队列里的回调，直到队列为空或执行的回调达到系统上限（上限具体多少未详），接下来even loop会去检查有无预设的setImmediate()，分两种情况：\n\n若有预设的setImmediate(), event loop将结束poll阶段进入check阶段，并执行check阶段的任务队列\n若没有预设的setImmediate()，event loop将阻塞在该阶段等待\n注意一个细节，没有setImmediate()会导致event loop阻塞在poll阶段，这样之前设置的timer岂不是执行不了了？所以咧，在poll阶段event loop会有一个检查机制，检查timer队列是否为空，如果timer队列非空，event loop就开始下一轮事件循环，即重新进入到timer阶段。\n\ncheck 阶段\nsetImmediate()的回调会被加入check队列中，从event loop的阶段图可以知道，check阶段的执行顺序在poll阶段之后。\n\n\n回顾上一篇，浏览器环境下，microtask的任务队列是每个macrotask执行完之后执行。而在Node.js中，microtask会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行microtask队列的任务。详见：http://lynnelv.github.io/js-event-loop-nodejs\n\nprocess.nextTick() 会在各个事件阶段之间执行，一旦执行，要直到nextTick队列被清空，才会进入到下一个事件阶段，所以如果递归调用 process.nextTick()，会导致出现I/O starving（饥饿）的问题\n\n官方文档：https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/\n\n```\n\n\n\n###vitual dom\n \n\nVD 最大的特点是将页面的状态抽象为 JS 对象的形式，配合不同的渲染工具，使跨平台渲染成为可能。如 React 就借助 VD 实现了服务端渲染、浏览器渲染和移动端渲染等功能。\njs计算-》生成渲染树-》渲染页面\n\n通过VD的比较，我们可以将多个操作合并成一个批量的操作，从而减少dom重排的次数，进而缩短了生成渲染树和绘制所花的时间。\n\n在mounted 方法中会将template 编译成为render 方法。这是一个编译过程，render中会调用createElement 创建vnode。\n\n![流程图片](https://ustbhuangyi.github.io/vue-analysis/assets/new-vue.png)\n\n\n回到 mountComponent 函数的过程，我们已经知道 createElement 是如何创建了一个 VNode，接下来就是要把这个 VNode 渲染成一个真实的 DOM 并渲染出来，这个过程是通过 vm._update 完成的\n\nVue 的 _update 是实例的一个私有方法，它被调用的时机有 2 个，一个是首次渲染，一个是数据更新的时候；由于我们这一章节只分析首次渲染部分，数据更新部分会在之后分析响应式原理的时候涉及。_update 方法的作用是把 VNode 渲染成真实的 DOM\n\n\n在我们之前对 setter 的分析过程知道，当响应式数据发送变化后，触发了 watcher.update()，只是把这个 watcher 推送到一个队列中，在 nextTick 后才会真正执行 watcher 的回调函数。而一旦我们设置了 sync，就可以在当前 Tick 中同步执行 watcher 的回调函数。\n \n\n##### 修饰符（Modifiers）是以半角句号 . 指明的特殊后缀，用于指出一个指定应该以特殊方式绑定。例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()\n\n```\n<!-- 阻止单击事件冒泡 -->\n<a v-on:click.stop=\"doThis\"></a>\n<!-- 提交事件不再重载页面 -->\n<form v-on:submit.prevent=\"onSubmit\"></form>\n<!-- 修饰符可以串联  -->\n<a v-on:click.stop.prevent=\"doThat\"></a>\n<!-- 只有修饰符 -->\n<form v-on:submit.prevent></form>\n<!-- 添加事件侦听器时使用事件捕获模式 -->\n<div v-on:click.capture=\"doThis\">...</div>\n<!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 -->\n<div v-on:click.self=\"doThat\">...</div>\n<a v-on:click.once=\"doThis\"></a>\n```\n \n\n##### 按键修饰符\n记住所有的 keyCode 比较困难，组合键 所以 Vue 为最常用的按键提供了别名：\n\n```\n<!-- Alt + C -->\n<input v-on:keyup.alt.67=\"clear\">\n\n<!-- Ctrl + Click -->\n<div v-on:click.ctrl=\"doSomething\">Do something</div>\n<!-- 同上 -->\n<input v-on:keyup.enter=\"submit\">\n<!-- 缩写语法 -->\n<input @keyup.enter=\"submit\">\n全部的按键别名：\n.enter\n.tab\n.delete (捕获 “删除” 和 “退格” 键)\n.esc\n.space\n.up\n.down\n.left\n.right\n```\n \n\n#### mock vuex\n```\nsetup() {\n          useLoginStatusProvide()\n          return {}\n        },\n\n\n        import { provide, inject, ref } from '@vue/composition-api'\n\nconst StatusSymbol = Symbol('status')\n\nexport const useLoginStatusProvide = () => {\n  const loginStatus = ref(false)\n\n  const setLoginStatus = val => (loginStatus.value = val)\n  provide(StatusSymbol, { loginStatus, setLoginStatus })\n}\n\nexport const useLoginStatusInject = () => {\n  const context = inject(StatusSymbol)\n  if (!context) throw new Error('useLoginStatusInject must be used after useLoginStatusProvide')\n\n  return context\n}\n\n```","source":"_posts/vue.md","raw":"---\ntitle: vue\ndate: 2017-01-19 15:19:03\ntags: vue eventloop js \n---\n### js\n1. 这里对该vm注册一个Watcher实例，Watcher的getter为updateComponent函数，用于触发所有渲染所需要用到的数据的getter，进行依赖收集，就是在mounted的时候进行依赖收集。\n\n用户的自定义 watcher 要优先于渲染 watcher 执行；因为用户自定义 watcher 是在渲染 watcher 之前创建的。Vm._watcher.update()\n\n1. 对于渲染 watcher 而言，它在执行 this.get() 方法求值的时候，会执行 getter 方法： updateComponent = () => {\n   updateComponent = () => { vm._update(vm._render(), hydrating)\n1. vue diff 算法\n```text\n//相同的话进行patch\npatchVnode (oldVnode, vnode) {\n    const el = vnode.el = oldVnode.el\n    let i, oldCh = oldVnode.children, ch = vnode.children\n    if (oldVnode === vnode) return\n    if (oldVnode.text !== null && vnode.text !== null && oldVnode.text !== vnode.text) {\n        api.setTextContent(el, vnode.text)\n    }else {\n        updateEle(el, vnode, oldVnode)\n    \tif (oldCh && ch && oldCh !== ch) {\n            updateChildren(el, oldCh, ch)\n    \t}else if (ch){\n            createEle(vnode) //create el's children dom\n    \t}else if (oldCh){\n            api.removeChildren(el)\n    \t}\n    }\n}\n```\n1. 提高性能\n```text\n\n压缩代码\n提取页面公共资源 基础包cdn\\splitchunks\nTree shaking \nscope hoisting\n图片压缩 \n动态polyfill \n\n```\n1. 事件代理：1. 减少事件注册，节省内存。 2. 简化了dom更新时，上面的事件off与on 操作。focus，blur之类的，本身就没用冒泡的特性\n2. 函数式组件与普通组件的区别\n   \n   函数式组件需要在声明组件是指定functional\n   函数式组件不需要实例化，所以没有this,this通过render函数的第二个参数来代替\n   函数式组件没有生命周期钩子函数，不能使用计算属性，watch等等\n   函数式组件不能通过$emit对外暴露事件，调用事件只能通过context.listeners.click的方式调用外部传入的事件\n   因为函数式组件是没有实例化的，所以在外部通过ref去引用组件时，实际引用的是HTMLElement\n   函数式组件的props可以不用显示声明，所以没有在props里面声明的属性都会被自动隐式解析为prop,而普通组件所有未声明的属性都被解析到$attrs里面，并自动挂载到组件根元素上面(可以通过inheritAttrs属性禁止)\n\n3. 「适合引入自动化测试的场景：」\n\n公共库类的开发维护\n中长期项目的迭代/重构\n引用了不可控的第三方依赖\n\n1. Observer 是一个类，它的作用是给对象的属性添加 getter 和 setter，用于依赖收集和派发更新。Render 时通过getter 进行依赖收集。\n2. Dep 是一个 Class，它定义了一些属性和方法，这里需要特别注意的是它有一个静态属性 target，这是一个全局唯一 Watcher，这是一个非常巧妙的设计，\n因为在同一时间只能有一个全局的 Watcher 被计算，另外它的自身属性 subs 也是 Watcher 的数组。\n3. vue array 拦截\n```js\n /*取得原生数组的原型*/\nconst arrayProto = Array.prototype\n/*创建一个新的数组对象，修改该对象上的数组的七个方法，防止污染原生数组方法*/\nexport const arrayMethods = Object.create(arrayProto)\n```\n1. 首先通过 Vue.options = Object.create(null) 创建一个空对象，然后遍历 ASSET_TYPES: \n    Vue.options.components = {}\n    Vue.options.directives = {} \n    Vue.options.filters = {}\n \n3. vue 父子组件：\n加载渲染过程\n父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted\n父beforeUpdate->子beforeUpdate->子updated->父updated\n父组件更新过程\n父beforeUpdate->父updated\n销毁过程\n父beforeDestroy->子beforeDestroy->子destroyed->父destroyed\n\n1. for await...of循环，则是用于遍历异步的 Iterator 接口。\n```javascript\nfunction main(inputFilePath) {\n  const readStream = fs.createReadStream(\n    inputFilePath,\n    { encoding: 'utf8', highWaterMark: 1024 }\n  );\n  readStream.on('data', (chunk) => {\n    console.log('>>> '+chunk);\n  });\n  readStream.on('end', () => {\n    console.log('### DONE ###');\n  });\n}\n\n// 异步遍历器写法\nasync function main(inputFilePath) {\n  const readStream = fs.createReadStream(\n    inputFilePath,\n    { encoding: 'utf8', highWaterMark: 1024 }\n  );\n\n  for await (const chunk of readStream) {\n    console.log('>>> '+chunk);\n  }\n  console.log('### DONE ###');\n}\n```  \n1. Vm.$watch this._data.$$state 的值，/* 检测store中的_committing的值，如果是true代表不是通过mutation的方法修改的 */\n2. /* 这里new了一个Vue对象，运用Vue内部的响应式实现注册state以及computed*/\n    store._vm = new Vue({ data: {$$state: state }, computed })\n3. this.$on('hook:updated', () => {})\n \n1. Vue.config.optionMergeStrategies  \n1.  在Vue2.5之前，使用函数式组件只能通过JSX的方式，在之后，可以通过模板语法来生命函数式组件\n ```html\n <!--在template 上面添加 functional属性-->\n<template functional>\n  <img :src=\"avatar ? avatar : 'default-avatar.png'\" />\n</template>\n<!--根据上一节第六条，可以省略声明props-->\n ```\n\n1. Vue beforecreated:data vue 实例化、init events\n \n1.  作用域插槽 this.$scopedSlots.header({ text: this.headerText })\n   \n2. 全局的components ，通过vue 的options merge 到组件上。 最后通过 extend(Vue.options.components, builtInComponents) 把一些内置组件扩展到 Vue.options.components 上，\nVue 的内置组件目前有 <keep-alive>、<transition> 和 <transition-group> 组件，这也就是为什么我们在其它组件中使用 <keep-alive> 组件不需要注册的原因\n\n11. components，filters，directives\n   两个对象合并的时候，不会相互覆盖，而是 权重小的 被放到 权重大 的 的原型上\n13. 数组叠加   包括生命周期函数和watch\n14. 函数合并叠加   包括选项：data，provide，权重大的优先 \n1. 最主要最关键的原因是函数式组件不需要实例化，无状态，没有生命周期，所以渲染性能要好于普通组件\n   函数式组件结构比较简单，代码结构更清晰\n4. inject 用法：\n\n```javastript\n   inject: {\n   // 注入的属性名称 parentForm: {\n   // 通过 from 指定从哪个属性注入\n   from: 'customForm',\n    default: () => ({ size: 'default' }) } },\n```\n1. redirective  \n\n```text\nbinding：一个对象，包含以下 property：\nname：指令名，不包括 v- 前缀。\nvalue：指令的绑定值，例如：v-my-directive=\"1 + 1\" 中，绑定值为 2。\noldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。\nexpression：字符串形式的指令表达式。例如 v-my-directive=\"1 + 1\" 中，表达式为 \"1 + 1\"。\narg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 \"foo\"。\nmodifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。\n```\n\n1. Async validator\n ```javascript\n asyncValidator: (rule, value) => {\n        return new Promise((resolve, reject) => {\n          if (value < 18) {\n            reject(\"too young\");  // reject with error message\n          } else {\n            resolve();\n          }\n        });\n      }\n ```\n\n1.  ref用创建一个包装对象，只具备一个响应式属性value，如果将对象指定为ref的值，该对象将被reactive方法深度遍历。如果传入 ref 的是一个对象，将调用 reactive 方法进行深层响应转换。所以ref 可以解构\n1. history 模式：\n```text\n通过 history.pushState() 方法改变地址栏\n监听 popstate 事件\n根据当前路由地址找到对应组件重新渲染\n```\n\n1. `<input type=\"text\" v-on=\"{ input:onInput,focus:onFocus,blur:onBlur, }\">`   同样 v-bind \n1. keepalive mouted 只会执行一次，vnode上关联的component intance,在patch 阶段会转换为真实的dom.\n1.\n```javascript\n/*parse解析得到ast树*/\n  \n    const ast = parse(template.trim(), options)\n    /*\n      将AST树进行优化\n      优化的目标：生成模板AST树，检测不需要进行DOM改变的静态子树。\n      一旦检测到这些静态树，我们就能做以下这些事情：\n      1.把它们变成常数，这样我们就再也不需要每次重新渲染时创建新的节点了。\n      2.在patch的过程中直接跳过。\n   */\n    optimize(ast, options)\n```\n\n  optimize的主要作用是标记static静态节点，这是Vue在编译过程中的一处优化，后面当update更新界面时，会有一个patch的过程，diff算法会直接跳过静态节点，从而减少了比较的过程，优化了patch的性能。\n  \n1. Render\n// resolve template/el and convert to render function 。mounted 方法中\n在此方法中调用 vm._render 方法先生成虚拟 Node(render 函数返回的就是vnode)，最终调用 vm._update 更新 DOM。\n\nUpdate 调用的时机：1.首次渲染 2.数据更新 \n\n \n1. \n1. Vue 通过在内存中实现文档结构的虚拟表示来解决此问题，其中虚拟节点（VNode）表示 DOM 树中的节点。当需要操纵时，可以在虚拟 DOM的 内存中执行计算和操作，而不是在真实 DOM 上进行操纵。这自然会更快，并且允许虚拟 DOM 算法计算出最优化的方式来更新实际 DOM 结构。\n1. \nVue 不会对 provide 中的变量进行响应式处理。所以，要想 inject 接受的变量是响应式的，provide 提供的变量本身就需要是响应式的。单项数据流\n\ninheritAttrs: false, // 可以关闭自动挂载到组件根元素上的没有在props声明的属性\n1. 子组件不需要任何处理，只需要在父组件引用的时候通过@hook来监听即可，代码重写如下：<Child @hook:mounted=\"doSomething”/>\n1. 数据动态变化：\n   export const store = Vue.observable({ count: 0 });\n1. vue life cycle\n```\nparse阶段：使用正在表达式将template进行字符串解析，得到指令、class、style等数据，生成抽象语法树 AST。\noptimize阶段：寻找 AST 中的静态节点进行标记，为后面 VNode 的 patch 过程中对比做优化。被标记为 static 的节点在后面的 diff 算法中会被直接忽略，不做详细的比较。\n\ngenerate阶段：根据 AST 结构拼接生成 render 函数的字符串。\n```\n [life cycle](https://user-gold-cdn.xitu.io/2019/12/26/16f40a08cac6d3cb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n1. 每个逻辑关注点的代码现在都在复合函数中并置在一起。 这大大减少了在处理大型组件时需要不断“跳转”的情况。 组合函数也可以在编辑器中折叠，使组件更容易扫描:\n\n1. js 链接 defer 和 async\n1. keep-alive 的实现正是用到了 LRU 策略,将最近访问的组件 push 到 this.keys 最后面,this.keys[0]也就是最久没被访问的组件,当缓存实例超过 max 设置值,删除 this.keys[0]\n\n```text\ndefer 和 async 都是并行加载的，主要区别在于下载后何时执行。\n每一个 async 属性的脚本都在它下载结束之后立刻执行，所以就有可能出现脚本执行顺序被打乱的情况\n每一个 defer 属性的脚本会在 HTML 解析完成后, DOMContentLoaded 之前，按照 DOM 中的顺序执行（ie>=10）\ndefer 和 async 都只适用于外部脚本文件，对与内联的 script 标签是不起作用\n\n```\n1. preload 用 “as” 或者用 “type” 属性来表示他们请求资源的优先级（比如说 preload 使用 as=\"style\" 属性将获得最高的优先级）。没有 “as” 属性的将被看作异步请求，“Early”意味着在所有未被预加载的图片请求之前被请求（“late”意味着之后）\n \n \n \n2. Vue.config.errorHandler   \n3. v-pre  场景:vue 是响应式系统,但是有些静态的标签不需要多次编译,这样可以节省性能\n4. v-loader transformAssetUrls  \n在模板编译过程中，编译器可以将某些特性转换为 require 调用，例如 src 中的 URL。因此这些目标资源可以被 webpack 处理。例如 <img src=\"./foo.png\"> 会找到你文件系统中的 ./foo.png 并将其作为一个依赖包含在你的包里\n\n1. view router加key  场景:由于 Vue 会复用相同组件, 即 /page/1 => /page/2 或者 /page?id=1 => /page?id=2 这类链接跳转时, 将不在执行created, mounted之类的钩子\n\n1.![事件循环](https://github.com/ryansecret/blog/blob/master/source/asset/eventloop.jpg)\n1. 生命周期\n```text\nbeforeCreate阶段：vue实例的挂载元素el和数据对象data都是undefined，还没有初始化。\ncreated阶段：vue实例的数据对象data有了，可以访问里面的数据和方法，未挂载到DOM，el还没有\nbeforeMount阶段：vue实例的el和data都初始化了，但是挂载之前为虚拟的dom节点\nmounted阶段：vue实例挂载到真实DOM上，就可以通过DOM获取DOM节点\nbeforeUpdate阶段：响应式数据更新时调用，发生在虚拟DOM打补丁之前，适合在更新之前访问现有的DOM，比如手动移除已添加的事件监听器\nupdated阶段：虚拟DOM重新渲染和打补丁之后调用，组成新的DOM已经更新，避免在这个钩子函数中操作数据，防止死循环\nbeforeDestroy阶段：实例销毁前调用，实例还可以用，this能获取到实例，常用于销毁定时器，解绑事件\ndestroyed阶段：实例销毁后调用，调用后所有事件监听器会被移除，所有的子实例都会被销毁  \n```         \n1. __proto__ 属性，这是历史遗留的非标准的语法，但在现代浏览器中广泛实现。获得原型的更可靠方法是使用 Object.getPrototypeOf(new Object())；例如：\n ```javascript\nconst car = {}\nconst list = []\n \nconsole.log(Object.getPrototypeOf(car));\nconsole.log(Object.getPrototypeOf(list));\n```\n \n### 内部机制 \n\nvue-loader \n\ncompiler 目录包含 Vue.js 所有编译相关的代码。它包括把模板解析成 ast 语法树，ast 语法树优化，代码生成等功能。\n\n\n微任务的例子：micortask\n\nprocess.nextTick\npromise\nObject.observe\n\n宏任务的例子：\n\nsetTimeout\nsetInterval\nsetImmediate\nI/O\n\n需要注意的是node 和 浏览器的 event loop 是有区别的(需要注意的是node v12.0 之后和浏览器处理事一致的)：\n\n```text\n浏览器的事件循环：\n\n执行全局Script同步代码，这些同步代码有一些是同步语句，有一些是异步语句（比如setTimeout等）；\n全局Script代码执行完毕后，调用栈Stack会清空；\n从微队列microtask queue中取出位于队首的回调任务，放入调用栈Stack中执行，执行完后microtask queue长度减1；\n继续取出位于队首的任务，放入调用栈Stack中执行，以此类推，直到直到把microtask queue中的所有任务都执行完毕。注意，如果在执行microtask的过程中，又产生了microtask，那么会加入到队列的末尾，也会在这个周期被调用执行；\nmicrotask queue中的所有任务都执行完毕，此时microtask queue为空队列，调用栈Stack也为空；\n取出宏队列macrotask queue中位于队首的任务，放入Stack中执行；\n执行完毕后，调用栈Stack为空；\n重复第3-7个步骤；\n重复第3-7个步骤；\n……\n\nNodeJS中微队列主要有2个：\nNext Tick Queue：是放置process.nextTick(callback)的回调任务的\nOther Micro Queue：放置其他microtask，比如Promise等\n\n具体参见： https://segmentfault.com/a/1190000016278115\n\n```\n\n\n``` \ntimers 阶段：这个阶段执行timer（setTimeout、setInterval）的回调\nI/O callbacks 阶段：执行一些系统调用错误，比如网络通信的错误回调\nidle, prepare 阶段：仅node内部使用\npoll 阶段：获取新的I/O事件, 适当的条件下node将阻塞在这里\ncheck 阶段：执行 setImmediate() 的回调\nclose callbacks 阶段：执行 socket 的 close 事件回调\n\ntimers 是事件循环的第一个阶段，Node 会去检查有无已过期的timer，如果有则把它的回调压入timer的任务队列中等待执行，事实上，Node 并不能保证timer在预设时间到了就会立即执行，因为Node对timer的过期检查不一定靠谱，它会受机器上其它运行程序影响，或者那个时间点主线程不空闲。比如下面的代码，setTimeout() 和 setImmediate() 的执行顺序是不确定的。\n\npoll 阶段\npoll 阶段主要有2个功能：\n\n处理 poll 队列的事件\n当有已超时的 timer，执行它的回调函数\neven loop将同步执行poll队列里的回调，直到队列为空或执行的回调达到系统上限（上限具体多少未详），接下来even loop会去检查有无预设的setImmediate()，分两种情况：\n\n若有预设的setImmediate(), event loop将结束poll阶段进入check阶段，并执行check阶段的任务队列\n若没有预设的setImmediate()，event loop将阻塞在该阶段等待\n注意一个细节，没有setImmediate()会导致event loop阻塞在poll阶段，这样之前设置的timer岂不是执行不了了？所以咧，在poll阶段event loop会有一个检查机制，检查timer队列是否为空，如果timer队列非空，event loop就开始下一轮事件循环，即重新进入到timer阶段。\n\ncheck 阶段\nsetImmediate()的回调会被加入check队列中，从event loop的阶段图可以知道，check阶段的执行顺序在poll阶段之后。\n\n\n回顾上一篇，浏览器环境下，microtask的任务队列是每个macrotask执行完之后执行。而在Node.js中，microtask会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行microtask队列的任务。详见：http://lynnelv.github.io/js-event-loop-nodejs\n\nprocess.nextTick() 会在各个事件阶段之间执行，一旦执行，要直到nextTick队列被清空，才会进入到下一个事件阶段，所以如果递归调用 process.nextTick()，会导致出现I/O starving（饥饿）的问题\n\n官方文档：https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/\n\n```\n\n\n\n###vitual dom\n \n\nVD 最大的特点是将页面的状态抽象为 JS 对象的形式，配合不同的渲染工具，使跨平台渲染成为可能。如 React 就借助 VD 实现了服务端渲染、浏览器渲染和移动端渲染等功能。\njs计算-》生成渲染树-》渲染页面\n\n通过VD的比较，我们可以将多个操作合并成一个批量的操作，从而减少dom重排的次数，进而缩短了生成渲染树和绘制所花的时间。\n\n在mounted 方法中会将template 编译成为render 方法。这是一个编译过程，render中会调用createElement 创建vnode。\n\n![流程图片](https://ustbhuangyi.github.io/vue-analysis/assets/new-vue.png)\n\n\n回到 mountComponent 函数的过程，我们已经知道 createElement 是如何创建了一个 VNode，接下来就是要把这个 VNode 渲染成一个真实的 DOM 并渲染出来，这个过程是通过 vm._update 完成的\n\nVue 的 _update 是实例的一个私有方法，它被调用的时机有 2 个，一个是首次渲染，一个是数据更新的时候；由于我们这一章节只分析首次渲染部分，数据更新部分会在之后分析响应式原理的时候涉及。_update 方法的作用是把 VNode 渲染成真实的 DOM\n\n\n在我们之前对 setter 的分析过程知道，当响应式数据发送变化后，触发了 watcher.update()，只是把这个 watcher 推送到一个队列中，在 nextTick 后才会真正执行 watcher 的回调函数。而一旦我们设置了 sync，就可以在当前 Tick 中同步执行 watcher 的回调函数。\n \n\n##### 修饰符（Modifiers）是以半角句号 . 指明的特殊后缀，用于指出一个指定应该以特殊方式绑定。例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()\n\n```\n<!-- 阻止单击事件冒泡 -->\n<a v-on:click.stop=\"doThis\"></a>\n<!-- 提交事件不再重载页面 -->\n<form v-on:submit.prevent=\"onSubmit\"></form>\n<!-- 修饰符可以串联  -->\n<a v-on:click.stop.prevent=\"doThat\"></a>\n<!-- 只有修饰符 -->\n<form v-on:submit.prevent></form>\n<!-- 添加事件侦听器时使用事件捕获模式 -->\n<div v-on:click.capture=\"doThis\">...</div>\n<!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 -->\n<div v-on:click.self=\"doThat\">...</div>\n<a v-on:click.once=\"doThis\"></a>\n```\n \n\n##### 按键修饰符\n记住所有的 keyCode 比较困难，组合键 所以 Vue 为最常用的按键提供了别名：\n\n```\n<!-- Alt + C -->\n<input v-on:keyup.alt.67=\"clear\">\n\n<!-- Ctrl + Click -->\n<div v-on:click.ctrl=\"doSomething\">Do something</div>\n<!-- 同上 -->\n<input v-on:keyup.enter=\"submit\">\n<!-- 缩写语法 -->\n<input @keyup.enter=\"submit\">\n全部的按键别名：\n.enter\n.tab\n.delete (捕获 “删除” 和 “退格” 键)\n.esc\n.space\n.up\n.down\n.left\n.right\n```\n \n\n#### mock vuex\n```\nsetup() {\n          useLoginStatusProvide()\n          return {}\n        },\n\n\n        import { provide, inject, ref } from '@vue/composition-api'\n\nconst StatusSymbol = Symbol('status')\n\nexport const useLoginStatusProvide = () => {\n  const loginStatus = ref(false)\n\n  const setLoginStatus = val => (loginStatus.value = val)\n  provide(StatusSymbol, { loginStatus, setLoginStatus })\n}\n\nexport const useLoginStatusInject = () => {\n  const context = inject(StatusSymbol)\n  if (!context) throw new Error('useLoginStatusInject must be used after useLoginStatusProvide')\n\n  return context\n}\n\n```","slug":"vue","published":1,"updated":"2021-12-22T13:08:52.757Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckzf5se0d0020yy8k43w0lz0a","content":"<h3 id=\"js\"><a href=\"#js\" class=\"headerlink\" title=\"js\"></a>js</h3><ol>\n<li>这里对该vm注册一个Watcher实例，Watcher的getter为updateComponent函数，用于触发所有渲染所需要用到的数据的getter，进行依赖收集，就是在mounted的时候进行依赖收集。</li>\n</ol>\n<p>用户的自定义 watcher 要优先于渲染 watcher 执行；因为用户自定义 watcher 是在渲染 watcher 之前创建的。Vm._watcher.update()</p>\n<ol>\n<li>对于渲染 watcher 而言，它在执行 this.get() 方法求值的时候，会执行 getter 方法： updateComponent = () =&gt; {<br>updateComponent = () =&gt; { vm._update(vm._render(), hydrating)</li>\n<li><p>vue diff 算法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//相同的话进行patch</span><br><span class=\"line\">patchVnode (oldVnode, vnode) &#123;</span><br><span class=\"line\">    const el = vnode.el = oldVnode.el</span><br><span class=\"line\">    let i, oldCh = oldVnode.children, ch = vnode.children</span><br><span class=\"line\">    if (oldVnode === vnode) return</span><br><span class=\"line\">    if (oldVnode.text !== null &amp;&amp; vnode.text !== null &amp;&amp; oldVnode.text !== vnode.text) &#123;</span><br><span class=\"line\">        api.setTextContent(el, vnode.text)</span><br><span class=\"line\">    &#125;else &#123;</span><br><span class=\"line\">        updateEle(el, vnode, oldVnode)</span><br><span class=\"line\">    \tif (oldCh &amp;&amp; ch &amp;&amp; oldCh !== ch) &#123;</span><br><span class=\"line\">            updateChildren(el, oldCh, ch)</span><br><span class=\"line\">    \t&#125;else if (ch)&#123;</span><br><span class=\"line\">            createEle(vnode) //create el&apos;s children dom</span><br><span class=\"line\">    \t&#125;else if (oldCh)&#123;</span><br><span class=\"line\">            api.removeChildren(el)</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>提高性能</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">压缩代码</span><br><span class=\"line\">提取页面公共资源 基础包cdn\\splitchunks</span><br><span class=\"line\">Tree shaking </span><br><span class=\"line\">scope hoisting</span><br><span class=\"line\">图片压缩 </span><br><span class=\"line\">动态polyfill</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>事件代理：1. 减少事件注册，节省内存。 2. 简化了dom更新时，上面的事件off与on 操作。focus，blur之类的，本身就没用冒泡的特性</p>\n</li>\n<li><p>函数式组件与普通组件的区别</p>\n<p>函数式组件需要在声明组件是指定functional<br>函数式组件不需要实例化，所以没有this,this通过render函数的第二个参数来代替<br>函数式组件没有生命周期钩子函数，不能使用计算属性，watch等等<br>函数式组件不能通过$emit对外暴露事件，调用事件只能通过context.listeners.click的方式调用外部传入的事件<br>因为函数式组件是没有实例化的，所以在外部通过ref去引用组件时，实际引用的是HTMLElement<br>函数式组件的props可以不用显示声明，所以没有在props里面声明的属性都会被自动隐式解析为prop,而普通组件所有未声明的属性都被解析到$attrs里面，并自动挂载到组件根元素上面(可以通过inheritAttrs属性禁止)</p>\n</li>\n<li><p>「适合引入自动化测试的场景：」</p>\n</li>\n</ol>\n<p>公共库类的开发维护<br>中长期项目的迭代/重构<br>引用了不可控的第三方依赖</p>\n<ol>\n<li>Observer 是一个类，它的作用是给对象的属性添加 getter 和 setter，用于依赖收集和派发更新。Render 时通过getter 进行依赖收集。</li>\n<li>Dep 是一个 Class，它定义了一些属性和方法，这里需要特别注意的是它有一个静态属性 target，这是一个全局唯一 Watcher，这是一个非常巧妙的设计，<br>因为在同一时间只能有一个全局的 Watcher 被计算，另外它的自身属性 subs 也是 Watcher 的数组。</li>\n<li><p>vue array 拦截</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/*取得原生数组的原型*/</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> arrayProto = <span class=\"built_in\">Array</span>.prototype</span><br><span class=\"line\"><span class=\"comment\">/*创建一个新的数组对象，修改该对象上的数组的七个方法，防止污染原生数组方法*/</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> arrayMethods = <span class=\"built_in\">Object</span>.create(arrayProto)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>首先通过 Vue.options = Object.create(null) 创建一个空对象，然后遍历 ASSET_TYPES:<br> Vue.options.components = {}<br> Vue.options.directives = {}<br> Vue.options.filters = {}</p>\n</li>\n<li><p>vue 父子组件：<br>加载渲染过程<br>父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted<br>父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated<br>父组件更新过程<br>父beforeUpdate-&gt;父updated<br>销毁过程<br>父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</p>\n</li>\n<li><p>for await…of循环，则是用于遍历异步的 Iterator 接口。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">main</span>(<span class=\"params\">inputFilePath</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> readStream = fs.createReadStream(</span><br><span class=\"line\">    inputFilePath,</span><br><span class=\"line\">    &#123; <span class=\"attr\">encoding</span>: <span class=\"string\">'utf8'</span>, <span class=\"attr\">highWaterMark</span>: <span class=\"number\">1024</span> &#125;</span><br><span class=\"line\">  );</span><br><span class=\"line\">  readStream.on(<span class=\"string\">'data'</span>, (chunk) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'&gt;&gt;&gt; '</span>+chunk);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  readStream.on(<span class=\"string\">'end'</span>, () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'### DONE ###'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 异步遍历器写法</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">main</span>(<span class=\"params\">inputFilePath</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> readStream = fs.createReadStream(</span><br><span class=\"line\">    inputFilePath,</span><br><span class=\"line\">    &#123; <span class=\"attr\">encoding</span>: <span class=\"string\">'utf8'</span>, <span class=\"attr\">highWaterMark</span>: <span class=\"number\">1024</span> &#125;</span><br><span class=\"line\">  );</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> <span class=\"keyword\">await</span> (<span class=\"keyword\">const</span> chunk <span class=\"keyword\">of</span> readStream) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'&gt;&gt;&gt; '</span>+chunk);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'### DONE ###'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`  </span></span><br><span class=\"line\"><span class=\"string\">1. Vm.$watch this._data.$$state 的值，/* 检测store中的_committing的值，如果是true代表不是通过mutation的方法修改的 */</span></span><br><span class=\"line\"><span class=\"string\">2. /* 这里new了一个Vue对象，运用Vue内部的响应式实现注册state以及computed*/</span></span><br><span class=\"line\"><span class=\"string\">    store._vm = new Vue(&#123; data: &#123;$$state: state &#125;, computed &#125;)</span></span><br><span class=\"line\"><span class=\"string\">3. this.$on('hook:updated', () =&gt; &#123;&#125;)</span></span><br><span class=\"line\"><span class=\"string\"> </span></span><br><span class=\"line\"><span class=\"string\">1. Vue.config.optionMergeStrategies  </span></span><br><span class=\"line\"><span class=\"string\">1.  在Vue2.5之前，使用函数式组件只能通过JSX的方式，在之后，可以通过模板语法来生命函数式组件</span></span><br><span class=\"line\"><span class=\"string\"> `</span><span class=\"string\">``</span>html</span><br><span class=\"line\"> &lt;!--在template 上面添加 functional属性--&gt;</span><br><span class=\"line\">&lt;template functional&gt;</span><br><span class=\"line\">  &lt;img :src=<span class=\"string\">\"avatar ? avatar : 'default-avatar.png'\"</span> /&gt;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/template&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;!--根据上一节第六条，可以省略声明props--&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Vue beforecreated:data vue 实例化、init events</p>\n</li>\n<li><p>作用域插槽 this.$scopedSlots.header({ text: this.headerText })</p>\n</li>\n<li><p>全局的components ，通过vue 的options merge 到组件上。 最后通过 extend(Vue.options.components, builtInComponents) 把一些内置组件扩展到 Vue.options.components 上，<br>Vue 的内置组件目前有 <keep-alive>、<transition> 和 <transition-group> 组件，这也就是为什么我们在其它组件中使用 <keep-alive> 组件不需要注册的原因</keep-alive></transition-group></transition></keep-alive></p>\n</li>\n<li><p>components，filters，directives<br>两个对象合并的时候，不会相互覆盖，而是 权重小的 被放到 权重大 的 的原型上</p>\n</li>\n<li>数组叠加   包括生命周期函数和watch</li>\n<li>函数合并叠加   包括选项：data，provide，权重大的优先 </li>\n<li>最主要最关键的原因是函数式组件不需要实例化，无状态，没有生命周期，所以渲染性能要好于普通组件<br>函数式组件结构比较简单，代码结构更清晰</li>\n<li>inject 用法：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inject: &#123;</span><br><span class=\"line\">// 注入的属性名称 parentForm: &#123;</span><br><span class=\"line\">// 通过 from 指定从哪个属性注入</span><br><span class=\"line\">from: &apos;customForm&apos;,</span><br><span class=\"line\"> default: () =&gt; (&#123; size: &apos;default&apos; &#125;) &#125; &#125;,</span><br></pre></td></tr></table></figure>\n<ol>\n<li>redirective  </li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">binding：一个对象，包含以下 property：</span><br><span class=\"line\">name：指令名，不包括 v- 前缀。</span><br><span class=\"line\">value：指令的绑定值，例如：v-my-directive=&quot;1 + 1&quot; 中，绑定值为 2。</span><br><span class=\"line\">oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。</span><br><span class=\"line\">expression：字符串形式的指令表达式。例如 v-my-directive=&quot;1 + 1&quot; 中，表达式为 &quot;1 + 1&quot;。</span><br><span class=\"line\">arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 &quot;foo&quot;。</span><br><span class=\"line\">modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 &#123; foo: true, bar: true &#125;。</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p>Async validator</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">asyncValidator: <span class=\"function\">(<span class=\"params\">rule, value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (value &lt; <span class=\"number\">18</span>) &#123;</span><br><span class=\"line\">           reject(<span class=\"string\">\"too young\"</span>);  <span class=\"comment\">// reject with error message</span></span><br><span class=\"line\">         &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">           resolve();</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">       &#125;);</span><br><span class=\"line\">     &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>ref用创建一个包装对象，只具备一个响应式属性value，如果将对象指定为ref的值，该对象将被reactive方法深度遍历。如果传入 ref 的是一个对象，将调用 reactive 方法进行深层响应转换。所以ref 可以解构</p>\n</li>\n<li><p>history 模式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">通过 history.pushState() 方法改变地址栏</span><br><span class=\"line\">监听 popstate 事件</span><br><span class=\"line\">根据当前路由地址找到对应组件重新渲染</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>&lt;input type=&quot;text&quot; v-on=&quot;{ input:onInput,focus:onFocus,blur:onBlur, }&quot;&gt;</code>   同样 v-bind </p>\n</li>\n<li><p>keepalive mouted 只会执行一次，vnode上关联的component intance,在patch 阶段会转换为真实的dom.<br>1.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*parse解析得到ast树*/</span></span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">const</span> ast = parse(template.trim(), options)</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">      将AST树进行优化</span></span><br><span class=\"line\"><span class=\"comment\">      优化的目标：生成模板AST树，检测不需要进行DOM改变的静态子树。</span></span><br><span class=\"line\"><span class=\"comment\">      一旦检测到这些静态树，我们就能做以下这些事情：</span></span><br><span class=\"line\"><span class=\"comment\">      1.把它们变成常数，这样我们就再也不需要每次重新渲染时创建新的节点了。</span></span><br><span class=\"line\"><span class=\"comment\">      2.在patch的过程中直接跳过。</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">    optimize(ast, options)</span><br></pre></td></tr></table></figure>\n<p>optimize的主要作用是标记static静态节点，这是Vue在编译过程中的一处优化，后面当update更新界面时，会有一个patch的过程，diff算法会直接跳过静态节点，从而减少了比较的过程，优化了patch的性能。</p>\n</li>\n<li><p>Render<br>// resolve template/el and convert to render function 。mounted 方法中<br>在此方法中调用 vm._render 方法先生成虚拟 Node(render 函数返回的就是vnode)，最终调用 vm._update 更新 DOM。</p>\n</li>\n</ol>\n<p>Update 调用的时机：1.首次渲染 2.数据更新 </p>\n<ol>\n<li></li>\n<li>Vue 通过在内存中实现文档结构的虚拟表示来解决此问题，其中虚拟节点（VNode）表示 DOM 树中的节点。当需要操纵时，可以在虚拟 DOM的 内存中执行计算和操作，而不是在真实 DOM 上进行操纵。这自然会更快，并且允许虚拟 DOM 算法计算出最优化的方式来更新实际 DOM 结构。</li>\n<li>Vue 不会对 provide 中的变量进行响应式处理。所以，要想 inject 接受的变量是响应式的，provide 提供的变量本身就需要是响应式的。单项数据流</li>\n</ol>\n<p>inheritAttrs: false, // 可以关闭自动挂载到组件根元素上的没有在props声明的属性</p>\n<ol>\n<li>子组件不需要任何处理，只需要在父组件引用的时候通过@hook来监听即可，代码重写如下：&lt;Child @hook:mounted=”doSomething”/&gt;</li>\n<li>数据动态变化：<br>export const store = Vue.observable({ count: 0 });</li>\n<li><p>vue life cycle</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">parse阶段：使用正在表达式将template进行字符串解析，得到指令、class、style等数据，生成抽象语法树 AST。</span><br><span class=\"line\">optimize阶段：寻找 AST 中的静态节点进行标记，为后面 VNode 的 patch 过程中对比做优化。被标记为 static 的节点在后面的 diff 算法中会被直接忽略，不做详细的比较。</span><br><span class=\"line\"></span><br><span class=\"line\">generate阶段：根据 AST 结构拼接生成 render 函数的字符串。</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://user-gold-cdn.xitu.io/2019/12/26/16f40a08cac6d3cb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" target=\"_blank\" rel=\"noopener\">life cycle</a></p>\n</li>\n<li><p>每个逻辑关注点的代码现在都在复合函数中并置在一起。 这大大减少了在处理大型组件时需要不断“跳转”的情况。 组合函数也可以在编辑器中折叠，使组件更容易扫描:</p>\n</li>\n<li><p>js 链接 defer 和 async</p>\n</li>\n<li>keep-alive 的实现正是用到了 LRU 策略,将最近访问的组件 push 到 this.keys 最后面,this.keys[0]也就是最久没被访问的组件,当缓存实例超过 max 设置值,删除 this.keys[0]</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">defer 和 async 都是并行加载的，主要区别在于下载后何时执行。</span><br><span class=\"line\">每一个 async 属性的脚本都在它下载结束之后立刻执行，所以就有可能出现脚本执行顺序被打乱的情况</span><br><span class=\"line\">每一个 defer 属性的脚本会在 HTML 解析完成后, DOMContentLoaded 之前，按照 DOM 中的顺序执行（ie&gt;=10）</span><br><span class=\"line\">defer 和 async 都只适用于外部脚本文件，对与内联的 script 标签是不起作用</span><br></pre></td></tr></table></figure>\n<ol>\n<li>preload 用 “as” 或者用 “type” 属性来表示他们请求资源的优先级（比如说 preload 使用 as=”style” 属性将获得最高的优先级）。没有 “as” 属性的将被看作异步请求，“Early”意味着在所有未被预加载的图片请求之前被请求（“late”意味着之后）</li>\n</ol>\n<ol start=\"2\">\n<li>Vue.config.errorHandler   </li>\n<li>v-pre  场景:vue 是响应式系统,但是有些静态的标签不需要多次编译,这样可以节省性能</li>\n<li><p>v-loader transformAssetUrls<br>在模板编译过程中，编译器可以将某些特性转换为 require 调用，例如 src 中的 URL。因此这些目标资源可以被 webpack 处理。例如 <img src=\"./foo.png\"> 会找到你文件系统中的 ./foo.png 并将其作为一个依赖包含在你的包里</p>\n</li>\n<li><p>view router加key  场景:由于 Vue 会复用相同组件, 即 /page/1 =&gt; /page/2 或者 /page?id=1 =&gt; /page?id=2 这类链接跳转时, 将不在执行created, mounted之类的钩子</p>\n</li>\n</ol>\n<p>1.<img src=\"https://github.com/ryansecret/blog/blob/master/source/asset/eventloop.jpg\" alt=\"事件循环\"></p>\n<ol>\n<li>生命周期<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">beforeCreate阶段：vue实例的挂载元素el和数据对象data都是undefined，还没有初始化。</span><br><span class=\"line\">created阶段：vue实例的数据对象data有了，可以访问里面的数据和方法，未挂载到DOM，el还没有</span><br><span class=\"line\">beforeMount阶段：vue实例的el和data都初始化了，但是挂载之前为虚拟的dom节点</span><br><span class=\"line\">mounted阶段：vue实例挂载到真实DOM上，就可以通过DOM获取DOM节点</span><br><span class=\"line\">beforeUpdate阶段：响应式数据更新时调用，发生在虚拟DOM打补丁之前，适合在更新之前访问现有的DOM，比如手动移除已添加的事件监听器</span><br><span class=\"line\">updated阶段：虚拟DOM重新渲染和打补丁之后调用，组成新的DOM已经更新，避免在这个钩子函数中操作数据，防止死循环</span><br><span class=\"line\">beforeDestroy阶段：实例销毁前调用，实例还可以用，this能获取到实例，常用于销毁定时器，解绑事件</span><br><span class=\"line\">destroyed阶段：实例销毁后调用，调用后所有事件监听器会被移除，所有的子实例都会被销毁  </span><br><span class=\"line\">```         </span><br><span class=\"line\">1. __proto__ 属性，这是历史遗留的非标准的语法，但在现代浏览器中广泛实现。获得原型的更可靠方法是使用 Object.getPrototypeOf(new Object())；例如：</span><br><span class=\"line\"> ```javascript</span><br><span class=\"line\">const car = &#123;&#125;</span><br><span class=\"line\">const list = []</span><br><span class=\"line\"> </span><br><span class=\"line\">console.log(Object.getPrototypeOf(car));</span><br><span class=\"line\">console.log(Object.getPrototypeOf(list));</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"内部机制\"><a href=\"#内部机制\" class=\"headerlink\" title=\"内部机制\"></a>内部机制</h3><p>vue-loader </p>\n<p>compiler 目录包含 Vue.js 所有编译相关的代码。它包括把模板解析成 ast 语法树，ast 语法树优化，代码生成等功能。</p>\n<p>微任务的例子：micortask</p>\n<p>process.nextTick<br>promise<br>Object.observe</p>\n<p>宏任务的例子：</p>\n<p>setTimeout<br>setInterval<br>setImmediate<br>I/O</p>\n<p>需要注意的是node 和 浏览器的 event loop 是有区别的(需要注意的是node v12.0 之后和浏览器处理事一致的)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">浏览器的事件循环：</span><br><span class=\"line\"></span><br><span class=\"line\">执行全局Script同步代码，这些同步代码有一些是同步语句，有一些是异步语句（比如setTimeout等）；</span><br><span class=\"line\">全局Script代码执行完毕后，调用栈Stack会清空；</span><br><span class=\"line\">从微队列microtask queue中取出位于队首的回调任务，放入调用栈Stack中执行，执行完后microtask queue长度减1；</span><br><span class=\"line\">继续取出位于队首的任务，放入调用栈Stack中执行，以此类推，直到直到把microtask queue中的所有任务都执行完毕。注意，如果在执行microtask的过程中，又产生了microtask，那么会加入到队列的末尾，也会在这个周期被调用执行；</span><br><span class=\"line\">microtask queue中的所有任务都执行完毕，此时microtask queue为空队列，调用栈Stack也为空；</span><br><span class=\"line\">取出宏队列macrotask queue中位于队首的任务，放入Stack中执行；</span><br><span class=\"line\">执行完毕后，调用栈Stack为空；</span><br><span class=\"line\">重复第3-7个步骤；</span><br><span class=\"line\">重复第3-7个步骤；</span><br><span class=\"line\">……</span><br><span class=\"line\"></span><br><span class=\"line\">NodeJS中微队列主要有2个：</span><br><span class=\"line\">Next Tick Queue：是放置process.nextTick(callback)的回调任务的</span><br><span class=\"line\">Other Micro Queue：放置其他microtask，比如Promise等</span><br><span class=\"line\"></span><br><span class=\"line\">具体参见： https://segmentfault.com/a/1190000016278115</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">timers 阶段：这个阶段执行timer（setTimeout、setInterval）的回调</span><br><span class=\"line\">I/O callbacks 阶段：执行一些系统调用错误，比如网络通信的错误回调</span><br><span class=\"line\">idle, prepare 阶段：仅node内部使用</span><br><span class=\"line\">poll 阶段：获取新的I/O事件, 适当的条件下node将阻塞在这里</span><br><span class=\"line\">check 阶段：执行 setImmediate() 的回调</span><br><span class=\"line\">close callbacks 阶段：执行 socket 的 close 事件回调</span><br><span class=\"line\"></span><br><span class=\"line\">timers 是事件循环的第一个阶段，Node 会去检查有无已过期的timer，如果有则把它的回调压入timer的任务队列中等待执行，事实上，Node 并不能保证timer在预设时间到了就会立即执行，因为Node对timer的过期检查不一定靠谱，它会受机器上其它运行程序影响，或者那个时间点主线程不空闲。比如下面的代码，setTimeout() 和 setImmediate() 的执行顺序是不确定的。</span><br><span class=\"line\"></span><br><span class=\"line\">poll 阶段</span><br><span class=\"line\">poll 阶段主要有2个功能：</span><br><span class=\"line\"></span><br><span class=\"line\">处理 poll 队列的事件</span><br><span class=\"line\">当有已超时的 timer，执行它的回调函数</span><br><span class=\"line\">even loop将同步执行poll队列里的回调，直到队列为空或执行的回调达到系统上限（上限具体多少未详），接下来even loop会去检查有无预设的setImmediate()，分两种情况：</span><br><span class=\"line\"></span><br><span class=\"line\">若有预设的setImmediate(), event loop将结束poll阶段进入check阶段，并执行check阶段的任务队列</span><br><span class=\"line\">若没有预设的setImmediate()，event loop将阻塞在该阶段等待</span><br><span class=\"line\">注意一个细节，没有setImmediate()会导致event loop阻塞在poll阶段，这样之前设置的timer岂不是执行不了了？所以咧，在poll阶段event loop会有一个检查机制，检查timer队列是否为空，如果timer队列非空，event loop就开始下一轮事件循环，即重新进入到timer阶段。</span><br><span class=\"line\"></span><br><span class=\"line\">check 阶段</span><br><span class=\"line\">setImmediate()的回调会被加入check队列中，从event loop的阶段图可以知道，check阶段的执行顺序在poll阶段之后。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">回顾上一篇，浏览器环境下，microtask的任务队列是每个macrotask执行完之后执行。而在Node.js中，microtask会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行microtask队列的任务。详见：http://lynnelv.github.io/js-event-loop-nodejs</span><br><span class=\"line\"></span><br><span class=\"line\">process.nextTick() 会在各个事件阶段之间执行，一旦执行，要直到nextTick队列被清空，才会进入到下一个事件阶段，所以如果递归调用 process.nextTick()，会导致出现I/O starving（饥饿）的问题</span><br><span class=\"line\"></span><br><span class=\"line\">官方文档：https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/</span><br></pre></td></tr></table></figure>\n<p>###vitual dom</p>\n<p>VD 最大的特点是将页面的状态抽象为 JS 对象的形式，配合不同的渲染工具，使跨平台渲染成为可能。如 React 就借助 VD 实现了服务端渲染、浏览器渲染和移动端渲染等功能。<br>js计算-》生成渲染树-》渲染页面</p>\n<p>通过VD的比较，我们可以将多个操作合并成一个批量的操作，从而减少dom重排的次数，进而缩短了生成渲染树和绘制所花的时间。</p>\n<p>在mounted 方法中会将template 编译成为render 方法。这是一个编译过程，render中会调用createElement 创建vnode。</p>\n<p><img src=\"https://ustbhuangyi.github.io/vue-analysis/assets/new-vue.png\" alt=\"流程图片\"></p>\n<p>回到 mountComponent 函数的过程，我们已经知道 createElement 是如何创建了一个 VNode，接下来就是要把这个 VNode 渲染成一个真实的 DOM 并渲染出来，这个过程是通过 vm._update 完成的</p>\n<p>Vue 的 _update 是实例的一个私有方法，它被调用的时机有 2 个，一个是首次渲染，一个是数据更新的时候；由于我们这一章节只分析首次渲染部分，数据更新部分会在之后分析响应式原理的时候涉及。_update 方法的作用是把 VNode 渲染成真实的 DOM</p>\n<p>在我们之前对 setter 的分析过程知道，当响应式数据发送变化后，触发了 watcher.update()，只是把这个 watcher 推送到一个队列中，在 nextTick 后才会真正执行 watcher 的回调函数。而一旦我们设置了 sync，就可以在当前 Tick 中同步执行 watcher 的回调函数。</p>\n<h5 id=\"修饰符（Modifiers）是以半角句号-指明的特殊后缀，用于指出一个指定应该以特殊方式绑定。例如，-prevent-修饰符告诉-v-on-指令对于触发的事件调用-event-preventDefault\"><a href=\"#修饰符（Modifiers）是以半角句号-指明的特殊后缀，用于指出一个指定应该以特殊方式绑定。例如，-prevent-修饰符告诉-v-on-指令对于触发的事件调用-event-preventDefault\" class=\"headerlink\" title=\"修饰符（Modifiers）是以半角句号 . 指明的特殊后缀，用于指出一个指定应该以特殊方式绑定。例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()\"></a>修饰符（Modifiers）是以半角句号 . 指明的特殊后缀，用于指出一个指定应该以特殊方式绑定。例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 阻止单击事件冒泡 --&gt;</span><br><span class=\"line\">&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">&lt;!-- 提交事件不再重载页面 --&gt;</span><br><span class=\"line\">&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;</span><br><span class=\"line\">&lt;!-- 修饰符可以串联  --&gt;</span><br><span class=\"line\">&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">&lt;!-- 只有修饰符 --&gt;</span><br><span class=\"line\">&lt;form v-on:submit.prevent&gt;&lt;/form&gt;</span><br><span class=\"line\">&lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt;</span><br><span class=\"line\">&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;</span><br><span class=\"line\">&lt;!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 --&gt;</span><br><span class=\"line\">&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;</span><br><span class=\"line\">&lt;a v-on:click.once=&quot;doThis&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n<h5 id=\"按键修饰符\"><a href=\"#按键修饰符\" class=\"headerlink\" title=\"按键修饰符\"></a>按键修饰符</h5><p>记住所有的 keyCode 比较困难，组合键 所以 Vue 为最常用的按键提供了别名：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Alt + C --&gt;</span><br><span class=\"line\">&lt;input v-on:keyup.alt.67=&quot;clear&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- Ctrl + Click --&gt;</span><br><span class=\"line\">&lt;div v-on:click.ctrl=&quot;doSomething&quot;&gt;Do something&lt;/div&gt;</span><br><span class=\"line\">&lt;!-- 同上 --&gt;</span><br><span class=\"line\">&lt;input v-on:keyup.enter=&quot;submit&quot;&gt;</span><br><span class=\"line\">&lt;!-- 缩写语法 --&gt;</span><br><span class=\"line\">&lt;input @keyup.enter=&quot;submit&quot;&gt;</span><br><span class=\"line\">全部的按键别名：</span><br><span class=\"line\">.enter</span><br><span class=\"line\">.tab</span><br><span class=\"line\">.delete (捕获 “删除” 和 “退格” 键)</span><br><span class=\"line\">.esc</span><br><span class=\"line\">.space</span><br><span class=\"line\">.up</span><br><span class=\"line\">.down</span><br><span class=\"line\">.left</span><br><span class=\"line\">.right</span><br></pre></td></tr></table></figure>\n<h4 id=\"mock-vuex\"><a href=\"#mock-vuex\" class=\"headerlink\" title=\"mock vuex\"></a>mock vuex</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setup() &#123;</span><br><span class=\"line\">          useLoginStatusProvide()</span><br><span class=\"line\">          return &#123;&#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        import &#123; provide, inject, ref &#125; from &apos;@vue/composition-api&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">const StatusSymbol = Symbol(&apos;status&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">export const useLoginStatusProvide = () =&gt; &#123;</span><br><span class=\"line\">  const loginStatus = ref(false)</span><br><span class=\"line\"></span><br><span class=\"line\">  const setLoginStatus = val =&gt; (loginStatus.value = val)</span><br><span class=\"line\">  provide(StatusSymbol, &#123; loginStatus, setLoginStatus &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export const useLoginStatusInject = () =&gt; &#123;</span><br><span class=\"line\">  const context = inject(StatusSymbol)</span><br><span class=\"line\">  if (!context) throw new Error(&apos;useLoginStatusInject must be used after useLoginStatusProvide&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">  return context</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"js\"><a href=\"#js\" class=\"headerlink\" title=\"js\"></a>js</h3><ol>\n<li>这里对该vm注册一个Watcher实例，Watcher的getter为updateComponent函数，用于触发所有渲染所需要用到的数据的getter，进行依赖收集，就是在mounted的时候进行依赖收集。</li>\n</ol>\n<p>用户的自定义 watcher 要优先于渲染 watcher 执行；因为用户自定义 watcher 是在渲染 watcher 之前创建的。Vm._watcher.update()</p>\n<ol>\n<li>对于渲染 watcher 而言，它在执行 this.get() 方法求值的时候，会执行 getter 方法： updateComponent = () =&gt; {<br>updateComponent = () =&gt; { vm._update(vm._render(), hydrating)</li>\n<li><p>vue diff 算法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//相同的话进行patch</span><br><span class=\"line\">patchVnode (oldVnode, vnode) &#123;</span><br><span class=\"line\">    const el = vnode.el = oldVnode.el</span><br><span class=\"line\">    let i, oldCh = oldVnode.children, ch = vnode.children</span><br><span class=\"line\">    if (oldVnode === vnode) return</span><br><span class=\"line\">    if (oldVnode.text !== null &amp;&amp; vnode.text !== null &amp;&amp; oldVnode.text !== vnode.text) &#123;</span><br><span class=\"line\">        api.setTextContent(el, vnode.text)</span><br><span class=\"line\">    &#125;else &#123;</span><br><span class=\"line\">        updateEle(el, vnode, oldVnode)</span><br><span class=\"line\">    \tif (oldCh &amp;&amp; ch &amp;&amp; oldCh !== ch) &#123;</span><br><span class=\"line\">            updateChildren(el, oldCh, ch)</span><br><span class=\"line\">    \t&#125;else if (ch)&#123;</span><br><span class=\"line\">            createEle(vnode) //create el&apos;s children dom</span><br><span class=\"line\">    \t&#125;else if (oldCh)&#123;</span><br><span class=\"line\">            api.removeChildren(el)</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>提高性能</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">压缩代码</span><br><span class=\"line\">提取页面公共资源 基础包cdn\\splitchunks</span><br><span class=\"line\">Tree shaking </span><br><span class=\"line\">scope hoisting</span><br><span class=\"line\">图片压缩 </span><br><span class=\"line\">动态polyfill</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>事件代理：1. 减少事件注册，节省内存。 2. 简化了dom更新时，上面的事件off与on 操作。focus，blur之类的，本身就没用冒泡的特性</p>\n</li>\n<li><p>函数式组件与普通组件的区别</p>\n<p>函数式组件需要在声明组件是指定functional<br>函数式组件不需要实例化，所以没有this,this通过render函数的第二个参数来代替<br>函数式组件没有生命周期钩子函数，不能使用计算属性，watch等等<br>函数式组件不能通过$emit对外暴露事件，调用事件只能通过context.listeners.click的方式调用外部传入的事件<br>因为函数式组件是没有实例化的，所以在外部通过ref去引用组件时，实际引用的是HTMLElement<br>函数式组件的props可以不用显示声明，所以没有在props里面声明的属性都会被自动隐式解析为prop,而普通组件所有未声明的属性都被解析到$attrs里面，并自动挂载到组件根元素上面(可以通过inheritAttrs属性禁止)</p>\n</li>\n<li><p>「适合引入自动化测试的场景：」</p>\n</li>\n</ol>\n<p>公共库类的开发维护<br>中长期项目的迭代/重构<br>引用了不可控的第三方依赖</p>\n<ol>\n<li>Observer 是一个类，它的作用是给对象的属性添加 getter 和 setter，用于依赖收集和派发更新。Render 时通过getter 进行依赖收集。</li>\n<li>Dep 是一个 Class，它定义了一些属性和方法，这里需要特别注意的是它有一个静态属性 target，这是一个全局唯一 Watcher，这是一个非常巧妙的设计，<br>因为在同一时间只能有一个全局的 Watcher 被计算，另外它的自身属性 subs 也是 Watcher 的数组。</li>\n<li><p>vue array 拦截</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/*取得原生数组的原型*/</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> arrayProto = <span class=\"built_in\">Array</span>.prototype</span><br><span class=\"line\"><span class=\"comment\">/*创建一个新的数组对象，修改该对象上的数组的七个方法，防止污染原生数组方法*/</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> arrayMethods = <span class=\"built_in\">Object</span>.create(arrayProto)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>首先通过 Vue.options = Object.create(null) 创建一个空对象，然后遍历 ASSET_TYPES:<br> Vue.options.components = {}<br> Vue.options.directives = {}<br> Vue.options.filters = {}</p>\n</li>\n<li><p>vue 父子组件：<br>加载渲染过程<br>父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted<br>父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated<br>父组件更新过程<br>父beforeUpdate-&gt;父updated<br>销毁过程<br>父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</p>\n</li>\n<li><p>for await…of循环，则是用于遍历异步的 Iterator 接口。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">main</span>(<span class=\"params\">inputFilePath</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> readStream = fs.createReadStream(</span><br><span class=\"line\">    inputFilePath,</span><br><span class=\"line\">    &#123; <span class=\"attr\">encoding</span>: <span class=\"string\">'utf8'</span>, <span class=\"attr\">highWaterMark</span>: <span class=\"number\">1024</span> &#125;</span><br><span class=\"line\">  );</span><br><span class=\"line\">  readStream.on(<span class=\"string\">'data'</span>, (chunk) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'&gt;&gt;&gt; '</span>+chunk);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  readStream.on(<span class=\"string\">'end'</span>, () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'### DONE ###'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 异步遍历器写法</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">main</span>(<span class=\"params\">inputFilePath</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> readStream = fs.createReadStream(</span><br><span class=\"line\">    inputFilePath,</span><br><span class=\"line\">    &#123; <span class=\"attr\">encoding</span>: <span class=\"string\">'utf8'</span>, <span class=\"attr\">highWaterMark</span>: <span class=\"number\">1024</span> &#125;</span><br><span class=\"line\">  );</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> <span class=\"keyword\">await</span> (<span class=\"keyword\">const</span> chunk <span class=\"keyword\">of</span> readStream) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'&gt;&gt;&gt; '</span>+chunk);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'### DONE ###'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`  </span></span><br><span class=\"line\"><span class=\"string\">1. Vm.$watch this._data.$$state 的值，/* 检测store中的_committing的值，如果是true代表不是通过mutation的方法修改的 */</span></span><br><span class=\"line\"><span class=\"string\">2. /* 这里new了一个Vue对象，运用Vue内部的响应式实现注册state以及computed*/</span></span><br><span class=\"line\"><span class=\"string\">    store._vm = new Vue(&#123; data: &#123;$$state: state &#125;, computed &#125;)</span></span><br><span class=\"line\"><span class=\"string\">3. this.$on('hook:updated', () =&gt; &#123;&#125;)</span></span><br><span class=\"line\"><span class=\"string\"> </span></span><br><span class=\"line\"><span class=\"string\">1. Vue.config.optionMergeStrategies  </span></span><br><span class=\"line\"><span class=\"string\">1.  在Vue2.5之前，使用函数式组件只能通过JSX的方式，在之后，可以通过模板语法来生命函数式组件</span></span><br><span class=\"line\"><span class=\"string\"> `</span><span class=\"string\">``</span>html</span><br><span class=\"line\"> &lt;!--在template 上面添加 functional属性--&gt;</span><br><span class=\"line\">&lt;template functional&gt;</span><br><span class=\"line\">  &lt;img :src=<span class=\"string\">\"avatar ? avatar : 'default-avatar.png'\"</span> /&gt;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/template&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;!--根据上一节第六条，可以省略声明props--&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Vue beforecreated:data vue 实例化、init events</p>\n</li>\n<li><p>作用域插槽 this.$scopedSlots.header({ text: this.headerText })</p>\n</li>\n<li><p>全局的components ，通过vue 的options merge 到组件上。 最后通过 extend(Vue.options.components, builtInComponents) 把一些内置组件扩展到 Vue.options.components 上，<br>Vue 的内置组件目前有 <keep-alive>、<transition> 和 <transition-group> 组件，这也就是为什么我们在其它组件中使用 <keep-alive> 组件不需要注册的原因</keep-alive></transition-group></transition></keep-alive></p>\n</li>\n<li><p>components，filters，directives<br>两个对象合并的时候，不会相互覆盖，而是 权重小的 被放到 权重大 的 的原型上</p>\n</li>\n<li>数组叠加   包括生命周期函数和watch</li>\n<li>函数合并叠加   包括选项：data，provide，权重大的优先 </li>\n<li>最主要最关键的原因是函数式组件不需要实例化，无状态，没有生命周期，所以渲染性能要好于普通组件<br>函数式组件结构比较简单，代码结构更清晰</li>\n<li>inject 用法：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inject: &#123;</span><br><span class=\"line\">// 注入的属性名称 parentForm: &#123;</span><br><span class=\"line\">// 通过 from 指定从哪个属性注入</span><br><span class=\"line\">from: &apos;customForm&apos;,</span><br><span class=\"line\"> default: () =&gt; (&#123; size: &apos;default&apos; &#125;) &#125; &#125;,</span><br></pre></td></tr></table></figure>\n<ol>\n<li>redirective  </li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">binding：一个对象，包含以下 property：</span><br><span class=\"line\">name：指令名，不包括 v- 前缀。</span><br><span class=\"line\">value：指令的绑定值，例如：v-my-directive=&quot;1 + 1&quot; 中，绑定值为 2。</span><br><span class=\"line\">oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。</span><br><span class=\"line\">expression：字符串形式的指令表达式。例如 v-my-directive=&quot;1 + 1&quot; 中，表达式为 &quot;1 + 1&quot;。</span><br><span class=\"line\">arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 &quot;foo&quot;。</span><br><span class=\"line\">modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 &#123; foo: true, bar: true &#125;。</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p>Async validator</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">asyncValidator: <span class=\"function\">(<span class=\"params\">rule, value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (value &lt; <span class=\"number\">18</span>) &#123;</span><br><span class=\"line\">           reject(<span class=\"string\">\"too young\"</span>);  <span class=\"comment\">// reject with error message</span></span><br><span class=\"line\">         &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">           resolve();</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">       &#125;);</span><br><span class=\"line\">     &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>ref用创建一个包装对象，只具备一个响应式属性value，如果将对象指定为ref的值，该对象将被reactive方法深度遍历。如果传入 ref 的是一个对象，将调用 reactive 方法进行深层响应转换。所以ref 可以解构</p>\n</li>\n<li><p>history 模式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">通过 history.pushState() 方法改变地址栏</span><br><span class=\"line\">监听 popstate 事件</span><br><span class=\"line\">根据当前路由地址找到对应组件重新渲染</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>&lt;input type=&quot;text&quot; v-on=&quot;{ input:onInput,focus:onFocus,blur:onBlur, }&quot;&gt;</code>   同样 v-bind </p>\n</li>\n<li><p>keepalive mouted 只会执行一次，vnode上关联的component intance,在patch 阶段会转换为真实的dom.<br>1.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*parse解析得到ast树*/</span></span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">const</span> ast = parse(template.trim(), options)</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">      将AST树进行优化</span></span><br><span class=\"line\"><span class=\"comment\">      优化的目标：生成模板AST树，检测不需要进行DOM改变的静态子树。</span></span><br><span class=\"line\"><span class=\"comment\">      一旦检测到这些静态树，我们就能做以下这些事情：</span></span><br><span class=\"line\"><span class=\"comment\">      1.把它们变成常数，这样我们就再也不需要每次重新渲染时创建新的节点了。</span></span><br><span class=\"line\"><span class=\"comment\">      2.在patch的过程中直接跳过。</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">    optimize(ast, options)</span><br></pre></td></tr></table></figure>\n<p>optimize的主要作用是标记static静态节点，这是Vue在编译过程中的一处优化，后面当update更新界面时，会有一个patch的过程，diff算法会直接跳过静态节点，从而减少了比较的过程，优化了patch的性能。</p>\n</li>\n<li><p>Render<br>// resolve template/el and convert to render function 。mounted 方法中<br>在此方法中调用 vm._render 方法先生成虚拟 Node(render 函数返回的就是vnode)，最终调用 vm._update 更新 DOM。</p>\n</li>\n</ol>\n<p>Update 调用的时机：1.首次渲染 2.数据更新 </p>\n<ol>\n<li></li>\n<li>Vue 通过在内存中实现文档结构的虚拟表示来解决此问题，其中虚拟节点（VNode）表示 DOM 树中的节点。当需要操纵时，可以在虚拟 DOM的 内存中执行计算和操作，而不是在真实 DOM 上进行操纵。这自然会更快，并且允许虚拟 DOM 算法计算出最优化的方式来更新实际 DOM 结构。</li>\n<li>Vue 不会对 provide 中的变量进行响应式处理。所以，要想 inject 接受的变量是响应式的，provide 提供的变量本身就需要是响应式的。单项数据流</li>\n</ol>\n<p>inheritAttrs: false, // 可以关闭自动挂载到组件根元素上的没有在props声明的属性</p>\n<ol>\n<li>子组件不需要任何处理，只需要在父组件引用的时候通过@hook来监听即可，代码重写如下：&lt;Child @hook:mounted=”doSomething”/&gt;</li>\n<li>数据动态变化：<br>export const store = Vue.observable({ count: 0 });</li>\n<li><p>vue life cycle</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">parse阶段：使用正在表达式将template进行字符串解析，得到指令、class、style等数据，生成抽象语法树 AST。</span><br><span class=\"line\">optimize阶段：寻找 AST 中的静态节点进行标记，为后面 VNode 的 patch 过程中对比做优化。被标记为 static 的节点在后面的 diff 算法中会被直接忽略，不做详细的比较。</span><br><span class=\"line\"></span><br><span class=\"line\">generate阶段：根据 AST 结构拼接生成 render 函数的字符串。</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://user-gold-cdn.xitu.io/2019/12/26/16f40a08cac6d3cb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" target=\"_blank\" rel=\"noopener\">life cycle</a></p>\n</li>\n<li><p>每个逻辑关注点的代码现在都在复合函数中并置在一起。 这大大减少了在处理大型组件时需要不断“跳转”的情况。 组合函数也可以在编辑器中折叠，使组件更容易扫描:</p>\n</li>\n<li><p>js 链接 defer 和 async</p>\n</li>\n<li>keep-alive 的实现正是用到了 LRU 策略,将最近访问的组件 push 到 this.keys 最后面,this.keys[0]也就是最久没被访问的组件,当缓存实例超过 max 设置值,删除 this.keys[0]</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">defer 和 async 都是并行加载的，主要区别在于下载后何时执行。</span><br><span class=\"line\">每一个 async 属性的脚本都在它下载结束之后立刻执行，所以就有可能出现脚本执行顺序被打乱的情况</span><br><span class=\"line\">每一个 defer 属性的脚本会在 HTML 解析完成后, DOMContentLoaded 之前，按照 DOM 中的顺序执行（ie&gt;=10）</span><br><span class=\"line\">defer 和 async 都只适用于外部脚本文件，对与内联的 script 标签是不起作用</span><br></pre></td></tr></table></figure>\n<ol>\n<li>preload 用 “as” 或者用 “type” 属性来表示他们请求资源的优先级（比如说 preload 使用 as=”style” 属性将获得最高的优先级）。没有 “as” 属性的将被看作异步请求，“Early”意味着在所有未被预加载的图片请求之前被请求（“late”意味着之后）</li>\n</ol>\n<ol start=\"2\">\n<li>Vue.config.errorHandler   </li>\n<li>v-pre  场景:vue 是响应式系统,但是有些静态的标签不需要多次编译,这样可以节省性能</li>\n<li><p>v-loader transformAssetUrls<br>在模板编译过程中，编译器可以将某些特性转换为 require 调用，例如 src 中的 URL。因此这些目标资源可以被 webpack 处理。例如 <img src=\"./foo.png\"> 会找到你文件系统中的 ./foo.png 并将其作为一个依赖包含在你的包里</p>\n</li>\n<li><p>view router加key  场景:由于 Vue 会复用相同组件, 即 /page/1 =&gt; /page/2 或者 /page?id=1 =&gt; /page?id=2 这类链接跳转时, 将不在执行created, mounted之类的钩子</p>\n</li>\n</ol>\n<p>1.<img src=\"https://github.com/ryansecret/blog/blob/master/source/asset/eventloop.jpg\" alt=\"事件循环\"></p>\n<ol>\n<li>生命周期<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">beforeCreate阶段：vue实例的挂载元素el和数据对象data都是undefined，还没有初始化。</span><br><span class=\"line\">created阶段：vue实例的数据对象data有了，可以访问里面的数据和方法，未挂载到DOM，el还没有</span><br><span class=\"line\">beforeMount阶段：vue实例的el和data都初始化了，但是挂载之前为虚拟的dom节点</span><br><span class=\"line\">mounted阶段：vue实例挂载到真实DOM上，就可以通过DOM获取DOM节点</span><br><span class=\"line\">beforeUpdate阶段：响应式数据更新时调用，发生在虚拟DOM打补丁之前，适合在更新之前访问现有的DOM，比如手动移除已添加的事件监听器</span><br><span class=\"line\">updated阶段：虚拟DOM重新渲染和打补丁之后调用，组成新的DOM已经更新，避免在这个钩子函数中操作数据，防止死循环</span><br><span class=\"line\">beforeDestroy阶段：实例销毁前调用，实例还可以用，this能获取到实例，常用于销毁定时器，解绑事件</span><br><span class=\"line\">destroyed阶段：实例销毁后调用，调用后所有事件监听器会被移除，所有的子实例都会被销毁  </span><br><span class=\"line\">```         </span><br><span class=\"line\">1. __proto__ 属性，这是历史遗留的非标准的语法，但在现代浏览器中广泛实现。获得原型的更可靠方法是使用 Object.getPrototypeOf(new Object())；例如：</span><br><span class=\"line\"> ```javascript</span><br><span class=\"line\">const car = &#123;&#125;</span><br><span class=\"line\">const list = []</span><br><span class=\"line\"> </span><br><span class=\"line\">console.log(Object.getPrototypeOf(car));</span><br><span class=\"line\">console.log(Object.getPrototypeOf(list));</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"内部机制\"><a href=\"#内部机制\" class=\"headerlink\" title=\"内部机制\"></a>内部机制</h3><p>vue-loader </p>\n<p>compiler 目录包含 Vue.js 所有编译相关的代码。它包括把模板解析成 ast 语法树，ast 语法树优化，代码生成等功能。</p>\n<p>微任务的例子：micortask</p>\n<p>process.nextTick<br>promise<br>Object.observe</p>\n<p>宏任务的例子：</p>\n<p>setTimeout<br>setInterval<br>setImmediate<br>I/O</p>\n<p>需要注意的是node 和 浏览器的 event loop 是有区别的(需要注意的是node v12.0 之后和浏览器处理事一致的)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">浏览器的事件循环：</span><br><span class=\"line\"></span><br><span class=\"line\">执行全局Script同步代码，这些同步代码有一些是同步语句，有一些是异步语句（比如setTimeout等）；</span><br><span class=\"line\">全局Script代码执行完毕后，调用栈Stack会清空；</span><br><span class=\"line\">从微队列microtask queue中取出位于队首的回调任务，放入调用栈Stack中执行，执行完后microtask queue长度减1；</span><br><span class=\"line\">继续取出位于队首的任务，放入调用栈Stack中执行，以此类推，直到直到把microtask queue中的所有任务都执行完毕。注意，如果在执行microtask的过程中，又产生了microtask，那么会加入到队列的末尾，也会在这个周期被调用执行；</span><br><span class=\"line\">microtask queue中的所有任务都执行完毕，此时microtask queue为空队列，调用栈Stack也为空；</span><br><span class=\"line\">取出宏队列macrotask queue中位于队首的任务，放入Stack中执行；</span><br><span class=\"line\">执行完毕后，调用栈Stack为空；</span><br><span class=\"line\">重复第3-7个步骤；</span><br><span class=\"line\">重复第3-7个步骤；</span><br><span class=\"line\">……</span><br><span class=\"line\"></span><br><span class=\"line\">NodeJS中微队列主要有2个：</span><br><span class=\"line\">Next Tick Queue：是放置process.nextTick(callback)的回调任务的</span><br><span class=\"line\">Other Micro Queue：放置其他microtask，比如Promise等</span><br><span class=\"line\"></span><br><span class=\"line\">具体参见： https://segmentfault.com/a/1190000016278115</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">timers 阶段：这个阶段执行timer（setTimeout、setInterval）的回调</span><br><span class=\"line\">I/O callbacks 阶段：执行一些系统调用错误，比如网络通信的错误回调</span><br><span class=\"line\">idle, prepare 阶段：仅node内部使用</span><br><span class=\"line\">poll 阶段：获取新的I/O事件, 适当的条件下node将阻塞在这里</span><br><span class=\"line\">check 阶段：执行 setImmediate() 的回调</span><br><span class=\"line\">close callbacks 阶段：执行 socket 的 close 事件回调</span><br><span class=\"line\"></span><br><span class=\"line\">timers 是事件循环的第一个阶段，Node 会去检查有无已过期的timer，如果有则把它的回调压入timer的任务队列中等待执行，事实上，Node 并不能保证timer在预设时间到了就会立即执行，因为Node对timer的过期检查不一定靠谱，它会受机器上其它运行程序影响，或者那个时间点主线程不空闲。比如下面的代码，setTimeout() 和 setImmediate() 的执行顺序是不确定的。</span><br><span class=\"line\"></span><br><span class=\"line\">poll 阶段</span><br><span class=\"line\">poll 阶段主要有2个功能：</span><br><span class=\"line\"></span><br><span class=\"line\">处理 poll 队列的事件</span><br><span class=\"line\">当有已超时的 timer，执行它的回调函数</span><br><span class=\"line\">even loop将同步执行poll队列里的回调，直到队列为空或执行的回调达到系统上限（上限具体多少未详），接下来even loop会去检查有无预设的setImmediate()，分两种情况：</span><br><span class=\"line\"></span><br><span class=\"line\">若有预设的setImmediate(), event loop将结束poll阶段进入check阶段，并执行check阶段的任务队列</span><br><span class=\"line\">若没有预设的setImmediate()，event loop将阻塞在该阶段等待</span><br><span class=\"line\">注意一个细节，没有setImmediate()会导致event loop阻塞在poll阶段，这样之前设置的timer岂不是执行不了了？所以咧，在poll阶段event loop会有一个检查机制，检查timer队列是否为空，如果timer队列非空，event loop就开始下一轮事件循环，即重新进入到timer阶段。</span><br><span class=\"line\"></span><br><span class=\"line\">check 阶段</span><br><span class=\"line\">setImmediate()的回调会被加入check队列中，从event loop的阶段图可以知道，check阶段的执行顺序在poll阶段之后。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">回顾上一篇，浏览器环境下，microtask的任务队列是每个macrotask执行完之后执行。而在Node.js中，microtask会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行microtask队列的任务。详见：http://lynnelv.github.io/js-event-loop-nodejs</span><br><span class=\"line\"></span><br><span class=\"line\">process.nextTick() 会在各个事件阶段之间执行，一旦执行，要直到nextTick队列被清空，才会进入到下一个事件阶段，所以如果递归调用 process.nextTick()，会导致出现I/O starving（饥饿）的问题</span><br><span class=\"line\"></span><br><span class=\"line\">官方文档：https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/</span><br></pre></td></tr></table></figure>\n<p>###vitual dom</p>\n<p>VD 最大的特点是将页面的状态抽象为 JS 对象的形式，配合不同的渲染工具，使跨平台渲染成为可能。如 React 就借助 VD 实现了服务端渲染、浏览器渲染和移动端渲染等功能。<br>js计算-》生成渲染树-》渲染页面</p>\n<p>通过VD的比较，我们可以将多个操作合并成一个批量的操作，从而减少dom重排的次数，进而缩短了生成渲染树和绘制所花的时间。</p>\n<p>在mounted 方法中会将template 编译成为render 方法。这是一个编译过程，render中会调用createElement 创建vnode。</p>\n<p><img src=\"https://ustbhuangyi.github.io/vue-analysis/assets/new-vue.png\" alt=\"流程图片\"></p>\n<p>回到 mountComponent 函数的过程，我们已经知道 createElement 是如何创建了一个 VNode，接下来就是要把这个 VNode 渲染成一个真实的 DOM 并渲染出来，这个过程是通过 vm._update 完成的</p>\n<p>Vue 的 _update 是实例的一个私有方法，它被调用的时机有 2 个，一个是首次渲染，一个是数据更新的时候；由于我们这一章节只分析首次渲染部分，数据更新部分会在之后分析响应式原理的时候涉及。_update 方法的作用是把 VNode 渲染成真实的 DOM</p>\n<p>在我们之前对 setter 的分析过程知道，当响应式数据发送变化后，触发了 watcher.update()，只是把这个 watcher 推送到一个队列中，在 nextTick 后才会真正执行 watcher 的回调函数。而一旦我们设置了 sync，就可以在当前 Tick 中同步执行 watcher 的回调函数。</p>\n<h5 id=\"修饰符（Modifiers）是以半角句号-指明的特殊后缀，用于指出一个指定应该以特殊方式绑定。例如，-prevent-修饰符告诉-v-on-指令对于触发的事件调用-event-preventDefault\"><a href=\"#修饰符（Modifiers）是以半角句号-指明的特殊后缀，用于指出一个指定应该以特殊方式绑定。例如，-prevent-修饰符告诉-v-on-指令对于触发的事件调用-event-preventDefault\" class=\"headerlink\" title=\"修饰符（Modifiers）是以半角句号 . 指明的特殊后缀，用于指出一个指定应该以特殊方式绑定。例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()\"></a>修饰符（Modifiers）是以半角句号 . 指明的特殊后缀，用于指出一个指定应该以特殊方式绑定。例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 阻止单击事件冒泡 --&gt;</span><br><span class=\"line\">&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">&lt;!-- 提交事件不再重载页面 --&gt;</span><br><span class=\"line\">&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;</span><br><span class=\"line\">&lt;!-- 修饰符可以串联  --&gt;</span><br><span class=\"line\">&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;</span><br><span class=\"line\">&lt;!-- 只有修饰符 --&gt;</span><br><span class=\"line\">&lt;form v-on:submit.prevent&gt;&lt;/form&gt;</span><br><span class=\"line\">&lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt;</span><br><span class=\"line\">&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;</span><br><span class=\"line\">&lt;!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 --&gt;</span><br><span class=\"line\">&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;</span><br><span class=\"line\">&lt;a v-on:click.once=&quot;doThis&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n<h5 id=\"按键修饰符\"><a href=\"#按键修饰符\" class=\"headerlink\" title=\"按键修饰符\"></a>按键修饰符</h5><p>记住所有的 keyCode 比较困难，组合键 所以 Vue 为最常用的按键提供了别名：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Alt + C --&gt;</span><br><span class=\"line\">&lt;input v-on:keyup.alt.67=&quot;clear&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- Ctrl + Click --&gt;</span><br><span class=\"line\">&lt;div v-on:click.ctrl=&quot;doSomething&quot;&gt;Do something&lt;/div&gt;</span><br><span class=\"line\">&lt;!-- 同上 --&gt;</span><br><span class=\"line\">&lt;input v-on:keyup.enter=&quot;submit&quot;&gt;</span><br><span class=\"line\">&lt;!-- 缩写语法 --&gt;</span><br><span class=\"line\">&lt;input @keyup.enter=&quot;submit&quot;&gt;</span><br><span class=\"line\">全部的按键别名：</span><br><span class=\"line\">.enter</span><br><span class=\"line\">.tab</span><br><span class=\"line\">.delete (捕获 “删除” 和 “退格” 键)</span><br><span class=\"line\">.esc</span><br><span class=\"line\">.space</span><br><span class=\"line\">.up</span><br><span class=\"line\">.down</span><br><span class=\"line\">.left</span><br><span class=\"line\">.right</span><br></pre></td></tr></table></figure>\n<h4 id=\"mock-vuex\"><a href=\"#mock-vuex\" class=\"headerlink\" title=\"mock vuex\"></a>mock vuex</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setup() &#123;</span><br><span class=\"line\">          useLoginStatusProvide()</span><br><span class=\"line\">          return &#123;&#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        import &#123; provide, inject, ref &#125; from &apos;@vue/composition-api&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">const StatusSymbol = Symbol(&apos;status&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">export const useLoginStatusProvide = () =&gt; &#123;</span><br><span class=\"line\">  const loginStatus = ref(false)</span><br><span class=\"line\"></span><br><span class=\"line\">  const setLoginStatus = val =&gt; (loginStatus.value = val)</span><br><span class=\"line\">  provide(StatusSymbol, &#123; loginStatus, setLoginStatus &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export const useLoginStatusInject = () =&gt; &#123;</span><br><span class=\"line\">  const context = inject(StatusSymbol)</span><br><span class=\"line\">  if (!context) throw new Error(&apos;useLoginStatusInject must be used after useLoginStatusProvide&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">  return context</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"stock","date":"2021-07-09T02:05:05.000Z","_content":"\n格力\n48.5 \n47.5 1w\n46.5 1w\n45.5 1W\n44.5 1W\n43.5 1.5W\n42.5 1.5W ","source":"_posts/stock.md","raw":"---\ntitle: stock\ndate: 2021-07-09 10:05:05\ntags:\n---\n\n格力\n48.5 \n47.5 1w\n46.5 1w\n45.5 1W\n44.5 1W\n43.5 1.5W\n42.5 1.5W ","slug":"stock","published":1,"updated":"2021-07-09T02:06:53.112Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckzf5se0e0022yy8krzfyh5ai","content":"<p>格力<br>48.5<br>47.5 1w<br>46.5 1w<br>45.5 1W<br>44.5 1W<br>43.5 1.5W<br>42.5 1.5W </p>\n","site":{"data":{}},"excerpt":"","more":"<p>格力<br>48.5<br>47.5 1w<br>46.5 1w<br>45.5 1W<br>44.5 1W<br>43.5 1.5W<br>42.5 1.5W </p>\n"},{"title":"webpack","date":"2017-01-17T06:58:02.000Z","_content":"### babel相关\n1. DefinePlugin  需要字段是json,stringfy\n1. <!doctype html> 的作用就是让浏览器进入标准模式，使用最新的 HTML5标准来解析渲染页面；如果不写，浏览器就会进入混杂模式，我们需要避免此类情况发生。   \n   \n2. 转义的过程：\n   ```text\n   编写ES6代码\n   babylon 进行解析\n   解析得到 AST\n   plugin 用 babel-traverse 对 AST 树进行遍历转译\n   得到新的 AST树\n   用 babel-generator 通过 AST 树生成 ES5 代码\n   ```\n3. use(new webpack.IgnorePlugin(/^\\.\\/locale$/, /moment$/)) \n4. require.context 参数：\n```text\n文件夹路径\n是否递归查找子文件夹下的模块\n模块匹配规则，一般匹配文件后缀名\n```\n1. 虽然@babel/polyfill提供了我们想要的所有新方法新类，但是这里依然存在一些问题：\n   \n   体积太大：比如我只用了String的新特性，但是我把整个包都引进来了，，这不是徒增了很多无用的代码。\n   污染全局环境：如果你引用了 @babel/polyfill，那么像Promise这样的新类就是挂载在全局上的，这样就会污染了全局命名空间。可能在一个团建建立的项目问题不太大，但是如果你是一个工具的开发者，你把全局环境污染了，别人用你的工具，就有可能把别人给坑了\n   \n1.  @babel/plugin-transform-runtime会为代码创建一个沙盒环境，为core-js这里内建的实例提供假名，你可以无缝的使用这些新特性，而不需要使用require polyfill。\n    \n    一个解决方案就是引入transform runtime 来替代 @babel/polyfill。\n    幸运的是，我们有env这个preset，它又一个useBuiltIns选项，如果设置成\"usage\"，那么将会自动检测语法帮你require你代码中使用到的功能。  \n1. @babel/core\n   其中最核心的包就是@babel/core，它主要的作用就是编译.\n   \n   Babel-cli \n   光有core是无法在命令行使用这些功能的，@babel/cli支持你直接在命令行中编译代码。\n   这句话会编译你src目录下的所有js代码，并编译成你想要的那样（babel.config.js配置的），并输出到lib目录下。 \n1. @babel/preset-env\n如果useBuiltIns为true，项目中必须引入babel-polyfill。\n\n1.  我们可以配置webpack的特殊注释(需要 Webpack > 2.4)，将一些按需加载的路由打包到同一个js文件\n```javascript\n   const Foo = () => import(/* webpackChunkName: \"group-foo\" */ './Foo.vue')\n   const Bar = () => import(/* webpackChunkName: \"group-foo\" */ './Bar.vue')\n   const Baz = () => import(/* webpackChunkName: \"group-foo\" */ './Baz.vue')\n```   \n\n1. babel的转译过程分为三个阶段：parsing、transforming、generating，以ES6代码转译为ES5代码为例，babel转译的具体过程如下：\n   \n   ES6代码输入\n   \n   babylon 进行解析得到 AST\n   \n   plugin 用 babel-traverse 对 AST 树进行遍历转译,得到新的AST树\n   \n   用 babel-generator 通过 AST 树生成 ES5 代码\n\n1. UglifyJS: vue-cli 默认使用的压缩代码方式，它使用的是单线程压缩代码，打包时间较慢\n   ParallelUglifyPlugin: 开启多个子进程，把对多个文件压缩的工作分别给多个子进程去完成\n\n1. Vue Loader 是一个 webpack 的 loader，它允许你以一种名为单文件组件 (SFCs)的格式撰写 Vue 组件.   \n1. autoprefixer 自动补充前缀\n\n2.  webpack-dev-server 修改了webpack 配置中的 entry 属性，在里面添加了 webpack-dev-client 的代码，这样在最后的 bundle.js 文件中就会有接收 websocket 消息的代码了。\n\n3.  WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。\n\n4. Webpack splitchunk 将各个模块的交集部分抽离出来 \n\n5. Webpack ProvidePlugin 自动加载js，不必import。\n   new webpack.ProvidePlugin({\n     _map: ['lodash', 'map']\n   })\n\n6. Webpack在打包时可以为我们生成的source maps，这为我们提供了一种对应编译文件和源文件的方法，使得编译后的代码可读性更高，也更容易调试\n\n具体配置参考：http://www.jianshu.com/p/42e11515c10f\n\n感叹号的作用在于使同一文件能够使用不同类型的loader\n\n对css 分模块：\n\n```\n{\n        test: /\\.css$/,\n        loader: 'style!css?modules'//跟前面相比就在后面加上了?modules\n}\n```\n\nLoaders和Plugins常常被弄混，但是他们其实是完全不同的东西，可以这么来说，loaders是在打包构建过程中用来处理源文件的（JSX，Scss，Less..），一次处理一个，插件并不直接操作单个文件，它直接对整个构建过程其作用。\n\n####  常用命令\n\n\n```\n$ webpack --config webpack.min.js //另一份配置文件\n\n$ webpack --display-error-details //显示异常信息\n\n$ webpack --watch   //监听变动并自动打包\n \n$ webpack -p    //压缩混淆脚本，这个非常非常重要！\n \n$ webpack -d    //生成map映射文件，告知哪些模块被最终打包到哪里了\n```\n\n对公共库的封装：\n\n```\nentry: {\n  vendor: [\"jquery\", \"other-lib\"],\n  app: \"./entry\"\n}\nnew CommonsChunkPlugin({\n  name: \"vendor\",\n\n  // filename: \"vendor.js\"\n  // (Give the chunk a different name)\n\n  minChunks: Infinity,\n  // (with more entries, this ensures that no other module\n  //  goes into the vendor chunk)\n})\n```\n\n关于express webpack middleware 的配置\n\nhttp://www.cnblogs.com/linfangshuhellowored/p/5657285.html\n\n给文件自动添加hash后缀\n\n根据chunkhash的定义知道，chunkhash是根据具体模块文件的内容计算所得的hash值，所以某个文件的改动只会影响它本身的hash指纹，不会影响其他文件。配置webpack的output如下：\n```\noutput: {\n    filename: '[name].[chunkhash:8].js',\n    path: __dirname + '/built'\n}\noutput: {\n    filename: '[name].[hash:8].js',\n    path: __dirname + '/built'\n}\n```","source":"_posts/webpack.md","raw":"---\ntitle: webpack\ndate: 2017-01-17 14:58:02\ntags: webpack  \n---\n### babel相关\n1. DefinePlugin  需要字段是json,stringfy\n1. <!doctype html> 的作用就是让浏览器进入标准模式，使用最新的 HTML5标准来解析渲染页面；如果不写，浏览器就会进入混杂模式，我们需要避免此类情况发生。   \n   \n2. 转义的过程：\n   ```text\n   编写ES6代码\n   babylon 进行解析\n   解析得到 AST\n   plugin 用 babel-traverse 对 AST 树进行遍历转译\n   得到新的 AST树\n   用 babel-generator 通过 AST 树生成 ES5 代码\n   ```\n3. use(new webpack.IgnorePlugin(/^\\.\\/locale$/, /moment$/)) \n4. require.context 参数：\n```text\n文件夹路径\n是否递归查找子文件夹下的模块\n模块匹配规则，一般匹配文件后缀名\n```\n1. 虽然@babel/polyfill提供了我们想要的所有新方法新类，但是这里依然存在一些问题：\n   \n   体积太大：比如我只用了String的新特性，但是我把整个包都引进来了，，这不是徒增了很多无用的代码。\n   污染全局环境：如果你引用了 @babel/polyfill，那么像Promise这样的新类就是挂载在全局上的，这样就会污染了全局命名空间。可能在一个团建建立的项目问题不太大，但是如果你是一个工具的开发者，你把全局环境污染了，别人用你的工具，就有可能把别人给坑了\n   \n1.  @babel/plugin-transform-runtime会为代码创建一个沙盒环境，为core-js这里内建的实例提供假名，你可以无缝的使用这些新特性，而不需要使用require polyfill。\n    \n    一个解决方案就是引入transform runtime 来替代 @babel/polyfill。\n    幸运的是，我们有env这个preset，它又一个useBuiltIns选项，如果设置成\"usage\"，那么将会自动检测语法帮你require你代码中使用到的功能。  \n1. @babel/core\n   其中最核心的包就是@babel/core，它主要的作用就是编译.\n   \n   Babel-cli \n   光有core是无法在命令行使用这些功能的，@babel/cli支持你直接在命令行中编译代码。\n   这句话会编译你src目录下的所有js代码，并编译成你想要的那样（babel.config.js配置的），并输出到lib目录下。 \n1. @babel/preset-env\n如果useBuiltIns为true，项目中必须引入babel-polyfill。\n\n1.  我们可以配置webpack的特殊注释(需要 Webpack > 2.4)，将一些按需加载的路由打包到同一个js文件\n```javascript\n   const Foo = () => import(/* webpackChunkName: \"group-foo\" */ './Foo.vue')\n   const Bar = () => import(/* webpackChunkName: \"group-foo\" */ './Bar.vue')\n   const Baz = () => import(/* webpackChunkName: \"group-foo\" */ './Baz.vue')\n```   \n\n1. babel的转译过程分为三个阶段：parsing、transforming、generating，以ES6代码转译为ES5代码为例，babel转译的具体过程如下：\n   \n   ES6代码输入\n   \n   babylon 进行解析得到 AST\n   \n   plugin 用 babel-traverse 对 AST 树进行遍历转译,得到新的AST树\n   \n   用 babel-generator 通过 AST 树生成 ES5 代码\n\n1. UglifyJS: vue-cli 默认使用的压缩代码方式，它使用的是单线程压缩代码，打包时间较慢\n   ParallelUglifyPlugin: 开启多个子进程，把对多个文件压缩的工作分别给多个子进程去完成\n\n1. Vue Loader 是一个 webpack 的 loader，它允许你以一种名为单文件组件 (SFCs)的格式撰写 Vue 组件.   \n1. autoprefixer 自动补充前缀\n\n2.  webpack-dev-server 修改了webpack 配置中的 entry 属性，在里面添加了 webpack-dev-client 的代码，这样在最后的 bundle.js 文件中就会有接收 websocket 消息的代码了。\n\n3.  WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。\n\n4. Webpack splitchunk 将各个模块的交集部分抽离出来 \n\n5. Webpack ProvidePlugin 自动加载js，不必import。\n   new webpack.ProvidePlugin({\n     _map: ['lodash', 'map']\n   })\n\n6. Webpack在打包时可以为我们生成的source maps，这为我们提供了一种对应编译文件和源文件的方法，使得编译后的代码可读性更高，也更容易调试\n\n具体配置参考：http://www.jianshu.com/p/42e11515c10f\n\n感叹号的作用在于使同一文件能够使用不同类型的loader\n\n对css 分模块：\n\n```\n{\n        test: /\\.css$/,\n        loader: 'style!css?modules'//跟前面相比就在后面加上了?modules\n}\n```\n\nLoaders和Plugins常常被弄混，但是他们其实是完全不同的东西，可以这么来说，loaders是在打包构建过程中用来处理源文件的（JSX，Scss，Less..），一次处理一个，插件并不直接操作单个文件，它直接对整个构建过程其作用。\n\n####  常用命令\n\n\n```\n$ webpack --config webpack.min.js //另一份配置文件\n\n$ webpack --display-error-details //显示异常信息\n\n$ webpack --watch   //监听变动并自动打包\n \n$ webpack -p    //压缩混淆脚本，这个非常非常重要！\n \n$ webpack -d    //生成map映射文件，告知哪些模块被最终打包到哪里了\n```\n\n对公共库的封装：\n\n```\nentry: {\n  vendor: [\"jquery\", \"other-lib\"],\n  app: \"./entry\"\n}\nnew CommonsChunkPlugin({\n  name: \"vendor\",\n\n  // filename: \"vendor.js\"\n  // (Give the chunk a different name)\n\n  minChunks: Infinity,\n  // (with more entries, this ensures that no other module\n  //  goes into the vendor chunk)\n})\n```\n\n关于express webpack middleware 的配置\n\nhttp://www.cnblogs.com/linfangshuhellowored/p/5657285.html\n\n给文件自动添加hash后缀\n\n根据chunkhash的定义知道，chunkhash是根据具体模块文件的内容计算所得的hash值，所以某个文件的改动只会影响它本身的hash指纹，不会影响其他文件。配置webpack的output如下：\n```\noutput: {\n    filename: '[name].[chunkhash:8].js',\n    path: __dirname + '/built'\n}\noutput: {\n    filename: '[name].[hash:8].js',\n    path: __dirname + '/built'\n}\n```","slug":"webpack","published":1,"updated":"2020-08-18T02:14:14.754Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckzf5se0h0024yy8k46qvj5vn","content":"<h3 id=\"babel相关\"><a href=\"#babel相关\" class=\"headerlink\" title=\"babel相关\"></a>babel相关</h3><ol>\n<li>DefinePlugin  需要字段是json,stringfy</li>\n<li><p>&lt;!doctype html&gt; 的作用就是让浏览器进入标准模式，使用最新的 HTML5标准来解析渲染页面；如果不写，浏览器就会进入混杂模式，我们需要避免此类情况发生。   </p>\n</li>\n<li><p>转义的过程：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">编写ES6代码</span><br><span class=\"line\">babylon 进行解析</span><br><span class=\"line\">解析得到 AST</span><br><span class=\"line\">plugin 用 babel-traverse 对 AST 树进行遍历转译</span><br><span class=\"line\">得到新的 AST树</span><br><span class=\"line\">用 babel-generator 通过 AST 树生成 ES5 代码</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>use(new webpack.IgnorePlugin(/^.\\/locale$/, /moment$/)) </p>\n</li>\n<li><p>require.context 参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">文件夹路径</span><br><span class=\"line\">是否递归查找子文件夹下的模块</span><br><span class=\"line\">模块匹配规则，一般匹配文件后缀名</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>虽然@babel/polyfill提供了我们想要的所有新方法新类，但是这里依然存在一些问题：</p>\n<p>体积太大：比如我只用了String的新特性，但是我把整个包都引进来了，，这不是徒增了很多无用的代码。<br>污染全局环境：如果你引用了 @babel/polyfill，那么像Promise这样的新类就是挂载在全局上的，这样就会污染了全局命名空间。可能在一个团建建立的项目问题不太大，但是如果你是一个工具的开发者，你把全局环境污染了，别人用你的工具，就有可能把别人给坑了</p>\n</li>\n<li><p>@babel/plugin-transform-runtime会为代码创建一个沙盒环境，为core-js这里内建的实例提供假名，你可以无缝的使用这些新特性，而不需要使用require polyfill。</p>\n<p>一个解决方案就是引入transform runtime 来替代 @babel/polyfill。<br>幸运的是，我们有env这个preset，它又一个useBuiltIns选项，如果设置成”usage”，那么将会自动检测语法帮你require你代码中使用到的功能。  </p>\n</li>\n<li><p>@babel/core<br>其中最核心的包就是@babel/core，它主要的作用就是编译.</p>\n<p>Babel-cli<br>光有core是无法在命令行使用这些功能的，@babel/cli支持你直接在命令行中编译代码。<br>这句话会编译你src目录下的所有js代码，并编译成你想要的那样（babel.config.js配置的），并输出到lib目录下。 </p>\n</li>\n<li><p>@babel/preset-env<br>如果useBuiltIns为true，项目中必须引入babel-polyfill。</p>\n</li>\n<li><p>我们可以配置webpack的特殊注释(需要 Webpack &gt; 2.4)，将一些按需加载的路由打包到同一个js文件</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"keyword\">const</span> Foo = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">import</span>(<span class=\"comment\">/* webpackChunkName: \"group-foo\" */</span> <span class=\"string\">'./Foo.vue'</span>)</span><br><span class=\"line\">   <span class=\"keyword\">const</span> Bar = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">import</span>(<span class=\"comment\">/* webpackChunkName: \"group-foo\" */</span> <span class=\"string\">'./Bar.vue'</span>)</span><br><span class=\"line\">   <span class=\"keyword\">const</span> Baz = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">import</span>(<span class=\"comment\">/* webpackChunkName: \"group-foo\" */</span> <span class=\"string\">'./Baz.vue'</span>)</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`   </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">1. babel的转译过程分为三个阶段：parsing、transforming、generating，以ES6代码转译为ES5代码为例，babel转译的具体过程如下：</span></span><br><span class=\"line\"><span class=\"string\">   </span></span><br><span class=\"line\"><span class=\"string\">   ES6代码输入</span></span><br><span class=\"line\"><span class=\"string\">   </span></span><br><span class=\"line\"><span class=\"string\">   babylon 进行解析得到 AST</span></span><br><span class=\"line\"><span class=\"string\">   </span></span><br><span class=\"line\"><span class=\"string\">   plugin 用 babel-traverse 对 AST 树进行遍历转译,得到新的AST树</span></span><br><span class=\"line\"><span class=\"string\">   </span></span><br><span class=\"line\"><span class=\"string\">   用 babel-generator 通过 AST 树生成 ES5 代码</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">1. UglifyJS: vue-cli 默认使用的压缩代码方式，它使用的是单线程压缩代码，打包时间较慢</span></span><br><span class=\"line\"><span class=\"string\">   ParallelUglifyPlugin: 开启多个子进程，把对多个文件压缩的工作分别给多个子进程去完成</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">1. Vue Loader 是一个 webpack 的 loader，它允许你以一种名为单文件组件 (SFCs)的格式撰写 Vue 组件.   </span></span><br><span class=\"line\"><span class=\"string\">1. autoprefixer 自动补充前缀</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">2.  webpack-dev-server 修改了webpack 配置中的 entry 属性，在里面添加了 webpack-dev-client 的代码，这样在最后的 bundle.js 文件中就会有接收 websocket 消息的代码了。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">3.  WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">4. Webpack splitchunk 将各个模块的交集部分抽离出来 </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">5. Webpack ProvidePlugin 自动加载js，不必import。</span></span><br><span class=\"line\"><span class=\"string\">   new webpack.ProvidePlugin(&#123;</span></span><br><span class=\"line\"><span class=\"string\">     _map: ['lodash', 'map']</span></span><br><span class=\"line\"><span class=\"string\">   &#125;)</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">6. Webpack在打包时可以为我们生成的source maps，这为我们提供了一种对应编译文件和源文件的方法，使得编译后的代码可读性更高，也更容易调试</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">具体配置参考：http://www.jianshu.com/p/42e11515c10f</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">感叹号的作用在于使同一文件能够使用不同类型的loader</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">对css 分模块：</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>{<br>        test: /.css$/,<br>        loader: ‘style!css?modules’//跟前面相比就在后面加上了?modules<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Loaders和Plugins常常被弄混，但是他们其实是完全不同的东西，可以这么来说，loaders是在打包构建过程中用来处理源文件的（JSX，Scss，Less..），一次处理一个，插件并不直接操作单个文件，它直接对整个构建过程其作用。</span><br><span class=\"line\"></span><br><span class=\"line\">####  常用命令</span><br></pre></td></tr></table></figure></p>\n<p>$ webpack –config webpack.min.js //另一份配置文件</p>\n<p>$ webpack –display-error-details //显示异常信息</p>\n<p>$ webpack –watch   //监听变动并自动打包</p>\n<p>$ webpack -p    //压缩混淆脚本，这个非常非常重要！</p>\n<p>$ webpack -d    //生成map映射文件，告知哪些模块被最终打包到哪里了<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">对公共库的封装：</span><br></pre></td></tr></table></figure></p>\n<p>entry: {<br>  vendor: [“jquery”, “other-lib”],<br>  app: “./entry”<br>}<br>new CommonsChunkPlugin({<br>  name: “vendor”,</p>\n<p>  // filename: “vendor.js”<br>  // (Give the chunk a different name)</p>\n<p>  minChunks: Infinity,<br>  // (with more entries, this ensures that no other module<br>  //  goes into the vendor chunk)<br>})<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">关于express webpack middleware 的配置</span><br><span class=\"line\"></span><br><span class=\"line\">http://www.cnblogs.com/linfangshuhellowored/p/5657285.html</span><br><span class=\"line\"></span><br><span class=\"line\">给文件自动添加hash后缀</span><br><span class=\"line\"></span><br><span class=\"line\">根据chunkhash的定义知道，chunkhash是根据具体模块文件的内容计算所得的hash值，所以某个文件的改动只会影响它本身的hash指纹，不会影响其他文件。配置webpack的output如下：</span><br></pre></td></tr></table></figure></p>\n<p>output: {<br>    filename: ‘[name].[chunkhash:8].js’,<br>    path: <strong>dirname + ‘/built’<br>}<br>output: {<br>    filename: ‘[name].[hash:8].js’,<br>    path: </strong>dirname + ‘/built’<br>}<br><code>`</code></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"babel相关\"><a href=\"#babel相关\" class=\"headerlink\" title=\"babel相关\"></a>babel相关</h3><ol>\n<li>DefinePlugin  需要字段是json,stringfy</li>\n<li><p>&lt;!doctype html&gt; 的作用就是让浏览器进入标准模式，使用最新的 HTML5标准来解析渲染页面；如果不写，浏览器就会进入混杂模式，我们需要避免此类情况发生。   </p>\n</li>\n<li><p>转义的过程：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">编写ES6代码</span><br><span class=\"line\">babylon 进行解析</span><br><span class=\"line\">解析得到 AST</span><br><span class=\"line\">plugin 用 babel-traverse 对 AST 树进行遍历转译</span><br><span class=\"line\">得到新的 AST树</span><br><span class=\"line\">用 babel-generator 通过 AST 树生成 ES5 代码</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>use(new webpack.IgnorePlugin(/^.\\/locale$/, /moment$/)) </p>\n</li>\n<li><p>require.context 参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">文件夹路径</span><br><span class=\"line\">是否递归查找子文件夹下的模块</span><br><span class=\"line\">模块匹配规则，一般匹配文件后缀名</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>虽然@babel/polyfill提供了我们想要的所有新方法新类，但是这里依然存在一些问题：</p>\n<p>体积太大：比如我只用了String的新特性，但是我把整个包都引进来了，，这不是徒增了很多无用的代码。<br>污染全局环境：如果你引用了 @babel/polyfill，那么像Promise这样的新类就是挂载在全局上的，这样就会污染了全局命名空间。可能在一个团建建立的项目问题不太大，但是如果你是一个工具的开发者，你把全局环境污染了，别人用你的工具，就有可能把别人给坑了</p>\n</li>\n<li><p>@babel/plugin-transform-runtime会为代码创建一个沙盒环境，为core-js这里内建的实例提供假名，你可以无缝的使用这些新特性，而不需要使用require polyfill。</p>\n<p>一个解决方案就是引入transform runtime 来替代 @babel/polyfill。<br>幸运的是，我们有env这个preset，它又一个useBuiltIns选项，如果设置成”usage”，那么将会自动检测语法帮你require你代码中使用到的功能。  </p>\n</li>\n<li><p>@babel/core<br>其中最核心的包就是@babel/core，它主要的作用就是编译.</p>\n<p>Babel-cli<br>光有core是无法在命令行使用这些功能的，@babel/cli支持你直接在命令行中编译代码。<br>这句话会编译你src目录下的所有js代码，并编译成你想要的那样（babel.config.js配置的），并输出到lib目录下。 </p>\n</li>\n<li><p>@babel/preset-env<br>如果useBuiltIns为true，项目中必须引入babel-polyfill。</p>\n</li>\n<li><p>我们可以配置webpack的特殊注释(需要 Webpack &gt; 2.4)，将一些按需加载的路由打包到同一个js文件</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"keyword\">const</span> Foo = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">import</span>(<span class=\"comment\">/* webpackChunkName: \"group-foo\" */</span> <span class=\"string\">'./Foo.vue'</span>)</span><br><span class=\"line\">   <span class=\"keyword\">const</span> Bar = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">import</span>(<span class=\"comment\">/* webpackChunkName: \"group-foo\" */</span> <span class=\"string\">'./Bar.vue'</span>)</span><br><span class=\"line\">   <span class=\"keyword\">const</span> Baz = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">import</span>(<span class=\"comment\">/* webpackChunkName: \"group-foo\" */</span> <span class=\"string\">'./Baz.vue'</span>)</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`   </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">1. babel的转译过程分为三个阶段：parsing、transforming、generating，以ES6代码转译为ES5代码为例，babel转译的具体过程如下：</span></span><br><span class=\"line\"><span class=\"string\">   </span></span><br><span class=\"line\"><span class=\"string\">   ES6代码输入</span></span><br><span class=\"line\"><span class=\"string\">   </span></span><br><span class=\"line\"><span class=\"string\">   babylon 进行解析得到 AST</span></span><br><span class=\"line\"><span class=\"string\">   </span></span><br><span class=\"line\"><span class=\"string\">   plugin 用 babel-traverse 对 AST 树进行遍历转译,得到新的AST树</span></span><br><span class=\"line\"><span class=\"string\">   </span></span><br><span class=\"line\"><span class=\"string\">   用 babel-generator 通过 AST 树生成 ES5 代码</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">1. UglifyJS: vue-cli 默认使用的压缩代码方式，它使用的是单线程压缩代码，打包时间较慢</span></span><br><span class=\"line\"><span class=\"string\">   ParallelUglifyPlugin: 开启多个子进程，把对多个文件压缩的工作分别给多个子进程去完成</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">1. Vue Loader 是一个 webpack 的 loader，它允许你以一种名为单文件组件 (SFCs)的格式撰写 Vue 组件.   </span></span><br><span class=\"line\"><span class=\"string\">1. autoprefixer 自动补充前缀</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">2.  webpack-dev-server 修改了webpack 配置中的 entry 属性，在里面添加了 webpack-dev-client 的代码，这样在最后的 bundle.js 文件中就会有接收 websocket 消息的代码了。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">3.  WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">4. Webpack splitchunk 将各个模块的交集部分抽离出来 </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">5. Webpack ProvidePlugin 自动加载js，不必import。</span></span><br><span class=\"line\"><span class=\"string\">   new webpack.ProvidePlugin(&#123;</span></span><br><span class=\"line\"><span class=\"string\">     _map: ['lodash', 'map']</span></span><br><span class=\"line\"><span class=\"string\">   &#125;)</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">6. Webpack在打包时可以为我们生成的source maps，这为我们提供了一种对应编译文件和源文件的方法，使得编译后的代码可读性更高，也更容易调试</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">具体配置参考：http://www.jianshu.com/p/42e11515c10f</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">感叹号的作用在于使同一文件能够使用不同类型的loader</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">对css 分模块：</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>{<br>        test: /.css$/,<br>        loader: ‘style!css?modules’//跟前面相比就在后面加上了?modules<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Loaders和Plugins常常被弄混，但是他们其实是完全不同的东西，可以这么来说，loaders是在打包构建过程中用来处理源文件的（JSX，Scss，Less..），一次处理一个，插件并不直接操作单个文件，它直接对整个构建过程其作用。</span><br><span class=\"line\"></span><br><span class=\"line\">####  常用命令</span><br></pre></td></tr></table></figure></p>\n<p>$ webpack –config webpack.min.js //另一份配置文件</p>\n<p>$ webpack –display-error-details //显示异常信息</p>\n<p>$ webpack –watch   //监听变动并自动打包</p>\n<p>$ webpack -p    //压缩混淆脚本，这个非常非常重要！</p>\n<p>$ webpack -d    //生成map映射文件，告知哪些模块被最终打包到哪里了<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">对公共库的封装：</span><br></pre></td></tr></table></figure></p>\n<p>entry: {<br>  vendor: [“jquery”, “other-lib”],<br>  app: “./entry”<br>}<br>new CommonsChunkPlugin({<br>  name: “vendor”,</p>\n<p>  // filename: “vendor.js”<br>  // (Give the chunk a different name)</p>\n<p>  minChunks: Infinity,<br>  // (with more entries, this ensures that no other module<br>  //  goes into the vendor chunk)<br>})<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">关于express webpack middleware 的配置</span><br><span class=\"line\"></span><br><span class=\"line\">http://www.cnblogs.com/linfangshuhellowored/p/5657285.html</span><br><span class=\"line\"></span><br><span class=\"line\">给文件自动添加hash后缀</span><br><span class=\"line\"></span><br><span class=\"line\">根据chunkhash的定义知道，chunkhash是根据具体模块文件的内容计算所得的hash值，所以某个文件的改动只会影响它本身的hash指纹，不会影响其他文件。配置webpack的output如下：</span><br></pre></td></tr></table></figure></p>\n<p>output: {<br>    filename: ‘[name].[chunkhash:8].js’,<br>    path: <strong>dirname + ‘/built’<br>}<br>output: {<br>    filename: ‘[name].[hash:8].js’,<br>    path: </strong>dirname + ‘/built’<br>}<br><code>`</code></p>\n"},{"title":"vite","date":"2022-06-06T07:44:53.000Z","_content":"\n1. 上面提到Vite是基于浏览器原生支持ESM的能力实现的，但要求用户的代码模块必须是ESM模块，因此必须将commonJs的文件提前处理，转化成 ESM 模块并缓存入 node_modules/.vite\n2. 减少模块和请求数量  Vite 将有许多内部模块的 ESM 依赖关系转换为单个模块，以提高后续页面加载性能。\n3. handleHotUpdate  热更新hook\n4. configureServer   是用于配置开发服务器的钩子。最常见的用例是在内部 connect 应用程序中添加自定义中间件:\n\n```\n以下钩子在服务器启动时被调用：\n\noptions\nbuildStart\n\n以下钩子会在每个传入模块请求时被调用：\n\nresolveId\nload\ntransform\n以下钩子在服务器关闭时被调用：\n\nbuildEnd\ncloseBundle\n如果你的插件使用 'virtual modules'（比如帮助函数），给模块名加上 \\0 前缀。这可以阻止其他插件执行它。\n\nconst myPlugin = {\n    name: 'my-plugin', //  必须的插件标志\n    apply: 'build' | 'serve', //  表明此插件应用在何种模式\n    enforce: 'post' | 'pre', //  插件排序\n\n    // rollup通用插件，ctx是一个plugins集合的上下文\n    options(ctx,pluginOptions) {\n      //  返回plugin opthons ，类型：async, sequential\n      return somePluginOptions\n    },\n    buildStart(ctx,pluginOptions) {\n      //  在服务启动前开始执行，类型：async, parallel\n      //  ...do something\n    },\n    resolveId(ctx,srouce, importer, pluginOptions) {\n      //  srouce为资源的路径，importer为引入此资源的文件\n      //  如果有返回值，则将替换掉importer中引入的路径，同时将返回值传递给其他hook\n      //  类型 async, first\n      //  ...do something\n      return srouce\n    },\n    load(ctx,id, srr) {\n      //  id为resolveId返回的值\n      //  加载资源并返回 类型 async, first\n      //  ...do something\n      return code\n    },\n    transform(ctx,code, id, ssr) {\n      //  code为load返回的值，id为resolveId返回的值\n      //  转译code并返回转译结果 类型 async, first，\n      //  ...do something\n      return transformCode\n    },\n    buildEnd(err) {\n      //  构建结束的回调，可以捕获错误。类型 async, parallel\n    },\n    closeBundle() {\n      //  构建结束的最终回调，类型 async, parallel\n    },\n\n    //  vite 独有插件\n    config(config, env) {\n      //  返回一个配置对象，merge到最终config中\n      //  类型 sync, sequential\n      return config\n    },\n    configResolved(config) {\n      //  解析 Vite 配置后调用 类型 sync, parallel\n    },\n    configureServer(server) {\n      //  服务器配置完后的hook 类型 sync, paralle\n    },\n    transformIndexHtml() {\n      // 转换 index.html 的专用钩子。钩子接收当前的 HTML 字符串和转换上下文\n      // 类型 async, sequential\n    },\n    handleHotUpdate(HmrContext) {\n      //  触发热更新时的hook，可以更加精确的控制hmr\n      //  类型\n    }\n  }\n\n```\n\n\n1. ","source":"_posts/vite.md","raw":"---\ntitle: vite \ndate: 2022-06-06 15:44:53\ntags:\n---\n\n1. 上面提到Vite是基于浏览器原生支持ESM的能力实现的，但要求用户的代码模块必须是ESM模块，因此必须将commonJs的文件提前处理，转化成 ESM 模块并缓存入 node_modules/.vite\n2. 减少模块和请求数量  Vite 将有许多内部模块的 ESM 依赖关系转换为单个模块，以提高后续页面加载性能。\n3. handleHotUpdate  热更新hook\n4. configureServer   是用于配置开发服务器的钩子。最常见的用例是在内部 connect 应用程序中添加自定义中间件:\n\n```\n以下钩子在服务器启动时被调用：\n\noptions\nbuildStart\n\n以下钩子会在每个传入模块请求时被调用：\n\nresolveId\nload\ntransform\n以下钩子在服务器关闭时被调用：\n\nbuildEnd\ncloseBundle\n如果你的插件使用 'virtual modules'（比如帮助函数），给模块名加上 \\0 前缀。这可以阻止其他插件执行它。\n\nconst myPlugin = {\n    name: 'my-plugin', //  必须的插件标志\n    apply: 'build' | 'serve', //  表明此插件应用在何种模式\n    enforce: 'post' | 'pre', //  插件排序\n\n    // rollup通用插件，ctx是一个plugins集合的上下文\n    options(ctx,pluginOptions) {\n      //  返回plugin opthons ，类型：async, sequential\n      return somePluginOptions\n    },\n    buildStart(ctx,pluginOptions) {\n      //  在服务启动前开始执行，类型：async, parallel\n      //  ...do something\n    },\n    resolveId(ctx,srouce, importer, pluginOptions) {\n      //  srouce为资源的路径，importer为引入此资源的文件\n      //  如果有返回值，则将替换掉importer中引入的路径，同时将返回值传递给其他hook\n      //  类型 async, first\n      //  ...do something\n      return srouce\n    },\n    load(ctx,id, srr) {\n      //  id为resolveId返回的值\n      //  加载资源并返回 类型 async, first\n      //  ...do something\n      return code\n    },\n    transform(ctx,code, id, ssr) {\n      //  code为load返回的值，id为resolveId返回的值\n      //  转译code并返回转译结果 类型 async, first，\n      //  ...do something\n      return transformCode\n    },\n    buildEnd(err) {\n      //  构建结束的回调，可以捕获错误。类型 async, parallel\n    },\n    closeBundle() {\n      //  构建结束的最终回调，类型 async, parallel\n    },\n\n    //  vite 独有插件\n    config(config, env) {\n      //  返回一个配置对象，merge到最终config中\n      //  类型 sync, sequential\n      return config\n    },\n    configResolved(config) {\n      //  解析 Vite 配置后调用 类型 sync, parallel\n    },\n    configureServer(server) {\n      //  服务器配置完后的hook 类型 sync, paralle\n    },\n    transformIndexHtml() {\n      // 转换 index.html 的专用钩子。钩子接收当前的 HTML 字符串和转换上下文\n      // 类型 async, sequential\n    },\n    handleHotUpdate(HmrContext) {\n      //  触发热更新时的hook，可以更加精确的控制hmr\n      //  类型\n    }\n  }\n\n```\n\n\n1. ","slug":"vite","published":1,"updated":"2022-06-06T07:52:51.570Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl42gnsc70000yr8kcpgf3e5p","content":"<ol>\n<li>上面提到Vite是基于浏览器原生支持ESM的能力实现的，但要求用户的代码模块必须是ESM模块，因此必须将commonJs的文件提前处理，转化成 ESM 模块并缓存入 node_modules&#x2F;.vite</li>\n<li>减少模块和请求数量  Vite 将有许多内部模块的 ESM 依赖关系转换为单个模块，以提高后续页面加载性能。</li>\n<li>handleHotUpdate  热更新hook</li>\n<li>configureServer   是用于配置开发服务器的钩子。最常见的用例是在内部 connect 应用程序中添加自定义中间件:</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">以下钩子在服务器启动时被调用：</span><br><span class=\"line\"></span><br><span class=\"line\">options</span><br><span class=\"line\">buildStart</span><br><span class=\"line\"></span><br><span class=\"line\">以下钩子会在每个传入模块请求时被调用：</span><br><span class=\"line\"></span><br><span class=\"line\">resolveId</span><br><span class=\"line\">load</span><br><span class=\"line\">transform</span><br><span class=\"line\">以下钩子在服务器关闭时被调用：</span><br><span class=\"line\"></span><br><span class=\"line\">buildEnd</span><br><span class=\"line\">closeBundle</span><br><span class=\"line\">如果你的插件使用 &#x27;virtual modules&#x27;（比如帮助函数），给模块名加上 \\0 前缀。这可以阻止其他插件执行它。</span><br><span class=\"line\"></span><br><span class=\"line\">const myPlugin = &#123;</span><br><span class=\"line\">    name: &#x27;my-plugin&#x27;, //  必须的插件标志</span><br><span class=\"line\">    apply: &#x27;build&#x27; | &#x27;serve&#x27;, //  表明此插件应用在何种模式</span><br><span class=\"line\">    enforce: &#x27;post&#x27; | &#x27;pre&#x27;, //  插件排序</span><br><span class=\"line\"></span><br><span class=\"line\">    // rollup通用插件，ctx是一个plugins集合的上下文</span><br><span class=\"line\">    options(ctx,pluginOptions) &#123;</span><br><span class=\"line\">      //  返回plugin opthons ，类型：async, sequential</span><br><span class=\"line\">      return somePluginOptions</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    buildStart(ctx,pluginOptions) &#123;</span><br><span class=\"line\">      //  在服务启动前开始执行，类型：async, parallel</span><br><span class=\"line\">      //  ...do something</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    resolveId(ctx,srouce, importer, pluginOptions) &#123;</span><br><span class=\"line\">      //  srouce为资源的路径，importer为引入此资源的文件</span><br><span class=\"line\">      //  如果有返回值，则将替换掉importer中引入的路径，同时将返回值传递给其他hook</span><br><span class=\"line\">      //  类型 async, first</span><br><span class=\"line\">      //  ...do something</span><br><span class=\"line\">      return srouce</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    load(ctx,id, srr) &#123;</span><br><span class=\"line\">      //  id为resolveId返回的值</span><br><span class=\"line\">      //  加载资源并返回 类型 async, first</span><br><span class=\"line\">      //  ...do something</span><br><span class=\"line\">      return code</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    transform(ctx,code, id, ssr) &#123;</span><br><span class=\"line\">      //  code为load返回的值，id为resolveId返回的值</span><br><span class=\"line\">      //  转译code并返回转译结果 类型 async, first，</span><br><span class=\"line\">      //  ...do something</span><br><span class=\"line\">      return transformCode</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    buildEnd(err) &#123;</span><br><span class=\"line\">      //  构建结束的回调，可以捕获错误。类型 async, parallel</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    closeBundle() &#123;</span><br><span class=\"line\">      //  构建结束的最终回调，类型 async, parallel</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    //  vite 独有插件</span><br><span class=\"line\">    config(config, env) &#123;</span><br><span class=\"line\">      //  返回一个配置对象，merge到最终config中</span><br><span class=\"line\">      //  类型 sync, sequential</span><br><span class=\"line\">      return config</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    configResolved(config) &#123;</span><br><span class=\"line\">      //  解析 Vite 配置后调用 类型 sync, parallel</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    configureServer(server) &#123;</span><br><span class=\"line\">      //  服务器配置完后的hook 类型 sync, paralle</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    transformIndexHtml() &#123;</span><br><span class=\"line\">      // 转换 index.html 的专用钩子。钩子接收当前的 HTML 字符串和转换上下文</span><br><span class=\"line\">      // 类型 async, sequential</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    handleHotUpdate(HmrContext) &#123;</span><br><span class=\"line\">      //  触发热更新时的hook，可以更加精确的控制hmr</span><br><span class=\"line\">      //  类型</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<p>1. </p>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>上面提到Vite是基于浏览器原生支持ESM的能力实现的，但要求用户的代码模块必须是ESM模块，因此必须将commonJs的文件提前处理，转化成 ESM 模块并缓存入 node_modules&#x2F;.vite</li>\n<li>减少模块和请求数量  Vite 将有许多内部模块的 ESM 依赖关系转换为单个模块，以提高后续页面加载性能。</li>\n<li>handleHotUpdate  热更新hook</li>\n<li>configureServer   是用于配置开发服务器的钩子。最常见的用例是在内部 connect 应用程序中添加自定义中间件:</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">以下钩子在服务器启动时被调用：</span><br><span class=\"line\"></span><br><span class=\"line\">options</span><br><span class=\"line\">buildStart</span><br><span class=\"line\"></span><br><span class=\"line\">以下钩子会在每个传入模块请求时被调用：</span><br><span class=\"line\"></span><br><span class=\"line\">resolveId</span><br><span class=\"line\">load</span><br><span class=\"line\">transform</span><br><span class=\"line\">以下钩子在服务器关闭时被调用：</span><br><span class=\"line\"></span><br><span class=\"line\">buildEnd</span><br><span class=\"line\">closeBundle</span><br><span class=\"line\">如果你的插件使用 &#x27;virtual modules&#x27;（比如帮助函数），给模块名加上 \\0 前缀。这可以阻止其他插件执行它。</span><br><span class=\"line\"></span><br><span class=\"line\">const myPlugin = &#123;</span><br><span class=\"line\">    name: &#x27;my-plugin&#x27;, //  必须的插件标志</span><br><span class=\"line\">    apply: &#x27;build&#x27; | &#x27;serve&#x27;, //  表明此插件应用在何种模式</span><br><span class=\"line\">    enforce: &#x27;post&#x27; | &#x27;pre&#x27;, //  插件排序</span><br><span class=\"line\"></span><br><span class=\"line\">    // rollup通用插件，ctx是一个plugins集合的上下文</span><br><span class=\"line\">    options(ctx,pluginOptions) &#123;</span><br><span class=\"line\">      //  返回plugin opthons ，类型：async, sequential</span><br><span class=\"line\">      return somePluginOptions</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    buildStart(ctx,pluginOptions) &#123;</span><br><span class=\"line\">      //  在服务启动前开始执行，类型：async, parallel</span><br><span class=\"line\">      //  ...do something</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    resolveId(ctx,srouce, importer, pluginOptions) &#123;</span><br><span class=\"line\">      //  srouce为资源的路径，importer为引入此资源的文件</span><br><span class=\"line\">      //  如果有返回值，则将替换掉importer中引入的路径，同时将返回值传递给其他hook</span><br><span class=\"line\">      //  类型 async, first</span><br><span class=\"line\">      //  ...do something</span><br><span class=\"line\">      return srouce</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    load(ctx,id, srr) &#123;</span><br><span class=\"line\">      //  id为resolveId返回的值</span><br><span class=\"line\">      //  加载资源并返回 类型 async, first</span><br><span class=\"line\">      //  ...do something</span><br><span class=\"line\">      return code</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    transform(ctx,code, id, ssr) &#123;</span><br><span class=\"line\">      //  code为load返回的值，id为resolveId返回的值</span><br><span class=\"line\">      //  转译code并返回转译结果 类型 async, first，</span><br><span class=\"line\">      //  ...do something</span><br><span class=\"line\">      return transformCode</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    buildEnd(err) &#123;</span><br><span class=\"line\">      //  构建结束的回调，可以捕获错误。类型 async, parallel</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    closeBundle() &#123;</span><br><span class=\"line\">      //  构建结束的最终回调，类型 async, parallel</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    //  vite 独有插件</span><br><span class=\"line\">    config(config, env) &#123;</span><br><span class=\"line\">      //  返回一个配置对象，merge到最终config中</span><br><span class=\"line\">      //  类型 sync, sequential</span><br><span class=\"line\">      return config</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    configResolved(config) &#123;</span><br><span class=\"line\">      //  解析 Vite 配置后调用 类型 sync, parallel</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    configureServer(server) &#123;</span><br><span class=\"line\">      //  服务器配置完后的hook 类型 sync, paralle</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    transformIndexHtml() &#123;</span><br><span class=\"line\">      // 转换 index.html 的专用钩子。钩子接收当前的 HTML 字符串和转换上下文</span><br><span class=\"line\">      // 类型 async, sequential</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    handleHotUpdate(HmrContext) &#123;</span><br><span class=\"line\">      //  触发热更新时的hook，可以更加精确的控制hmr</span><br><span class=\"line\">      //  类型</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<p>1. </p>\n"},{"title":"yanbao","date":"2022-07-06T01:52:11.000Z","_content":"\n## 协鑫\n掌握颗粒硅量产技术，迈入万吨级产能规模。公司未来规划徐州 10 万吨、\n乐山 10 万吨以及包头 30 万吨颗粒硅产能。预计 21-22 年公司颗粒硅产\n能可达 3/26 万吨，实现大幅提升。颗粒硅产能规模的扩大助力公司具备\n规模优势，生产成本有望进一步降低，盈利能力有望逐步提升\n\n目前生产 1 千克颗粒硅耗电\n仅 18 度，相较于西门子法 60 度/千克有显著下降；水耗氢耗方面，FBR\n方法较西门子法降低 30%/42%。投资方面，颗粒硅每万吨产能仅需要 7\n亿初始投资，相较西门子法可降低 1.5-2 亿元，具备成本优势。","source":"_posts/yanbao.md","raw":"---\ntitle: yanbao\ndate: 2022-07-06 09:52:11\ntags:\n---\n\n## 协鑫\n掌握颗粒硅量产技术，迈入万吨级产能规模。公司未来规划徐州 10 万吨、\n乐山 10 万吨以及包头 30 万吨颗粒硅产能。预计 21-22 年公司颗粒硅产\n能可达 3/26 万吨，实现大幅提升。颗粒硅产能规模的扩大助力公司具备\n规模优势，生产成本有望进一步降低，盈利能力有望逐步提升\n\n目前生产 1 千克颗粒硅耗电\n仅 18 度，相较于西门子法 60 度/千克有显著下降；水耗氢耗方面，FBR\n方法较西门子法降低 30%/42%。投资方面，颗粒硅每万吨产能仅需要 7\n亿初始投资，相较西门子法可降低 1.5-2 亿元，具备成本优势。","slug":"yanbao","published":1,"updated":"2022-07-06T01:53:08.982Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl7zl5h780000crsl8a6g4932","content":"<h2 id=\"协鑫\"><a href=\"#协鑫\" class=\"headerlink\" title=\"协鑫\"></a>协鑫</h2><p>掌握颗粒硅量产技术，迈入万吨级产能规模。公司未来规划徐州 10 万吨、<br>乐山 10 万吨以及包头 30 万吨颗粒硅产能。预计 21-22 年公司颗粒硅产<br>能可达 3&#x2F;26 万吨，实现大幅提升。颗粒硅产能规模的扩大助力公司具备<br>规模优势，生产成本有望进一步降低，盈利能力有望逐步提升</p>\n<p>目前生产 1 千克颗粒硅耗电<br>仅 18 度，相较于西门子法 60 度&#x2F;千克有显著下降；水耗氢耗方面，FBR<br>方法较西门子法降低 30%&#x2F;42%。投资方面，颗粒硅每万吨产能仅需要 7<br>亿初始投资，相较西门子法可降低 1.5-2 亿元，具备成本优势。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"协鑫\"><a href=\"#协鑫\" class=\"headerlink\" title=\"协鑫\"></a>协鑫</h2><p>掌握颗粒硅量产技术，迈入万吨级产能规模。公司未来规划徐州 10 万吨、<br>乐山 10 万吨以及包头 30 万吨颗粒硅产能。预计 21-22 年公司颗粒硅产<br>能可达 3&#x2F;26 万吨，实现大幅提升。颗粒硅产能规模的扩大助力公司具备<br>规模优势，生产成本有望进一步降低，盈利能力有望逐步提升</p>\n<p>目前生产 1 千克颗粒硅耗电<br>仅 18 度，相较于西门子法 60 度&#x2F;千克有显著下降；水耗氢耗方面，FBR<br>方法较西门子法降低 30%&#x2F;42%。投资方面，颗粒硅每万吨产能仅需要 7<br>亿初始投资，相较西门子法可降低 1.5-2 亿元，具备成本优势。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ckzf5sdyt0000yy8kmd769rti","tag_id":"ckzf5sdyz0002yy8kx28s5ks9","_id":"ckzf5sdz40007yy8k6dgno3hw"},{"post_id":"ckzf5sdyx0001yy8kr15yui10","tag_id":"ckzf5sdz30006yy8kyqd9pcka","_id":"ckzf5sdz8000cyy8kwtt6ic07"},{"post_id":"ckzf5sdz00003yy8kwrbubbr1","tag_id":"ckzf5sdz6000ayy8k8021yu1h","_id":"ckzf5sdza000gyy8kja3x8w13"},{"post_id":"ckzf5sdz10004yy8kzjoaknzp","tag_id":"ckzf5sdz9000eyy8k34dwupn6","_id":"ckzf5sdzc000kyy8kbxnxyti3"},{"post_id":"ckzf5sdz50009yy8kz8op9s2m","tag_id":"ckzf5sdzb000iyy8kssa8i01f","_id":"ckzf5sdzf000oyy8k7hfy42av"},{"post_id":"ckzf5sdz7000byy8kfpyjem2w","tag_id":"ckzf5sdzb000iyy8kssa8i01f","_id":"ckzf5sdzg000ryy8kvwbv8o2z"},{"post_id":"ckzf5sdz8000dyy8k29g6ve88","tag_id":"ckzf5sdzg000qyy8ki8jk7i8z","_id":"ckzf5sdzg000tyy8kv3r0g7fh"},{"post_id":"ckzf5sdza000hyy8ktd9jwllr","tag_id":"ckzf5sdzg000syy8kkwg9bopk","_id":"ckzf5sdzh000vyy8kej1kdrhr"},{"post_id":"ckzf5sdzc000lyy8k9vpw6foi","tag_id":"ckzf5sdzg000uyy8k28dafgfe","_id":"ckzf5sdzh000xyy8kakpmbr9x"},{"post_id":"ckzf5sdzd000myy8k7p79iiia","tag_id":"ckzf5sdzh000wyy8khfwnyz5n","_id":"ckzf5sdzh000zyy8ks8zwlnvn"},{"post_id":"ckzf5sdzf000pyy8ka3xwt8wg","tag_id":"ckzf5sdzh000yyy8kfown54ao","_id":"ckzf5sdzi0010yy8k6m09y7n3"},{"post_id":"ckzf5sdzt0011yy8km8m96hpl","tag_id":"ckzf5sdzw0015yy8kn7poe6z3","_id":"ckzf5se00001byy8kbka87v2k"},{"post_id":"ckzf5sdzu0013yy8kbq705u2x","tag_id":"ckzf5sdzz001ayy8krn65wekr","_id":"ckzf5se02001gyy8kvxj6cx3g"},{"post_id":"ckzf5sdzw0016yy8k0odcnot3","tag_id":"ckzf5se01001eyy8k53rgvqo3","_id":"ckzf5se04001kyy8k8a6bw9gx"},{"post_id":"ckzf5sdzy0018yy8kjk235izp","tag_id":"ckzf5se03001iyy8k5vzl9dyr","_id":"ckzf5se06001oyy8kbz2071xm"},{"post_id":"ckzf5se00001cyy8kexq6tpd4","tag_id":"ckzf5se05001myy8kbuxdvnsn","_id":"ckzf5se08001syy8k1byn0a4i"},{"post_id":"ckzf5se01001dyy8kqqgbzys3","tag_id":"ckzf5se08001ryy8kfgt4390r","_id":"ckzf5se0b001xyy8k17s64fa7"},{"post_id":"ckzf5se02001fyy8kjwqmoexv","tag_id":"ckzf5se0a001vyy8kqnwxnw3c","_id":"ckzf5se0d0021yy8kls4o23m6"},{"post_id":"ckzf5se03001hyy8kowub1e2u","tag_id":"ckzf5se0c001zyy8k3l0g7xja","_id":"ckzf5se0i0025yy8k809hmv8m"},{"post_id":"ckzf5se04001jyy8kch13339z","tag_id":"ckzf5se0f0023yy8kjevxv5k8","_id":"ckzf5se0j0027yy8kgzphytd8"},{"post_id":"ckzf5se05001nyy8k5e3tjozz","tag_id":"ckzf5se0i0026yy8kcacc95gm","_id":"ckzf5se0j0029yy8k3q7xb766"},{"post_id":"ckzf5se06001pyy8k6hle2lny","tag_id":"ckzf5se0j0028yy8kcp84av7y","_id":"ckzf5se0k002byy8kcqv7zcqd"},{"post_id":"ckzf5se07001qyy8ktj7eu1yc","tag_id":"ckzf5se0k002ayy8kh1od3thj","_id":"ckzf5se0l002dyy8kny7oophd"},{"post_id":"ckzf5se08001tyy8kyris7kj2","tag_id":"ckzf5se0k002cyy8kvznvtan7","_id":"ckzf5se0l002fyy8k59cg7bg3"},{"post_id":"ckzf5se09001uyy8k3xjon3gt","tag_id":"ckzf5se0l002eyy8ky7c7jyfm","_id":"ckzf5se0m002hyy8kwixl41ko"},{"post_id":"ckzf5se0a001wyy8khyv2rcii","tag_id":"ckzf5se0m002gyy8kfhgunbnu","_id":"ckzf5se0m002jyy8kccepwgr2"},{"post_id":"ckzf5se0b001yyy8k12cc98uq","tag_id":"ckzf5se0m002iyy8knc4md2f8","_id":"ckzf5se0n002lyy8kzvr5fx0i"},{"post_id":"ckzf5se0d0020yy8k43w0lz0a","tag_id":"ckzf5se0n002kyy8k63o5jay6","_id":"ckzf5se0o002nyy8kcowforj2"},{"post_id":"ckzf5se0h0024yy8k46qvj5vn","tag_id":"ckzf5se0n002myy8kbv4u6mxg","_id":"ckzf5se0o002oyy8kg0v45fzg"}],"Tag":[{"name":"零碎","_id":"ckzf5sdyz0002yy8kx28s5ks9"},{"name":"https","_id":"ckzf5sdz30006yy8kyqd9pcka"},{"name":"css","_id":"ckzf5sdz6000ayy8k8021yu1h"},{"name":"docker","_id":"ckzf5sdz9000eyy8k34dwupn6"},{"name":"es","_id":"ckzf5sdzb000iyy8kssa8i01f"},{"name":"eslint","_id":"ckzf5sdzg000qyy8ki8jk7i8z"},{"name":"hexo","_id":"ckzf5sdzg000syy8kkwg9bopk"},{"name":"git","_id":"ckzf5sdzg000uyy8k28dafgfe"},{"name":"interview","_id":"ckzf5sdzh000wyy8khfwnyz5n"},{"name":"http","_id":"ckzf5sdzh000yyy8kfown54ao"},{"name":"k8s","_id":"ckzf5sdzw0015yy8kn7poe6z3"},{"name":"html","_id":"ckzf5sdzz001ayy8krn65wekr"},{"name":"stock","_id":"ckzf5se01001eyy8k53rgvqo3"},{"name":"loadtest","_id":"ckzf5se03001iyy8k5vzl9dyr"},{"name":"ops","_id":"ckzf5se05001myy8kbuxdvnsn"},{"name":"node、egg","_id":"ckzf5se08001ryy8kfgt4390r"},{"name":"overview","_id":"ckzf5se0a001vyy8kqnwxnw3c"},{"name":"useful package","_id":"ckzf5se0c001zyy8k3l0g7xja"},{"name":"pattern","_id":"ckzf5se0f0023yy8kjevxv5k8"},{"name":"pm2","_id":"ckzf5se0i0026yy8kcacc95gm"},{"name":"postgre","_id":"ckzf5se0j0028yy8kcp84av7y"},{"name":"web 安全","_id":"ckzf5se0k002ayy8kh1od3thj"},{"name":"regex","_id":"ckzf5se0k002cyy8kvznvtan7"},{"name":"encode decode","_id":"ckzf5se0l002eyy8ky7c7jyfm"},{"name":"安全","_id":"ckzf5se0m002gyy8kfhgunbnu"},{"name":"ts","_id":"ckzf5se0m002iyy8knc4md2f8"},{"name":"vue eventloop js","_id":"ckzf5se0n002kyy8k63o5jay6"},{"name":"webpack","_id":"ckzf5se0n002myy8kbv4u6mxg"}]}}